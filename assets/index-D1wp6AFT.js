var v6=Object.defineProperty;var S6=(e,t,n)=>t in e?v6(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var iN=(e,t,n)=>S6(e,typeof t!="symbol"?t+"":t,n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))a(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const s of i.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&a(s)}).observe(document,{childList:!0,subtree:!0});function n(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function a(r){if(r.ep)return;r.ep=!0;const i=n(r);fetch(r.href,i)}})();var q2={exports:{}},py={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var sN;function k6(){if(sN)return py;sN=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function n(a,r,i){var s=null;if(i!==void 0&&(s=""+i),r.key!==void 0&&(s=""+r.key),"key"in r){i={};for(var o in r)o!=="key"&&(i[o]=r[o])}else i=r;return r=i.ref,{$$typeof:e,type:a,key:s,ref:r!==void 0?r:null,props:i}}return py.Fragment=t,py.jsx=n,py.jsxs=n,py}var oN;function A6(){return oN||(oN=1,q2.exports=k6()),q2.exports}var aa=A6(),P2={exports:{}},an={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var lN;function E6(){if(lN)return an;lN=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),s=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),c=Symbol.for("react.lazy"),h=Symbol.iterator;function m(Y){return Y===null||typeof Y!="object"?null:(Y=h&&Y[h]||Y["@@iterator"],typeof Y=="function"?Y:null)}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,v={};function S(Y,ie,xe){this.props=Y,this.context=ie,this.refs=v,this.updater=xe||g}S.prototype.isReactComponent={},S.prototype.setState=function(Y,ie){if(typeof Y!="object"&&typeof Y!="function"&&Y!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,Y,ie,"setState")},S.prototype.forceUpdate=function(Y){this.updater.enqueueForceUpdate(this,Y,"forceUpdate")};function E(){}E.prototype=S.prototype;function C(Y,ie,xe){this.props=Y,this.context=ie,this.refs=v,this.updater=xe||g}var T=C.prototype=new E;T.constructor=C,x(T,S.prototype),T.isPureReactComponent=!0;var N=Array.isArray,D={H:null,A:null,T:null,S:null,V:null},q=Object.prototype.hasOwnProperty;function H(Y,ie,xe,me,_e,Le){return xe=Le.ref,{$$typeof:e,type:Y,key:ie,ref:xe!==void 0?xe:null,props:Le}}function K(Y,ie){return H(Y.type,ie,void 0,void 0,void 0,Y.props)}function j(Y){return typeof Y=="object"&&Y!==null&&Y.$$typeof===e}function te(Y){var ie={"=":"=0",":":"=2"};return"$"+Y.replace(/[=:]/g,function(xe){return ie[xe]})}var Q=/\/+/g;function z(Y,ie){return typeof Y=="object"&&Y!==null&&Y.key!=null?te(""+Y.key):ie.toString(36)}function ae(){}function ue(Y){switch(Y.status){case"fulfilled":return Y.value;case"rejected":throw Y.reason;default:switch(typeof Y.status=="string"?Y.then(ae,ae):(Y.status="pending",Y.then(function(ie){Y.status==="pending"&&(Y.status="fulfilled",Y.value=ie)},function(ie){Y.status==="pending"&&(Y.status="rejected",Y.reason=ie)})),Y.status){case"fulfilled":return Y.value;case"rejected":throw Y.reason}}throw Y}function he(Y,ie,xe,me,_e){var Le=typeof Y;(Le==="undefined"||Le==="boolean")&&(Y=null);var qe=!1;if(Y===null)qe=!0;else switch(Le){case"bigint":case"string":case"number":qe=!0;break;case"object":switch(Y.$$typeof){case e:case t:qe=!0;break;case c:return qe=Y._init,he(qe(Y._payload),ie,xe,me,_e)}}if(qe)return _e=_e(Y),qe=me===""?"."+z(Y,0):me,N(_e)?(xe="",qe!=null&&(xe=qe.replace(Q,"$&/")+"/"),he(_e,ie,xe,"",function(rt){return rt})):_e!=null&&(j(_e)&&(_e=K(_e,xe+(_e.key==null||Y&&Y.key===_e.key?"":(""+_e.key).replace(Q,"$&/")+"/")+qe)),ie.push(_e)),1;qe=0;var $e=me===""?".":me+":";if(N(Y))for(var Ke=0;Ke<Y.length;Ke++)me=Y[Ke],Le=$e+z(me,Ke),qe+=he(me,ie,xe,Le,_e);else if(Ke=m(Y),typeof Ke=="function")for(Y=Ke.call(Y),Ke=0;!(me=Y.next()).done;)me=me.value,Le=$e+z(me,Ke++),qe+=he(me,ie,xe,Le,_e);else if(Le==="object"){if(typeof Y.then=="function")return he(ue(Y),ie,xe,me,_e);throw ie=String(Y),Error("Objects are not valid as a React child (found: "+(ie==="[object Object]"?"object with keys {"+Object.keys(Y).join(", ")+"}":ie)+"). If you meant to render a collection of children, use an array instead.")}return qe}function Z(Y,ie,xe){if(Y==null)return Y;var me=[],_e=0;return he(Y,me,"","",function(Le){return ie.call(xe,Le,_e++)}),me}function se(Y){if(Y._status===-1){var ie=Y._result;ie=ie(),ie.then(function(xe){(Y._status===0||Y._status===-1)&&(Y._status=1,Y._result=xe)},function(xe){(Y._status===0||Y._status===-1)&&(Y._status=2,Y._result=xe)}),Y._status===-1&&(Y._status=0,Y._result=ie)}if(Y._status===1)return Y._result.default;throw Y._result}var de=typeof reportError=="function"?reportError:function(Y){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var ie=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof Y=="object"&&Y!==null&&typeof Y.message=="string"?String(Y.message):String(Y),error:Y});if(!window.dispatchEvent(ie))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",Y);return}console.error(Y)};function Ce(){}return an.Children={map:Z,forEach:function(Y,ie,xe){Z(Y,function(){ie.apply(this,arguments)},xe)},count:function(Y){var ie=0;return Z(Y,function(){ie++}),ie},toArray:function(Y){return Z(Y,function(ie){return ie})||[]},only:function(Y){if(!j(Y))throw Error("React.Children.only expected to receive a single React element child.");return Y}},an.Component=S,an.Fragment=n,an.Profiler=r,an.PureComponent=C,an.StrictMode=a,an.Suspense=u,an.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=D,an.__COMPILER_RUNTIME={__proto__:null,c:function(Y){return D.H.useMemoCache(Y)}},an.cache=function(Y){return function(){return Y.apply(null,arguments)}},an.cloneElement=function(Y,ie,xe){if(Y==null)throw Error("The argument must be a React element, but you passed "+Y+".");var me=x({},Y.props),_e=Y.key,Le=void 0;if(ie!=null)for(qe in ie.ref!==void 0&&(Le=void 0),ie.key!==void 0&&(_e=""+ie.key),ie)!q.call(ie,qe)||qe==="key"||qe==="__self"||qe==="__source"||qe==="ref"&&ie.ref===void 0||(me[qe]=ie[qe]);var qe=arguments.length-2;if(qe===1)me.children=xe;else if(1<qe){for(var $e=Array(qe),Ke=0;Ke<qe;Ke++)$e[Ke]=arguments[Ke+2];me.children=$e}return H(Y.type,_e,void 0,void 0,Le,me)},an.createContext=function(Y){return Y={$$typeof:s,_currentValue:Y,_currentValue2:Y,_threadCount:0,Provider:null,Consumer:null},Y.Provider=Y,Y.Consumer={$$typeof:i,_context:Y},Y},an.createElement=function(Y,ie,xe){var me,_e={},Le=null;if(ie!=null)for(me in ie.key!==void 0&&(Le=""+ie.key),ie)q.call(ie,me)&&me!=="key"&&me!=="__self"&&me!=="__source"&&(_e[me]=ie[me]);var qe=arguments.length-2;if(qe===1)_e.children=xe;else if(1<qe){for(var $e=Array(qe),Ke=0;Ke<qe;Ke++)$e[Ke]=arguments[Ke+2];_e.children=$e}if(Y&&Y.defaultProps)for(me in qe=Y.defaultProps,qe)_e[me]===void 0&&(_e[me]=qe[me]);return H(Y,Le,void 0,void 0,null,_e)},an.createRef=function(){return{current:null}},an.forwardRef=function(Y){return{$$typeof:o,render:Y}},an.isValidElement=j,an.lazy=function(Y){return{$$typeof:c,_payload:{_status:-1,_result:Y},_init:se}},an.memo=function(Y,ie){return{$$typeof:d,type:Y,compare:ie===void 0?null:ie}},an.startTransition=function(Y){var ie=D.T,xe={};D.T=xe;try{var me=Y(),_e=D.S;_e!==null&&_e(xe,me),typeof me=="object"&&me!==null&&typeof me.then=="function"&&me.then(Ce,de)}catch(Le){de(Le)}finally{D.T=ie}},an.unstable_useCacheRefresh=function(){return D.H.useCacheRefresh()},an.use=function(Y){return D.H.use(Y)},an.useActionState=function(Y,ie,xe){return D.H.useActionState(Y,ie,xe)},an.useCallback=function(Y,ie){return D.H.useCallback(Y,ie)},an.useContext=function(Y){return D.H.useContext(Y)},an.useDebugValue=function(){},an.useDeferredValue=function(Y,ie){return D.H.useDeferredValue(Y,ie)},an.useEffect=function(Y,ie,xe){var me=D.H;if(typeof xe=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return me.useEffect(Y,ie)},an.useId=function(){return D.H.useId()},an.useImperativeHandle=function(Y,ie,xe){return D.H.useImperativeHandle(Y,ie,xe)},an.useInsertionEffect=function(Y,ie){return D.H.useInsertionEffect(Y,ie)},an.useLayoutEffect=function(Y,ie){return D.H.useLayoutEffect(Y,ie)},an.useMemo=function(Y,ie){return D.H.useMemo(Y,ie)},an.useOptimistic=function(Y,ie){return D.H.useOptimistic(Y,ie)},an.useReducer=function(Y,ie,xe){return D.H.useReducer(Y,ie,xe)},an.useRef=function(Y){return D.H.useRef(Y)},an.useState=function(Y){return D.H.useState(Y)},an.useSyncExternalStore=function(Y,ie,xe){return D.H.useSyncExternalStore(Y,ie,xe)},an.useTransition=function(){return D.H.useTransition()},an.version="19.1.0",an}var uN;function CA(){return uN||(uN=1,P2.exports=E6()),P2.exports}var ii=CA(),H2={exports:{}},hy={},G2={exports:{}},K2={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var cN;function C6(){return cN||(cN=1,function(e){function t(Z,se){var de=Z.length;Z.push(se);e:for(;0<de;){var Ce=de-1>>>1,Y=Z[Ce];if(0<r(Y,se))Z[Ce]=se,Z[de]=Y,de=Ce;else break e}}function n(Z){return Z.length===0?null:Z[0]}function a(Z){if(Z.length===0)return null;var se=Z[0],de=Z.pop();if(de!==se){Z[0]=de;e:for(var Ce=0,Y=Z.length,ie=Y>>>1;Ce<ie;){var xe=2*(Ce+1)-1,me=Z[xe],_e=xe+1,Le=Z[_e];if(0>r(me,de))_e<Y&&0>r(Le,me)?(Z[Ce]=Le,Z[_e]=de,Ce=_e):(Z[Ce]=me,Z[xe]=de,Ce=xe);else if(_e<Y&&0>r(Le,de))Z[Ce]=Le,Z[_e]=de,Ce=_e;else break e}}return se}function r(Z,se){var de=Z.sortIndex-se.sortIndex;return de!==0?de:Z.id-se.id}if(e.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var i=performance;e.unstable_now=function(){return i.now()}}else{var s=Date,o=s.now();e.unstable_now=function(){return s.now()-o}}var u=[],d=[],c=1,h=null,m=3,g=!1,x=!1,v=!1,S=!1,E=typeof setTimeout=="function"?setTimeout:null,C=typeof clearTimeout=="function"?clearTimeout:null,T=typeof setImmediate<"u"?setImmediate:null;function N(Z){for(var se=n(d);se!==null;){if(se.callback===null)a(d);else if(se.startTime<=Z)a(d),se.sortIndex=se.expirationTime,t(u,se);else break;se=n(d)}}function D(Z){if(v=!1,N(Z),!x)if(n(u)!==null)x=!0,q||(q=!0,z());else{var se=n(d);se!==null&&he(D,se.startTime-Z)}}var q=!1,H=-1,K=5,j=-1;function te(){return S?!0:!(e.unstable_now()-j<K)}function Q(){if(S=!1,q){var Z=e.unstable_now();j=Z;var se=!0;try{e:{x=!1,v&&(v=!1,C(H),H=-1),g=!0;var de=m;try{t:{for(N(Z),h=n(u);h!==null&&!(h.expirationTime>Z&&te());){var Ce=h.callback;if(typeof Ce=="function"){h.callback=null,m=h.priorityLevel;var Y=Ce(h.expirationTime<=Z);if(Z=e.unstable_now(),typeof Y=="function"){h.callback=Y,N(Z),se=!0;break t}h===n(u)&&a(u),N(Z)}else a(u);h=n(u)}if(h!==null)se=!0;else{var ie=n(d);ie!==null&&he(D,ie.startTime-Z),se=!1}}break e}finally{h=null,m=de,g=!1}se=void 0}}finally{se?z():q=!1}}}var z;if(typeof T=="function")z=function(){T(Q)};else if(typeof MessageChannel<"u"){var ae=new MessageChannel,ue=ae.port2;ae.port1.onmessage=Q,z=function(){ue.postMessage(null)}}else z=function(){E(Q,0)};function he(Z,se){H=E(function(){Z(e.unstable_now())},se)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(Z){Z.callback=null},e.unstable_forceFrameRate=function(Z){0>Z||125<Z?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):K=0<Z?Math.floor(1e3/Z):5},e.unstable_getCurrentPriorityLevel=function(){return m},e.unstable_next=function(Z){switch(m){case 1:case 2:case 3:var se=3;break;default:se=m}var de=m;m=se;try{return Z()}finally{m=de}},e.unstable_requestPaint=function(){S=!0},e.unstable_runWithPriority=function(Z,se){switch(Z){case 1:case 2:case 3:case 4:case 5:break;default:Z=3}var de=m;m=Z;try{return se()}finally{m=de}},e.unstable_scheduleCallback=function(Z,se,de){var Ce=e.unstable_now();switch(typeof de=="object"&&de!==null?(de=de.delay,de=typeof de=="number"&&0<de?Ce+de:Ce):de=Ce,Z){case 1:var Y=-1;break;case 2:Y=250;break;case 5:Y=1073741823;break;case 4:Y=1e4;break;default:Y=5e3}return Y=de+Y,Z={id:c++,callback:se,priorityLevel:Z,startTime:de,expirationTime:Y,sortIndex:-1},de>Ce?(Z.sortIndex=de,t(d,Z),n(u)===null&&Z===n(d)&&(v?(C(H),H=-1):v=!0,he(D,de-Ce))):(Z.sortIndex=Y,t(u,Z),x||g||(x=!0,q||(q=!0,z()))),Z},e.unstable_shouldYield=te,e.unstable_wrapCallback=function(Z){var se=m;return function(){var de=m;m=se;try{return Z.apply(this,arguments)}finally{m=de}}}}(K2)),K2}var dN;function I6(){return dN||(dN=1,G2.exports=C6()),G2.exports}var $2={exports:{}},Ur={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var pN;function _6(){if(pN)return Ur;pN=1;var e=CA();function t(u){var d="https://react.dev/errors/"+u;if(1<arguments.length){d+="?args[]="+encodeURIComponent(arguments[1]);for(var c=2;c<arguments.length;c++)d+="&args[]="+encodeURIComponent(arguments[c])}return"Minified React error #"+u+"; visit "+d+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function n(){}var a={d:{f:n,r:function(){throw Error(t(522))},D:n,C:n,L:n,m:n,X:n,S:n,M:n},p:0,findDOMNode:null},r=Symbol.for("react.portal");function i(u,d,c){var h=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:h==null?null:""+h,children:u,containerInfo:d,implementation:c}}var s=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(u,d){if(u==="font")return"";if(typeof d=="string")return d==="use-credentials"?d:""}return Ur.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=a,Ur.createPortal=function(u,d){var c=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!d||d.nodeType!==1&&d.nodeType!==9&&d.nodeType!==11)throw Error(t(299));return i(u,d,null,c)},Ur.flushSync=function(u){var d=s.T,c=a.p;try{if(s.T=null,a.p=2,u)return u()}finally{s.T=d,a.p=c,a.d.f()}},Ur.preconnect=function(u,d){typeof u=="string"&&(d?(d=d.crossOrigin,d=typeof d=="string"?d==="use-credentials"?d:"":void 0):d=null,a.d.C(u,d))},Ur.prefetchDNS=function(u){typeof u=="string"&&a.d.D(u)},Ur.preinit=function(u,d){if(typeof u=="string"&&d&&typeof d.as=="string"){var c=d.as,h=o(c,d.crossOrigin),m=typeof d.integrity=="string"?d.integrity:void 0,g=typeof d.fetchPriority=="string"?d.fetchPriority:void 0;c==="style"?a.d.S(u,typeof d.precedence=="string"?d.precedence:void 0,{crossOrigin:h,integrity:m,fetchPriority:g}):c==="script"&&a.d.X(u,{crossOrigin:h,integrity:m,fetchPriority:g,nonce:typeof d.nonce=="string"?d.nonce:void 0})}},Ur.preinitModule=function(u,d){if(typeof u=="string")if(typeof d=="object"&&d!==null){if(d.as==null||d.as==="script"){var c=o(d.as,d.crossOrigin);a.d.M(u,{crossOrigin:c,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0})}}else d==null&&a.d.M(u)},Ur.preload=function(u,d){if(typeof u=="string"&&typeof d=="object"&&d!==null&&typeof d.as=="string"){var c=d.as,h=o(c,d.crossOrigin);a.d.L(u,c,{crossOrigin:h,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0,type:typeof d.type=="string"?d.type:void 0,fetchPriority:typeof d.fetchPriority=="string"?d.fetchPriority:void 0,referrerPolicy:typeof d.referrerPolicy=="string"?d.referrerPolicy:void 0,imageSrcSet:typeof d.imageSrcSet=="string"?d.imageSrcSet:void 0,imageSizes:typeof d.imageSizes=="string"?d.imageSizes:void 0,media:typeof d.media=="string"?d.media:void 0})}},Ur.preloadModule=function(u,d){if(typeof u=="string")if(d){var c=o(d.as,d.crossOrigin);a.d.m(u,{as:typeof d.as=="string"&&d.as!=="script"?d.as:void 0,crossOrigin:c,integrity:typeof d.integrity=="string"?d.integrity:void 0})}else a.d.m(u)},Ur.requestFormReset=function(u){a.d.r(u)},Ur.unstable_batchedUpdates=function(u,d){return u(d)},Ur.useFormState=function(u,d,c){return s.H.useFormState(u,d,c)},Ur.useFormStatus=function(){return s.H.useHostTransitionStatus()},Ur.version="19.1.0",Ur}var hN;function T6(){if(hN)return $2.exports;hN=1;function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}return e(),$2.exports=_6(),$2.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var fN;function N6(){if(fN)return hy;fN=1;var e=I6(),t=CA(),n=T6();function a(l){var p="https://react.dev/errors/"+l;if(1<arguments.length){p+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)p+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+l+"; visit "+p+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(l){return!(!l||l.nodeType!==1&&l.nodeType!==9&&l.nodeType!==11)}function i(l){var p=l,f=l;if(l.alternate)for(;p.return;)p=p.return;else{l=p;do p=l,(p.flags&4098)!==0&&(f=p.return),l=p.return;while(l)}return p.tag===3?f:null}function s(l){if(l.tag===13){var p=l.memoizedState;if(p===null&&(l=l.alternate,l!==null&&(p=l.memoizedState)),p!==null)return p.dehydrated}return null}function o(l){if(i(l)!==l)throw Error(a(188))}function u(l){var p=l.alternate;if(!p){if(p=i(l),p===null)throw Error(a(188));return p!==l?null:l}for(var f=l,b=p;;){var A=f.return;if(A===null)break;var I=A.alternate;if(I===null){if(b=A.return,b!==null){f=b;continue}break}if(A.child===I.child){for(I=A.child;I;){if(I===f)return o(A),l;if(I===b)return o(A),p;I=I.sibling}throw Error(a(188))}if(f.return!==b.return)f=A,b=I;else{for(var W=!1,J=A.child;J;){if(J===f){W=!0,f=A,b=I;break}if(J===b){W=!0,b=A,f=I;break}J=J.sibling}if(!W){for(J=I.child;J;){if(J===f){W=!0,f=I,b=A;break}if(J===b){W=!0,b=I,f=A;break}J=J.sibling}if(!W)throw Error(a(189))}}if(f.alternate!==b)throw Error(a(190))}if(f.tag!==3)throw Error(a(188));return f.stateNode.current===f?l:p}function d(l){var p=l.tag;if(p===5||p===26||p===27||p===6)return l;for(l=l.child;l!==null;){if(p=d(l),p!==null)return p;l=l.sibling}return null}var c=Object.assign,h=Symbol.for("react.element"),m=Symbol.for("react.transitional.element"),g=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),v=Symbol.for("react.strict_mode"),S=Symbol.for("react.profiler"),E=Symbol.for("react.provider"),C=Symbol.for("react.consumer"),T=Symbol.for("react.context"),N=Symbol.for("react.forward_ref"),D=Symbol.for("react.suspense"),q=Symbol.for("react.suspense_list"),H=Symbol.for("react.memo"),K=Symbol.for("react.lazy"),j=Symbol.for("react.activity"),te=Symbol.for("react.memo_cache_sentinel"),Q=Symbol.iterator;function z(l){return l===null||typeof l!="object"?null:(l=Q&&l[Q]||l["@@iterator"],typeof l=="function"?l:null)}var ae=Symbol.for("react.client.reference");function ue(l){if(l==null)return null;if(typeof l=="function")return l.$$typeof===ae?null:l.displayName||l.name||null;if(typeof l=="string")return l;switch(l){case x:return"Fragment";case S:return"Profiler";case v:return"StrictMode";case D:return"Suspense";case q:return"SuspenseList";case j:return"Activity"}if(typeof l=="object")switch(l.$$typeof){case g:return"Portal";case T:return(l.displayName||"Context")+".Provider";case C:return(l._context.displayName||"Context")+".Consumer";case N:var p=l.render;return l=l.displayName,l||(l=p.displayName||p.name||"",l=l!==""?"ForwardRef("+l+")":"ForwardRef"),l;case H:return p=l.displayName||null,p!==null?p:ue(l.type)||"Memo";case K:p=l._payload,l=l._init;try{return ue(l(p))}catch{}}return null}var he=Array.isArray,Z=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,se=n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,de={pending:!1,data:null,method:null,action:null},Ce=[],Y=-1;function ie(l){return{current:l}}function xe(l){0>Y||(l.current=Ce[Y],Ce[Y]=null,Y--)}function me(l,p){Y++,Ce[Y]=l.current,l.current=p}var _e=ie(null),Le=ie(null),qe=ie(null),$e=ie(null);function Ke(l,p){switch(me(qe,p),me(Le,l),me(_e,null),p.nodeType){case 9:case 11:l=(l=p.documentElement)&&(l=l.namespaceURI)?DT(l):0;break;default:if(l=p.tagName,p=p.namespaceURI)p=DT(p),l=OT(p,l);else switch(l){case"svg":l=1;break;case"math":l=2;break;default:l=0}}xe(_e),me(_e,l)}function rt(){xe(_e),xe(Le),xe(qe)}function ht(l){l.memoizedState!==null&&me($e,l);var p=_e.current,f=OT(p,l.type);p!==f&&(me(Le,l),me(_e,f))}function kt(l){Le.current===l&&(xe(_e),xe(Le)),$e.current===l&&(xe($e),oy._currentValue=de)}var _t=Object.prototype.hasOwnProperty,ln=e.unstable_scheduleCallback,Nt=e.unstable_cancelCallback,Pt=e.unstable_shouldYield,Re=e.unstable_requestPaint,ft=e.unstable_now,wt=e.unstable_getCurrentPriorityLevel,oa=e.unstable_ImmediatePriority,en=e.unstable_UserBlockingPriority,Ht=e.unstable_NormalPriority,Jn=e.unstable_LowPriority,kn=e.unstable_IdlePriority,pa=e.log,Na=e.unstable_setDisableYieldValue,An=null,tn=null;function G(l){if(typeof pa=="function"&&Na(l),tn&&typeof tn.setStrictMode=="function")try{tn.setStrictMode(An,l)}catch{}}var F=Math.clz32?Math.clz32:ke,L=Math.log,ne=Math.LN2;function ke(l){return l>>>=0,l===0?32:31-(L(l)/ne|0)|0}var ve=256,ze=4194304;function ot(l){var p=l&42;if(p!==0)return p;switch(l&-l){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return l&4194048;case 4194304:case 8388608:case 16777216:case 33554432:return l&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return l}}function Lt(l,p,f){var b=l.pendingLanes;if(b===0)return 0;var A=0,I=l.suspendedLanes,W=l.pingedLanes;l=l.warmLanes;var J=b&134217727;return J!==0?(b=J&~I,b!==0?A=ot(b):(W&=J,W!==0?A=ot(W):f||(f=J&~l,f!==0&&(A=ot(f))))):(J=b&~I,J!==0?A=ot(J):W!==0?A=ot(W):f||(f=b&~l,f!==0&&(A=ot(f)))),A===0?0:p!==0&&p!==A&&(p&I)===0&&(I=A&-A,f=p&-p,I>=f||I===32&&(f&4194048)!==0)?p:A}function Rt(l,p){return(l.pendingLanes&~(l.suspendedLanes&~l.pingedLanes)&p)===0}function on(l,p){switch(l){case 1:case 2:case 4:case 8:case 64:return p+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return p+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function hn(){var l=ve;return ve<<=1,(ve&4194048)===0&&(ve=256),l}function fi(){var l=ze;return ze<<=1,(ze&62914560)===0&&(ze=4194304),l}function ls(l){for(var p=[],f=0;31>f;f++)p.push(l);return p}function us(l,p){l.pendingLanes|=p,p!==268435456&&(l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0)}function Va(l,p,f,b,A,I){var W=l.pendingLanes;l.pendingLanes=f,l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0,l.expiredLanes&=f,l.entangledLanes&=f,l.errorRecoveryDisabledLanes&=f,l.shellSuspendCounter=0;var J=l.entanglements,ce=l.expirationTimes,Ne=l.hiddenUpdates;for(f=W&~f;0<f;){var Ue=31-F(f),Ge=1<<Ue;J[Ue]=0,ce[Ue]=-1;var Fe=Ne[Ue];if(Fe!==null)for(Ne[Ue]=null,Ue=0;Ue<Fe.length;Ue++){var De=Fe[Ue];De!==null&&(De.lane&=-536870913)}f&=~Ge}b!==0&&cs(l,b,0),I!==0&&A===0&&l.tag!==0&&(l.suspendedLanes|=I&~(W&~p))}function cs(l,p,f){l.pendingLanes|=p,l.suspendedLanes&=~p;var b=31-F(p);l.entangledLanes|=p,l.entanglements[b]=l.entanglements[b]|1073741824|f&4194090}function mo(l,p){var f=l.entangledLanes|=p;for(l=l.entanglements;f;){var b=31-F(f),A=1<<b;A&p|l[b]&p&&(l[b]|=p),f&=~A}}function Me(l){switch(l){case 2:l=1;break;case 8:l=4;break;case 32:l=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:l=128;break;case 268435456:l=134217728;break;default:l=0}return l}function Je(l){return l&=-l,2<l?8<l?(l&134217727)!==0?32:268435456:8:2}function mt(){var l=se.p;return l!==0?l:(l=window.event,l===void 0?32:XT(l.type))}function Ze(l,p){var f=se.p;try{return se.p=l,p()}finally{se.p=f}}var cn=Math.random().toString(36).slice(2),Gt="__reactFiber$"+cn,xt="__reactProps$"+cn,It="__reactContainer$"+cn,Xn="__reactEvents$"+cn,Wa="__reactListeners$"+cn,Li="__reactHandles$"+cn,go="__reactResources$"+cn,mi="__reactMarker$"+cn;function bo(l){delete l[Gt],delete l[xt],delete l[Xn],delete l[Wa],delete l[Li]}function On(l){var p=l[Gt];if(p)return p;for(var f=l.parentNode;f;){if(p=f[It]||f[Gt]){if(f=p.alternate,p.child!==null||f!==null&&f.child!==null)for(l=zT(l);l!==null;){if(f=l[Gt])return f;l=zT(l)}return p}l=f,f=l.parentNode}return null}function Sr(l){if(l=l[Gt]||l[It]){var p=l.tag;if(p===5||p===6||p===13||p===26||p===27||p===3)return l}return null}function zi(l){var p=l.tag;if(p===5||p===26||p===27||p===6)return l.stateNode;throw Error(a(33))}function yo(l){var p=l[go];return p||(p=l[go]={hoistableStyles:new Map,hoistableScripts:new Map}),p}function ha(l){l[mi]=!0}var $h=new Set,pu={};function Qr(l,p){pr(l,p),pr(l+"Capture",p)}function pr(l,p){for(pu[l]=p,l=0;l<p.length;l++)$h.add(p[l])}var wo=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),hu={},fu={};function Ms(l){return _t.call(fu,l)?!0:_t.call(hu,l)?!1:wo.test(l)?fu[l]=!0:(hu[l]=!0,!1)}function ds(l,p,f){if(Ms(p))if(f===null)l.removeAttribute(p);else{switch(typeof f){case"undefined":case"function":case"symbol":l.removeAttribute(p);return;case"boolean":var b=p.toLowerCase().slice(0,5);if(b!=="data-"&&b!=="aria-"){l.removeAttribute(p);return}}l.setAttribute(p,""+f)}}function mu(l,p,f){if(f===null)l.removeAttribute(p);else{switch(typeof f){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(p);return}l.setAttribute(p,""+f)}}function Zr(l,p,f,b){if(b===null)l.removeAttribute(f);else{switch(typeof b){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(f);return}l.setAttributeNS(p,f,""+b)}}var gu,ps;function Ui(l){if(gu===void 0)try{throw Error()}catch(f){var p=f.stack.trim().match(/\n( *(at )?)/);gu=p&&p[1]||"",ps=-1<f.stack.indexOf(`
    at`)?" (<anonymous>)":-1<f.stack.indexOf("@")?"@unknown:0:0":""}return`
`+gu+l+ps}var pl=!1;function xo(l,p){if(!l||pl)return"";pl=!0;var f=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var b={DetermineComponentFrameRoot:function(){try{if(p){var Ge=function(){throw Error()};if(Object.defineProperty(Ge.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Ge,[])}catch(De){var Fe=De}Reflect.construct(l,[],Ge)}else{try{Ge.call()}catch(De){Fe=De}l.call(Ge.prototype)}}else{try{throw Error()}catch(De){Fe=De}(Ge=l())&&typeof Ge.catch=="function"&&Ge.catch(function(){})}}catch(De){if(De&&Fe&&typeof De.stack=="string")return[De.stack,Fe.stack]}return[null,null]}};b.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var A=Object.getOwnPropertyDescriptor(b.DetermineComponentFrameRoot,"name");A&&A.configurable&&Object.defineProperty(b.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var I=b.DetermineComponentFrameRoot(),W=I[0],J=I[1];if(W&&J){var ce=W.split(`
`),Ne=J.split(`
`);for(A=b=0;b<ce.length&&!ce[b].includes("DetermineComponentFrameRoot");)b++;for(;A<Ne.length&&!Ne[A].includes("DetermineComponentFrameRoot");)A++;if(b===ce.length||A===Ne.length)for(b=ce.length-1,A=Ne.length-1;1<=b&&0<=A&&ce[b]!==Ne[A];)A--;for(;1<=b&&0<=A;b--,A--)if(ce[b]!==Ne[A]){if(b!==1||A!==1)do if(b--,A--,0>A||ce[b]!==Ne[A]){var Ue=`
`+ce[b].replace(" at new "," at ");return l.displayName&&Ue.includes("<anonymous>")&&(Ue=Ue.replace("<anonymous>",l.displayName)),Ue}while(1<=b&&0<=A);break}}}finally{pl=!1,Error.prepareStackTrace=f}return(f=l?l.displayName||l.name:"")?Ui(f):""}function nb(l){switch(l.tag){case 26:case 27:case 5:return Ui(l.type);case 16:return Ui("Lazy");case 13:return Ui("Suspense");case 19:return Ui("SuspenseList");case 0:case 15:return xo(l.type,!1);case 11:return xo(l.type.render,!1);case 1:return xo(l.type,!0);case 31:return Ui("Activity");default:return""}}function Qc(l){try{var p="";do p+=nb(l),l=l.return;while(l);return p}catch(f){return`
Error generating stack: `+f.message+`
`+f.stack}}function kr(l){switch(typeof l){case"bigint":case"boolean":case"number":case"string":case"undefined":return l;case"object":return l;default:return""}}function Xr(l){var p=l.type;return(l=l.nodeName)&&l.toLowerCase()==="input"&&(p==="checkbox"||p==="radio")}function hl(l){var p=Xr(l)?"checked":"value",f=Object.getOwnPropertyDescriptor(l.constructor.prototype,p),b=""+l[p];if(!l.hasOwnProperty(p)&&typeof f<"u"&&typeof f.get=="function"&&typeof f.set=="function"){var A=f.get,I=f.set;return Object.defineProperty(l,p,{configurable:!0,get:function(){return A.call(this)},set:function(W){b=""+W,I.call(this,W)}}),Object.defineProperty(l,p,{enumerable:f.enumerable}),{getValue:function(){return b},setValue:function(W){b=""+W},stopTracking:function(){l._valueTracker=null,delete l[p]}}}}function hs(l){l._valueTracker||(l._valueTracker=hl(l))}function Bs(l){if(!l)return!1;var p=l._valueTracker;if(!p)return!0;var f=p.getValue(),b="";return l&&(b=Xr(l)?l.checked?"true":"false":l.value),l=b,l!==f?(p.setValue(l),!0):!1}function Ls(l){if(l=l||(typeof document<"u"?document:void 0),typeof l>"u")return null;try{return l.activeElement||l.body}catch{return l.body}}var bu=/[\n"\\]/g;function hr(l){return l.replace(bu,function(p){return"\\"+p.charCodeAt(0).toString(16)+" "})}function yu(l,p,f,b,A,I,W,J){l.name="",W!=null&&typeof W!="function"&&typeof W!="symbol"&&typeof W!="boolean"?l.type=W:l.removeAttribute("type"),p!=null?W==="number"?(p===0&&l.value===""||l.value!=p)&&(l.value=""+kr(p)):l.value!==""+kr(p)&&(l.value=""+kr(p)):W!=="submit"&&W!=="reset"||l.removeAttribute("value"),p!=null?fl(l,W,kr(p)):f!=null?fl(l,W,kr(f)):b!=null&&l.removeAttribute("value"),A==null&&I!=null&&(l.defaultChecked=!!I),A!=null&&(l.checked=A&&typeof A!="function"&&typeof A!="symbol"),J!=null&&typeof J!="function"&&typeof J!="symbol"&&typeof J!="boolean"?l.name=""+kr(J):l.removeAttribute("name")}function Zc(l,p,f,b,A,I,W,J){if(I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"&&(l.type=I),p!=null||f!=null){if(!(I!=="submit"&&I!=="reset"||p!=null))return;f=f!=null?""+kr(f):"",p=p!=null?""+kr(p):f,J||p===l.value||(l.value=p),l.defaultValue=p}b=b??A,b=typeof b!="function"&&typeof b!="symbol"&&!!b,l.checked=J?l.checked:!!b,l.defaultChecked=!!b,W!=null&&typeof W!="function"&&typeof W!="symbol"&&typeof W!="boolean"&&(l.name=W)}function fl(l,p,f){p==="number"&&Ls(l.ownerDocument)===l||l.defaultValue===""+f||(l.defaultValue=""+f)}function ei(l,p,f,b){if(l=l.options,p){p={};for(var A=0;A<f.length;A++)p["$"+f[A]]=!0;for(f=0;f<l.length;f++)A=p.hasOwnProperty("$"+l[f].value),l[f].selected!==A&&(l[f].selected=A),A&&b&&(l[f].defaultSelected=!0)}else{for(f=""+kr(f),p=null,A=0;A<l.length;A++){if(l[A].value===f){l[A].selected=!0,b&&(l[A].defaultSelected=!0);return}p!==null||l[A].disabled||(p=l[A])}p!==null&&(p.selected=!0)}}function wu(l,p,f){if(p!=null&&(p=""+kr(p),p!==l.value&&(l.value=p),f==null)){l.defaultValue!==p&&(l.defaultValue=p);return}l.defaultValue=f!=null?""+kr(f):""}function zs(l,p,f,b){if(p==null){if(b!=null){if(f!=null)throw Error(a(92));if(he(b)){if(1<b.length)throw Error(a(93));b=b[0]}f=b}f==null&&(f=""),p=f}f=kr(p),l.defaultValue=f,b=l.textContent,b===f&&b!==""&&b!==null&&(l.value=b)}function fa(l,p){if(p){var f=l.firstChild;if(f&&f===l.lastChild&&f.nodeType===3){f.nodeValue=p;return}}l.textContent=p}var Mr=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function xu(l,p,f){var b=p.indexOf("--")===0;f==null||typeof f=="boolean"||f===""?b?l.setProperty(p,""):p==="float"?l.cssFloat="":l[p]="":b?l.setProperty(p,f):typeof f!="number"||f===0||Mr.has(p)?p==="float"?l.cssFloat=f:l[p]=(""+f).trim():l[p]=f+"px"}function Xc(l,p,f){if(p!=null&&typeof p!="object")throw Error(a(62));if(l=l.style,f!=null){for(var b in f)!f.hasOwnProperty(b)||p!=null&&p.hasOwnProperty(b)||(b.indexOf("--")===0?l.setProperty(b,""):b==="float"?l.cssFloat="":l[b]="");for(var A in p)b=p[A],p.hasOwnProperty(A)&&f[A]!==b&&xu(l,A,b)}else for(var I in p)p.hasOwnProperty(I)&&xu(l,I,p[I])}function ml(l){if(l.indexOf("-")===-1)return!1;switch(l){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var gl=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),vu=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function fs(l){return vu.test(""+l)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":l}var bl=null;function Us(l){return l=l.target||l.srcElement||window,l.correspondingUseElement&&(l=l.correspondingUseElement),l.nodeType===3?l.parentNode:l}var ti=null,Vs=null;function re(l){var p=Sr(l);if(p&&(l=p.stateNode)){var f=l[xt]||null;e:switch(l=p.stateNode,p.type){case"input":if(yu(l,f.value,f.defaultValue,f.defaultValue,f.checked,f.defaultChecked,f.type,f.name),p=f.name,f.type==="radio"&&p!=null){for(f=l;f.parentNode;)f=f.parentNode;for(f=f.querySelectorAll('input[name="'+hr(""+p)+'"][type="radio"]'),p=0;p<f.length;p++){var b=f[p];if(b!==l&&b.form===l.form){var A=b[xt]||null;if(!A)throw Error(a(90));yu(b,A.value,A.defaultValue,A.defaultValue,A.checked,A.defaultChecked,A.type,A.name)}}for(p=0;p<f.length;p++)b=f[p],b.form===l.form&&Bs(b)}break e;case"textarea":wu(l,f.value,f.defaultValue);break e;case"select":p=f.value,p!=null&&ei(l,!!f.multiple,p,!1)}}}var Ie=!1;function Ye(l,p,f){if(Ie)return l(p,f);Ie=!0;try{var b=l(p);return b}finally{if(Ie=!1,(ti!==null||Vs!==null)&&(Sx(),ti&&(p=ti,l=Vs,Vs=ti=null,re(p),l)))for(p=0;p<l.length;p++)re(l[p])}}function bt(l,p){var f=l.stateNode;if(f===null)return null;var b=f[xt]||null;if(b===null)return null;f=b[p];e:switch(p){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(b=!b.disabled)||(l=l.type,b=!(l==="button"||l==="input"||l==="select"||l==="textarea")),l=!b;break e;default:l=!1}if(l)return null;if(f&&typeof f!="function")throw Error(a(231,p,typeof f));return f}var At=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Mt=!1;if(At)try{var et={};Object.defineProperty(et,"passive",{get:function(){Mt=!0}}),window.addEventListener("test",et,et),window.removeEventListener("test",et,et)}catch{Mt=!1}var st=null,Rn=null,qa=null;function gi(){if(qa)return qa;var l,p=Rn,f=p.length,b,A="value"in st?st.value:st.textContent,I=A.length;for(l=0;l<f&&p[l]===A[l];l++);var W=f-l;for(b=1;b<=W&&p[f-b]===A[I-b];b++);return qa=A.slice(l,1<b?1-b:void 0)}function yl(l){var p=l.keyCode;return"charCode"in l?(l=l.charCode,l===0&&p===13&&(l=13)):l=p,l===10&&(l=13),32<=l||l===13?l:0}function vo(){return!0}function Jh(){return!1}function Mn(l){function p(f,b,A,I,W){this._reactName=f,this._targetInst=A,this.type=b,this.nativeEvent=I,this.target=W,this.currentTarget=null;for(var J in l)l.hasOwnProperty(J)&&(f=l[J],this[J]=f?f(I):I[J]);return this.isDefaultPrevented=(I.defaultPrevented!=null?I.defaultPrevented:I.returnValue===!1)?vo:Jh,this.isPropagationStopped=Jh,this}return c(p.prototype,{preventDefault:function(){this.defaultPrevented=!0;var f=this.nativeEvent;f&&(f.preventDefault?f.preventDefault():typeof f.returnValue!="unknown"&&(f.returnValue=!1),this.isDefaultPrevented=vo)},stopPropagation:function(){var f=this.nativeEvent;f&&(f.stopPropagation?f.stopPropagation():typeof f.cancelBubble!="unknown"&&(f.cancelBubble=!0),this.isPropagationStopped=vo)},persist:function(){},isPersistent:vo}),p}var Br={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(l){return l.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},wl=Mn(Br),ed=c({},Br,{view:0,detail:0}),$_=Mn(ed),xl,ab,td,rb=c({},ed,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:yi,button:0,buttons:0,relatedTarget:function(l){return l.relatedTarget===void 0?l.fromElement===l.srcElement?l.toElement:l.fromElement:l.relatedTarget},movementX:function(l){return"movementX"in l?l.movementX:(l!==td&&(td&&l.type==="mousemove"?(xl=l.screenX-td.screenX,ab=l.screenY-td.screenY):ab=xl=0,td=l),xl)},movementY:function(l){return"movementY"in l?l.movementY:ab}}),Ra=Mn(rb),vl=c({},rb,{dataTransfer:0}),nd=Mn(vl),TS=c({},ed,{relatedTarget:0}),ad=Mn(TS),NS=c({},Br,{animationName:0,elapsedTime:0,pseudoElement:0}),So=Mn(NS),RS=c({},Br,{clipboardData:function(l){return"clipboardData"in l?l.clipboardData:window.clipboardData}}),ko=Mn(RS),FS=c({},Br,{data:0}),fw=Mn(FS),bi={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},mw={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Qa={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function gw(l){var p=this.nativeEvent;return p.getModifierState?p.getModifierState(l):(l=Qa[l])?!!p[l]:!1}function yi(){return gw}var DS=c({},ed,{key:function(l){if(l.key){var p=bi[l.key]||l.key;if(p!=="Unidentified")return p}return l.type==="keypress"?(l=yl(l),l===13?"Enter":String.fromCharCode(l)):l.type==="keydown"||l.type==="keyup"?mw[l.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:yi,charCode:function(l){return l.type==="keypress"?yl(l):0},keyCode:function(l){return l.type==="keydown"||l.type==="keyup"?l.keyCode:0},which:function(l){return l.type==="keypress"?yl(l):l.type==="keydown"||l.type==="keyup"?l.keyCode:0}}),ib=Mn(DS),OS=c({},rb,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),bw=Mn(OS),Yh=c({},ed,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:yi}),MS=Mn(Yh),BS=c({},Br,{propertyName:0,elapsedTime:0,pseudoElement:0}),LS=Mn(BS),zS=c({},rb,{deltaX:function(l){return"deltaX"in l?l.deltaX:"wheelDeltaX"in l?-l.wheelDeltaX:0},deltaY:function(l){return"deltaY"in l?l.deltaY:"wheelDeltaY"in l?-l.wheelDeltaY:"wheelDelta"in l?-l.wheelDelta:0},deltaZ:0,deltaMode:0}),jh=Mn(zS),US=c({},Br,{newState:0,oldState:0}),VS=Mn(US),WS=[9,13,27,32],yw=At&&"CompositionEvent"in window,Qh=null;At&&"documentMode"in document&&(Qh=document.documentMode);var sb=At&&"TextEvent"in window&&!Qh,ww=At&&(!yw||Qh&&8<Qh&&11>=Qh),xw=" ",vw=!1;function Sw(l,p){switch(l){case"keyup":return WS.indexOf(p.keyCode)!==-1;case"keydown":return p.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function dn(l){return l=l.detail,typeof l=="object"&&"data"in l?l.data:null}var ni=!1;function ms(l,p){switch(l){case"compositionend":return dn(p);case"keypress":return p.which!==32?null:(vw=!0,xw);case"textInput":return l=p.data,l===xw&&vw?null:l;default:return null}}function qS(l,p){if(ni)return l==="compositionend"||!yw&&Sw(l,p)?(l=gi(),qa=Rn=st=null,ni=!1,l):null;switch(l){case"paste":return null;case"keypress":if(!(p.ctrlKey||p.altKey||p.metaKey)||p.ctrlKey&&p.altKey){if(p.char&&1<p.char.length)return p.char;if(p.which)return String.fromCharCode(p.which)}return null;case"compositionend":return ww&&p.locale!=="ko"?null:p.data;default:return null}}var Su={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Zh(l){var p=l&&l.nodeName&&l.nodeName.toLowerCase();return p==="input"?!!Su[l.type]:p==="textarea"}function Xh(l,p,f,b){ti?Vs?Vs.push(b):Vs=[b]:ti=b,p=_x(p,"onChange"),0<p.length&&(f=new wl("onChange","change",null,f,b),l.push({event:f,listeners:p}))}var Sl=null,kl=null;function ob(l){_T(l,0)}function gs(l){var p=zi(l);if(Bs(p))return l}function ku(l,p){if(l==="change")return p}var fr=!1;if(At){var Ao;if(At){var Ws="oninput"in document;if(!Ws){var Al=document.createElement("div");Al.setAttribute("oninput","return;"),Ws=typeof Al.oninput=="function"}Ao=Ws}else Ao=!1;fr=Ao&&(!document.documentMode||9<document.documentMode)}function kw(){Sl&&(Sl.detachEvent("onpropertychange",Eo),kl=Sl=null)}function Eo(l){if(l.propertyName==="value"&&gs(kl)){var p=[];Xh(p,kl,l,Us(l)),Ye(ob,p)}}function Aw(l,p,f){l==="focusin"?(kw(),Sl=p,kl=f,Sl.attachEvent("onpropertychange",Eo)):l==="focusout"&&kw()}function Co(l){if(l==="selectionchange"||l==="keyup"||l==="keydown")return gs(kl)}function PS(l,p){if(l==="click")return gs(p)}function J_(l,p){if(l==="input"||l==="change")return gs(p)}function Io(l,p){return l===p&&(l!==0||1/l===1/p)||l!==l&&p!==p}var ea=typeof Object.is=="function"?Object.is:Io;function Za(l,p){if(ea(l,p))return!0;if(typeof l!="object"||l===null||typeof p!="object"||p===null)return!1;var f=Object.keys(l),b=Object.keys(p);if(f.length!==b.length)return!1;for(b=0;b<f.length;b++){var A=f[b];if(!_t.call(p,A)||!ea(l[A],p[A]))return!1}return!0}function wn(l){for(;l&&l.firstChild;)l=l.firstChild;return l}function Au(l,p){var f=wn(l);l=0;for(var b;f;){if(f.nodeType===3){if(b=l+f.textContent.length,l<=p&&b>=p)return{node:f,offset:p-l};l=b}e:{for(;f;){if(f.nextSibling){f=f.nextSibling;break e}f=f.parentNode}f=void 0}f=wn(f)}}function ef(l,p){return l&&p?l===p?!0:l&&l.nodeType===3?!1:p&&p.nodeType===3?ef(l,p.parentNode):"contains"in l?l.contains(p):l.compareDocumentPosition?!!(l.compareDocumentPosition(p)&16):!1:!1}function lb(l){l=l!=null&&l.ownerDocument!=null&&l.ownerDocument.defaultView!=null?l.ownerDocument.defaultView:window;for(var p=Ls(l.document);p instanceof l.HTMLIFrameElement;){try{var f=typeof p.contentWindow.location.href=="string"}catch{f=!1}if(f)l=p.contentWindow;else break;p=Ls(l.document)}return p}function _o(l){var p=l&&l.nodeName&&l.nodeName.toLowerCase();return p&&(p==="input"&&(l.type==="text"||l.type==="search"||l.type==="tel"||l.type==="url"||l.type==="password")||p==="textarea"||l.contentEditable==="true")}var Ew=At&&"documentMode"in document&&11>=document.documentMode,To=null,No=null,rd=null,ub=!1;function Vi(l,p,f){var b=f.window===f?f.document:f.nodeType===9?f:f.ownerDocument;ub||To==null||To!==Ls(b)||(b=To,"selectionStart"in b&&_o(b)?b={start:b.selectionStart,end:b.selectionEnd}:(b=(b.ownerDocument&&b.ownerDocument.defaultView||window).getSelection(),b={anchorNode:b.anchorNode,anchorOffset:b.anchorOffset,focusNode:b.focusNode,focusOffset:b.focusOffset}),rd&&Za(rd,b)||(rd=b,b=_x(No,"onSelect"),0<b.length&&(p=new wl("onSelect","select",null,p,f),l.push({event:p,listeners:b}),p.target=To)))}function Wi(l,p){var f={};return f[l.toLowerCase()]=p.toLowerCase(),f["Webkit"+l]="webkit"+p,f["Moz"+l]="moz"+p,f}var Eu={animationend:Wi("Animation","AnimationEnd"),animationiteration:Wi("Animation","AnimationIteration"),animationstart:Wi("Animation","AnimationStart"),transitionrun:Wi("Transition","TransitionRun"),transitionstart:Wi("Transition","TransitionStart"),transitioncancel:Wi("Transition","TransitionCancel"),transitionend:Wi("Transition","TransitionEnd")},cb={},Cu={};At&&(Cu=document.createElement("div").style,"AnimationEvent"in window||(delete Eu.animationend.animation,delete Eu.animationiteration.animation,delete Eu.animationstart.animation),"TransitionEvent"in window||delete Eu.transitionend.transition);function Ro(l){if(cb[l])return cb[l];if(!Eu[l])return l;var p=Eu[l],f;for(f in p)if(p.hasOwnProperty(f)&&f in Cu)return cb[l]=p[f];return l}var db=Ro("animationend"),Cw=Ro("animationiteration"),pb=Ro("animationstart"),HS=Ro("transitionrun"),GS=Ro("transitionstart"),KS=Ro("transitioncancel"),Iw=Ro("transitionend"),_w=new Map,hb="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");hb.push("scrollEnd");function qi(l,p){_w.set(l,p),Qr(p,[l])}var Tw=new WeakMap;function wi(l,p){if(typeof l=="object"&&l!==null){var f=Tw.get(l);return f!==void 0?f:(p={value:l,source:p,stack:Qc(p)},Tw.set(l,p),p)}return{value:l,source:p,stack:Qc(p)}}var xi=[],Iu=0,fb=0;function tf(){for(var l=Iu,p=fb=Iu=0;p<l;){var f=xi[p];xi[p++]=null;var b=xi[p];xi[p++]=null;var A=xi[p];xi[p++]=null;var I=xi[p];if(xi[p++]=null,b!==null&&A!==null){var W=b.pending;W===null?A.next=A:(A.next=W.next,W.next=A),b.pending=A}I!==0&&Nw(f,A,I)}}function Fo(l,p,f,b){xi[Iu++]=l,xi[Iu++]=p,xi[Iu++]=f,xi[Iu++]=b,fb|=b,l.lanes|=b,l=l.alternate,l!==null&&(l.lanes|=b)}function mb(l,p,f,b){return Fo(l,p,f,b),El(l)}function _u(l,p){return Fo(l,null,null,p),El(l)}function Nw(l,p,f){l.lanes|=f;var b=l.alternate;b!==null&&(b.lanes|=f);for(var A=!1,I=l.return;I!==null;)I.childLanes|=f,b=I.alternate,b!==null&&(b.childLanes|=f),I.tag===22&&(l=I.stateNode,l===null||l._visibility&1||(A=!0)),l=I,I=I.return;return l.tag===3?(I=l.stateNode,A&&p!==null&&(A=31-F(f),l=I.hiddenUpdates,b=l[A],b===null?l[A]=[p]:b.push(p),p.lane=f|536870912),I):null}function El(l){if(50<Xb)throw Xb=0,p2=null,Error(a(185));for(var p=l.return;p!==null;)l=p,p=l.return;return l.tag===3?l.stateNode:null}var Cl={};function id(l,p,f,b){this.tag=l,this.key=f,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=p,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=b,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ai(l,p,f,b){return new id(l,p,f,b)}function gb(l){return l=l.prototype,!(!l||!l.isReactComponent)}function qs(l,p){var f=l.alternate;return f===null?(f=ai(l.tag,p,l.key,l.mode),f.elementType=l.elementType,f.type=l.type,f.stateNode=l.stateNode,f.alternate=l,l.alternate=f):(f.pendingProps=p,f.type=l.type,f.flags=0,f.subtreeFlags=0,f.deletions=null),f.flags=l.flags&65011712,f.childLanes=l.childLanes,f.lanes=l.lanes,f.child=l.child,f.memoizedProps=l.memoizedProps,f.memoizedState=l.memoizedState,f.updateQueue=l.updateQueue,p=l.dependencies,f.dependencies=p===null?null:{lanes:p.lanes,firstContext:p.firstContext},f.sibling=l.sibling,f.index=l.index,f.ref=l.ref,f.refCleanup=l.refCleanup,f}function Rw(l,p){l.flags&=65011714;var f=l.alternate;return f===null?(l.childLanes=0,l.lanes=p,l.child=null,l.subtreeFlags=0,l.memoizedProps=null,l.memoizedState=null,l.updateQueue=null,l.dependencies=null,l.stateNode=null):(l.childLanes=f.childLanes,l.lanes=f.lanes,l.child=f.child,l.subtreeFlags=0,l.deletions=null,l.memoizedProps=f.memoizedProps,l.memoizedState=f.memoizedState,l.updateQueue=f.updateQueue,l.type=f.type,p=f.dependencies,l.dependencies=p===null?null:{lanes:p.lanes,firstContext:p.firstContext}),l}function Do(l,p,f,b,A,I){var W=0;if(b=l,typeof l=="function")gb(l)&&(W=1);else if(typeof l=="string")W=l6(l,f,_e.current)?26:l==="html"||l==="head"||l==="body"?27:5;else e:switch(l){case j:return l=ai(31,f,p,A),l.elementType=j,l.lanes=I,l;case x:return Il(f.children,A,I,p);case v:W=8,A|=24;break;case S:return l=ai(12,f,p,A|2),l.elementType=S,l.lanes=I,l;case D:return l=ai(13,f,p,A),l.elementType=D,l.lanes=I,l;case q:return l=ai(19,f,p,A),l.elementType=q,l.lanes=I,l;default:if(typeof l=="object"&&l!==null)switch(l.$$typeof){case E:case T:W=10;break e;case C:W=9;break e;case N:W=11;break e;case H:W=14;break e;case K:W=16,b=null;break e}W=29,f=Error(a(130,l===null?"null":typeof l,"")),b=null}return p=ai(W,f,p,A),p.elementType=l,p.type=b,p.lanes=I,p}function Il(l,p,f,b){return l=ai(7,l,b,p),l.lanes=f,l}function nf(l,p,f){return l=ai(6,l,null,p),l.lanes=f,l}function af(l,p,f){return p=ai(4,l.children!==null?l.children:[],l.key,p),p.lanes=f,p.stateNode={containerInfo:l.containerInfo,pendingChildren:null,implementation:l.implementation},p}var Tu=[],Nu=0,rf=null,sf=0,Ar=[],vi=0,_l=null,Ps=1,Hs="";function Pi(l,p){Tu[Nu++]=sf,Tu[Nu++]=rf,rf=l,sf=p}function of(l,p,f){Ar[vi++]=Ps,Ar[vi++]=Hs,Ar[vi++]=_l,_l=l;var b=Ps;l=Hs;var A=32-F(b)-1;b&=~(1<<A),f+=1;var I=32-F(p)+A;if(30<I){var W=A-A%5;I=(b&(1<<W)-1).toString(32),b>>=W,A-=W,Ps=1<<32-F(p)+A|f<<A|b,Hs=I+l}else Ps=1<<I|f<<A|b,Hs=l}function bb(l){l.return!==null&&(Pi(l,1),of(l,1,0))}function yb(l){for(;l===rf;)rf=Tu[--Nu],Tu[Nu]=null,sf=Tu[--Nu],Tu[Nu]=null;for(;l===_l;)_l=Ar[--vi],Ar[vi]=null,Hs=Ar[--vi],Ar[vi]=null,Ps=Ar[--vi],Ar[vi]=null}var Er=null,ma=null,En=!1,Tl=null,bs=!1,Ru=Error(a(519));function Nl(l){var p=Error(a(418,""));throw Fl(wi(p,l)),Ru}function Fw(l){var p=l.stateNode,f=l.type,b=l.memoizedProps;switch(p[Gt]=l,p[xt]=b,f){case"dialog":mn("cancel",p),mn("close",p);break;case"iframe":case"object":case"embed":mn("load",p);break;case"video":case"audio":for(f=0;f<ty.length;f++)mn(ty[f],p);break;case"source":mn("error",p);break;case"img":case"image":case"link":mn("error",p),mn("load",p);break;case"details":mn("toggle",p);break;case"input":mn("invalid",p),Zc(p,b.value,b.defaultValue,b.checked,b.defaultChecked,b.type,b.name,!0),hs(p);break;case"select":mn("invalid",p);break;case"textarea":mn("invalid",p),zs(p,b.value,b.defaultValue,b.children),hs(p)}f=b.children,typeof f!="string"&&typeof f!="number"&&typeof f!="bigint"||p.textContent===""+f||b.suppressHydrationWarning===!0||FT(p.textContent,f)?(b.popover!=null&&(mn("beforetoggle",p),mn("toggle",p)),b.onScroll!=null&&mn("scroll",p),b.onScrollEnd!=null&&mn("scrollend",p),b.onClick!=null&&(p.onclick=Tx),p=!0):p=!1,p||Nl(l)}function Rl(l){for(Er=l.return;Er;)switch(Er.tag){case 5:case 13:bs=!1;return;case 27:case 3:bs=!0;return;default:Er=Er.return}}function Fu(l){if(l!==Er)return!1;if(!En)return Rl(l),En=!0,!1;var p=l.tag,f;if((f=p!==3&&p!==27)&&((f=p===5)&&(f=l.type,f=!(f!=="form"&&f!=="button")||_2(l.type,l.memoizedProps)),f=!f),f&&ma&&Nl(l),Rl(l),p===13){if(l=l.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(a(317));e:{for(l=l.nextSibling,p=0;l;){if(l.nodeType===8)if(f=l.data,f==="/$"){if(p===0){ma=Zs(l.nextSibling);break e}p--}else f!=="$"&&f!=="$!"&&f!=="$?"||p++;l=l.nextSibling}ma=null}}else p===27?(p=ma,Qu(l.type)?(l=F2,F2=null,ma=l):ma=p):ma=Er?Zs(l.stateNode.nextSibling):null;return!0}function Du(){ma=Er=null,En=!1}function wb(){var l=Tl;return l!==null&&(Si===null?Si=l:Si.push.apply(Si,l),Tl=null),l}function Fl(l){Tl===null?Tl=[l]:Tl.push(l)}var lf=ie(null),Dl=null,Gs=null;function Oo(l,p,f){me(lf,p._currentValue),p._currentValue=f}function Ks(l){l._currentValue=lf.current,xe(lf)}function Dw(l,p,f){for(;l!==null;){var b=l.alternate;if((l.childLanes&p)!==p?(l.childLanes|=p,b!==null&&(b.childLanes|=p)):b!==null&&(b.childLanes&p)!==p&&(b.childLanes|=p),l===f)break;l=l.return}}function Ol(l,p,f,b){var A=l.child;for(A!==null&&(A.return=l);A!==null;){var I=A.dependencies;if(I!==null){var W=A.child;I=I.firstContext;e:for(;I!==null;){var J=I;I=A;for(var ce=0;ce<p.length;ce++)if(J.context===p[ce]){I.lanes|=f,J=I.alternate,J!==null&&(J.lanes|=f),Dw(I.return,f,l),b||(W=null);break e}I=J.next}}else if(A.tag===18){if(W=A.return,W===null)throw Error(a(341));W.lanes|=f,I=W.alternate,I!==null&&(I.lanes|=f),Dw(W,f,l),W=null}else W=A.child;if(W!==null)W.return=A;else for(W=A;W!==null;){if(W===l){W=null;break}if(A=W.sibling,A!==null){A.return=W.return,W=A;break}W=W.return}A=W}}function sd(l,p,f,b){l=null;for(var A=p,I=!1;A!==null;){if(!I){if((A.flags&524288)!==0)I=!0;else if((A.flags&262144)!==0)break}if(A.tag===10){var W=A.alternate;if(W===null)throw Error(a(387));if(W=W.memoizedProps,W!==null){var J=A.type;ea(A.pendingProps.value,W.value)||(l!==null?l.push(J):l=[J])}}else if(A===$e.current){if(W=A.alternate,W===null)throw Error(a(387));W.memoizedState.memoizedState!==A.memoizedState.memoizedState&&(l!==null?l.push(oy):l=[oy])}A=A.return}l!==null&&Ol(p,l,f,b),p.flags|=262144}function od(l){for(l=l.firstContext;l!==null;){if(!ea(l.context._currentValue,l.memoizedValue))return!0;l=l.next}return!1}function Mo(l){Dl=l,Gs=null,l=l.dependencies,l!==null&&(l.firstContext=null)}function Xa(l){return ld(Dl,l)}function uf(l,p){return Dl===null&&Mo(l),ld(l,p)}function ld(l,p){var f=p._currentValue;if(p={context:p,memoizedValue:f,next:null},Gs===null){if(l===null)throw Error(a(308));Gs=p,l.dependencies={lanes:0,firstContext:p},l.flags|=524288}else Gs=Gs.next=p;return f}var Ml=typeof AbortController<"u"?AbortController:function(){var l=[],p=this.signal={aborted:!1,addEventListener:function(f,b){l.push(b)}};this.abort=function(){p.aborted=!0,l.forEach(function(f){return f()})}},$S=e.unstable_scheduleCallback,JS=e.unstable_NormalPriority,In={$$typeof:T,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function cf(){return{controller:new Ml,data:new Map,refCount:0}}function Ou(l){l.refCount--,l.refCount===0&&$S(JS,function(){l.controller.abort()})}var ud=null,df=0,$s=0,Bl=null;function Ow(l,p){if(ud===null){var f=ud=[];df=0,$s=w2(),Bl={status:"pending",value:void 0,then:function(b){f.push(b)}}}return df++,p.then(xb,xb),p}function xb(){if(--df===0&&ud!==null){Bl!==null&&(Bl.status="fulfilled");var l=ud;ud=null,$s=0,Bl=null;for(var p=0;p<l.length;p++)(0,l[p])()}}function Mw(l,p){var f=[],b={status:"pending",value:null,reason:null,then:function(A){f.push(A)}};return l.then(function(){b.status="fulfilled",b.value=p;for(var A=0;A<f.length;A++)(0,f[A])(p)},function(A){for(b.status="rejected",b.reason=A,A=0;A<f.length;A++)(0,f[A])(void 0)}),b}var vb=Z.S;Z.S=function(l,p){typeof p=="object"&&p!==null&&typeof p.then=="function"&&Ow(l,p),vb!==null&&vb(l,p)};var Bo=ie(null);function pf(){var l=Bo.current;return l!==null?l:la.pooledCache}function cd(l,p){p===null?me(Bo,Bo.current):me(Bo,p.pool)}function Sb(){var l=pf();return l===null?null:{parent:In._currentValue,pool:l}}var Lo=Error(a(460)),ys=Error(a(474)),Mu=Error(a(542)),hf={then:function(){}};function ff(l){return l=l.status,l==="fulfilled"||l==="rejected"}function dd(){}function kb(l,p,f){switch(f=l[f],f===void 0?l.push(p):f!==p&&(p.then(dd,dd),p=f),p.status){case"fulfilled":return p.value;case"rejected":throw l=p.reason,pd(l),l;default:if(typeof p.status=="string")p.then(dd,dd);else{if(l=la,l!==null&&100<l.shellSuspendCounter)throw Error(a(482));l=p,l.status="pending",l.then(function(b){if(p.status==="pending"){var A=p;A.status="fulfilled",A.value=b}},function(b){if(p.status==="pending"){var A=p;A.status="rejected",A.reason=b}})}switch(p.status){case"fulfilled":return p.value;case"rejected":throw l=p.reason,pd(l),l}throw Bu=p,Lo}}var Bu=null;function Ab(){if(Bu===null)throw Error(a(459));var l=Bu;return Bu=null,l}function pd(l){if(l===Lo||l===Mu)throw Error(a(483))}var Hi=!1;function mf(l){l.updateQueue={baseState:l.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function gf(l,p){l=l.updateQueue,p.updateQueue===l&&(p.updateQueue={baseState:l.baseState,firstBaseUpdate:l.firstBaseUpdate,lastBaseUpdate:l.lastBaseUpdate,shared:l.shared,callbacks:null})}function Js(l){return{lane:l,tag:0,payload:null,callback:null,next:null}}function Ys(l,p,f){var b=l.updateQueue;if(b===null)return null;if(b=b.shared,(Wn&2)!==0){var A=b.pending;return A===null?p.next=p:(p.next=A.next,A.next=p),b.pending=p,p=El(l),Nw(l,null,f),p}return Fo(l,b,p,f),El(l)}function Lu(l,p,f){if(p=p.updateQueue,p!==null&&(p=p.shared,(f&4194048)!==0)){var b=p.lanes;b&=l.pendingLanes,f|=b,p.lanes=f,mo(l,f)}}function hd(l,p){var f=l.updateQueue,b=l.alternate;if(b!==null&&(b=b.updateQueue,f===b)){var A=null,I=null;if(f=f.firstBaseUpdate,f!==null){do{var W={lane:f.lane,tag:f.tag,payload:f.payload,callback:null,next:null};I===null?A=I=W:I=I.next=W,f=f.next}while(f!==null);I===null?A=I=p:I=I.next=p}else A=I=p;f={baseState:b.baseState,firstBaseUpdate:A,lastBaseUpdate:I,shared:b.shared,callbacks:b.callbacks},l.updateQueue=f;return}l=f.lastBaseUpdate,l===null?f.firstBaseUpdate=p:l.next=p,f.lastBaseUpdate=p}var bf=!1;function zu(){if(bf){var l=Bl;if(l!==null)throw l}}function Bn(l,p,f,b){bf=!1;var A=l.updateQueue;Hi=!1;var I=A.firstBaseUpdate,W=A.lastBaseUpdate,J=A.shared.pending;if(J!==null){A.shared.pending=null;var ce=J,Ne=ce.next;ce.next=null,W===null?I=Ne:W.next=Ne,W=ce;var Ue=l.alternate;Ue!==null&&(Ue=Ue.updateQueue,J=Ue.lastBaseUpdate,J!==W&&(J===null?Ue.firstBaseUpdate=Ne:J.next=Ne,Ue.lastBaseUpdate=ce))}if(I!==null){var Ge=A.baseState;W=0,Ue=Ne=ce=null,J=I;do{var Fe=J.lane&-536870913,De=Fe!==J.lane;if(De?(xn&Fe)===Fe:(b&Fe)===Fe){Fe!==0&&Fe===$s&&(bf=!0),Ue!==null&&(Ue=Ue.next={lane:0,tag:J.tag,payload:J.payload,callback:null,next:null});e:{var Bt=l,Tt=J;Fe=p;var Qn=f;switch(Tt.tag){case 1:if(Bt=Tt.payload,typeof Bt=="function"){Ge=Bt.call(Qn,Ge,Fe);break e}Ge=Bt;break e;case 3:Bt.flags=Bt.flags&-65537|128;case 0:if(Bt=Tt.payload,Fe=typeof Bt=="function"?Bt.call(Qn,Ge,Fe):Bt,Fe==null)break e;Ge=c({},Ge,Fe);break e;case 2:Hi=!0}}Fe=J.callback,Fe!==null&&(l.flags|=64,De&&(l.flags|=8192),De=A.callbacks,De===null?A.callbacks=[Fe]:De.push(Fe))}else De={lane:Fe,tag:J.tag,payload:J.payload,callback:J.callback,next:null},Ue===null?(Ne=Ue=De,ce=Ge):Ue=Ue.next=De,W|=Fe;if(J=J.next,J===null){if(J=A.shared.pending,J===null)break;De=J,J=De.next,De.next=null,A.lastBaseUpdate=De,A.shared.pending=null}}while(!0);Ue===null&&(ce=Ge),A.baseState=ce,A.firstBaseUpdate=Ne,A.lastBaseUpdate=Ue,I===null&&(A.shared.lanes=0),$u|=W,l.lanes=W,l.memoizedState=Ge}}function Eb(l,p){if(typeof l!="function")throw Error(a(191,l));l.call(p)}function Cb(l,p){var f=l.callbacks;if(f!==null)for(l.callbacks=null,l=0;l<f.length;l++)Eb(f[l],p)}var Uu=ie(null),yf=ie(0);function YS(l,p){l=Gl,me(yf,l),me(Uu,p),Gl=l|p.baseLanes}function Ib(){me(yf,Gl),me(Uu,Uu.current)}function wf(){Gl=yf.current,xe(Uu),xe(yf)}var zo=0,zt=null,Fn=null,Sa=null,fd=!1,Ll=!1,zl=!1,md=0,Ul=0,Uo=null,jS=0;function ga(){throw Error(a(321))}function _b(l,p){if(p===null)return!1;for(var f=0;f<p.length&&f<l.length;f++)if(!ea(l[f],p[f]))return!1;return!0}function Tb(l,p,f,b,A,I){return zo=I,zt=p,p.memoizedState=null,p.updateQueue=null,p.lanes=0,Z.H=l===null||l.memoizedState===null?lx:Wb,zl=!1,I=f(b,A),zl=!1,Ll&&(I=Lw(p,f,b,A)),Bw(l),I}function Bw(l){Z.H=kd;var p=Fn!==null&&Fn.next!==null;if(zo=0,Sa=Fn=zt=null,fd=!1,Ul=0,Uo=null,p)throw Error(a(300));l===null||Ha||(l=l.dependencies,l!==null&&od(l)&&(Ha=!0))}function Lw(l,p,f,b){zt=l;var A=0;do{if(Ll&&(Uo=null),Ul=0,Ll=!1,25<=A)throw Error(a(301));if(A+=1,Sa=Fn=null,l.updateQueue!=null){var I=l.updateQueue;I.lastEffect=null,I.events=null,I.stores=null,I.memoCache!=null&&(I.memoCache.index=0)}Z.H=ux,I=p(f,b)}while(Ll);return I}function QS(){var l=Z.H,p=l.useState()[0];return p=typeof p.then=="function"?gd(p):p,l=l.useState()[0],(Fn!==null?Fn.memoizedState:null)!==l&&(zt.flags|=1024),p}function Nb(){var l=md!==0;return md=0,l}function Rb(l,p,f){p.updateQueue=l.updateQueue,p.flags&=-2053,l.lanes&=~f}function Fb(l){if(fd){for(l=l.memoizedState;l!==null;){var p=l.queue;p!==null&&(p.pending=null),l=l.next}fd=!1}zo=0,Sa=Fn=zt=null,Ll=!1,Ul=md=0,Uo=null}function Lr(){var l={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Sa===null?zt.memoizedState=Sa=l:Sa=Sa.next=l,Sa}function Ea(){if(Fn===null){var l=zt.alternate;l=l!==null?l.memoizedState:null}else l=Fn.next;var p=Sa===null?zt.memoizedState:Sa.next;if(p!==null)Sa=p,Fn=l;else{if(l===null)throw zt.alternate===null?Error(a(467)):Error(a(310));Fn=l,l={memoizedState:Fn.memoizedState,baseState:Fn.baseState,baseQueue:Fn.baseQueue,queue:Fn.queue,next:null},Sa===null?zt.memoizedState=Sa=l:Sa=Sa.next=l}return Sa}function Db(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function gd(l){var p=Ul;return Ul+=1,Uo===null&&(Uo=[]),l=kb(Uo,l,p),p=zt,(Sa===null?p.memoizedState:Sa.next)===null&&(p=p.alternate,Z.H=p===null||p.memoizedState===null?lx:Wb),l}function xf(l){if(l!==null&&typeof l=="object"){if(typeof l.then=="function")return gd(l);if(l.$$typeof===T)return Xa(l)}throw Error(a(438,String(l)))}function Ob(l){var p=null,f=zt.updateQueue;if(f!==null&&(p=f.memoCache),p==null){var b=zt.alternate;b!==null&&(b=b.updateQueue,b!==null&&(b=b.memoCache,b!=null&&(p={data:b.data.map(function(A){return A.slice()}),index:0})))}if(p==null&&(p={data:[],index:0}),f===null&&(f=Db(),zt.updateQueue=f),f.memoCache=p,f=p.data[p.index],f===void 0)for(f=p.data[p.index]=Array(l),b=0;b<l;b++)f[b]=te;return p.index++,f}function er(l,p){return typeof p=="function"?p(l):p}function vf(l){var p=Ea();return Mb(p,Fn,l)}function Mb(l,p,f){var b=l.queue;if(b===null)throw Error(a(311));b.lastRenderedReducer=f;var A=l.baseQueue,I=b.pending;if(I!==null){if(A!==null){var W=A.next;A.next=I.next,I.next=W}p.baseQueue=A=I,b.pending=null}if(I=l.baseState,A===null)l.memoizedState=I;else{p=A.next;var J=W=null,ce=null,Ne=p,Ue=!1;do{var Ge=Ne.lane&-536870913;if(Ge!==Ne.lane?(xn&Ge)===Ge:(zo&Ge)===Ge){var Fe=Ne.revertLane;if(Fe===0)ce!==null&&(ce=ce.next={lane:0,revertLane:0,action:Ne.action,hasEagerState:Ne.hasEagerState,eagerState:Ne.eagerState,next:null}),Ge===$s&&(Ue=!0);else if((zo&Fe)===Fe){Ne=Ne.next,Fe===$s&&(Ue=!0);continue}else Ge={lane:0,revertLane:Ne.revertLane,action:Ne.action,hasEagerState:Ne.hasEagerState,eagerState:Ne.eagerState,next:null},ce===null?(J=ce=Ge,W=I):ce=ce.next=Ge,zt.lanes|=Fe,$u|=Fe;Ge=Ne.action,zl&&f(I,Ge),I=Ne.hasEagerState?Ne.eagerState:f(I,Ge)}else Fe={lane:Ge,revertLane:Ne.revertLane,action:Ne.action,hasEagerState:Ne.hasEagerState,eagerState:Ne.eagerState,next:null},ce===null?(J=ce=Fe,W=I):ce=ce.next=Fe,zt.lanes|=Ge,$u|=Ge;Ne=Ne.next}while(Ne!==null&&Ne!==p);if(ce===null?W=I:ce.next=J,!ea(I,l.memoizedState)&&(Ha=!0,Ue&&(f=Bl,f!==null)))throw f;l.memoizedState=I,l.baseState=W,l.baseQueue=ce,b.lastRenderedState=I}return A===null&&(b.lanes=0),[l.memoizedState,b.dispatch]}function Sf(l){var p=Ea(),f=p.queue;if(f===null)throw Error(a(311));f.lastRenderedReducer=l;var b=f.dispatch,A=f.pending,I=p.memoizedState;if(A!==null){f.pending=null;var W=A=A.next;do I=l(I,W.action),W=W.next;while(W!==A);ea(I,p.memoizedState)||(Ha=!0),p.memoizedState=I,p.baseQueue===null&&(p.baseState=I),f.lastRenderedState=I}return[I,b]}function zw(l,p,f){var b=zt,A=Ea(),I=En;if(I){if(f===void 0)throw Error(a(407));f=f()}else f=p();var W=!ea((Fn||A).memoizedState,f);W&&(A.memoizedState=f,Ha=!0),A=A.queue;var J=kf.bind(null,b,A,l);if(yd(2048,8,J,[l]),A.getSnapshot!==p||W||Sa!==null&&Sa.memoizedState.tag&1){if(b.flags|=2048,Wu(9,If(),Vu.bind(null,b,A,f,p),null),la===null)throw Error(a(349));I||(zo&124)!==0||Uw(b,p,f)}return f}function Uw(l,p,f){l.flags|=16384,l={getSnapshot:p,value:f},p=zt.updateQueue,p===null?(p=Db(),zt.updateQueue=p,p.stores=[l]):(f=p.stores,f===null?p.stores=[l]:f.push(l))}function Vu(l,p,f,b){p.value=f,p.getSnapshot=b,Af(p)&&Vw(l)}function kf(l,p,f){return f(function(){Af(p)&&Vw(l)})}function Af(l){var p=l.getSnapshot;l=l.value;try{var f=p();return!ea(l,f)}catch{return!0}}function Vw(l){var p=_u(l,2);p!==null&&Qi(p,l,2)}function Ef(l){var p=Lr();if(typeof l=="function"){var f=l;if(l=f(),zl){G(!0);try{f()}finally{G(!1)}}}return p.memoizedState=p.baseState=l,p.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:er,lastRenderedState:l},p}function Ww(l,p,f,b){return l.baseState=f,Mb(l,Fn,typeof b=="function"?b:er)}function bd(l,p,f,b,A){if(Vo(l))throw Error(a(485));if(l=p.action,l!==null){var I={payload:A,action:l,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(W){I.listeners.push(W)}};Z.T!==null?f(!0):I.isTransition=!1,b(I),f=p.pending,f===null?(I.next=p.pending=I,Cf(p,I)):(I.next=f.next,p.pending=f.next=I)}}function Cf(l,p){var f=p.action,b=p.payload,A=l.state;if(p.isTransition){var I=Z.T,W={};Z.T=W;try{var J=f(A,b),ce=Z.S;ce!==null&&ce(W,J),qw(l,p,J)}catch(Ne){Bb(l,p,Ne)}finally{Z.T=I}}else try{I=f(A,b),qw(l,p,I)}catch(Ne){Bb(l,p,Ne)}}function qw(l,p,f){f!==null&&typeof f=="object"&&typeof f.then=="function"?f.then(function(b){Pw(l,p,b)},function(b){return Bb(l,p,b)}):Pw(l,p,f)}function Pw(l,p,f){p.status="fulfilled",p.value=f,Hw(p),l.state=f,p=l.pending,p!==null&&(f=p.next,f===p?l.pending=null:(f=f.next,p.next=f,Cf(l,f)))}function Bb(l,p,f){var b=l.pending;if(l.pending=null,b!==null){b=b.next;do p.status="rejected",p.reason=f,Hw(p),p=p.next;while(p!==b)}l.action=null}function Hw(l){l=l.listeners;for(var p=0;p<l.length;p++)(0,l[p])()}function Gw(l,p){return p}function Kw(l,p){if(En){var f=la.formState;if(f!==null){e:{var b=zt;if(En){if(ma){t:{for(var A=ma,I=bs;A.nodeType!==8;){if(!I){A=null;break t}if(A=Zs(A.nextSibling),A===null){A=null;break t}}I=A.data,A=I==="F!"||I==="F"?A:null}if(A){ma=Zs(A.nextSibling),b=A.data==="F!";break e}}Nl(b)}b=!1}b&&(p=f[0])}}return f=Lr(),f.memoizedState=f.baseState=p,b={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Gw,lastRenderedState:p},f.queue=b,f=sx.bind(null,zt,b),b.dispatch=f,b=Ef(!1),I=Cr.bind(null,zt,!1,b.queue),b=Lr(),A={state:p,dispatch:null,action:l,pending:null},b.queue=A,f=bd.bind(null,zt,A,I,f),A.dispatch=f,b.memoizedState=l,[p,f,!1]}function $w(l){var p=Ea();return Jw(p,Fn,l)}function Jw(l,p,f){if(p=Mb(l,p,Gw)[0],l=vf(er)[0],typeof p=="object"&&p!==null&&typeof p.then=="function")try{var b=gd(p)}catch(W){throw W===Lo?Mu:W}else b=p;p=Ea();var A=p.queue,I=A.dispatch;return f!==p.memoizedState&&(zt.flags|=2048,Wu(9,If(),ZS.bind(null,A,f),null)),[b,I,l]}function ZS(l,p){l.action=p}function Yw(l){var p=Ea(),f=Fn;if(f!==null)return Jw(p,f,l);Ea(),p=p.memoizedState,f=Ea();var b=f.queue.dispatch;return f.memoizedState=l,[p,b,!1]}function Wu(l,p,f,b){return l={tag:l,create:f,deps:b,inst:p,next:null},p=zt.updateQueue,p===null&&(p=Db(),zt.updateQueue=p),f=p.lastEffect,f===null?p.lastEffect=l.next=l:(b=f.next,f.next=l,l.next=b,p.lastEffect=l),l}function If(){return{destroy:void 0,resource:void 0}}function jw(){return Ea().memoizedState}function _f(l,p,f,b){var A=Lr();b=b===void 0?null:b,zt.flags|=l,A.memoizedState=Wu(1|p,If(),f,b)}function yd(l,p,f,b){var A=Ea();b=b===void 0?null:b;var I=A.memoizedState.inst;Fn!==null&&b!==null&&_b(b,Fn.memoizedState.deps)?A.memoizedState=Wu(p,I,f,b):(zt.flags|=l,A.memoizedState=Wu(1|p,I,f,b))}function Qw(l,p){_f(8390656,8,l,p)}function Zw(l,p){yd(2048,8,l,p)}function Xw(l,p){return yd(4,2,l,p)}function ex(l,p){return yd(4,4,l,p)}function tx(l,p){if(typeof p=="function"){l=l();var f=p(l);return function(){typeof f=="function"?f():p(null)}}if(p!=null)return l=l(),p.current=l,function(){p.current=null}}function nx(l,p,f){f=f!=null?f.concat([l]):null,yd(4,4,tx.bind(null,p,l),f)}function Lb(){}function ax(l,p){var f=Ea();p=p===void 0?null:p;var b=f.memoizedState;return p!==null&&_b(p,b[1])?b[0]:(f.memoizedState=[l,p],l)}function rx(l,p){var f=Ea();p=p===void 0?null:p;var b=f.memoizedState;if(p!==null&&_b(p,b[1]))return b[0];if(b=l(),zl){G(!0);try{l()}finally{G(!1)}}return f.memoizedState=[b,p],b}function zb(l,p,f){return f===void 0||(zo&1073741824)!==0?l.memoizedState=p:(l.memoizedState=f,l=iT(),zt.lanes|=l,$u|=l,f)}function Ub(l,p,f,b){return ea(f,p)?f:Uu.current!==null?(l=zb(l,f,b),ea(l,p)||(Ha=!0),l):(zo&42)===0?(Ha=!0,l.memoizedState=f):(l=iT(),zt.lanes|=l,$u|=l,p)}function ix(l,p,f,b,A){var I=se.p;se.p=I!==0&&8>I?I:8;var W=Z.T,J={};Z.T=J,Cr(l,!1,p,f);try{var ce=A(),Ne=Z.S;if(Ne!==null&&Ne(J,ce),ce!==null&&typeof ce=="object"&&typeof ce.then=="function"){var Ue=Mw(ce,b);Sd(l,p,Ue,ji(l))}else Sd(l,p,b,ji(l))}catch(Ge){Sd(l,p,{then:function(){},status:"rejected",reason:Ge},ji())}finally{se.p=I,Z.T=W}}function XS(){}function wd(l,p,f,b){if(l.tag!==5)throw Error(a(476));var A=Tf(l).queue;ix(l,A,p,de,f===null?XS:function(){return Nf(l),f(b)})}function Tf(l){var p=l.memoizedState;if(p!==null)return p;p={memoizedState:de,baseState:de,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:er,lastRenderedState:de},next:null};var f={};return p.next={memoizedState:f,baseState:f,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:er,lastRenderedState:f},next:null},l.memoizedState=p,l=l.alternate,l!==null&&(l.memoizedState=p),p}function Nf(l){var p=Tf(l).next.queue;Sd(l,p,{},ji())}function xd(){return Xa(oy)}function vd(){return Ea().memoizedState}function Rf(){return Ea().memoizedState}function e2(l){for(var p=l.return;p!==null;){switch(p.tag){case 24:case 3:var f=ji();l=Js(f);var b=Ys(p,l,f);b!==null&&(Qi(b,p,f),Lu(b,p,f)),p={cache:cf()},l.payload=p;return}p=p.return}}function t2(l,p,f){var b=ji();f={lane:b,revertLane:0,action:f,hasEagerState:!1,eagerState:null,next:null},Vo(l)?ox(p,f):(f=mb(l,p,f,b),f!==null&&(Qi(f,l,b),Vb(f,p,b)))}function sx(l,p,f){var b=ji();Sd(l,p,f,b)}function Sd(l,p,f,b){var A={lane:b,revertLane:0,action:f,hasEagerState:!1,eagerState:null,next:null};if(Vo(l))ox(p,A);else{var I=l.alternate;if(l.lanes===0&&(I===null||I.lanes===0)&&(I=p.lastRenderedReducer,I!==null))try{var W=p.lastRenderedState,J=I(W,f);if(A.hasEagerState=!0,A.eagerState=J,ea(J,W))return Fo(l,p,A,0),la===null&&tf(),!1}catch{}finally{}if(f=mb(l,p,A,b),f!==null)return Qi(f,l,b),Vb(f,p,b),!0}return!1}function Cr(l,p,f,b){if(b={lane:2,revertLane:w2(),action:b,hasEagerState:!1,eagerState:null,next:null},Vo(l)){if(p)throw Error(a(479))}else p=mb(l,f,b,2),p!==null&&Qi(p,l,2)}function Vo(l){var p=l.alternate;return l===zt||p!==null&&p===zt}function ox(l,p){Ll=fd=!0;var f=l.pending;f===null?p.next=p:(p.next=f.next,f.next=p),l.pending=p}function Vb(l,p,f){if((f&4194048)!==0){var b=p.lanes;b&=l.pendingLanes,f|=b,p.lanes=f,mo(l,f)}}var kd={readContext:Xa,use:xf,useCallback:ga,useContext:ga,useEffect:ga,useImperativeHandle:ga,useLayoutEffect:ga,useInsertionEffect:ga,useMemo:ga,useReducer:ga,useRef:ga,useState:ga,useDebugValue:ga,useDeferredValue:ga,useTransition:ga,useSyncExternalStore:ga,useId:ga,useHostTransitionStatus:ga,useFormState:ga,useActionState:ga,useOptimistic:ga,useMemoCache:ga,useCacheRefresh:ga},lx={readContext:Xa,use:xf,useCallback:function(l,p){return Lr().memoizedState=[l,p===void 0?null:p],l},useContext:Xa,useEffect:Qw,useImperativeHandle:function(l,p,f){f=f!=null?f.concat([l]):null,_f(4194308,4,tx.bind(null,p,l),f)},useLayoutEffect:function(l,p){return _f(4194308,4,l,p)},useInsertionEffect:function(l,p){_f(4,2,l,p)},useMemo:function(l,p){var f=Lr();p=p===void 0?null:p;var b=l();if(zl){G(!0);try{l()}finally{G(!1)}}return f.memoizedState=[b,p],b},useReducer:function(l,p,f){var b=Lr();if(f!==void 0){var A=f(p);if(zl){G(!0);try{f(p)}finally{G(!1)}}}else A=p;return b.memoizedState=b.baseState=A,l={pending:null,lanes:0,dispatch:null,lastRenderedReducer:l,lastRenderedState:A},b.queue=l,l=l.dispatch=t2.bind(null,zt,l),[b.memoizedState,l]},useRef:function(l){var p=Lr();return l={current:l},p.memoizedState=l},useState:function(l){l=Ef(l);var p=l.queue,f=sx.bind(null,zt,p);return p.dispatch=f,[l.memoizedState,f]},useDebugValue:Lb,useDeferredValue:function(l,p){var f=Lr();return zb(f,l,p)},useTransition:function(){var l=Ef(!1);return l=ix.bind(null,zt,l.queue,!0,!1),Lr().memoizedState=l,[!1,l]},useSyncExternalStore:function(l,p,f){var b=zt,A=Lr();if(En){if(f===void 0)throw Error(a(407));f=f()}else{if(f=p(),la===null)throw Error(a(349));(xn&124)!==0||Uw(b,p,f)}A.memoizedState=f;var I={value:f,getSnapshot:p};return A.queue=I,Qw(kf.bind(null,b,I,l),[l]),b.flags|=2048,Wu(9,If(),Vu.bind(null,b,I,f,p),null),f},useId:function(){var l=Lr(),p=la.identifierPrefix;if(En){var f=Hs,b=Ps;f=(b&~(1<<32-F(b)-1)).toString(32)+f,p=""+p+"R"+f,f=md++,0<f&&(p+="H"+f.toString(32)),p+=""}else f=jS++,p=""+p+"r"+f.toString(32)+"";return l.memoizedState=p},useHostTransitionStatus:xd,useFormState:Kw,useActionState:Kw,useOptimistic:function(l){var p=Lr();p.memoizedState=p.baseState=l;var f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return p.queue=f,p=Cr.bind(null,zt,!0,f),f.dispatch=p,[l,p]},useMemoCache:Ob,useCacheRefresh:function(){return Lr().memoizedState=e2.bind(null,zt)}},Wb={readContext:Xa,use:xf,useCallback:ax,useContext:Xa,useEffect:Zw,useImperativeHandle:nx,useInsertionEffect:Xw,useLayoutEffect:ex,useMemo:rx,useReducer:vf,useRef:jw,useState:function(){return vf(er)},useDebugValue:Lb,useDeferredValue:function(l,p){var f=Ea();return Ub(f,Fn.memoizedState,l,p)},useTransition:function(){var l=vf(er)[0],p=Ea().memoizedState;return[typeof l=="boolean"?l:gd(l),p]},useSyncExternalStore:zw,useId:vd,useHostTransitionStatus:xd,useFormState:$w,useActionState:$w,useOptimistic:function(l,p){var f=Ea();return Ww(f,Fn,l,p)},useMemoCache:Ob,useCacheRefresh:Rf},ux={readContext:Xa,use:xf,useCallback:ax,useContext:Xa,useEffect:Zw,useImperativeHandle:nx,useInsertionEffect:Xw,useLayoutEffect:ex,useMemo:rx,useReducer:Sf,useRef:jw,useState:function(){return Sf(er)},useDebugValue:Lb,useDeferredValue:function(l,p){var f=Ea();return Fn===null?zb(f,l,p):Ub(f,Fn.memoizedState,l,p)},useTransition:function(){var l=Sf(er)[0],p=Ea().memoizedState;return[typeof l=="boolean"?l:gd(l),p]},useSyncExternalStore:zw,useId:vd,useHostTransitionStatus:xd,useFormState:Yw,useActionState:Yw,useOptimistic:function(l,p){var f=Ea();return Fn!==null?Ww(f,Fn,l,p):(f.baseState=l,[l,f.queue.dispatch])},useMemoCache:Ob,useCacheRefresh:Rf},Vl=null,Ad=0;function Ff(l){var p=Ad;return Ad+=1,Vl===null&&(Vl=[]),kb(Vl,l,p)}function Ed(l,p){p=p.props.ref,l.ref=p!==void 0?p:null}function Cd(l,p){throw p.$$typeof===h?Error(a(525)):(l=Object.prototype.toString.call(p),Error(a(31,l==="[object Object]"?"object with keys {"+Object.keys(p).join(", ")+"}":l)))}function Yn(l){var p=l._init;return p(l._payload)}function js(l){function p(Ee,Se){if(l){var Te=Ee.deletions;Te===null?(Ee.deletions=[Se],Ee.flags|=16):Te.push(Se)}}function f(Ee,Se){if(!l)return null;for(;Se!==null;)p(Ee,Se),Se=Se.sibling;return null}function b(Ee){for(var Se=new Map;Ee!==null;)Ee.key!==null?Se.set(Ee.key,Ee):Se.set(Ee.index,Ee),Ee=Ee.sibling;return Se}function A(Ee,Se){return Ee=qs(Ee,Se),Ee.index=0,Ee.sibling=null,Ee}function I(Ee,Se,Te){return Ee.index=Te,l?(Te=Ee.alternate,Te!==null?(Te=Te.index,Te<Se?(Ee.flags|=67108866,Se):Te):(Ee.flags|=67108866,Se)):(Ee.flags|=1048576,Se)}function W(Ee){return l&&Ee.alternate===null&&(Ee.flags|=67108866),Ee}function J(Ee,Se,Te,Ve){return Se===null||Se.tag!==6?(Se=nf(Te,Ee.mode,Ve),Se.return=Ee,Se):(Se=A(Se,Te),Se.return=Ee,Se)}function ce(Ee,Se,Te,Ve){var dt=Te.type;return dt===x?Ue(Ee,Se,Te.props.children,Ve,Te.key):Se!==null&&(Se.elementType===dt||typeof dt=="object"&&dt!==null&&dt.$$typeof===K&&Yn(dt)===Se.type)?(Se=A(Se,Te.props),Ed(Se,Te),Se.return=Ee,Se):(Se=Do(Te.type,Te.key,Te.props,null,Ee.mode,Ve),Ed(Se,Te),Se.return=Ee,Se)}function Ne(Ee,Se,Te,Ve){return Se===null||Se.tag!==4||Se.stateNode.containerInfo!==Te.containerInfo||Se.stateNode.implementation!==Te.implementation?(Se=af(Te,Ee.mode,Ve),Se.return=Ee,Se):(Se=A(Se,Te.children||[]),Se.return=Ee,Se)}function Ue(Ee,Se,Te,Ve,dt){return Se===null||Se.tag!==7?(Se=Il(Te,Ee.mode,Ve,dt),Se.return=Ee,Se):(Se=A(Se,Te),Se.return=Ee,Se)}function Ge(Ee,Se,Te){if(typeof Se=="string"&&Se!==""||typeof Se=="number"||typeof Se=="bigint")return Se=nf(""+Se,Ee.mode,Te),Se.return=Ee,Se;if(typeof Se=="object"&&Se!==null){switch(Se.$$typeof){case m:return Te=Do(Se.type,Se.key,Se.props,null,Ee.mode,Te),Ed(Te,Se),Te.return=Ee,Te;case g:return Se=af(Se,Ee.mode,Te),Se.return=Ee,Se;case K:var Ve=Se._init;return Se=Ve(Se._payload),Ge(Ee,Se,Te)}if(he(Se)||z(Se))return Se=Il(Se,Ee.mode,Te,null),Se.return=Ee,Se;if(typeof Se.then=="function")return Ge(Ee,Ff(Se),Te);if(Se.$$typeof===T)return Ge(Ee,uf(Ee,Se),Te);Cd(Ee,Se)}return null}function Fe(Ee,Se,Te,Ve){var dt=Se!==null?Se.key:null;if(typeof Te=="string"&&Te!==""||typeof Te=="number"||typeof Te=="bigint")return dt!==null?null:J(Ee,Se,""+Te,Ve);if(typeof Te=="object"&&Te!==null){switch(Te.$$typeof){case m:return Te.key===dt?ce(Ee,Se,Te,Ve):null;case g:return Te.key===dt?Ne(Ee,Se,Te,Ve):null;case K:return dt=Te._init,Te=dt(Te._payload),Fe(Ee,Se,Te,Ve)}if(he(Te)||z(Te))return dt!==null?null:Ue(Ee,Se,Te,Ve,null);if(typeof Te.then=="function")return Fe(Ee,Se,Ff(Te),Ve);if(Te.$$typeof===T)return Fe(Ee,Se,uf(Ee,Te),Ve);Cd(Ee,Te)}return null}function De(Ee,Se,Te,Ve,dt){if(typeof Ve=="string"&&Ve!==""||typeof Ve=="number"||typeof Ve=="bigint")return Ee=Ee.get(Te)||null,J(Se,Ee,""+Ve,dt);if(typeof Ve=="object"&&Ve!==null){switch(Ve.$$typeof){case m:return Ee=Ee.get(Ve.key===null?Te:Ve.key)||null,ce(Se,Ee,Ve,dt);case g:return Ee=Ee.get(Ve.key===null?Te:Ve.key)||null,Ne(Se,Ee,Ve,dt);case K:var pn=Ve._init;return Ve=pn(Ve._payload),De(Ee,Se,Te,Ve,dt)}if(he(Ve)||z(Ve))return Ee=Ee.get(Te)||null,Ue(Se,Ee,Ve,dt,null);if(typeof Ve.then=="function")return De(Ee,Se,Te,Ff(Ve),dt);if(Ve.$$typeof===T)return De(Ee,Se,Te,uf(Se,Ve),dt);Cd(Se,Ve)}return null}function Bt(Ee,Se,Te,Ve){for(var dt=null,pn=null,St=Se,Dt=Se=0,gr=null;St!==null&&Dt<Te.length;Dt++){St.index>Dt?(gr=St,St=null):gr=St.sibling;var Tn=Fe(Ee,St,Te[Dt],Ve);if(Tn===null){St===null&&(St=gr);break}l&&St&&Tn.alternate===null&&p(Ee,St),Se=I(Tn,Se,Dt),pn===null?dt=Tn:pn.sibling=Tn,pn=Tn,St=gr}if(Dt===Te.length)return f(Ee,St),En&&Pi(Ee,Dt),dt;if(St===null){for(;Dt<Te.length;Dt++)St=Ge(Ee,Te[Dt],Ve),St!==null&&(Se=I(St,Se,Dt),pn===null?dt=St:pn.sibling=St,pn=St);return En&&Pi(Ee,Dt),dt}for(St=b(St);Dt<Te.length;Dt++)gr=De(St,Ee,Dt,Te[Dt],Ve),gr!==null&&(l&&gr.alternate!==null&&St.delete(gr.key===null?Dt:gr.key),Se=I(gr,Se,Dt),pn===null?dt=gr:pn.sibling=gr,pn=gr);return l&&St.forEach(function(nc){return p(Ee,nc)}),En&&Pi(Ee,Dt),dt}function Tt(Ee,Se,Te,Ve){if(Te==null)throw Error(a(151));for(var dt=null,pn=null,St=Se,Dt=Se=0,gr=null,Tn=Te.next();St!==null&&!Tn.done;Dt++,Tn=Te.next()){St.index>Dt?(gr=St,St=null):gr=St.sibling;var nc=Fe(Ee,St,Tn.value,Ve);if(nc===null){St===null&&(St=gr);break}l&&St&&nc.alternate===null&&p(Ee,St),Se=I(nc,Se,Dt),pn===null?dt=nc:pn.sibling=nc,pn=nc,St=gr}if(Tn.done)return f(Ee,St),En&&Pi(Ee,Dt),dt;if(St===null){for(;!Tn.done;Dt++,Tn=Te.next())Tn=Ge(Ee,Tn.value,Ve),Tn!==null&&(Se=I(Tn,Se,Dt),pn===null?dt=Tn:pn.sibling=Tn,pn=Tn);return En&&Pi(Ee,Dt),dt}for(St=b(St);!Tn.done;Dt++,Tn=Te.next())Tn=De(St,Ee,Dt,Tn.value,Ve),Tn!==null&&(l&&Tn.alternate!==null&&St.delete(Tn.key===null?Dt:Tn.key),Se=I(Tn,Se,Dt),pn===null?dt=Tn:pn.sibling=Tn,pn=Tn);return l&&St.forEach(function(x6){return p(Ee,x6)}),En&&Pi(Ee,Dt),dt}function Qn(Ee,Se,Te,Ve){if(typeof Te=="object"&&Te!==null&&Te.type===x&&Te.key===null&&(Te=Te.props.children),typeof Te=="object"&&Te!==null){switch(Te.$$typeof){case m:e:{for(var dt=Te.key;Se!==null;){if(Se.key===dt){if(dt=Te.type,dt===x){if(Se.tag===7){f(Ee,Se.sibling),Ve=A(Se,Te.props.children),Ve.return=Ee,Ee=Ve;break e}}else if(Se.elementType===dt||typeof dt=="object"&&dt!==null&&dt.$$typeof===K&&Yn(dt)===Se.type){f(Ee,Se.sibling),Ve=A(Se,Te.props),Ed(Ve,Te),Ve.return=Ee,Ee=Ve;break e}f(Ee,Se);break}else p(Ee,Se);Se=Se.sibling}Te.type===x?(Ve=Il(Te.props.children,Ee.mode,Ve,Te.key),Ve.return=Ee,Ee=Ve):(Ve=Do(Te.type,Te.key,Te.props,null,Ee.mode,Ve),Ed(Ve,Te),Ve.return=Ee,Ee=Ve)}return W(Ee);case g:e:{for(dt=Te.key;Se!==null;){if(Se.key===dt)if(Se.tag===4&&Se.stateNode.containerInfo===Te.containerInfo&&Se.stateNode.implementation===Te.implementation){f(Ee,Se.sibling),Ve=A(Se,Te.children||[]),Ve.return=Ee,Ee=Ve;break e}else{f(Ee,Se);break}else p(Ee,Se);Se=Se.sibling}Ve=af(Te,Ee.mode,Ve),Ve.return=Ee,Ee=Ve}return W(Ee);case K:return dt=Te._init,Te=dt(Te._payload),Qn(Ee,Se,Te,Ve)}if(he(Te))return Bt(Ee,Se,Te,Ve);if(z(Te)){if(dt=z(Te),typeof dt!="function")throw Error(a(150));return Te=dt.call(Te),Tt(Ee,Se,Te,Ve)}if(typeof Te.then=="function")return Qn(Ee,Se,Ff(Te),Ve);if(Te.$$typeof===T)return Qn(Ee,Se,uf(Ee,Te),Ve);Cd(Ee,Te)}return typeof Te=="string"&&Te!==""||typeof Te=="number"||typeof Te=="bigint"?(Te=""+Te,Se!==null&&Se.tag===6?(f(Ee,Se.sibling),Ve=A(Se,Te),Ve.return=Ee,Ee=Ve):(f(Ee,Se),Ve=nf(Te,Ee.mode,Ve),Ve.return=Ee,Ee=Ve),W(Ee)):f(Ee,Se)}return function(Ee,Se,Te,Ve){try{Ad=0;var dt=Qn(Ee,Se,Te,Ve);return Vl=null,dt}catch(St){if(St===Lo||St===Mu)throw St;var pn=ai(29,St,null,Ee.mode);return pn.lanes=Ve,pn.return=Ee,pn}finally{}}}var ws=js(!0),qu=js(!1),ri=ie(null),xs=null;function Wo(l){var p=l.alternate;me(Fa,Fa.current&1),me(ri,l),xs===null&&(p===null||Uu.current!==null||p.memoizedState!==null)&&(xs=l)}function Df(l){if(l.tag===22){if(me(Fa,Fa.current),me(ri,l),xs===null){var p=l.alternate;p!==null&&p.memoizedState!==null&&(xs=l)}}else Pa()}function Pa(){me(Fa,Fa.current),me(ri,ri.current)}function Gi(l){xe(ri),xs===l&&(xs=null),xe(Fa)}var Fa=ie(0);function Of(l){for(var p=l;p!==null;){if(p.tag===13){var f=p.memoizedState;if(f!==null&&(f=f.dehydrated,f===null||f.data==="$?"||R2(f)))return p}else if(p.tag===19&&p.memoizedProps.revealOrder!==void 0){if((p.flags&128)!==0)return p}else if(p.child!==null){p.child.return=p,p=p.child;continue}if(p===l)break;for(;p.sibling===null;){if(p.return===null||p.return===l)return null;p=p.return}p.sibling.return=p.return,p=p.sibling}return null}function qb(l,p,f,b){p=l.memoizedState,f=f(b,p),f=f==null?p:c({},p,f),l.memoizedState=f,l.lanes===0&&(l.updateQueue.baseState=f)}var Ir={enqueueSetState:function(l,p,f){l=l._reactInternals;var b=ji(),A=Js(b);A.payload=p,f!=null&&(A.callback=f),p=Ys(l,A,b),p!==null&&(Qi(p,l,b),Lu(p,l,b))},enqueueReplaceState:function(l,p,f){l=l._reactInternals;var b=ji(),A=Js(b);A.tag=1,A.payload=p,f!=null&&(A.callback=f),p=Ys(l,A,b),p!==null&&(Qi(p,l,b),Lu(p,l,b))},enqueueForceUpdate:function(l,p){l=l._reactInternals;var f=ji(),b=Js(f);b.tag=2,p!=null&&(b.callback=p),p=Ys(l,b,f),p!==null&&(Qi(p,l,f),Lu(p,l,f))}};function Mf(l,p,f,b,A,I,W){return l=l.stateNode,typeof l.shouldComponentUpdate=="function"?l.shouldComponentUpdate(b,I,W):p.prototype&&p.prototype.isPureReactComponent?!Za(f,b)||!Za(A,I):!0}function cx(l,p,f,b){l=p.state,typeof p.componentWillReceiveProps=="function"&&p.componentWillReceiveProps(f,b),typeof p.UNSAFE_componentWillReceiveProps=="function"&&p.UNSAFE_componentWillReceiveProps(f,b),p.state!==l&&Ir.enqueueReplaceState(p,p.state,null)}function Wl(l,p){var f=p;if("ref"in p){f={};for(var b in p)b!=="ref"&&(f[b]=p[b])}if(l=l.defaultProps){f===p&&(f=c({},f));for(var A in l)f[A]===void 0&&(f[A]=l[A])}return f}var Bf=typeof reportError=="function"?reportError:function(l){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var p=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof l=="object"&&l!==null&&typeof l.message=="string"?String(l.message):String(l),error:l});if(!window.dispatchEvent(p))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",l);return}console.error(l)};function dx(l){Bf(l)}function px(l){console.error(l)}function hx(l){Bf(l)}function Lf(l,p){try{var f=l.onUncaughtError;f(p.value,{componentStack:p.stack})}catch(b){setTimeout(function(){throw b})}}function Id(l,p,f){try{var b=l.onCaughtError;b(f.value,{componentStack:f.stack,errorBoundary:p.tag===1?p.stateNode:null})}catch(A){setTimeout(function(){throw A})}}function Pb(l,p,f){return f=Js(f),f.tag=3,f.payload={element:null},f.callback=function(){Lf(l,p)},f}function fx(l){return l=Js(l),l.tag=3,l}function Hb(l,p,f,b){var A=f.type.getDerivedStateFromError;if(typeof A=="function"){var I=b.value;l.payload=function(){return A(I)},l.callback=function(){Id(p,f,b)}}var W=f.stateNode;W!==null&&typeof W.componentDidCatch=="function"&&(l.callback=function(){Id(p,f,b),typeof A!="function"&&(Ju===null?Ju=new Set([this]):Ju.add(this));var J=b.stack;this.componentDidCatch(b.value,{componentStack:J!==null?J:""})})}function n2(l,p,f,b,A){if(f.flags|=32768,b!==null&&typeof b=="object"&&typeof b.then=="function"){if(p=f.alternate,p!==null&&sd(p,f,A,!0),f=ri.current,f!==null){switch(f.tag){case 13:return xs===null?f2():f.alternate===null&&Ia===0&&(Ia=3),f.flags&=-257,f.flags|=65536,f.lanes=A,b===hf?f.flags|=16384:(p=f.updateQueue,p===null?f.updateQueue=new Set([b]):p.add(b),g2(l,b,A)),!1;case 22:return f.flags|=65536,b===hf?f.flags|=16384:(p=f.updateQueue,p===null?(p={transitions:null,markerInstances:null,retryQueue:new Set([b])},f.updateQueue=p):(f=p.retryQueue,f===null?p.retryQueue=new Set([b]):f.add(b)),g2(l,b,A)),!1}throw Error(a(435,f.tag))}return g2(l,b,A),f2(),!1}if(En)return p=ri.current,p!==null?((p.flags&65536)===0&&(p.flags|=256),p.flags|=65536,p.lanes=A,b!==Ru&&(l=Error(a(422),{cause:b}),Fl(wi(l,f)))):(b!==Ru&&(p=Error(a(423),{cause:b}),Fl(wi(p,f))),l=l.current.alternate,l.flags|=65536,A&=-A,l.lanes|=A,b=wi(b,f),A=Pb(l.stateNode,b,A),hd(l,A),Ia!==4&&(Ia=2)),!1;var I=Error(a(520),{cause:b});if(I=wi(I,f),Zb===null?Zb=[I]:Zb.push(I),Ia!==4&&(Ia=2),p===null)return!0;b=wi(b,f),f=p;do{switch(f.tag){case 3:return f.flags|=65536,l=A&-A,f.lanes|=l,l=Pb(f.stateNode,b,l),hd(f,l),!1;case 1:if(p=f.type,I=f.stateNode,(f.flags&128)===0&&(typeof p.getDerivedStateFromError=="function"||I!==null&&typeof I.componentDidCatch=="function"&&(Ju===null||!Ju.has(I))))return f.flags|=65536,A&=-A,f.lanes|=A,A=fx(A),Hb(A,l,f,b),hd(f,A),!1}f=f.return}while(f!==null);return!1}var mx=Error(a(461)),Ha=!1;function tr(l,p,f,b){p.child=l===null?qu(p,null,f,b):ws(p,l.child,f,b)}function Gb(l,p,f,b,A){f=f.render;var I=p.ref;if("ref"in b){var W={};for(var J in b)J!=="ref"&&(W[J]=b[J])}else W=b;return Mo(p),b=Tb(l,p,f,W,I,A),J=Nb(),l!==null&&!Ha?(Rb(l,p,A),ut(l,p,A)):(En&&J&&bb(p),p.flags|=1,tr(l,p,b,A),p.child)}function gx(l,p,f,b,A){if(l===null){var I=f.type;return typeof I=="function"&&!gb(I)&&I.defaultProps===void 0&&f.compare===null?(p.tag=15,p.type=I,qo(l,p,I,b,A)):(l=Do(f.type,null,b,p,p.mode,A),l.ref=p.ref,l.return=p,p.child=l)}if(I=l.child,!Cn(l,A)){var W=I.memoizedProps;if(f=f.compare,f=f!==null?f:Za,f(W,b)&&l.ref===p.ref)return ut(l,p,A)}return p.flags|=1,l=qs(I,b),l.ref=p.ref,l.return=p,p.child=l}function qo(l,p,f,b,A){if(l!==null){var I=l.memoizedProps;if(Za(I,b)&&l.ref===p.ref)if(Ha=!1,p.pendingProps=b=I,Cn(l,A))(l.flags&131072)!==0&&(Ha=!0);else return p.lanes=l.lanes,ut(l,p,A)}return y(l,p,f,b,A)}function zf(l,p,f){var b=p.pendingProps,A=b.children,I=l!==null?l.memoizedState:null;if(b.mode==="hidden"){if((p.flags&128)!==0){if(b=I!==null?I.baseLanes|f:f,l!==null){for(A=p.child=l.child,I=0;A!==null;)I=I|A.lanes|A.childLanes,A=A.sibling;p.childLanes=I&~b}else p.childLanes=0,p.child=null;return _d(l,p,b,f)}if((f&536870912)!==0)p.memoizedState={baseLanes:0,cachePool:null},l!==null&&cd(p,I!==null?I.cachePool:null),I!==null?YS(p,I):Ib(),Df(p);else return p.lanes=p.childLanes=536870912,_d(l,p,I!==null?I.baseLanes|f:f,f)}else I!==null?(cd(p,I.cachePool),YS(p,I),Pa(),p.memoizedState=null):(l!==null&&cd(p,null),Ib(),Pa());return tr(l,p,A,f),p.child}function _d(l,p,f,b){var A=pf();return A=A===null?null:{parent:In._currentValue,pool:A},p.memoizedState={baseLanes:f,cachePool:A},l!==null&&cd(p,null),Ib(),Df(p),l!==null&&sd(l,p,b,!0),null}function ql(l,p){var f=p.ref;if(f===null)l!==null&&l.ref!==null&&(p.flags|=4194816);else{if(typeof f!="function"&&typeof f!="object")throw Error(a(284));(l===null||l.ref!==f)&&(p.flags|=4194816)}}function y(l,p,f,b,A){return Mo(p),f=Tb(l,p,f,b,void 0,A),b=Nb(),l!==null&&!Ha?(Rb(l,p,A),ut(l,p,A)):(En&&b&&bb(p),p.flags|=1,tr(l,p,f,A),p.child)}function k(l,p,f,b,A,I){return Mo(p),p.updateQueue=null,f=Lw(p,b,f,A),Bw(l),b=Nb(),l!==null&&!Ha?(Rb(l,p,I),ut(l,p,I)):(En&&b&&bb(p),p.flags|=1,tr(l,p,f,I),p.child)}function w(l,p,f,b,A){if(Mo(p),p.stateNode===null){var I=Cl,W=f.contextType;typeof W=="object"&&W!==null&&(I=Xa(W)),I=new f(b,I),p.memoizedState=I.state!==null&&I.state!==void 0?I.state:null,I.updater=Ir,p.stateNode=I,I._reactInternals=p,I=p.stateNode,I.props=b,I.state=p.memoizedState,I.refs={},mf(p),W=f.contextType,I.context=typeof W=="object"&&W!==null?Xa(W):Cl,I.state=p.memoizedState,W=f.getDerivedStateFromProps,typeof W=="function"&&(qb(p,f,W,b),I.state=p.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof I.getSnapshotBeforeUpdate=="function"||typeof I.UNSAFE_componentWillMount!="function"&&typeof I.componentWillMount!="function"||(W=I.state,typeof I.componentWillMount=="function"&&I.componentWillMount(),typeof I.UNSAFE_componentWillMount=="function"&&I.UNSAFE_componentWillMount(),W!==I.state&&Ir.enqueueReplaceState(I,I.state,null),Bn(p,b,I,A),zu(),I.state=p.memoizedState),typeof I.componentDidMount=="function"&&(p.flags|=4194308),b=!0}else if(l===null){I=p.stateNode;var J=p.memoizedProps,ce=Wl(f,J);I.props=ce;var Ne=I.context,Ue=f.contextType;W=Cl,typeof Ue=="object"&&Ue!==null&&(W=Xa(Ue));var Ge=f.getDerivedStateFromProps;Ue=typeof Ge=="function"||typeof I.getSnapshotBeforeUpdate=="function",J=p.pendingProps!==J,Ue||typeof I.UNSAFE_componentWillReceiveProps!="function"&&typeof I.componentWillReceiveProps!="function"||(J||Ne!==W)&&cx(p,I,b,W),Hi=!1;var Fe=p.memoizedState;I.state=Fe,Bn(p,b,I,A),zu(),Ne=p.memoizedState,J||Fe!==Ne||Hi?(typeof Ge=="function"&&(qb(p,f,Ge,b),Ne=p.memoizedState),(ce=Hi||Mf(p,f,ce,b,Fe,Ne,W))?(Ue||typeof I.UNSAFE_componentWillMount!="function"&&typeof I.componentWillMount!="function"||(typeof I.componentWillMount=="function"&&I.componentWillMount(),typeof I.UNSAFE_componentWillMount=="function"&&I.UNSAFE_componentWillMount()),typeof I.componentDidMount=="function"&&(p.flags|=4194308)):(typeof I.componentDidMount=="function"&&(p.flags|=4194308),p.memoizedProps=b,p.memoizedState=Ne),I.props=b,I.state=Ne,I.context=W,b=ce):(typeof I.componentDidMount=="function"&&(p.flags|=4194308),b=!1)}else{I=p.stateNode,gf(l,p),W=p.memoizedProps,Ue=Wl(f,W),I.props=Ue,Ge=p.pendingProps,Fe=I.context,Ne=f.contextType,ce=Cl,typeof Ne=="object"&&Ne!==null&&(ce=Xa(Ne)),J=f.getDerivedStateFromProps,(Ne=typeof J=="function"||typeof I.getSnapshotBeforeUpdate=="function")||typeof I.UNSAFE_componentWillReceiveProps!="function"&&typeof I.componentWillReceiveProps!="function"||(W!==Ge||Fe!==ce)&&cx(p,I,b,ce),Hi=!1,Fe=p.memoizedState,I.state=Fe,Bn(p,b,I,A),zu();var De=p.memoizedState;W!==Ge||Fe!==De||Hi||l!==null&&l.dependencies!==null&&od(l.dependencies)?(typeof J=="function"&&(qb(p,f,J,b),De=p.memoizedState),(Ue=Hi||Mf(p,f,Ue,b,Fe,De,ce)||l!==null&&l.dependencies!==null&&od(l.dependencies))?(Ne||typeof I.UNSAFE_componentWillUpdate!="function"&&typeof I.componentWillUpdate!="function"||(typeof I.componentWillUpdate=="function"&&I.componentWillUpdate(b,De,ce),typeof I.UNSAFE_componentWillUpdate=="function"&&I.UNSAFE_componentWillUpdate(b,De,ce)),typeof I.componentDidUpdate=="function"&&(p.flags|=4),typeof I.getSnapshotBeforeUpdate=="function"&&(p.flags|=1024)):(typeof I.componentDidUpdate!="function"||W===l.memoizedProps&&Fe===l.memoizedState||(p.flags|=4),typeof I.getSnapshotBeforeUpdate!="function"||W===l.memoizedProps&&Fe===l.memoizedState||(p.flags|=1024),p.memoizedProps=b,p.memoizedState=De),I.props=b,I.state=De,I.context=ce,b=Ue):(typeof I.componentDidUpdate!="function"||W===l.memoizedProps&&Fe===l.memoizedState||(p.flags|=4),typeof I.getSnapshotBeforeUpdate!="function"||W===l.memoizedProps&&Fe===l.memoizedState||(p.flags|=1024),b=!1)}return I=b,ql(l,p),b=(p.flags&128)!==0,I||b?(I=p.stateNode,f=b&&typeof f.getDerivedStateFromError!="function"?null:I.render(),p.flags|=1,l!==null&&b?(p.child=ws(p,l.child,null,A),p.child=ws(p,null,f,A)):tr(l,p,f,A),p.memoizedState=I.state,l=p.child):l=ut(l,p,A),l}function _(l,p,f,b){return Du(),p.flags|=256,tr(l,p,f,b),p.child}var R={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function M(l){return{baseLanes:l,cachePool:Sb()}}function U(l,p,f){return l=l!==null?l.childLanes&~f:0,p&&(l|=As),l}function V(l,p,f){var b=p.pendingProps,A=!1,I=(p.flags&128)!==0,W;if((W=I)||(W=l!==null&&l.memoizedState===null?!1:(Fa.current&2)!==0),W&&(A=!0,p.flags&=-129),W=(p.flags&32)!==0,p.flags&=-33,l===null){if(En){if(A?Wo(p):Pa(),En){var J=ma,ce;if(ce=J){e:{for(ce=J,J=bs;ce.nodeType!==8;){if(!J){J=null;break e}if(ce=Zs(ce.nextSibling),ce===null){J=null;break e}}J=ce}J!==null?(p.memoizedState={dehydrated:J,treeContext:_l!==null?{id:Ps,overflow:Hs}:null,retryLane:536870912,hydrationErrors:null},ce=ai(18,null,null,0),ce.stateNode=J,ce.return=p,p.child=ce,Er=p,ma=null,ce=!0):ce=!1}ce||Nl(p)}if(J=p.memoizedState,J!==null&&(J=J.dehydrated,J!==null))return R2(J)?p.lanes=32:p.lanes=536870912,null;Gi(p)}return J=b.children,b=b.fallback,A?(Pa(),A=p.mode,J=X({mode:"hidden",children:J},A),b=Il(b,A,f,null),J.return=p,b.return=p,J.sibling=b,p.child=J,A=p.child,A.memoizedState=M(f),A.childLanes=U(l,W,f),p.memoizedState=R,b):(Wo(p),fe(p,J))}if(ce=l.memoizedState,ce!==null&&(J=ce.dehydrated,J!==null)){if(I)p.flags&256?(Wo(p),p.flags&=-257,p=ye(l,p,f)):p.memoizedState!==null?(Pa(),p.child=l.child,p.flags|=128,p=null):(Pa(),A=b.fallback,J=p.mode,b=X({mode:"visible",children:b.children},J),A=Il(A,J,f,null),A.flags|=2,b.return=p,A.return=p,b.sibling=A,p.child=b,ws(p,l.child,null,f),b=p.child,b.memoizedState=M(f),b.childLanes=U(l,W,f),p.memoizedState=R,p=A);else if(Wo(p),R2(J)){if(W=J.nextSibling&&J.nextSibling.dataset,W)var Ne=W.dgst;W=Ne,b=Error(a(419)),b.stack="",b.digest=W,Fl({value:b,source:null,stack:null}),p=ye(l,p,f)}else if(Ha||sd(l,p,f,!1),W=(f&l.childLanes)!==0,Ha||W){if(W=la,W!==null&&(b=f&-f,b=(b&42)!==0?1:Me(b),b=(b&(W.suspendedLanes|f))!==0?0:b,b!==0&&b!==ce.retryLane))throw ce.retryLane=b,_u(l,b),Qi(W,l,b),mx;J.data==="$?"||f2(),p=ye(l,p,f)}else J.data==="$?"?(p.flags|=192,p.child=l.child,p=null):(l=ce.treeContext,ma=Zs(J.nextSibling),Er=p,En=!0,Tl=null,bs=!1,l!==null&&(Ar[vi++]=Ps,Ar[vi++]=Hs,Ar[vi++]=_l,Ps=l.id,Hs=l.overflow,_l=p),p=fe(p,b.children),p.flags|=4096);return p}return A?(Pa(),A=b.fallback,J=p.mode,ce=l.child,Ne=ce.sibling,b=qs(ce,{mode:"hidden",children:b.children}),b.subtreeFlags=ce.subtreeFlags&65011712,Ne!==null?A=qs(Ne,A):(A=Il(A,J,f,null),A.flags|=2),A.return=p,b.return=p,b.sibling=A,p.child=b,b=A,A=p.child,J=l.child.memoizedState,J===null?J=M(f):(ce=J.cachePool,ce!==null?(Ne=In._currentValue,ce=ce.parent!==Ne?{parent:Ne,pool:Ne}:ce):ce=Sb(),J={baseLanes:J.baseLanes|f,cachePool:ce}),A.memoizedState=J,A.childLanes=U(l,W,f),p.memoizedState=R,b):(Wo(p),f=l.child,l=f.sibling,f=qs(f,{mode:"visible",children:b.children}),f.return=p,f.sibling=null,l!==null&&(W=p.deletions,W===null?(p.deletions=[l],p.flags|=16):W.push(l)),p.child=f,p.memoizedState=null,f)}function fe(l,p){return p=X({mode:"visible",children:p},l.mode),p.return=l,l.child=p}function X(l,p){return l=ai(22,l,null,p),l.lanes=0,l.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},l}function ye(l,p,f){return ws(p,l.child,null,f),l=fe(p,p.pendingProps.children),l.flags|=2,p.memoizedState=null,l}function Qe(l,p,f){l.lanes|=p;var b=l.alternate;b!==null&&(b.lanes|=p),Dw(l.return,p,f)}function He(l,p,f,b,A){var I=l.memoizedState;I===null?l.memoizedState={isBackwards:p,rendering:null,renderingStartTime:0,last:b,tail:f,tailMode:A}:(I.isBackwards=p,I.rendering=null,I.renderingStartTime=0,I.last=b,I.tail=f,I.tailMode=A)}function Pe(l,p,f){var b=p.pendingProps,A=b.revealOrder,I=b.tail;if(tr(l,p,b.children,f),b=Fa.current,(b&2)!==0)b=b&1|2,p.flags|=128;else{if(l!==null&&(l.flags&128)!==0)e:for(l=p.child;l!==null;){if(l.tag===13)l.memoizedState!==null&&Qe(l,f,p);else if(l.tag===19)Qe(l,f,p);else if(l.child!==null){l.child.return=l,l=l.child;continue}if(l===p)break e;for(;l.sibling===null;){if(l.return===null||l.return===p)break e;l=l.return}l.sibling.return=l.return,l=l.sibling}b&=1}switch(me(Fa,b),A){case"forwards":for(f=p.child,A=null;f!==null;)l=f.alternate,l!==null&&Of(l)===null&&(A=f),f=f.sibling;f=A,f===null?(A=p.child,p.child=null):(A=f.sibling,f.sibling=null),He(p,!1,A,f,I);break;case"backwards":for(f=null,A=p.child,p.child=null;A!==null;){if(l=A.alternate,l!==null&&Of(l)===null){p.child=A;break}l=A.sibling,A.sibling=f,f=A,A=l}He(p,!0,f,null,I);break;case"together":He(p,!1,null,null,void 0);break;default:p.memoizedState=null}return p.child}function ut(l,p,f){if(l!==null&&(p.dependencies=l.dependencies),$u|=p.lanes,(f&p.childLanes)===0)if(l!==null){if(sd(l,p,f,!1),(f&p.childLanes)===0)return null}else return null;if(l!==null&&p.child!==l.child)throw Error(a(153));if(p.child!==null){for(l=p.child,f=qs(l,l.pendingProps),p.child=f,f.return=p;l.sibling!==null;)l=l.sibling,f=f.sibling=qs(l,l.pendingProps),f.return=p;f.sibling=null}return p.child}function Cn(l,p){return(l.lanes&p)!==0?!0:(l=l.dependencies,!!(l!==null&&od(l)))}function Xt(l,p,f){switch(p.tag){case 3:Ke(p,p.stateNode.containerInfo),Oo(p,In,l.memoizedState.cache),Du();break;case 27:case 5:ht(p);break;case 4:Ke(p,p.stateNode.containerInfo);break;case 10:Oo(p,p.type,p.memoizedProps.value);break;case 13:var b=p.memoizedState;if(b!==null)return b.dehydrated!==null?(Wo(p),p.flags|=128,null):(f&p.child.childLanes)!==0?V(l,p,f):(Wo(p),l=ut(l,p,f),l!==null?l.sibling:null);Wo(p);break;case 19:var A=(l.flags&128)!==0;if(b=(f&p.childLanes)!==0,b||(sd(l,p,f,!1),b=(f&p.childLanes)!==0),A){if(b)return Pe(l,p,f);p.flags|=128}if(A=p.memoizedState,A!==null&&(A.rendering=null,A.tail=null,A.lastEffect=null),me(Fa,Fa.current),b)break;return null;case 22:case 23:return p.lanes=0,zf(l,p,f);case 24:Oo(p,In,l.memoizedState.cache)}return ut(l,p,f)}function Ut(l,p,f){if(l!==null)if(l.memoizedProps!==p.pendingProps)Ha=!0;else{if(!Cn(l,f)&&(p.flags&128)===0)return Ha=!1,Xt(l,p,f);Ha=(l.flags&131072)!==0}else Ha=!1,En&&(p.flags&1048576)!==0&&of(p,sf,p.index);switch(p.lanes=0,p.tag){case 16:e:{l=p.pendingProps;var b=p.elementType,A=b._init;if(b=A(b._payload),p.type=b,typeof b=="function")gb(b)?(l=Wl(b,l),p.tag=1,p=w(null,p,b,l,f)):(p.tag=0,p=y(null,p,b,l,f));else{if(b!=null){if(A=b.$$typeof,A===N){p.tag=11,p=Gb(null,p,b,l,f);break e}else if(A===H){p.tag=14,p=gx(null,p,b,l,f);break e}}throw p=ue(b)||b,Error(a(306,p,""))}}return p;case 0:return y(l,p,p.type,p.pendingProps,f);case 1:return b=p.type,A=Wl(b,p.pendingProps),w(l,p,b,A,f);case 3:e:{if(Ke(p,p.stateNode.containerInfo),l===null)throw Error(a(387));b=p.pendingProps;var I=p.memoizedState;A=I.element,gf(l,p),Bn(p,b,null,f);var W=p.memoizedState;if(b=W.cache,Oo(p,In,b),b!==I.cache&&Ol(p,[In],f,!0),zu(),b=W.element,I.isDehydrated)if(I={element:b,isDehydrated:!1,cache:W.cache},p.updateQueue.baseState=I,p.memoizedState=I,p.flags&256){p=_(l,p,b,f);break e}else if(b!==A){A=wi(Error(a(424)),p),Fl(A),p=_(l,p,b,f);break e}else{switch(l=p.stateNode.containerInfo,l.nodeType){case 9:l=l.body;break;default:l=l.nodeName==="HTML"?l.ownerDocument.body:l}for(ma=Zs(l.firstChild),Er=p,En=!0,Tl=null,bs=!0,f=qu(p,null,b,f),p.child=f;f;)f.flags=f.flags&-3|4096,f=f.sibling}else{if(Du(),b===A){p=ut(l,p,f);break e}tr(l,p,b,f)}p=p.child}return p;case 26:return ql(l,p),l===null?(f=qT(p.type,null,p.pendingProps,null))?p.memoizedState=f:En||(f=p.type,l=p.pendingProps,b=Nx(qe.current).createElement(f),b[Gt]=p,b[xt]=l,Nr(b,f,l),ha(b),p.stateNode=b):p.memoizedState=qT(p.type,l.memoizedProps,p.pendingProps,l.memoizedState),null;case 27:return ht(p),l===null&&En&&(b=p.stateNode=UT(p.type,p.pendingProps,qe.current),Er=p,bs=!0,A=ma,Qu(p.type)?(F2=A,ma=Zs(b.firstChild)):ma=A),tr(l,p,p.pendingProps.children,f),ql(l,p),l===null&&(p.flags|=4194304),p.child;case 5:return l===null&&En&&((A=b=ma)&&(b=YV(b,p.type,p.pendingProps,bs),b!==null?(p.stateNode=b,Er=p,ma=Zs(b.firstChild),bs=!1,A=!0):A=!1),A||Nl(p)),ht(p),A=p.type,I=p.pendingProps,W=l!==null?l.memoizedProps:null,b=I.children,_2(A,I)?b=null:W!==null&&_2(A,W)&&(p.flags|=32),p.memoizedState!==null&&(A=Tb(l,p,QS,null,null,f),oy._currentValue=A),ql(l,p),tr(l,p,b,f),p.child;case 6:return l===null&&En&&((l=f=ma)&&(f=jV(f,p.pendingProps,bs),f!==null?(p.stateNode=f,Er=p,ma=null,l=!0):l=!1),l||Nl(p)),null;case 13:return V(l,p,f);case 4:return Ke(p,p.stateNode.containerInfo),b=p.pendingProps,l===null?p.child=ws(p,null,b,f):tr(l,p,b,f),p.child;case 11:return Gb(l,p,p.type,p.pendingProps,f);case 7:return tr(l,p,p.pendingProps,f),p.child;case 8:return tr(l,p,p.pendingProps.children,f),p.child;case 12:return tr(l,p,p.pendingProps.children,f),p.child;case 10:return b=p.pendingProps,Oo(p,p.type,b.value),tr(l,p,b.children,f),p.child;case 9:return A=p.type._context,b=p.pendingProps.children,Mo(p),A=Xa(A),b=b(A),p.flags|=1,tr(l,p,b,f),p.child;case 14:return gx(l,p,p.type,p.pendingProps,f);case 15:return qo(l,p,p.type,p.pendingProps,f);case 19:return Pe(l,p,f);case 31:return b=p.pendingProps,f=p.mode,b={mode:b.mode,children:b.children},l===null?(f=X(b,f),f.ref=p.ref,p.child=f,f.return=p,p=f):(f=qs(l.child,b),f.ref=p.ref,p.child=f,f.return=p,p=f),p;case 22:return zf(l,p,f);case 24:return Mo(p),b=Xa(In),l===null?(A=pf(),A===null&&(A=la,I=cf(),A.pooledCache=I,I.refCount++,I!==null&&(A.pooledCacheLanes|=f),A=I),p.memoizedState={parent:b,cache:A},mf(p),Oo(p,In,A)):((l.lanes&f)!==0&&(gf(l,p),Bn(p,null,null,f),zu()),A=l.memoizedState,I=p.memoizedState,A.parent!==b?(A={parent:b,cache:b},p.memoizedState=A,p.lanes===0&&(p.memoizedState=p.updateQueue.baseState=A),Oo(p,In,b)):(b=I.cache,Oo(p,In,b),b!==A.cache&&Ol(p,[In],f,!0))),tr(l,p,p.pendingProps.children,f),p.child;case 29:throw p.pendingProps}throw Error(a(156,p.tag))}function Kt(l){l.flags|=4}function Ft(l,p){if(p.type!=="stylesheet"||(p.state.loading&4)!==0)l.flags&=-16777217;else if(l.flags|=16777216,!$T(p)){if(p=ri.current,p!==null&&((xn&4194048)===xn?xs!==null:(xn&62914560)!==xn&&(xn&536870912)===0||p!==xs))throw Bu=hf,ys;l.flags|=8192}}function tt(l,p){p!==null&&(l.flags|=4),l.flags&16384&&(p=l.tag!==22?fi():536870912,l.lanes|=p,Gf|=p)}function nn(l,p){if(!En)switch(l.tailMode){case"hidden":p=l.tail;for(var f=null;p!==null;)p.alternate!==null&&(f=p),p=p.sibling;f===null?l.tail=null:f.sibling=null;break;case"collapsed":f=l.tail;for(var b=null;f!==null;)f.alternate!==null&&(b=f),f=f.sibling;b===null?p||l.tail===null?l.tail=null:l.tail.sibling=null:b.sibling=null}}function Vt(l){var p=l.alternate!==null&&l.alternate.child===l.child,f=0,b=0;if(p)for(var A=l.child;A!==null;)f|=A.lanes|A.childLanes,b|=A.subtreeFlags&65011712,b|=A.flags&65011712,A.return=l,A=A.sibling;else for(A=l.child;A!==null;)f|=A.lanes|A.childLanes,b|=A.subtreeFlags,b|=A.flags,A.return=l,A=A.sibling;return l.subtreeFlags|=b,l.childLanes=f,p}function Et(l,p,f){var b=p.pendingProps;switch(yb(p),p.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Vt(p),null;case 1:return Vt(p),null;case 3:return f=p.stateNode,b=null,l!==null&&(b=l.memoizedState.cache),p.memoizedState.cache!==b&&(p.flags|=2048),Ks(In),rt(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(l===null||l.child===null)&&(Fu(p)?Kt(p):l===null||l.memoizedState.isDehydrated&&(p.flags&256)===0||(p.flags|=1024,wb())),Vt(p),null;case 26:return f=p.memoizedState,l===null?(Kt(p),f!==null?(Vt(p),Ft(p,f)):(Vt(p),p.flags&=-16777217)):f?f!==l.memoizedState?(Kt(p),Vt(p),Ft(p,f)):(Vt(p),p.flags&=-16777217):(l.memoizedProps!==b&&Kt(p),Vt(p),p.flags&=-16777217),null;case 27:kt(p),f=qe.current;var A=p.type;if(l!==null&&p.stateNode!=null)l.memoizedProps!==b&&Kt(p);else{if(!b){if(p.stateNode===null)throw Error(a(166));return Vt(p),null}l=_e.current,Fu(p)?Fw(p):(l=UT(A,b,f),p.stateNode=l,Kt(p))}return Vt(p),null;case 5:if(kt(p),f=p.type,l!==null&&p.stateNode!=null)l.memoizedProps!==b&&Kt(p);else{if(!b){if(p.stateNode===null)throw Error(a(166));return Vt(p),null}if(l=_e.current,Fu(p))Fw(p);else{switch(A=Nx(qe.current),l){case 1:l=A.createElementNS("http://www.w3.org/2000/svg",f);break;case 2:l=A.createElementNS("http://www.w3.org/1998/Math/MathML",f);break;default:switch(f){case"svg":l=A.createElementNS("http://www.w3.org/2000/svg",f);break;case"math":l=A.createElementNS("http://www.w3.org/1998/Math/MathML",f);break;case"script":l=A.createElement("div"),l.innerHTML="<script><\/script>",l=l.removeChild(l.firstChild);break;case"select":l=typeof b.is=="string"?A.createElement("select",{is:b.is}):A.createElement("select"),b.multiple?l.multiple=!0:b.size&&(l.size=b.size);break;default:l=typeof b.is=="string"?A.createElement(f,{is:b.is}):A.createElement(f)}}l[Gt]=p,l[xt]=b;e:for(A=p.child;A!==null;){if(A.tag===5||A.tag===6)l.appendChild(A.stateNode);else if(A.tag!==4&&A.tag!==27&&A.child!==null){A.child.return=A,A=A.child;continue}if(A===p)break e;for(;A.sibling===null;){if(A.return===null||A.return===p)break e;A=A.return}A.sibling.return=A.return,A=A.sibling}p.stateNode=l;e:switch(Nr(l,f,b),f){case"button":case"input":case"select":case"textarea":l=!!b.autoFocus;break e;case"img":l=!0;break e;default:l=!1}l&&Kt(p)}}return Vt(p),p.flags&=-16777217,null;case 6:if(l&&p.stateNode!=null)l.memoizedProps!==b&&Kt(p);else{if(typeof b!="string"&&p.stateNode===null)throw Error(a(166));if(l=qe.current,Fu(p)){if(l=p.stateNode,f=p.memoizedProps,b=null,A=Er,A!==null)switch(A.tag){case 27:case 5:b=A.memoizedProps}l[Gt]=p,l=!!(l.nodeValue===f||b!==null&&b.suppressHydrationWarning===!0||FT(l.nodeValue,f)),l||Nl(p)}else l=Nx(l).createTextNode(b),l[Gt]=p,p.stateNode=l}return Vt(p),null;case 13:if(b=p.memoizedState,l===null||l.memoizedState!==null&&l.memoizedState.dehydrated!==null){if(A=Fu(p),b!==null&&b.dehydrated!==null){if(l===null){if(!A)throw Error(a(318));if(A=p.memoizedState,A=A!==null?A.dehydrated:null,!A)throw Error(a(317));A[Gt]=p}else Du(),(p.flags&128)===0&&(p.memoizedState=null),p.flags|=4;Vt(p),A=!1}else A=wb(),l!==null&&l.memoizedState!==null&&(l.memoizedState.hydrationErrors=A),A=!0;if(!A)return p.flags&256?(Gi(p),p):(Gi(p),null)}if(Gi(p),(p.flags&128)!==0)return p.lanes=f,p;if(f=b!==null,l=l!==null&&l.memoizedState!==null,f){b=p.child,A=null,b.alternate!==null&&b.alternate.memoizedState!==null&&b.alternate.memoizedState.cachePool!==null&&(A=b.alternate.memoizedState.cachePool.pool);var I=null;b.memoizedState!==null&&b.memoizedState.cachePool!==null&&(I=b.memoizedState.cachePool.pool),I!==A&&(b.flags|=2048)}return f!==l&&f&&(p.child.flags|=8192),tt(p,p.updateQueue),Vt(p),null;case 4:return rt(),l===null&&k2(p.stateNode.containerInfo),Vt(p),null;case 10:return Ks(p.type),Vt(p),null;case 19:if(xe(Fa),A=p.memoizedState,A===null)return Vt(p),null;if(b=(p.flags&128)!==0,I=A.rendering,I===null)if(b)nn(A,!1);else{if(Ia!==0||l!==null&&(l.flags&128)!==0)for(l=p.child;l!==null;){if(I=Of(l),I!==null){for(p.flags|=128,nn(A,!1),l=I.updateQueue,p.updateQueue=l,tt(p,l),p.subtreeFlags=0,l=f,f=p.child;f!==null;)Rw(f,l),f=f.sibling;return me(Fa,Fa.current&1|2),p.child}l=l.sibling}A.tail!==null&&ft()>xx&&(p.flags|=128,b=!0,nn(A,!1),p.lanes=4194304)}else{if(!b)if(l=Of(I),l!==null){if(p.flags|=128,b=!0,l=l.updateQueue,p.updateQueue=l,tt(p,l),nn(A,!0),A.tail===null&&A.tailMode==="hidden"&&!I.alternate&&!En)return Vt(p),null}else 2*ft()-A.renderingStartTime>xx&&f!==536870912&&(p.flags|=128,b=!0,nn(A,!1),p.lanes=4194304);A.isBackwards?(I.sibling=p.child,p.child=I):(l=A.last,l!==null?l.sibling=I:p.child=I,A.last=I)}return A.tail!==null?(p=A.tail,A.rendering=p,A.tail=p.sibling,A.renderingStartTime=ft(),p.sibling=null,l=Fa.current,me(Fa,b?l&1|2:l&1),p):(Vt(p),null);case 22:case 23:return Gi(p),wf(),b=p.memoizedState!==null,l!==null?l.memoizedState!==null!==b&&(p.flags|=8192):b&&(p.flags|=8192),b?(f&536870912)!==0&&(p.flags&128)===0&&(Vt(p),p.subtreeFlags&6&&(p.flags|=8192)):Vt(p),f=p.updateQueue,f!==null&&tt(p,f.retryQueue),f=null,l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(f=l.memoizedState.cachePool.pool),b=null,p.memoizedState!==null&&p.memoizedState.cachePool!==null&&(b=p.memoizedState.cachePool.pool),b!==f&&(p.flags|=2048),l!==null&&xe(Bo),null;case 24:return f=null,l!==null&&(f=l.memoizedState.cache),p.memoizedState.cache!==f&&(p.flags|=2048),Ks(In),Vt(p),null;case 25:return null;case 30:return null}throw Error(a(156,p.tag))}function _n(l,p){switch(yb(p),p.tag){case 1:return l=p.flags,l&65536?(p.flags=l&-65537|128,p):null;case 3:return Ks(In),rt(),l=p.flags,(l&65536)!==0&&(l&128)===0?(p.flags=l&-65537|128,p):null;case 26:case 27:case 5:return kt(p),null;case 13:if(Gi(p),l=p.memoizedState,l!==null&&l.dehydrated!==null){if(p.alternate===null)throw Error(a(340));Du()}return l=p.flags,l&65536?(p.flags=l&-65537|128,p):null;case 19:return xe(Fa),null;case 4:return rt(),null;case 10:return Ks(p.type),null;case 22:case 23:return Gi(p),wf(),l!==null&&xe(Bo),l=p.flags,l&65536?(p.flags=l&-65537|128,p):null;case 24:return Ks(In),null;case 25:return null;default:return null}}function Jt(l,p){switch(yb(p),p.tag){case 3:Ks(In),rt();break;case 26:case 27:case 5:kt(p);break;case 4:rt();break;case 13:Gi(p);break;case 19:xe(Fa);break;case 10:Ks(p.type);break;case 22:case 23:Gi(p),wf(),l!==null&&xe(Bo);break;case 24:Ks(In)}}function Ct(l,p){try{var f=p.updateQueue,b=f!==null?f.lastEffect:null;if(b!==null){var A=b.next;f=A;do{if((f.tag&l)===l){b=void 0;var I=f.create,W=f.inst;b=I(),W.destroy=b}f=f.next}while(f!==A)}}catch(J){na(p,p.return,J)}}function vt(l,p,f){try{var b=p.updateQueue,A=b!==null?b.lastEffect:null;if(A!==null){var I=A.next;b=I;do{if((b.tag&l)===l){var W=b.inst,J=W.destroy;if(J!==void 0){W.destroy=void 0,A=p;var ce=f,Ne=J;try{Ne()}catch(Ue){na(A,ce,Ue)}}}b=b.next}while(b!==I)}}catch(Ue){na(p,p.return,Ue)}}function Ki(l){var p=l.updateQueue;if(p!==null){var f=l.stateNode;try{Cb(p,f)}catch(b){na(l,l.return,b)}}}function Td(l,p,f){f.props=Wl(l.type,l.memoizedProps),f.state=l.memoizedState;try{f.componentWillUnmount()}catch(b){na(l,p,b)}}function vs(l,p){try{var f=l.ref;if(f!==null){switch(l.tag){case 26:case 27:case 5:var b=l.stateNode;break;case 30:b=l.stateNode;break;default:b=l.stateNode}typeof f=="function"?l.refCleanup=f(b):f.current=b}}catch(A){na(l,p,A)}}function mr(l,p){var f=l.ref,b=l.refCleanup;if(f!==null)if(typeof b=="function")try{b()}catch(A){na(l,p,A)}finally{l.refCleanup=null,l=l.alternate,l!=null&&(l.refCleanup=null)}else if(typeof f=="function")try{f(null)}catch(A){na(l,p,A)}else f.current=null}function Pl(l){var p=l.type,f=l.memoizedProps,b=l.stateNode;try{e:switch(p){case"button":case"input":case"select":case"textarea":f.autoFocus&&b.focus();break e;case"img":f.src?b.src=f.src:f.srcSet&&(b.srcset=f.srcSet)}}catch(A){na(l,l.return,A)}}function Pu(l,p,f){try{var b=l.stateNode;HV(b,l.type,f,p),b[xt]=p}catch(A){na(l,l.return,A)}}function Kb(l){return l.tag===5||l.tag===3||l.tag===26||l.tag===27&&Qu(l.type)||l.tag===4}function Ss(l){e:for(;;){for(;l.sibling===null;){if(l.return===null||Kb(l.return))return null;l=l.return}for(l.sibling.return=l.return,l=l.sibling;l.tag!==5&&l.tag!==6&&l.tag!==18;){if(l.tag===27&&Qu(l.type)||l.flags&2||l.child===null||l.tag===4)continue e;l.child.return=l,l=l.child}if(!(l.flags&2))return l.stateNode}}function $b(l,p,f){var b=l.tag;if(b===5||b===6)l=l.stateNode,p?(f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f).insertBefore(l,p):(p=f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f,p.appendChild(l),f=f._reactRootContainer,f!=null||p.onclick!==null||(p.onclick=Tx));else if(b!==4&&(b===27&&Qu(l.type)&&(f=l.stateNode,p=null),l=l.child,l!==null))for($b(l,p,f),l=l.sibling;l!==null;)$b(l,p,f),l=l.sibling}function Uf(l,p,f){var b=l.tag;if(b===5||b===6)l=l.stateNode,p?f.insertBefore(l,p):f.appendChild(l);else if(b!==4&&(b===27&&Qu(l.type)&&(f=l.stateNode),l=l.child,l!==null))for(Uf(l,p,f),l=l.sibling;l!==null;)Uf(l,p,f),l=l.sibling}function Vf(l){var p=l.stateNode,f=l.memoizedProps;try{for(var b=l.type,A=p.attributes;A.length;)p.removeAttributeNode(A[0]);Nr(p,b,f),p[Gt]=l,p[xt]=f}catch(I){na(l,l.return,I)}}var zr=!1,ba=!1,Hl=!1,Wf=typeof WeakSet=="function"?WeakSet:Set,Ca=null;function bx(l,p){if(l=l.containerInfo,C2=Bx,l=lb(l),_o(l)){if("selectionStart"in l)var f={start:l.selectionStart,end:l.selectionEnd};else e:{f=(f=l.ownerDocument)&&f.defaultView||window;var b=f.getSelection&&f.getSelection();if(b&&b.rangeCount!==0){f=b.anchorNode;var A=b.anchorOffset,I=b.focusNode;b=b.focusOffset;try{f.nodeType,I.nodeType}catch{f=null;break e}var W=0,J=-1,ce=-1,Ne=0,Ue=0,Ge=l,Fe=null;t:for(;;){for(var De;Ge!==f||A!==0&&Ge.nodeType!==3||(J=W+A),Ge!==I||b!==0&&Ge.nodeType!==3||(ce=W+b),Ge.nodeType===3&&(W+=Ge.nodeValue.length),(De=Ge.firstChild)!==null;)Fe=Ge,Ge=De;for(;;){if(Ge===l)break t;if(Fe===f&&++Ne===A&&(J=W),Fe===I&&++Ue===b&&(ce=W),(De=Ge.nextSibling)!==null)break;Ge=Fe,Fe=Ge.parentNode}Ge=De}f=J===-1||ce===-1?null:{start:J,end:ce}}else f=null}f=f||{start:0,end:0}}else f=null;for(I2={focusedElem:l,selectionRange:f},Bx=!1,Ca=p;Ca!==null;)if(p=Ca,l=p.child,(p.subtreeFlags&1024)!==0&&l!==null)l.return=p,Ca=l;else for(;Ca!==null;){switch(p=Ca,I=p.alternate,l=p.flags,p.tag){case 0:break;case 11:case 15:break;case 1:if((l&1024)!==0&&I!==null){l=void 0,f=p,A=I.memoizedProps,I=I.memoizedState,b=f.stateNode;try{var Bt=Wl(f.type,A,f.elementType===f.type);l=b.getSnapshotBeforeUpdate(Bt,I),b.__reactInternalSnapshotBeforeUpdate=l}catch(Tt){na(f,f.return,Tt)}}break;case 3:if((l&1024)!==0){if(l=p.stateNode.containerInfo,f=l.nodeType,f===9)N2(l);else if(f===1)switch(l.nodeName){case"HEAD":case"HTML":case"BODY":N2(l);break;default:l.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((l&1024)!==0)throw Error(a(163))}if(l=p.sibling,l!==null){l.return=p.return,Ca=l;break}Ca=p.return}}function Jb(l,p,f){var b=f.flags;switch(f.tag){case 0:case 11:case 15:Hu(l,f),b&4&&Ct(5,f);break;case 1:if(Hu(l,f),b&4)if(l=f.stateNode,p===null)try{l.componentDidMount()}catch(W){na(f,f.return,W)}else{var A=Wl(f.type,p.memoizedProps);p=p.memoizedState;try{l.componentDidUpdate(A,p,l.__reactInternalSnapshotBeforeUpdate)}catch(W){na(f,f.return,W)}}b&64&&Ki(f),b&512&&vs(f,f.return);break;case 3:if(Hu(l,f),b&64&&(l=f.updateQueue,l!==null)){if(p=null,f.child!==null)switch(f.child.tag){case 27:case 5:p=f.child.stateNode;break;case 1:p=f.child.stateNode}try{Cb(l,p)}catch(W){na(f,f.return,W)}}break;case 27:p===null&&b&4&&Vf(f);case 26:case 5:Hu(l,f),p===null&&b&4&&Pl(f),b&512&&vs(f,f.return);break;case 12:Hu(l,f);break;case 13:Hu(l,f),b&4&&j_(l,f),b&64&&(l=f.memoizedState,l!==null&&(l=l.dehydrated,l!==null&&(f=DV.bind(null,f),QV(l,f))));break;case 22:if(b=f.memoizedState!==null||zr,!b){p=p!==null&&p.memoizedState!==null||ba,A=zr;var I=ba;zr=b,(ba=p)&&!I?Gu(l,f,(f.subtreeFlags&8772)!==0):Hu(l,f),zr=A,ba=I}break;case 30:break;default:Hu(l,f)}}function yx(l){var p=l.alternate;p!==null&&(l.alternate=null,yx(p)),l.child=null,l.deletions=null,l.sibling=null,l.tag===5&&(p=l.stateNode,p!==null&&bo(p)),l.stateNode=null,l.return=null,l.dependencies=null,l.memoizedProps=null,l.memoizedState=null,l.pendingProps=null,l.stateNode=null,l.updateQueue=null}var ta=null,_r=!1;function ks(l,p,f){for(f=f.child;f!==null;)Y_(l,p,f),f=f.sibling}function Y_(l,p,f){if(tn&&typeof tn.onCommitFiberUnmount=="function")try{tn.onCommitFiberUnmount(An,f)}catch{}switch(f.tag){case 26:ba||mr(f,p),ks(l,p,f),f.memoizedState?f.memoizedState.count--:f.stateNode&&(f=f.stateNode,f.parentNode.removeChild(f));break;case 27:ba||mr(f,p);var b=ta,A=_r;Qu(f.type)&&(ta=f.stateNode,_r=!1),ks(l,p,f),ay(f.stateNode),ta=b,_r=A;break;case 5:ba||mr(f,p);case 6:if(b=ta,A=_r,ta=null,ks(l,p,f),ta=b,_r=A,ta!==null)if(_r)try{(ta.nodeType===9?ta.body:ta.nodeName==="HTML"?ta.ownerDocument.body:ta).removeChild(f.stateNode)}catch(I){na(f,p,I)}else try{ta.removeChild(f.stateNode)}catch(I){na(f,p,I)}break;case 18:ta!==null&&(_r?(l=ta,LT(l.nodeType===9?l.body:l.nodeName==="HTML"?l.ownerDocument.body:l,f.stateNode),dy(l)):LT(ta,f.stateNode));break;case 4:b=ta,A=_r,ta=f.stateNode.containerInfo,_r=!0,ks(l,p,f),ta=b,_r=A;break;case 0:case 11:case 14:case 15:ba||vt(2,f,p),ba||vt(4,f,p),ks(l,p,f);break;case 1:ba||(mr(f,p),b=f.stateNode,typeof b.componentWillUnmount=="function"&&Td(f,p,b)),ks(l,p,f);break;case 21:ks(l,p,f);break;case 22:ba=(b=ba)||f.memoizedState!==null,ks(l,p,f),ba=b;break;default:ks(l,p,f)}}function j_(l,p){if(p.memoizedState===null&&(l=p.alternate,l!==null&&(l=l.memoizedState,l!==null&&(l=l.dehydrated,l!==null))))try{dy(l)}catch(f){na(p,p.return,f)}}function EV(l){switch(l.tag){case 13:case 19:var p=l.stateNode;return p===null&&(p=l.stateNode=new Wf),p;case 22:return l=l.stateNode,p=l._retryCache,p===null&&(p=l._retryCache=new Wf),p;default:throw Error(a(435,l.tag))}}function a2(l,p){var f=EV(l);p.forEach(function(b){var A=OV.bind(null,l,b);f.has(b)||(f.add(b),b.then(A,A))})}function $i(l,p){var f=p.deletions;if(f!==null)for(var b=0;b<f.length;b++){var A=f[b],I=l,W=p,J=W;e:for(;J!==null;){switch(J.tag){case 27:if(Qu(J.type)){ta=J.stateNode,_r=!1;break e}break;case 5:ta=J.stateNode,_r=!1;break e;case 3:case 4:ta=J.stateNode.containerInfo,_r=!0;break e}J=J.return}if(ta===null)throw Error(a(160));Y_(I,W,A),ta=null,_r=!1,I=A.alternate,I!==null&&(I.return=null),A.return=null}if(p.subtreeFlags&13878)for(p=p.child;p!==null;)Q_(p,l),p=p.sibling}var Qs=null;function Q_(l,p){var f=l.alternate,b=l.flags;switch(l.tag){case 0:case 11:case 14:case 15:$i(p,l),Ji(l),b&4&&(vt(3,l,l.return),Ct(3,l),vt(5,l,l.return));break;case 1:$i(p,l),Ji(l),b&512&&(ba||f===null||mr(f,f.return)),b&64&&zr&&(l=l.updateQueue,l!==null&&(b=l.callbacks,b!==null&&(f=l.shared.hiddenCallbacks,l.shared.hiddenCallbacks=f===null?b:f.concat(b))));break;case 26:var A=Qs;if($i(p,l),Ji(l),b&512&&(ba||f===null||mr(f,f.return)),b&4){var I=f!==null?f.memoizedState:null;if(b=l.memoizedState,f===null)if(b===null)if(l.stateNode===null){e:{b=l.type,f=l.memoizedProps,A=A.ownerDocument||A;t:switch(b){case"title":I=A.getElementsByTagName("title")[0],(!I||I[mi]||I[Gt]||I.namespaceURI==="http://www.w3.org/2000/svg"||I.hasAttribute("itemprop"))&&(I=A.createElement(b),A.head.insertBefore(I,A.querySelector("head > title"))),Nr(I,b,f),I[Gt]=l,ha(I),b=I;break e;case"link":var W=GT("link","href",A).get(b+(f.href||""));if(W){for(var J=0;J<W.length;J++)if(I=W[J],I.getAttribute("href")===(f.href==null||f.href===""?null:f.href)&&I.getAttribute("rel")===(f.rel==null?null:f.rel)&&I.getAttribute("title")===(f.title==null?null:f.title)&&I.getAttribute("crossorigin")===(f.crossOrigin==null?null:f.crossOrigin)){W.splice(J,1);break t}}I=A.createElement(b),Nr(I,b,f),A.head.appendChild(I);break;case"meta":if(W=GT("meta","content",A).get(b+(f.content||""))){for(J=0;J<W.length;J++)if(I=W[J],I.getAttribute("content")===(f.content==null?null:""+f.content)&&I.getAttribute("name")===(f.name==null?null:f.name)&&I.getAttribute("property")===(f.property==null?null:f.property)&&I.getAttribute("http-equiv")===(f.httpEquiv==null?null:f.httpEquiv)&&I.getAttribute("charset")===(f.charSet==null?null:f.charSet)){W.splice(J,1);break t}}I=A.createElement(b),Nr(I,b,f),A.head.appendChild(I);break;default:throw Error(a(468,b))}I[Gt]=l,ha(I),b=I}l.stateNode=b}else KT(A,l.type,l.stateNode);else l.stateNode=HT(A,b,l.memoizedProps);else I!==b?(I===null?f.stateNode!==null&&(f=f.stateNode,f.parentNode.removeChild(f)):I.count--,b===null?KT(A,l.type,l.stateNode):HT(A,b,l.memoizedProps)):b===null&&l.stateNode!==null&&Pu(l,l.memoizedProps,f.memoizedProps)}break;case 27:$i(p,l),Ji(l),b&512&&(ba||f===null||mr(f,f.return)),f!==null&&b&4&&Pu(l,l.memoizedProps,f.memoizedProps);break;case 5:if($i(p,l),Ji(l),b&512&&(ba||f===null||mr(f,f.return)),l.flags&32){A=l.stateNode;try{fa(A,"")}catch(De){na(l,l.return,De)}}b&4&&l.stateNode!=null&&(A=l.memoizedProps,Pu(l,A,f!==null?f.memoizedProps:A)),b&1024&&(Hl=!0);break;case 6:if($i(p,l),Ji(l),b&4){if(l.stateNode===null)throw Error(a(162));b=l.memoizedProps,f=l.stateNode;try{f.nodeValue=b}catch(De){na(l,l.return,De)}}break;case 3:if(Dx=null,A=Qs,Qs=Rx(p.containerInfo),$i(p,l),Qs=A,Ji(l),b&4&&f!==null&&f.memoizedState.isDehydrated)try{dy(p.containerInfo)}catch(De){na(l,l.return,De)}Hl&&(Hl=!1,Z_(l));break;case 4:b=Qs,Qs=Rx(l.stateNode.containerInfo),$i(p,l),Ji(l),Qs=b;break;case 12:$i(p,l),Ji(l);break;case 13:$i(p,l),Ji(l),l.child.flags&8192&&l.memoizedState!==null!=(f!==null&&f.memoizedState!==null)&&(u2=ft()),b&4&&(b=l.updateQueue,b!==null&&(l.updateQueue=null,a2(l,b)));break;case 22:A=l.memoizedState!==null;var ce=f!==null&&f.memoizedState!==null,Ne=zr,Ue=ba;if(zr=Ne||A,ba=Ue||ce,$i(p,l),ba=Ue,zr=Ne,Ji(l),b&8192)e:for(p=l.stateNode,p._visibility=A?p._visibility&-2:p._visibility|1,A&&(f===null||ce||zr||ba||Nd(l)),f=null,p=l;;){if(p.tag===5||p.tag===26){if(f===null){ce=f=p;try{if(I=ce.stateNode,A)W=I.style,typeof W.setProperty=="function"?W.setProperty("display","none","important"):W.display="none";else{J=ce.stateNode;var Ge=ce.memoizedProps.style,Fe=Ge!=null&&Ge.hasOwnProperty("display")?Ge.display:null;J.style.display=Fe==null||typeof Fe=="boolean"?"":(""+Fe).trim()}}catch(De){na(ce,ce.return,De)}}}else if(p.tag===6){if(f===null){ce=p;try{ce.stateNode.nodeValue=A?"":ce.memoizedProps}catch(De){na(ce,ce.return,De)}}}else if((p.tag!==22&&p.tag!==23||p.memoizedState===null||p===l)&&p.child!==null){p.child.return=p,p=p.child;continue}if(p===l)break e;for(;p.sibling===null;){if(p.return===null||p.return===l)break e;f===p&&(f=null),p=p.return}f===p&&(f=null),p.sibling.return=p.return,p=p.sibling}b&4&&(b=l.updateQueue,b!==null&&(f=b.retryQueue,f!==null&&(b.retryQueue=null,a2(l,f))));break;case 19:$i(p,l),Ji(l),b&4&&(b=l.updateQueue,b!==null&&(l.updateQueue=null,a2(l,b)));break;case 30:break;case 21:break;default:$i(p,l),Ji(l)}}function Ji(l){var p=l.flags;if(p&2){try{for(var f,b=l.return;b!==null;){if(Kb(b)){f=b;break}b=b.return}if(f==null)throw Error(a(160));switch(f.tag){case 27:var A=f.stateNode,I=Ss(l);Uf(l,I,A);break;case 5:var W=f.stateNode;f.flags&32&&(fa(W,""),f.flags&=-33);var J=Ss(l);Uf(l,J,W);break;case 3:case 4:var ce=f.stateNode.containerInfo,Ne=Ss(l);$b(l,Ne,ce);break;default:throw Error(a(161))}}catch(Ue){na(l,l.return,Ue)}l.flags&=-3}p&4096&&(l.flags&=-4097)}function Z_(l){if(l.subtreeFlags&1024)for(l=l.child;l!==null;){var p=l;Z_(p),p.tag===5&&p.flags&1024&&p.stateNode.reset(),l=l.sibling}}function Hu(l,p){if(p.subtreeFlags&8772)for(p=p.child;p!==null;)Jb(l,p.alternate,p),p=p.sibling}function Nd(l){for(l=l.child;l!==null;){var p=l;switch(p.tag){case 0:case 11:case 14:case 15:vt(4,p,p.return),Nd(p);break;case 1:mr(p,p.return);var f=p.stateNode;typeof f.componentWillUnmount=="function"&&Td(p,p.return,f),Nd(p);break;case 27:ay(p.stateNode);case 26:case 5:mr(p,p.return),Nd(p);break;case 22:p.memoizedState===null&&Nd(p);break;case 30:Nd(p);break;default:Nd(p)}l=l.sibling}}function Gu(l,p,f){for(f=f&&(p.subtreeFlags&8772)!==0,p=p.child;p!==null;){var b=p.alternate,A=l,I=p,W=I.flags;switch(I.tag){case 0:case 11:case 15:Gu(A,I,f),Ct(4,I);break;case 1:if(Gu(A,I,f),b=I,A=b.stateNode,typeof A.componentDidMount=="function")try{A.componentDidMount()}catch(Ne){na(b,b.return,Ne)}if(b=I,A=b.updateQueue,A!==null){var J=b.stateNode;try{var ce=A.shared.hiddenCallbacks;if(ce!==null)for(A.shared.hiddenCallbacks=null,A=0;A<ce.length;A++)Eb(ce[A],J)}catch(Ne){na(b,b.return,Ne)}}f&&W&64&&Ki(I),vs(I,I.return);break;case 27:Vf(I);case 26:case 5:Gu(A,I,f),f&&b===null&&W&4&&Pl(I),vs(I,I.return);break;case 12:Gu(A,I,f);break;case 13:Gu(A,I,f),f&&W&4&&j_(A,I);break;case 22:I.memoizedState===null&&Gu(A,I,f),vs(I,I.return);break;case 30:break;default:Gu(A,I,f)}p=p.sibling}}function r2(l,p){var f=null;l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(f=l.memoizedState.cachePool.pool),l=null,p.memoizedState!==null&&p.memoizedState.cachePool!==null&&(l=p.memoizedState.cachePool.pool),l!==f&&(l!=null&&l.refCount++,f!=null&&Ou(f))}function i2(l,p){l=null,p.alternate!==null&&(l=p.alternate.memoizedState.cache),p=p.memoizedState.cache,p!==l&&(p.refCount++,l!=null&&Ou(l))}function Po(l,p,f,b){if(p.subtreeFlags&10256)for(p=p.child;p!==null;)X_(l,p,f,b),p=p.sibling}function X_(l,p,f,b){var A=p.flags;switch(p.tag){case 0:case 11:case 15:Po(l,p,f,b),A&2048&&Ct(9,p);break;case 1:Po(l,p,f,b);break;case 3:Po(l,p,f,b),A&2048&&(l=null,p.alternate!==null&&(l=p.alternate.memoizedState.cache),p=p.memoizedState.cache,p!==l&&(p.refCount++,l!=null&&Ou(l)));break;case 12:if(A&2048){Po(l,p,f,b),l=p.stateNode;try{var I=p.memoizedProps,W=I.id,J=I.onPostCommit;typeof J=="function"&&J(W,p.alternate===null?"mount":"update",l.passiveEffectDuration,-0)}catch(ce){na(p,p.return,ce)}}else Po(l,p,f,b);break;case 13:Po(l,p,f,b);break;case 23:break;case 22:I=p.stateNode,W=p.alternate,p.memoizedState!==null?I._visibility&2?Po(l,p,f,b):Yb(l,p):I._visibility&2?Po(l,p,f,b):(I._visibility|=2,qf(l,p,f,b,(p.subtreeFlags&10256)!==0)),A&2048&&r2(W,p);break;case 24:Po(l,p,f,b),A&2048&&i2(p.alternate,p);break;default:Po(l,p,f,b)}}function qf(l,p,f,b,A){for(A=A&&(p.subtreeFlags&10256)!==0,p=p.child;p!==null;){var I=l,W=p,J=f,ce=b,Ne=W.flags;switch(W.tag){case 0:case 11:case 15:qf(I,W,J,ce,A),Ct(8,W);break;case 23:break;case 22:var Ue=W.stateNode;W.memoizedState!==null?Ue._visibility&2?qf(I,W,J,ce,A):Yb(I,W):(Ue._visibility|=2,qf(I,W,J,ce,A)),A&&Ne&2048&&r2(W.alternate,W);break;case 24:qf(I,W,J,ce,A),A&&Ne&2048&&i2(W.alternate,W);break;default:qf(I,W,J,ce,A)}p=p.sibling}}function Yb(l,p){if(p.subtreeFlags&10256)for(p=p.child;p!==null;){var f=l,b=p,A=b.flags;switch(b.tag){case 22:Yb(f,b),A&2048&&r2(b.alternate,b);break;case 24:Yb(f,b),A&2048&&i2(b.alternate,b);break;default:Yb(f,b)}p=p.sibling}}var jb=8192;function Pf(l){if(l.subtreeFlags&jb)for(l=l.child;l!==null;)eT(l),l=l.sibling}function eT(l){switch(l.tag){case 26:Pf(l),l.flags&jb&&l.memoizedState!==null&&c6(Qs,l.memoizedState,l.memoizedProps);break;case 5:Pf(l);break;case 3:case 4:var p=Qs;Qs=Rx(l.stateNode.containerInfo),Pf(l),Qs=p;break;case 22:l.memoizedState===null&&(p=l.alternate,p!==null&&p.memoizedState!==null?(p=jb,jb=16777216,Pf(l),jb=p):Pf(l));break;default:Pf(l)}}function tT(l){var p=l.alternate;if(p!==null&&(l=p.child,l!==null)){p.child=null;do p=l.sibling,l.sibling=null,l=p;while(l!==null)}}function Qb(l){var p=l.deletions;if((l.flags&16)!==0){if(p!==null)for(var f=0;f<p.length;f++){var b=p[f];Ca=b,aT(b,l)}tT(l)}if(l.subtreeFlags&10256)for(l=l.child;l!==null;)nT(l),l=l.sibling}function nT(l){switch(l.tag){case 0:case 11:case 15:Qb(l),l.flags&2048&&vt(9,l,l.return);break;case 3:Qb(l);break;case 12:Qb(l);break;case 22:var p=l.stateNode;l.memoizedState!==null&&p._visibility&2&&(l.return===null||l.return.tag!==13)?(p._visibility&=-3,wx(l)):Qb(l);break;default:Qb(l)}}function wx(l){var p=l.deletions;if((l.flags&16)!==0){if(p!==null)for(var f=0;f<p.length;f++){var b=p[f];Ca=b,aT(b,l)}tT(l)}for(l=l.child;l!==null;){switch(p=l,p.tag){case 0:case 11:case 15:vt(8,p,p.return),wx(p);break;case 22:f=p.stateNode,f._visibility&2&&(f._visibility&=-3,wx(p));break;default:wx(p)}l=l.sibling}}function aT(l,p){for(;Ca!==null;){var f=Ca;switch(f.tag){case 0:case 11:case 15:vt(8,f,p);break;case 23:case 22:if(f.memoizedState!==null&&f.memoizedState.cachePool!==null){var b=f.memoizedState.cachePool.pool;b!=null&&b.refCount++}break;case 24:Ou(f.memoizedState.cache)}if(b=f.child,b!==null)b.return=f,Ca=b;else e:for(f=l;Ca!==null;){b=Ca;var A=b.sibling,I=b.return;if(yx(b),b===f){Ca=null;break e}if(A!==null){A.return=I,Ca=A;break e}Ca=I}}}var CV={getCacheForType:function(l){var p=Xa(In),f=p.data.get(l);return f===void 0&&(f=l(),p.data.set(l,f)),f}},IV=typeof WeakMap=="function"?WeakMap:Map,Wn=0,la=null,fn=null,xn=0,qn=0,Yi=null,Ku=!1,Hf=!1,s2=!1,Gl=0,Ia=0,$u=0,Rd=0,o2=0,As=0,Gf=0,Zb=null,Si=null,l2=!1,u2=0,xx=1/0,vx=null,Ju=null,Tr=0,Yu=null,Kf=null,$f=0,c2=0,d2=null,rT=null,Xb=0,p2=null;function ji(){if((Wn&2)!==0&&xn!==0)return xn&-xn;if(Z.T!==null){var l=$s;return l!==0?l:w2()}return mt()}function iT(){As===0&&(As=(xn&536870912)===0||En?hn():536870912);var l=ri.current;return l!==null&&(l.flags|=32),As}function Qi(l,p,f){(l===la&&(qn===2||qn===9)||l.cancelPendingCommit!==null)&&(Jf(l,0),ju(l,xn,As,!1)),us(l,f),((Wn&2)===0||l!==la)&&(l===la&&((Wn&2)===0&&(Rd|=f),Ia===4&&ju(l,xn,As,!1)),Ho(l))}function sT(l,p,f){if((Wn&6)!==0)throw Error(a(327));var b=!f&&(p&124)===0&&(p&l.expiredLanes)===0||Rt(l,p),A=b?NV(l,p):m2(l,p,!0),I=b;do{if(A===0){Hf&&!b&&ju(l,p,0,!1);break}else{if(f=l.current.alternate,I&&!_V(f)){A=m2(l,p,!1),I=!1;continue}if(A===2){if(I=p,l.errorRecoveryDisabledLanes&I)var W=0;else W=l.pendingLanes&-536870913,W=W!==0?W:W&536870912?536870912:0;if(W!==0){p=W;e:{var J=l;A=Zb;var ce=J.current.memoizedState.isDehydrated;if(ce&&(Jf(J,W).flags|=256),W=m2(J,W,!1),W!==2){if(s2&&!ce){J.errorRecoveryDisabledLanes|=I,Rd|=I,A=4;break e}I=Si,Si=A,I!==null&&(Si===null?Si=I:Si.push.apply(Si,I))}A=W}if(I=!1,A!==2)continue}}if(A===1){Jf(l,0),ju(l,p,0,!0);break}e:{switch(b=l,I=A,I){case 0:case 1:throw Error(a(345));case 4:if((p&4194048)!==p)break;case 6:ju(b,p,As,!Ku);break e;case 2:Si=null;break;case 3:case 5:break;default:throw Error(a(329))}if((p&62914560)===p&&(A=u2+300-ft(),10<A)){if(ju(b,p,As,!Ku),Lt(b,0,!0)!==0)break e;b.timeoutHandle=MT(oT.bind(null,b,f,Si,vx,l2,p,As,Rd,Gf,Ku,I,2,-0,0),A);break e}oT(b,f,Si,vx,l2,p,As,Rd,Gf,Ku,I,0,-0,0)}}break}while(!0);Ho(l)}function oT(l,p,f,b,A,I,W,J,ce,Ne,Ue,Ge,Fe,De){if(l.timeoutHandle=-1,Ge=p.subtreeFlags,(Ge&8192||(Ge&16785408)===16785408)&&(sy={stylesheets:null,count:0,unsuspend:u6},eT(p),Ge=d6(),Ge!==null)){l.cancelPendingCommit=Ge(fT.bind(null,l,p,I,f,b,A,W,J,ce,Ue,1,Fe,De)),ju(l,I,W,!Ne);return}fT(l,p,I,f,b,A,W,J,ce)}function _V(l){for(var p=l;;){var f=p.tag;if((f===0||f===11||f===15)&&p.flags&16384&&(f=p.updateQueue,f!==null&&(f=f.stores,f!==null)))for(var b=0;b<f.length;b++){var A=f[b],I=A.getSnapshot;A=A.value;try{if(!ea(I(),A))return!1}catch{return!1}}if(f=p.child,p.subtreeFlags&16384&&f!==null)f.return=p,p=f;else{if(p===l)break;for(;p.sibling===null;){if(p.return===null||p.return===l)return!0;p=p.return}p.sibling.return=p.return,p=p.sibling}}return!0}function ju(l,p,f,b){p&=~o2,p&=~Rd,l.suspendedLanes|=p,l.pingedLanes&=~p,b&&(l.warmLanes|=p),b=l.expirationTimes;for(var A=p;0<A;){var I=31-F(A),W=1<<I;b[I]=-1,A&=~W}f!==0&&cs(l,f,p)}function Sx(){return(Wn&6)===0?(ey(0),!1):!0}function h2(){if(fn!==null){if(qn===0)var l=fn.return;else l=fn,Gs=Dl=null,Fb(l),Vl=null,Ad=0,l=fn;for(;l!==null;)Jt(l.alternate,l),l=l.return;fn=null}}function Jf(l,p){var f=l.timeoutHandle;f!==-1&&(l.timeoutHandle=-1,KV(f)),f=l.cancelPendingCommit,f!==null&&(l.cancelPendingCommit=null,f()),h2(),la=l,fn=f=qs(l.current,null),xn=p,qn=0,Yi=null,Ku=!1,Hf=Rt(l,p),s2=!1,Gf=As=o2=Rd=$u=Ia=0,Si=Zb=null,l2=!1,(p&8)!==0&&(p|=p&32);var b=l.entangledLanes;if(b!==0)for(l=l.entanglements,b&=p;0<b;){var A=31-F(b),I=1<<A;p|=l[A],b&=~I}return Gl=p,tf(),f}function lT(l,p){zt=null,Z.H=kd,p===Lo||p===Mu?(p=Ab(),qn=3):p===ys?(p=Ab(),qn=4):qn=p===mx?8:p!==null&&typeof p=="object"&&typeof p.then=="function"?6:1,Yi=p,fn===null&&(Ia=1,Lf(l,wi(p,l.current)))}function uT(){var l=Z.H;return Z.H=kd,l===null?kd:l}function cT(){var l=Z.A;return Z.A=CV,l}function f2(){Ia=4,Ku||(xn&4194048)!==xn&&ri.current!==null||(Hf=!0),($u&134217727)===0&&(Rd&134217727)===0||la===null||ju(la,xn,As,!1)}function m2(l,p,f){var b=Wn;Wn|=2;var A=uT(),I=cT();(la!==l||xn!==p)&&(vx=null,Jf(l,p)),p=!1;var W=Ia;e:do try{if(qn!==0&&fn!==null){var J=fn,ce=Yi;switch(qn){case 8:h2(),W=6;break e;case 3:case 2:case 9:case 6:ri.current===null&&(p=!0);var Ne=qn;if(qn=0,Yi=null,Yf(l,J,ce,Ne),f&&Hf){W=0;break e}break;default:Ne=qn,qn=0,Yi=null,Yf(l,J,ce,Ne)}}TV(),W=Ia;break}catch(Ue){lT(l,Ue)}while(!0);return p&&l.shellSuspendCounter++,Gs=Dl=null,Wn=b,Z.H=A,Z.A=I,fn===null&&(la=null,xn=0,tf()),W}function TV(){for(;fn!==null;)dT(fn)}function NV(l,p){var f=Wn;Wn|=2;var b=uT(),A=cT();la!==l||xn!==p?(vx=null,xx=ft()+500,Jf(l,p)):Hf=Rt(l,p);e:do try{if(qn!==0&&fn!==null){p=fn;var I=Yi;t:switch(qn){case 1:qn=0,Yi=null,Yf(l,p,I,1);break;case 2:case 9:if(ff(I)){qn=0,Yi=null,pT(p);break}p=function(){qn!==2&&qn!==9||la!==l||(qn=7),Ho(l)},I.then(p,p);break e;case 3:qn=7;break e;case 4:qn=5;break e;case 7:ff(I)?(qn=0,Yi=null,pT(p)):(qn=0,Yi=null,Yf(l,p,I,7));break;case 5:var W=null;switch(fn.tag){case 26:W=fn.memoizedState;case 5:case 27:var J=fn;if(!W||$T(W)){qn=0,Yi=null;var ce=J.sibling;if(ce!==null)fn=ce;else{var Ne=J.return;Ne!==null?(fn=Ne,kx(Ne)):fn=null}break t}}qn=0,Yi=null,Yf(l,p,I,5);break;case 6:qn=0,Yi=null,Yf(l,p,I,6);break;case 8:h2(),Ia=6;break e;default:throw Error(a(462))}}RV();break}catch(Ue){lT(l,Ue)}while(!0);return Gs=Dl=null,Z.H=b,Z.A=A,Wn=f,fn!==null?0:(la=null,xn=0,tf(),Ia)}function RV(){for(;fn!==null&&!Pt();)dT(fn)}function dT(l){var p=Ut(l.alternate,l,Gl);l.memoizedProps=l.pendingProps,p===null?kx(l):fn=p}function pT(l){var p=l,f=p.alternate;switch(p.tag){case 15:case 0:p=k(f,p,p.pendingProps,p.type,void 0,xn);break;case 11:p=k(f,p,p.pendingProps,p.type.render,p.ref,xn);break;case 5:Fb(p);default:Jt(f,p),p=fn=Rw(p,Gl),p=Ut(f,p,Gl)}l.memoizedProps=l.pendingProps,p===null?kx(l):fn=p}function Yf(l,p,f,b){Gs=Dl=null,Fb(p),Vl=null,Ad=0;var A=p.return;try{if(n2(l,A,p,f,xn)){Ia=1,Lf(l,wi(f,l.current)),fn=null;return}}catch(I){if(A!==null)throw fn=A,I;Ia=1,Lf(l,wi(f,l.current)),fn=null;return}p.flags&32768?(En||b===1?l=!0:Hf||(xn&536870912)!==0?l=!1:(Ku=l=!0,(b===2||b===9||b===3||b===6)&&(b=ri.current,b!==null&&b.tag===13&&(b.flags|=16384))),hT(p,l)):kx(p)}function kx(l){var p=l;do{if((p.flags&32768)!==0){hT(p,Ku);return}l=p.return;var f=Et(p.alternate,p,Gl);if(f!==null){fn=f;return}if(p=p.sibling,p!==null){fn=p;return}fn=p=l}while(p!==null);Ia===0&&(Ia=5)}function hT(l,p){do{var f=_n(l.alternate,l);if(f!==null){f.flags&=32767,fn=f;return}if(f=l.return,f!==null&&(f.flags|=32768,f.subtreeFlags=0,f.deletions=null),!p&&(l=l.sibling,l!==null)){fn=l;return}fn=l=f}while(l!==null);Ia=6,fn=null}function fT(l,p,f,b,A,I,W,J,ce){l.cancelPendingCommit=null;do Ax();while(Tr!==0);if((Wn&6)!==0)throw Error(a(327));if(p!==null){if(p===l.current)throw Error(a(177));if(I=p.lanes|p.childLanes,I|=fb,Va(l,f,I,W,J,ce),l===la&&(fn=la=null,xn=0),Kf=p,Yu=l,$f=f,c2=I,d2=A,rT=b,(p.subtreeFlags&10256)!==0||(p.flags&10256)!==0?(l.callbackNode=null,l.callbackPriority=0,MV(Ht,function(){return wT(),null})):(l.callbackNode=null,l.callbackPriority=0),b=(p.flags&13878)!==0,(p.subtreeFlags&13878)!==0||b){b=Z.T,Z.T=null,A=se.p,se.p=2,W=Wn,Wn|=4;try{bx(l,p,f)}finally{Wn=W,se.p=A,Z.T=b}}Tr=1,mT(),gT(),bT()}}function mT(){if(Tr===1){Tr=0;var l=Yu,p=Kf,f=(p.flags&13878)!==0;if((p.subtreeFlags&13878)!==0||f){f=Z.T,Z.T=null;var b=se.p;se.p=2;var A=Wn;Wn|=4;try{Q_(p,l);var I=I2,W=lb(l.containerInfo),J=I.focusedElem,ce=I.selectionRange;if(W!==J&&J&&J.ownerDocument&&ef(J.ownerDocument.documentElement,J)){if(ce!==null&&_o(J)){var Ne=ce.start,Ue=ce.end;if(Ue===void 0&&(Ue=Ne),"selectionStart"in J)J.selectionStart=Ne,J.selectionEnd=Math.min(Ue,J.value.length);else{var Ge=J.ownerDocument||document,Fe=Ge&&Ge.defaultView||window;if(Fe.getSelection){var De=Fe.getSelection(),Bt=J.textContent.length,Tt=Math.min(ce.start,Bt),Qn=ce.end===void 0?Tt:Math.min(ce.end,Bt);!De.extend&&Tt>Qn&&(W=Qn,Qn=Tt,Tt=W);var Ee=Au(J,Tt),Se=Au(J,Qn);if(Ee&&Se&&(De.rangeCount!==1||De.anchorNode!==Ee.node||De.anchorOffset!==Ee.offset||De.focusNode!==Se.node||De.focusOffset!==Se.offset)){var Te=Ge.createRange();Te.setStart(Ee.node,Ee.offset),De.removeAllRanges(),Tt>Qn?(De.addRange(Te),De.extend(Se.node,Se.offset)):(Te.setEnd(Se.node,Se.offset),De.addRange(Te))}}}}for(Ge=[],De=J;De=De.parentNode;)De.nodeType===1&&Ge.push({element:De,left:De.scrollLeft,top:De.scrollTop});for(typeof J.focus=="function"&&J.focus(),J=0;J<Ge.length;J++){var Ve=Ge[J];Ve.element.scrollLeft=Ve.left,Ve.element.scrollTop=Ve.top}}Bx=!!C2,I2=C2=null}finally{Wn=A,se.p=b,Z.T=f}}l.current=p,Tr=2}}function gT(){if(Tr===2){Tr=0;var l=Yu,p=Kf,f=(p.flags&8772)!==0;if((p.subtreeFlags&8772)!==0||f){f=Z.T,Z.T=null;var b=se.p;se.p=2;var A=Wn;Wn|=4;try{Jb(l,p.alternate,p)}finally{Wn=A,se.p=b,Z.T=f}}Tr=3}}function bT(){if(Tr===4||Tr===3){Tr=0,Re();var l=Yu,p=Kf,f=$f,b=rT;(p.subtreeFlags&10256)!==0||(p.flags&10256)!==0?Tr=5:(Tr=0,Kf=Yu=null,yT(l,l.pendingLanes));var A=l.pendingLanes;if(A===0&&(Ju=null),Je(f),p=p.stateNode,tn&&typeof tn.onCommitFiberRoot=="function")try{tn.onCommitFiberRoot(An,p,void 0,(p.current.flags&128)===128)}catch{}if(b!==null){p=Z.T,A=se.p,se.p=2,Z.T=null;try{for(var I=l.onRecoverableError,W=0;W<b.length;W++){var J=b[W];I(J.value,{componentStack:J.stack})}}finally{Z.T=p,se.p=A}}($f&3)!==0&&Ax(),Ho(l),A=l.pendingLanes,(f&4194090)!==0&&(A&42)!==0?l===p2?Xb++:(Xb=0,p2=l):Xb=0,ey(0)}}function yT(l,p){(l.pooledCacheLanes&=p)===0&&(p=l.pooledCache,p!=null&&(l.pooledCache=null,Ou(p)))}function Ax(l){return mT(),gT(),bT(),wT()}function wT(){if(Tr!==5)return!1;var l=Yu,p=c2;c2=0;var f=Je($f),b=Z.T,A=se.p;try{se.p=32>f?32:f,Z.T=null,f=d2,d2=null;var I=Yu,W=$f;if(Tr=0,Kf=Yu=null,$f=0,(Wn&6)!==0)throw Error(a(331));var J=Wn;if(Wn|=4,nT(I.current),X_(I,I.current,W,f),Wn=J,ey(0,!1),tn&&typeof tn.onPostCommitFiberRoot=="function")try{tn.onPostCommitFiberRoot(An,I)}catch{}return!0}finally{se.p=A,Z.T=b,yT(l,p)}}function xT(l,p,f){p=wi(f,p),p=Pb(l.stateNode,p,2),l=Ys(l,p,2),l!==null&&(us(l,2),Ho(l))}function na(l,p,f){if(l.tag===3)xT(l,l,f);else for(;p!==null;){if(p.tag===3){xT(p,l,f);break}else if(p.tag===1){var b=p.stateNode;if(typeof p.type.getDerivedStateFromError=="function"||typeof b.componentDidCatch=="function"&&(Ju===null||!Ju.has(b))){l=wi(f,l),f=fx(2),b=Ys(p,f,2),b!==null&&(Hb(f,b,p,l),us(b,2),Ho(b));break}}p=p.return}}function g2(l,p,f){var b=l.pingCache;if(b===null){b=l.pingCache=new IV;var A=new Set;b.set(p,A)}else A=b.get(p),A===void 0&&(A=new Set,b.set(p,A));A.has(f)||(s2=!0,A.add(f),l=FV.bind(null,l,p,f),p.then(l,l))}function FV(l,p,f){var b=l.pingCache;b!==null&&b.delete(p),l.pingedLanes|=l.suspendedLanes&f,l.warmLanes&=~f,la===l&&(xn&f)===f&&(Ia===4||Ia===3&&(xn&62914560)===xn&&300>ft()-u2?(Wn&2)===0&&Jf(l,0):o2|=f,Gf===xn&&(Gf=0)),Ho(l)}function vT(l,p){p===0&&(p=fi()),l=_u(l,p),l!==null&&(us(l,p),Ho(l))}function DV(l){var p=l.memoizedState,f=0;p!==null&&(f=p.retryLane),vT(l,f)}function OV(l,p){var f=0;switch(l.tag){case 13:var b=l.stateNode,A=l.memoizedState;A!==null&&(f=A.retryLane);break;case 19:b=l.stateNode;break;case 22:b=l.stateNode._retryCache;break;default:throw Error(a(314))}b!==null&&b.delete(p),vT(l,f)}function MV(l,p){return ln(l,p)}var Ex=null,jf=null,b2=!1,Cx=!1,y2=!1,Fd=0;function Ho(l){l!==jf&&l.next===null&&(jf===null?Ex=jf=l:jf=jf.next=l),Cx=!0,b2||(b2=!0,LV())}function ey(l,p){if(!y2&&Cx){y2=!0;do for(var f=!1,b=Ex;b!==null;){if(l!==0){var A=b.pendingLanes;if(A===0)var I=0;else{var W=b.suspendedLanes,J=b.pingedLanes;I=(1<<31-F(42|l)+1)-1,I&=A&~(W&~J),I=I&201326741?I&201326741|1:I?I|2:0}I!==0&&(f=!0,ET(b,I))}else I=xn,I=Lt(b,b===la?I:0,b.cancelPendingCommit!==null||b.timeoutHandle!==-1),(I&3)===0||Rt(b,I)||(f=!0,ET(b,I));b=b.next}while(f);y2=!1}}function BV(){ST()}function ST(){Cx=b2=!1;var l=0;Fd!==0&&(GV()&&(l=Fd),Fd=0);for(var p=ft(),f=null,b=Ex;b!==null;){var A=b.next,I=kT(b,p);I===0?(b.next=null,f===null?Ex=A:f.next=A,A===null&&(jf=f)):(f=b,(l!==0||(I&3)!==0)&&(Cx=!0)),b=A}ey(l)}function kT(l,p){for(var f=l.suspendedLanes,b=l.pingedLanes,A=l.expirationTimes,I=l.pendingLanes&-62914561;0<I;){var W=31-F(I),J=1<<W,ce=A[W];ce===-1?((J&f)===0||(J&b)!==0)&&(A[W]=on(J,p)):ce<=p&&(l.expiredLanes|=J),I&=~J}if(p=la,f=xn,f=Lt(l,l===p?f:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),b=l.callbackNode,f===0||l===p&&(qn===2||qn===9)||l.cancelPendingCommit!==null)return b!==null&&b!==null&&Nt(b),l.callbackNode=null,l.callbackPriority=0;if((f&3)===0||Rt(l,f)){if(p=f&-f,p===l.callbackPriority)return p;switch(b!==null&&Nt(b),Je(f)){case 2:case 8:f=en;break;case 32:f=Ht;break;case 268435456:f=kn;break;default:f=Ht}return b=AT.bind(null,l),f=ln(f,b),l.callbackPriority=p,l.callbackNode=f,p}return b!==null&&b!==null&&Nt(b),l.callbackPriority=2,l.callbackNode=null,2}function AT(l,p){if(Tr!==0&&Tr!==5)return l.callbackNode=null,l.callbackPriority=0,null;var f=l.callbackNode;if(Ax()&&l.callbackNode!==f)return null;var b=xn;return b=Lt(l,l===la?b:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),b===0?null:(sT(l,b,p),kT(l,ft()),l.callbackNode!=null&&l.callbackNode===f?AT.bind(null,l):null)}function ET(l,p){if(Ax())return null;sT(l,p,!0)}function LV(){$V(function(){(Wn&6)!==0?ln(oa,BV):ST()})}function w2(){return Fd===0&&(Fd=hn()),Fd}function CT(l){return l==null||typeof l=="symbol"||typeof l=="boolean"?null:typeof l=="function"?l:fs(""+l)}function IT(l,p){var f=p.ownerDocument.createElement("input");return f.name=p.name,f.value=p.value,l.id&&f.setAttribute("form",l.id),p.parentNode.insertBefore(f,p),l=new FormData(l),f.parentNode.removeChild(f),l}function zV(l,p,f,b,A){if(p==="submit"&&f&&f.stateNode===A){var I=CT((A[xt]||null).action),W=b.submitter;W&&(p=(p=W[xt]||null)?CT(p.formAction):W.getAttribute("formAction"),p!==null&&(I=p,W=null));var J=new wl("action","action",null,b,A);l.push({event:J,listeners:[{instance:null,listener:function(){if(b.defaultPrevented){if(Fd!==0){var ce=W?IT(A,W):new FormData(A);wd(f,{pending:!0,data:ce,method:A.method,action:I},null,ce)}}else typeof I=="function"&&(J.preventDefault(),ce=W?IT(A,W):new FormData(A),wd(f,{pending:!0,data:ce,method:A.method,action:I},I,ce))},currentTarget:A}]})}}for(var x2=0;x2<hb.length;x2++){var v2=hb[x2],UV=v2.toLowerCase(),VV=v2[0].toUpperCase()+v2.slice(1);qi(UV,"on"+VV)}qi(db,"onAnimationEnd"),qi(Cw,"onAnimationIteration"),qi(pb,"onAnimationStart"),qi("dblclick","onDoubleClick"),qi("focusin","onFocus"),qi("focusout","onBlur"),qi(HS,"onTransitionRun"),qi(GS,"onTransitionStart"),qi(KS,"onTransitionCancel"),qi(Iw,"onTransitionEnd"),pr("onMouseEnter",["mouseout","mouseover"]),pr("onMouseLeave",["mouseout","mouseover"]),pr("onPointerEnter",["pointerout","pointerover"]),pr("onPointerLeave",["pointerout","pointerover"]),Qr("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Qr("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Qr("onBeforeInput",["compositionend","keypress","textInput","paste"]),Qr("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Qr("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Qr("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var ty="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),WV=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(ty));function _T(l,p){p=(p&4)!==0;for(var f=0;f<l.length;f++){var b=l[f],A=b.event;b=b.listeners;e:{var I=void 0;if(p)for(var W=b.length-1;0<=W;W--){var J=b[W],ce=J.instance,Ne=J.currentTarget;if(J=J.listener,ce!==I&&A.isPropagationStopped())break e;I=J,A.currentTarget=Ne;try{I(A)}catch(Ue){Bf(Ue)}A.currentTarget=null,I=ce}else for(W=0;W<b.length;W++){if(J=b[W],ce=J.instance,Ne=J.currentTarget,J=J.listener,ce!==I&&A.isPropagationStopped())break e;I=J,A.currentTarget=Ne;try{I(A)}catch(Ue){Bf(Ue)}A.currentTarget=null,I=ce}}}}function mn(l,p){var f=p[Xn];f===void 0&&(f=p[Xn]=new Set);var b=l+"__bubble";f.has(b)||(TT(p,l,2,!1),f.add(b))}function S2(l,p,f){var b=0;p&&(b|=4),TT(f,l,b,p)}var Ix="_reactListening"+Math.random().toString(36).slice(2);function k2(l){if(!l[Ix]){l[Ix]=!0,$h.forEach(function(f){f!=="selectionchange"&&(WV.has(f)||S2(f,!1,l),S2(f,!0,l))});var p=l.nodeType===9?l:l.ownerDocument;p===null||p[Ix]||(p[Ix]=!0,S2("selectionchange",!1,p))}}function TT(l,p,f,b){switch(XT(p)){case 2:var A=f6;break;case 8:A=m6;break;default:A=L2}f=A.bind(null,p,f,l),A=void 0,!Mt||p!=="touchstart"&&p!=="touchmove"&&p!=="wheel"||(A=!0),b?A!==void 0?l.addEventListener(p,f,{capture:!0,passive:A}):l.addEventListener(p,f,!0):A!==void 0?l.addEventListener(p,f,{passive:A}):l.addEventListener(p,f,!1)}function A2(l,p,f,b,A){var I=b;if((p&1)===0&&(p&2)===0&&b!==null)e:for(;;){if(b===null)return;var W=b.tag;if(W===3||W===4){var J=b.stateNode.containerInfo;if(J===A)break;if(W===4)for(W=b.return;W!==null;){var ce=W.tag;if((ce===3||ce===4)&&W.stateNode.containerInfo===A)return;W=W.return}for(;J!==null;){if(W=On(J),W===null)return;if(ce=W.tag,ce===5||ce===6||ce===26||ce===27){b=I=W;continue e}J=J.parentNode}}b=b.return}Ye(function(){var Ne=I,Ue=Us(f),Ge=[];e:{var Fe=_w.get(l);if(Fe!==void 0){var De=wl,Bt=l;switch(l){case"keypress":if(yl(f)===0)break e;case"keydown":case"keyup":De=ib;break;case"focusin":Bt="focus",De=ad;break;case"focusout":Bt="blur",De=ad;break;case"beforeblur":case"afterblur":De=ad;break;case"click":if(f.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":De=Ra;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":De=nd;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":De=MS;break;case db:case Cw:case pb:De=So;break;case Iw:De=LS;break;case"scroll":case"scrollend":De=$_;break;case"wheel":De=jh;break;case"copy":case"cut":case"paste":De=ko;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":De=bw;break;case"toggle":case"beforetoggle":De=VS}var Tt=(p&4)!==0,Qn=!Tt&&(l==="scroll"||l==="scrollend"),Ee=Tt?Fe!==null?Fe+"Capture":null:Fe;Tt=[];for(var Se=Ne,Te;Se!==null;){var Ve=Se;if(Te=Ve.stateNode,Ve=Ve.tag,Ve!==5&&Ve!==26&&Ve!==27||Te===null||Ee===null||(Ve=bt(Se,Ee),Ve!=null&&Tt.push(ny(Se,Ve,Te))),Qn)break;Se=Se.return}0<Tt.length&&(Fe=new De(Fe,Bt,null,f,Ue),Ge.push({event:Fe,listeners:Tt}))}}if((p&7)===0){e:{if(Fe=l==="mouseover"||l==="pointerover",De=l==="mouseout"||l==="pointerout",Fe&&f!==bl&&(Bt=f.relatedTarget||f.fromElement)&&(On(Bt)||Bt[It]))break e;if((De||Fe)&&(Fe=Ue.window===Ue?Ue:(Fe=Ue.ownerDocument)?Fe.defaultView||Fe.parentWindow:window,De?(Bt=f.relatedTarget||f.toElement,De=Ne,Bt=Bt?On(Bt):null,Bt!==null&&(Qn=i(Bt),Tt=Bt.tag,Bt!==Qn||Tt!==5&&Tt!==27&&Tt!==6)&&(Bt=null)):(De=null,Bt=Ne),De!==Bt)){if(Tt=Ra,Ve="onMouseLeave",Ee="onMouseEnter",Se="mouse",(l==="pointerout"||l==="pointerover")&&(Tt=bw,Ve="onPointerLeave",Ee="onPointerEnter",Se="pointer"),Qn=De==null?Fe:zi(De),Te=Bt==null?Fe:zi(Bt),Fe=new Tt(Ve,Se+"leave",De,f,Ue),Fe.target=Qn,Fe.relatedTarget=Te,Ve=null,On(Ue)===Ne&&(Tt=new Tt(Ee,Se+"enter",Bt,f,Ue),Tt.target=Te,Tt.relatedTarget=Qn,Ve=Tt),Qn=Ve,De&&Bt)t:{for(Tt=De,Ee=Bt,Se=0,Te=Tt;Te;Te=Qf(Te))Se++;for(Te=0,Ve=Ee;Ve;Ve=Qf(Ve))Te++;for(;0<Se-Te;)Tt=Qf(Tt),Se--;for(;0<Te-Se;)Ee=Qf(Ee),Te--;for(;Se--;){if(Tt===Ee||Ee!==null&&Tt===Ee.alternate)break t;Tt=Qf(Tt),Ee=Qf(Ee)}Tt=null}else Tt=null;De!==null&&NT(Ge,Fe,De,Tt,!1),Bt!==null&&Qn!==null&&NT(Ge,Qn,Bt,Tt,!0)}}e:{if(Fe=Ne?zi(Ne):window,De=Fe.nodeName&&Fe.nodeName.toLowerCase(),De==="select"||De==="input"&&Fe.type==="file")var dt=ku;else if(Zh(Fe))if(fr)dt=J_;else{dt=Co;var pn=Aw}else De=Fe.nodeName,!De||De.toLowerCase()!=="input"||Fe.type!=="checkbox"&&Fe.type!=="radio"?Ne&&ml(Ne.elementType)&&(dt=ku):dt=PS;if(dt&&(dt=dt(l,Ne))){Xh(Ge,dt,f,Ue);break e}pn&&pn(l,Fe,Ne),l==="focusout"&&Ne&&Fe.type==="number"&&Ne.memoizedProps.value!=null&&fl(Fe,"number",Fe.value)}switch(pn=Ne?zi(Ne):window,l){case"focusin":(Zh(pn)||pn.contentEditable==="true")&&(To=pn,No=Ne,rd=null);break;case"focusout":rd=No=To=null;break;case"mousedown":ub=!0;break;case"contextmenu":case"mouseup":case"dragend":ub=!1,Vi(Ge,f,Ue);break;case"selectionchange":if(Ew)break;case"keydown":case"keyup":Vi(Ge,f,Ue)}var St;if(yw)e:{switch(l){case"compositionstart":var Dt="onCompositionStart";break e;case"compositionend":Dt="onCompositionEnd";break e;case"compositionupdate":Dt="onCompositionUpdate";break e}Dt=void 0}else ni?Sw(l,f)&&(Dt="onCompositionEnd"):l==="keydown"&&f.keyCode===229&&(Dt="onCompositionStart");Dt&&(ww&&f.locale!=="ko"&&(ni||Dt!=="onCompositionStart"?Dt==="onCompositionEnd"&&ni&&(St=gi()):(st=Ue,Rn="value"in st?st.value:st.textContent,ni=!0)),pn=_x(Ne,Dt),0<pn.length&&(Dt=new fw(Dt,l,null,f,Ue),Ge.push({event:Dt,listeners:pn}),St?Dt.data=St:(St=dn(f),St!==null&&(Dt.data=St)))),(St=sb?ms(l,f):qS(l,f))&&(Dt=_x(Ne,"onBeforeInput"),0<Dt.length&&(pn=new fw("onBeforeInput","beforeinput",null,f,Ue),Ge.push({event:pn,listeners:Dt}),pn.data=St)),zV(Ge,l,Ne,f,Ue)}_T(Ge,p)})}function ny(l,p,f){return{instance:l,listener:p,currentTarget:f}}function _x(l,p){for(var f=p+"Capture",b=[];l!==null;){var A=l,I=A.stateNode;if(A=A.tag,A!==5&&A!==26&&A!==27||I===null||(A=bt(l,f),A!=null&&b.unshift(ny(l,A,I)),A=bt(l,p),A!=null&&b.push(ny(l,A,I))),l.tag===3)return b;l=l.return}return[]}function Qf(l){if(l===null)return null;do l=l.return;while(l&&l.tag!==5&&l.tag!==27);return l||null}function NT(l,p,f,b,A){for(var I=p._reactName,W=[];f!==null&&f!==b;){var J=f,ce=J.alternate,Ne=J.stateNode;if(J=J.tag,ce!==null&&ce===b)break;J!==5&&J!==26&&J!==27||Ne===null||(ce=Ne,A?(Ne=bt(f,I),Ne!=null&&W.unshift(ny(f,Ne,ce))):A||(Ne=bt(f,I),Ne!=null&&W.push(ny(f,Ne,ce)))),f=f.return}W.length!==0&&l.push({event:p,listeners:W})}var qV=/\r\n?/g,PV=/\u0000|\uFFFD/g;function RT(l){return(typeof l=="string"?l:""+l).replace(qV,`
`).replace(PV,"")}function FT(l,p){return p=RT(p),RT(l)===p}function Tx(){}function jn(l,p,f,b,A,I){switch(f){case"children":typeof b=="string"?p==="body"||p==="textarea"&&b===""||fa(l,b):(typeof b=="number"||typeof b=="bigint")&&p!=="body"&&fa(l,""+b);break;case"className":mu(l,"class",b);break;case"tabIndex":mu(l,"tabindex",b);break;case"dir":case"role":case"viewBox":case"width":case"height":mu(l,f,b);break;case"style":Xc(l,b,I);break;case"data":if(p!=="object"){mu(l,"data",b);break}case"src":case"href":if(b===""&&(p!=="a"||f!=="href")){l.removeAttribute(f);break}if(b==null||typeof b=="function"||typeof b=="symbol"||typeof b=="boolean"){l.removeAttribute(f);break}b=fs(""+b),l.setAttribute(f,b);break;case"action":case"formAction":if(typeof b=="function"){l.setAttribute(f,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof I=="function"&&(f==="formAction"?(p!=="input"&&jn(l,p,"name",A.name,A,null),jn(l,p,"formEncType",A.formEncType,A,null),jn(l,p,"formMethod",A.formMethod,A,null),jn(l,p,"formTarget",A.formTarget,A,null)):(jn(l,p,"encType",A.encType,A,null),jn(l,p,"method",A.method,A,null),jn(l,p,"target",A.target,A,null)));if(b==null||typeof b=="symbol"||typeof b=="boolean"){l.removeAttribute(f);break}b=fs(""+b),l.setAttribute(f,b);break;case"onClick":b!=null&&(l.onclick=Tx);break;case"onScroll":b!=null&&mn("scroll",l);break;case"onScrollEnd":b!=null&&mn("scrollend",l);break;case"dangerouslySetInnerHTML":if(b!=null){if(typeof b!="object"||!("__html"in b))throw Error(a(61));if(f=b.__html,f!=null){if(A.children!=null)throw Error(a(60));l.innerHTML=f}}break;case"multiple":l.multiple=b&&typeof b!="function"&&typeof b!="symbol";break;case"muted":l.muted=b&&typeof b!="function"&&typeof b!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(b==null||typeof b=="function"||typeof b=="boolean"||typeof b=="symbol"){l.removeAttribute("xlink:href");break}f=fs(""+b),l.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",f);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":b!=null&&typeof b!="function"&&typeof b!="symbol"?l.setAttribute(f,""+b):l.removeAttribute(f);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":b&&typeof b!="function"&&typeof b!="symbol"?l.setAttribute(f,""):l.removeAttribute(f);break;case"capture":case"download":b===!0?l.setAttribute(f,""):b!==!1&&b!=null&&typeof b!="function"&&typeof b!="symbol"?l.setAttribute(f,b):l.removeAttribute(f);break;case"cols":case"rows":case"size":case"span":b!=null&&typeof b!="function"&&typeof b!="symbol"&&!isNaN(b)&&1<=b?l.setAttribute(f,b):l.removeAttribute(f);break;case"rowSpan":case"start":b==null||typeof b=="function"||typeof b=="symbol"||isNaN(b)?l.removeAttribute(f):l.setAttribute(f,b);break;case"popover":mn("beforetoggle",l),mn("toggle",l),ds(l,"popover",b);break;case"xlinkActuate":Zr(l,"http://www.w3.org/1999/xlink","xlink:actuate",b);break;case"xlinkArcrole":Zr(l,"http://www.w3.org/1999/xlink","xlink:arcrole",b);break;case"xlinkRole":Zr(l,"http://www.w3.org/1999/xlink","xlink:role",b);break;case"xlinkShow":Zr(l,"http://www.w3.org/1999/xlink","xlink:show",b);break;case"xlinkTitle":Zr(l,"http://www.w3.org/1999/xlink","xlink:title",b);break;case"xlinkType":Zr(l,"http://www.w3.org/1999/xlink","xlink:type",b);break;case"xmlBase":Zr(l,"http://www.w3.org/XML/1998/namespace","xml:base",b);break;case"xmlLang":Zr(l,"http://www.w3.org/XML/1998/namespace","xml:lang",b);break;case"xmlSpace":Zr(l,"http://www.w3.org/XML/1998/namespace","xml:space",b);break;case"is":ds(l,"is",b);break;case"innerText":case"textContent":break;default:(!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(f=gl.get(f)||f,ds(l,f,b))}}function E2(l,p,f,b,A,I){switch(f){case"style":Xc(l,b,I);break;case"dangerouslySetInnerHTML":if(b!=null){if(typeof b!="object"||!("__html"in b))throw Error(a(61));if(f=b.__html,f!=null){if(A.children!=null)throw Error(a(60));l.innerHTML=f}}break;case"children":typeof b=="string"?fa(l,b):(typeof b=="number"||typeof b=="bigint")&&fa(l,""+b);break;case"onScroll":b!=null&&mn("scroll",l);break;case"onScrollEnd":b!=null&&mn("scrollend",l);break;case"onClick":b!=null&&(l.onclick=Tx);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!pu.hasOwnProperty(f))e:{if(f[0]==="o"&&f[1]==="n"&&(A=f.endsWith("Capture"),p=f.slice(2,A?f.length-7:void 0),I=l[xt]||null,I=I!=null?I[f]:null,typeof I=="function"&&l.removeEventListener(p,I,A),typeof b=="function")){typeof I!="function"&&I!==null&&(f in l?l[f]=null:l.hasAttribute(f)&&l.removeAttribute(f)),l.addEventListener(p,b,A);break e}f in l?l[f]=b:b===!0?l.setAttribute(f,""):ds(l,f,b)}}}function Nr(l,p,f){switch(p){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":mn("error",l),mn("load",l);var b=!1,A=!1,I;for(I in f)if(f.hasOwnProperty(I)){var W=f[I];if(W!=null)switch(I){case"src":b=!0;break;case"srcSet":A=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(a(137,p));default:jn(l,p,I,W,f,null)}}A&&jn(l,p,"srcSet",f.srcSet,f,null),b&&jn(l,p,"src",f.src,f,null);return;case"input":mn("invalid",l);var J=I=W=A=null,ce=null,Ne=null;for(b in f)if(f.hasOwnProperty(b)){var Ue=f[b];if(Ue!=null)switch(b){case"name":A=Ue;break;case"type":W=Ue;break;case"checked":ce=Ue;break;case"defaultChecked":Ne=Ue;break;case"value":I=Ue;break;case"defaultValue":J=Ue;break;case"children":case"dangerouslySetInnerHTML":if(Ue!=null)throw Error(a(137,p));break;default:jn(l,p,b,Ue,f,null)}}Zc(l,I,J,ce,Ne,W,A,!1),hs(l);return;case"select":mn("invalid",l),b=W=I=null;for(A in f)if(f.hasOwnProperty(A)&&(J=f[A],J!=null))switch(A){case"value":I=J;break;case"defaultValue":W=J;break;case"multiple":b=J;default:jn(l,p,A,J,f,null)}p=I,f=W,l.multiple=!!b,p!=null?ei(l,!!b,p,!1):f!=null&&ei(l,!!b,f,!0);return;case"textarea":mn("invalid",l),I=A=b=null;for(W in f)if(f.hasOwnProperty(W)&&(J=f[W],J!=null))switch(W){case"value":b=J;break;case"defaultValue":A=J;break;case"children":I=J;break;case"dangerouslySetInnerHTML":if(J!=null)throw Error(a(91));break;default:jn(l,p,W,J,f,null)}zs(l,b,A,I),hs(l);return;case"option":for(ce in f)if(f.hasOwnProperty(ce)&&(b=f[ce],b!=null))switch(ce){case"selected":l.selected=b&&typeof b!="function"&&typeof b!="symbol";break;default:jn(l,p,ce,b,f,null)}return;case"dialog":mn("beforetoggle",l),mn("toggle",l),mn("cancel",l),mn("close",l);break;case"iframe":case"object":mn("load",l);break;case"video":case"audio":for(b=0;b<ty.length;b++)mn(ty[b],l);break;case"image":mn("error",l),mn("load",l);break;case"details":mn("toggle",l);break;case"embed":case"source":case"link":mn("error",l),mn("load",l);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(Ne in f)if(f.hasOwnProperty(Ne)&&(b=f[Ne],b!=null))switch(Ne){case"children":case"dangerouslySetInnerHTML":throw Error(a(137,p));default:jn(l,p,Ne,b,f,null)}return;default:if(ml(p)){for(Ue in f)f.hasOwnProperty(Ue)&&(b=f[Ue],b!==void 0&&E2(l,p,Ue,b,f,void 0));return}}for(J in f)f.hasOwnProperty(J)&&(b=f[J],b!=null&&jn(l,p,J,b,f,null))}function HV(l,p,f,b){switch(p){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var A=null,I=null,W=null,J=null,ce=null,Ne=null,Ue=null;for(De in f){var Ge=f[De];if(f.hasOwnProperty(De)&&Ge!=null)switch(De){case"checked":break;case"value":break;case"defaultValue":ce=Ge;default:b.hasOwnProperty(De)||jn(l,p,De,null,b,Ge)}}for(var Fe in b){var De=b[Fe];if(Ge=f[Fe],b.hasOwnProperty(Fe)&&(De!=null||Ge!=null))switch(Fe){case"type":I=De;break;case"name":A=De;break;case"checked":Ne=De;break;case"defaultChecked":Ue=De;break;case"value":W=De;break;case"defaultValue":J=De;break;case"children":case"dangerouslySetInnerHTML":if(De!=null)throw Error(a(137,p));break;default:De!==Ge&&jn(l,p,Fe,De,b,Ge)}}yu(l,W,J,ce,Ne,Ue,I,A);return;case"select":De=W=J=Fe=null;for(I in f)if(ce=f[I],f.hasOwnProperty(I)&&ce!=null)switch(I){case"value":break;case"multiple":De=ce;default:b.hasOwnProperty(I)||jn(l,p,I,null,b,ce)}for(A in b)if(I=b[A],ce=f[A],b.hasOwnProperty(A)&&(I!=null||ce!=null))switch(A){case"value":Fe=I;break;case"defaultValue":J=I;break;case"multiple":W=I;default:I!==ce&&jn(l,p,A,I,b,ce)}p=J,f=W,b=De,Fe!=null?ei(l,!!f,Fe,!1):!!b!=!!f&&(p!=null?ei(l,!!f,p,!0):ei(l,!!f,f?[]:"",!1));return;case"textarea":De=Fe=null;for(J in f)if(A=f[J],f.hasOwnProperty(J)&&A!=null&&!b.hasOwnProperty(J))switch(J){case"value":break;case"children":break;default:jn(l,p,J,null,b,A)}for(W in b)if(A=b[W],I=f[W],b.hasOwnProperty(W)&&(A!=null||I!=null))switch(W){case"value":Fe=A;break;case"defaultValue":De=A;break;case"children":break;case"dangerouslySetInnerHTML":if(A!=null)throw Error(a(91));break;default:A!==I&&jn(l,p,W,A,b,I)}wu(l,Fe,De);return;case"option":for(var Bt in f)if(Fe=f[Bt],f.hasOwnProperty(Bt)&&Fe!=null&&!b.hasOwnProperty(Bt))switch(Bt){case"selected":l.selected=!1;break;default:jn(l,p,Bt,null,b,Fe)}for(ce in b)if(Fe=b[ce],De=f[ce],b.hasOwnProperty(ce)&&Fe!==De&&(Fe!=null||De!=null))switch(ce){case"selected":l.selected=Fe&&typeof Fe!="function"&&typeof Fe!="symbol";break;default:jn(l,p,ce,Fe,b,De)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Tt in f)Fe=f[Tt],f.hasOwnProperty(Tt)&&Fe!=null&&!b.hasOwnProperty(Tt)&&jn(l,p,Tt,null,b,Fe);for(Ne in b)if(Fe=b[Ne],De=f[Ne],b.hasOwnProperty(Ne)&&Fe!==De&&(Fe!=null||De!=null))switch(Ne){case"children":case"dangerouslySetInnerHTML":if(Fe!=null)throw Error(a(137,p));break;default:jn(l,p,Ne,Fe,b,De)}return;default:if(ml(p)){for(var Qn in f)Fe=f[Qn],f.hasOwnProperty(Qn)&&Fe!==void 0&&!b.hasOwnProperty(Qn)&&E2(l,p,Qn,void 0,b,Fe);for(Ue in b)Fe=b[Ue],De=f[Ue],!b.hasOwnProperty(Ue)||Fe===De||Fe===void 0&&De===void 0||E2(l,p,Ue,Fe,b,De);return}}for(var Ee in f)Fe=f[Ee],f.hasOwnProperty(Ee)&&Fe!=null&&!b.hasOwnProperty(Ee)&&jn(l,p,Ee,null,b,Fe);for(Ge in b)Fe=b[Ge],De=f[Ge],!b.hasOwnProperty(Ge)||Fe===De||Fe==null&&De==null||jn(l,p,Ge,Fe,b,De)}var C2=null,I2=null;function Nx(l){return l.nodeType===9?l:l.ownerDocument}function DT(l){switch(l){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function OT(l,p){if(l===0)switch(p){case"svg":return 1;case"math":return 2;default:return 0}return l===1&&p==="foreignObject"?0:l}function _2(l,p){return l==="textarea"||l==="noscript"||typeof p.children=="string"||typeof p.children=="number"||typeof p.children=="bigint"||typeof p.dangerouslySetInnerHTML=="object"&&p.dangerouslySetInnerHTML!==null&&p.dangerouslySetInnerHTML.__html!=null}var T2=null;function GV(){var l=window.event;return l&&l.type==="popstate"?l===T2?!1:(T2=l,!0):(T2=null,!1)}var MT=typeof setTimeout=="function"?setTimeout:void 0,KV=typeof clearTimeout=="function"?clearTimeout:void 0,BT=typeof Promise=="function"?Promise:void 0,$V=typeof queueMicrotask=="function"?queueMicrotask:typeof BT<"u"?function(l){return BT.resolve(null).then(l).catch(JV)}:MT;function JV(l){setTimeout(function(){throw l})}function Qu(l){return l==="head"}function LT(l,p){var f=p,b=0,A=0;do{var I=f.nextSibling;if(l.removeChild(f),I&&I.nodeType===8)if(f=I.data,f==="/$"){if(0<b&&8>b){f=b;var W=l.ownerDocument;if(f&1&&ay(W.documentElement),f&2&&ay(W.body),f&4)for(f=W.head,ay(f),W=f.firstChild;W;){var J=W.nextSibling,ce=W.nodeName;W[mi]||ce==="SCRIPT"||ce==="STYLE"||ce==="LINK"&&W.rel.toLowerCase()==="stylesheet"||f.removeChild(W),W=J}}if(A===0){l.removeChild(I),dy(p);return}A--}else f==="$"||f==="$?"||f==="$!"?A++:b=f.charCodeAt(0)-48;else b=0;f=I}while(f);dy(p)}function N2(l){var p=l.firstChild;for(p&&p.nodeType===10&&(p=p.nextSibling);p;){var f=p;switch(p=p.nextSibling,f.nodeName){case"HTML":case"HEAD":case"BODY":N2(f),bo(f);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(f.rel.toLowerCase()==="stylesheet")continue}l.removeChild(f)}}function YV(l,p,f,b){for(;l.nodeType===1;){var A=f;if(l.nodeName.toLowerCase()!==p.toLowerCase()){if(!b&&(l.nodeName!=="INPUT"||l.type!=="hidden"))break}else if(b){if(!l[mi])switch(p){case"meta":if(!l.hasAttribute("itemprop"))break;return l;case"link":if(I=l.getAttribute("rel"),I==="stylesheet"&&l.hasAttribute("data-precedence"))break;if(I!==A.rel||l.getAttribute("href")!==(A.href==null||A.href===""?null:A.href)||l.getAttribute("crossorigin")!==(A.crossOrigin==null?null:A.crossOrigin)||l.getAttribute("title")!==(A.title==null?null:A.title))break;return l;case"style":if(l.hasAttribute("data-precedence"))break;return l;case"script":if(I=l.getAttribute("src"),(I!==(A.src==null?null:A.src)||l.getAttribute("type")!==(A.type==null?null:A.type)||l.getAttribute("crossorigin")!==(A.crossOrigin==null?null:A.crossOrigin))&&I&&l.hasAttribute("async")&&!l.hasAttribute("itemprop"))break;return l;default:return l}}else if(p==="input"&&l.type==="hidden"){var I=A.name==null?null:""+A.name;if(A.type==="hidden"&&l.getAttribute("name")===I)return l}else return l;if(l=Zs(l.nextSibling),l===null)break}return null}function jV(l,p,f){if(p==="")return null;for(;l.nodeType!==3;)if((l.nodeType!==1||l.nodeName!=="INPUT"||l.type!=="hidden")&&!f||(l=Zs(l.nextSibling),l===null))return null;return l}function R2(l){return l.data==="$!"||l.data==="$?"&&l.ownerDocument.readyState==="complete"}function QV(l,p){var f=l.ownerDocument;if(l.data!=="$?"||f.readyState==="complete")p();else{var b=function(){p(),f.removeEventListener("DOMContentLoaded",b)};f.addEventListener("DOMContentLoaded",b),l._reactRetry=b}}function Zs(l){for(;l!=null;l=l.nextSibling){var p=l.nodeType;if(p===1||p===3)break;if(p===8){if(p=l.data,p==="$"||p==="$!"||p==="$?"||p==="F!"||p==="F")break;if(p==="/$")return null}}return l}var F2=null;function zT(l){l=l.previousSibling;for(var p=0;l;){if(l.nodeType===8){var f=l.data;if(f==="$"||f==="$!"||f==="$?"){if(p===0)return l;p--}else f==="/$"&&p++}l=l.previousSibling}return null}function UT(l,p,f){switch(p=Nx(f),l){case"html":if(l=p.documentElement,!l)throw Error(a(452));return l;case"head":if(l=p.head,!l)throw Error(a(453));return l;case"body":if(l=p.body,!l)throw Error(a(454));return l;default:throw Error(a(451))}}function ay(l){for(var p=l.attributes;p.length;)l.removeAttributeNode(p[0]);bo(l)}var Es=new Map,VT=new Set;function Rx(l){return typeof l.getRootNode=="function"?l.getRootNode():l.nodeType===9?l:l.ownerDocument}var Kl=se.d;se.d={f:ZV,r:XV,D:e6,C:t6,L:n6,m:a6,X:i6,S:r6,M:s6};function ZV(){var l=Kl.f(),p=Sx();return l||p}function XV(l){var p=Sr(l);p!==null&&p.tag===5&&p.type==="form"?Nf(p):Kl.r(l)}var Zf=typeof document>"u"?null:document;function WT(l,p,f){var b=Zf;if(b&&typeof p=="string"&&p){var A=hr(p);A='link[rel="'+l+'"][href="'+A+'"]',typeof f=="string"&&(A+='[crossorigin="'+f+'"]'),VT.has(A)||(VT.add(A),l={rel:l,crossOrigin:f,href:p},b.querySelector(A)===null&&(p=b.createElement("link"),Nr(p,"link",l),ha(p),b.head.appendChild(p)))}}function e6(l){Kl.D(l),WT("dns-prefetch",l,null)}function t6(l,p){Kl.C(l,p),WT("preconnect",l,p)}function n6(l,p,f){Kl.L(l,p,f);var b=Zf;if(b&&l&&p){var A='link[rel="preload"][as="'+hr(p)+'"]';p==="image"&&f&&f.imageSrcSet?(A+='[imagesrcset="'+hr(f.imageSrcSet)+'"]',typeof f.imageSizes=="string"&&(A+='[imagesizes="'+hr(f.imageSizes)+'"]')):A+='[href="'+hr(l)+'"]';var I=A;switch(p){case"style":I=Xf(l);break;case"script":I=em(l)}Es.has(I)||(l=c({rel:"preload",href:p==="image"&&f&&f.imageSrcSet?void 0:l,as:p},f),Es.set(I,l),b.querySelector(A)!==null||p==="style"&&b.querySelector(ry(I))||p==="script"&&b.querySelector(iy(I))||(p=b.createElement("link"),Nr(p,"link",l),ha(p),b.head.appendChild(p)))}}function a6(l,p){Kl.m(l,p);var f=Zf;if(f&&l){var b=p&&typeof p.as=="string"?p.as:"script",A='link[rel="modulepreload"][as="'+hr(b)+'"][href="'+hr(l)+'"]',I=A;switch(b){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":I=em(l)}if(!Es.has(I)&&(l=c({rel:"modulepreload",href:l},p),Es.set(I,l),f.querySelector(A)===null)){switch(b){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(f.querySelector(iy(I)))return}b=f.createElement("link"),Nr(b,"link",l),ha(b),f.head.appendChild(b)}}}function r6(l,p,f){Kl.S(l,p,f);var b=Zf;if(b&&l){var A=yo(b).hoistableStyles,I=Xf(l);p=p||"default";var W=A.get(I);if(!W){var J={loading:0,preload:null};if(W=b.querySelector(ry(I)))J.loading=5;else{l=c({rel:"stylesheet",href:l,"data-precedence":p},f),(f=Es.get(I))&&D2(l,f);var ce=W=b.createElement("link");ha(ce),Nr(ce,"link",l),ce._p=new Promise(function(Ne,Ue){ce.onload=Ne,ce.onerror=Ue}),ce.addEventListener("load",function(){J.loading|=1}),ce.addEventListener("error",function(){J.loading|=2}),J.loading|=4,Fx(W,p,b)}W={type:"stylesheet",instance:W,count:1,state:J},A.set(I,W)}}}function i6(l,p){Kl.X(l,p);var f=Zf;if(f&&l){var b=yo(f).hoistableScripts,A=em(l),I=b.get(A);I||(I=f.querySelector(iy(A)),I||(l=c({src:l,async:!0},p),(p=Es.get(A))&&O2(l,p),I=f.createElement("script"),ha(I),Nr(I,"link",l),f.head.appendChild(I)),I={type:"script",instance:I,count:1,state:null},b.set(A,I))}}function s6(l,p){Kl.M(l,p);var f=Zf;if(f&&l){var b=yo(f).hoistableScripts,A=em(l),I=b.get(A);I||(I=f.querySelector(iy(A)),I||(l=c({src:l,async:!0,type:"module"},p),(p=Es.get(A))&&O2(l,p),I=f.createElement("script"),ha(I),Nr(I,"link",l),f.head.appendChild(I)),I={type:"script",instance:I,count:1,state:null},b.set(A,I))}}function qT(l,p,f,b){var A=(A=qe.current)?Rx(A):null;if(!A)throw Error(a(446));switch(l){case"meta":case"title":return null;case"style":return typeof f.precedence=="string"&&typeof f.href=="string"?(p=Xf(f.href),f=yo(A).hoistableStyles,b=f.get(p),b||(b={type:"style",instance:null,count:0,state:null},f.set(p,b)),b):{type:"void",instance:null,count:0,state:null};case"link":if(f.rel==="stylesheet"&&typeof f.href=="string"&&typeof f.precedence=="string"){l=Xf(f.href);var I=yo(A).hoistableStyles,W=I.get(l);if(W||(A=A.ownerDocument||A,W={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},I.set(l,W),(I=A.querySelector(ry(l)))&&!I._p&&(W.instance=I,W.state.loading=5),Es.has(l)||(f={rel:"preload",as:"style",href:f.href,crossOrigin:f.crossOrigin,integrity:f.integrity,media:f.media,hrefLang:f.hrefLang,referrerPolicy:f.referrerPolicy},Es.set(l,f),I||o6(A,l,f,W.state))),p&&b===null)throw Error(a(528,""));return W}if(p&&b!==null)throw Error(a(529,""));return null;case"script":return p=f.async,f=f.src,typeof f=="string"&&p&&typeof p!="function"&&typeof p!="symbol"?(p=em(f),f=yo(A).hoistableScripts,b=f.get(p),b||(b={type:"script",instance:null,count:0,state:null},f.set(p,b)),b):{type:"void",instance:null,count:0,state:null};default:throw Error(a(444,l))}}function Xf(l){return'href="'+hr(l)+'"'}function ry(l){return'link[rel="stylesheet"]['+l+"]"}function PT(l){return c({},l,{"data-precedence":l.precedence,precedence:null})}function o6(l,p,f,b){l.querySelector('link[rel="preload"][as="style"]['+p+"]")?b.loading=1:(p=l.createElement("link"),b.preload=p,p.addEventListener("load",function(){return b.loading|=1}),p.addEventListener("error",function(){return b.loading|=2}),Nr(p,"link",f),ha(p),l.head.appendChild(p))}function em(l){return'[src="'+hr(l)+'"]'}function iy(l){return"script[async]"+l}function HT(l,p,f){if(p.count++,p.instance===null)switch(p.type){case"style":var b=l.querySelector('style[data-href~="'+hr(f.href)+'"]');if(b)return p.instance=b,ha(b),b;var A=c({},f,{"data-href":f.href,"data-precedence":f.precedence,href:null,precedence:null});return b=(l.ownerDocument||l).createElement("style"),ha(b),Nr(b,"style",A),Fx(b,f.precedence,l),p.instance=b;case"stylesheet":A=Xf(f.href);var I=l.querySelector(ry(A));if(I)return p.state.loading|=4,p.instance=I,ha(I),I;b=PT(f),(A=Es.get(A))&&D2(b,A),I=(l.ownerDocument||l).createElement("link"),ha(I);var W=I;return W._p=new Promise(function(J,ce){W.onload=J,W.onerror=ce}),Nr(I,"link",b),p.state.loading|=4,Fx(I,f.precedence,l),p.instance=I;case"script":return I=em(f.src),(A=l.querySelector(iy(I)))?(p.instance=A,ha(A),A):(b=f,(A=Es.get(I))&&(b=c({},f),O2(b,A)),l=l.ownerDocument||l,A=l.createElement("script"),ha(A),Nr(A,"link",b),l.head.appendChild(A),p.instance=A);case"void":return null;default:throw Error(a(443,p.type))}else p.type==="stylesheet"&&(p.state.loading&4)===0&&(b=p.instance,p.state.loading|=4,Fx(b,f.precedence,l));return p.instance}function Fx(l,p,f){for(var b=f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),A=b.length?b[b.length-1]:null,I=A,W=0;W<b.length;W++){var J=b[W];if(J.dataset.precedence===p)I=J;else if(I!==A)break}I?I.parentNode.insertBefore(l,I.nextSibling):(p=f.nodeType===9?f.head:f,p.insertBefore(l,p.firstChild))}function D2(l,p){l.crossOrigin==null&&(l.crossOrigin=p.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=p.referrerPolicy),l.title==null&&(l.title=p.title)}function O2(l,p){l.crossOrigin==null&&(l.crossOrigin=p.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=p.referrerPolicy),l.integrity==null&&(l.integrity=p.integrity)}var Dx=null;function GT(l,p,f){if(Dx===null){var b=new Map,A=Dx=new Map;A.set(f,b)}else A=Dx,b=A.get(f),b||(b=new Map,A.set(f,b));if(b.has(l))return b;for(b.set(l,null),f=f.getElementsByTagName(l),A=0;A<f.length;A++){var I=f[A];if(!(I[mi]||I[Gt]||l==="link"&&I.getAttribute("rel")==="stylesheet")&&I.namespaceURI!=="http://www.w3.org/2000/svg"){var W=I.getAttribute(p)||"";W=l+W;var J=b.get(W);J?J.push(I):b.set(W,[I])}}return b}function KT(l,p,f){l=l.ownerDocument||l,l.head.insertBefore(f,p==="title"?l.querySelector("head > title"):null)}function l6(l,p,f){if(f===1||p.itemProp!=null)return!1;switch(l){case"meta":case"title":return!0;case"style":if(typeof p.precedence!="string"||typeof p.href!="string"||p.href==="")break;return!0;case"link":if(typeof p.rel!="string"||typeof p.href!="string"||p.href===""||p.onLoad||p.onError)break;switch(p.rel){case"stylesheet":return l=p.disabled,typeof p.precedence=="string"&&l==null;default:return!0}case"script":if(p.async&&typeof p.async!="function"&&typeof p.async!="symbol"&&!p.onLoad&&!p.onError&&p.src&&typeof p.src=="string")return!0}return!1}function $T(l){return!(l.type==="stylesheet"&&(l.state.loading&3)===0)}var sy=null;function u6(){}function c6(l,p,f){if(sy===null)throw Error(a(475));var b=sy;if(p.type==="stylesheet"&&(typeof f.media!="string"||matchMedia(f.media).matches!==!1)&&(p.state.loading&4)===0){if(p.instance===null){var A=Xf(f.href),I=l.querySelector(ry(A));if(I){l=I._p,l!==null&&typeof l=="object"&&typeof l.then=="function"&&(b.count++,b=Ox.bind(b),l.then(b,b)),p.state.loading|=4,p.instance=I,ha(I);return}I=l.ownerDocument||l,f=PT(f),(A=Es.get(A))&&D2(f,A),I=I.createElement("link"),ha(I);var W=I;W._p=new Promise(function(J,ce){W.onload=J,W.onerror=ce}),Nr(I,"link",f),p.instance=I}b.stylesheets===null&&(b.stylesheets=new Map),b.stylesheets.set(p,l),(l=p.state.preload)&&(p.state.loading&3)===0&&(b.count++,p=Ox.bind(b),l.addEventListener("load",p),l.addEventListener("error",p))}}function d6(){if(sy===null)throw Error(a(475));var l=sy;return l.stylesheets&&l.count===0&&M2(l,l.stylesheets),0<l.count?function(p){var f=setTimeout(function(){if(l.stylesheets&&M2(l,l.stylesheets),l.unsuspend){var b=l.unsuspend;l.unsuspend=null,b()}},6e4);return l.unsuspend=p,function(){l.unsuspend=null,clearTimeout(f)}}:null}function Ox(){if(this.count--,this.count===0){if(this.stylesheets)M2(this,this.stylesheets);else if(this.unsuspend){var l=this.unsuspend;this.unsuspend=null,l()}}}var Mx=null;function M2(l,p){l.stylesheets=null,l.unsuspend!==null&&(l.count++,Mx=new Map,p.forEach(p6,l),Mx=null,Ox.call(l))}function p6(l,p){if(!(p.state.loading&4)){var f=Mx.get(l);if(f)var b=f.get(null);else{f=new Map,Mx.set(l,f);for(var A=l.querySelectorAll("link[data-precedence],style[data-precedence]"),I=0;I<A.length;I++){var W=A[I];(W.nodeName==="LINK"||W.getAttribute("media")!=="not all")&&(f.set(W.dataset.precedence,W),b=W)}b&&f.set(null,b)}A=p.instance,W=A.getAttribute("data-precedence"),I=f.get(W)||b,I===b&&f.set(null,A),f.set(W,A),this.count++,b=Ox.bind(this),A.addEventListener("load",b),A.addEventListener("error",b),I?I.parentNode.insertBefore(A,I.nextSibling):(l=l.nodeType===9?l.head:l,l.insertBefore(A,l.firstChild)),p.state.loading|=4}}var oy={$$typeof:T,Provider:null,Consumer:null,_currentValue:de,_currentValue2:de,_threadCount:0};function h6(l,p,f,b,A,I,W,J){this.tag=1,this.containerInfo=l,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=ls(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=ls(0),this.hiddenUpdates=ls(null),this.identifierPrefix=b,this.onUncaughtError=A,this.onCaughtError=I,this.onRecoverableError=W,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=J,this.incompleteTransitions=new Map}function JT(l,p,f,b,A,I,W,J,ce,Ne,Ue,Ge){return l=new h6(l,p,f,W,J,ce,Ne,Ge),p=1,I===!0&&(p|=24),I=ai(3,null,null,p),l.current=I,I.stateNode=l,p=cf(),p.refCount++,l.pooledCache=p,p.refCount++,I.memoizedState={element:b,isDehydrated:f,cache:p},mf(I),l}function YT(l){return l?(l=Cl,l):Cl}function jT(l,p,f,b,A,I){A=YT(A),b.context===null?b.context=A:b.pendingContext=A,b=Js(p),b.payload={element:f},I=I===void 0?null:I,I!==null&&(b.callback=I),f=Ys(l,b,p),f!==null&&(Qi(f,l,p),Lu(f,l,p))}function QT(l,p){if(l=l.memoizedState,l!==null&&l.dehydrated!==null){var f=l.retryLane;l.retryLane=f!==0&&f<p?f:p}}function B2(l,p){QT(l,p),(l=l.alternate)&&QT(l,p)}function ZT(l){if(l.tag===13){var p=_u(l,67108864);p!==null&&Qi(p,l,67108864),B2(l,67108864)}}var Bx=!0;function f6(l,p,f,b){var A=Z.T;Z.T=null;var I=se.p;try{se.p=2,L2(l,p,f,b)}finally{se.p=I,Z.T=A}}function m6(l,p,f,b){var A=Z.T;Z.T=null;var I=se.p;try{se.p=8,L2(l,p,f,b)}finally{se.p=I,Z.T=A}}function L2(l,p,f,b){if(Bx){var A=z2(b);if(A===null)A2(l,p,b,Lx,f),eN(l,b);else if(b6(A,l,p,f,b))b.stopPropagation();else if(eN(l,b),p&4&&-1<g6.indexOf(l)){for(;A!==null;){var I=Sr(A);if(I!==null)switch(I.tag){case 3:if(I=I.stateNode,I.current.memoizedState.isDehydrated){var W=ot(I.pendingLanes);if(W!==0){var J=I;for(J.pendingLanes|=2,J.entangledLanes|=2;W;){var ce=1<<31-F(W);J.entanglements[1]|=ce,W&=~ce}Ho(I),(Wn&6)===0&&(xx=ft()+500,ey(0))}}break;case 13:J=_u(I,2),J!==null&&Qi(J,I,2),Sx(),B2(I,2)}if(I=z2(b),I===null&&A2(l,p,b,Lx,f),I===A)break;A=I}A!==null&&b.stopPropagation()}else A2(l,p,b,null,f)}}function z2(l){return l=Us(l),U2(l)}var Lx=null;function U2(l){if(Lx=null,l=On(l),l!==null){var p=i(l);if(p===null)l=null;else{var f=p.tag;if(f===13){if(l=s(p),l!==null)return l;l=null}else if(f===3){if(p.stateNode.current.memoizedState.isDehydrated)return p.tag===3?p.stateNode.containerInfo:null;l=null}else p!==l&&(l=null)}}return Lx=l,null}function XT(l){switch(l){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(wt()){case oa:return 2;case en:return 8;case Ht:case Jn:return 32;case kn:return 268435456;default:return 32}default:return 32}}var V2=!1,Zu=null,Xu=null,ec=null,ly=new Map,uy=new Map,tc=[],g6="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function eN(l,p){switch(l){case"focusin":case"focusout":Zu=null;break;case"dragenter":case"dragleave":Xu=null;break;case"mouseover":case"mouseout":ec=null;break;case"pointerover":case"pointerout":ly.delete(p.pointerId);break;case"gotpointercapture":case"lostpointercapture":uy.delete(p.pointerId)}}function cy(l,p,f,b,A,I){return l===null||l.nativeEvent!==I?(l={blockedOn:p,domEventName:f,eventSystemFlags:b,nativeEvent:I,targetContainers:[A]},p!==null&&(p=Sr(p),p!==null&&ZT(p)),l):(l.eventSystemFlags|=b,p=l.targetContainers,A!==null&&p.indexOf(A)===-1&&p.push(A),l)}function b6(l,p,f,b,A){switch(p){case"focusin":return Zu=cy(Zu,l,p,f,b,A),!0;case"dragenter":return Xu=cy(Xu,l,p,f,b,A),!0;case"mouseover":return ec=cy(ec,l,p,f,b,A),!0;case"pointerover":var I=A.pointerId;return ly.set(I,cy(ly.get(I)||null,l,p,f,b,A)),!0;case"gotpointercapture":return I=A.pointerId,uy.set(I,cy(uy.get(I)||null,l,p,f,b,A)),!0}return!1}function tN(l){var p=On(l.target);if(p!==null){var f=i(p);if(f!==null){if(p=f.tag,p===13){if(p=s(f),p!==null){l.blockedOn=p,Ze(l.priority,function(){if(f.tag===13){var b=ji();b=Me(b);var A=_u(f,b);A!==null&&Qi(A,f,b),B2(f,b)}});return}}else if(p===3&&f.stateNode.current.memoizedState.isDehydrated){l.blockedOn=f.tag===3?f.stateNode.containerInfo:null;return}}}l.blockedOn=null}function zx(l){if(l.blockedOn!==null)return!1;for(var p=l.targetContainers;0<p.length;){var f=z2(l.nativeEvent);if(f===null){f=l.nativeEvent;var b=new f.constructor(f.type,f);bl=b,f.target.dispatchEvent(b),bl=null}else return p=Sr(f),p!==null&&ZT(p),l.blockedOn=f,!1;p.shift()}return!0}function nN(l,p,f){zx(l)&&f.delete(p)}function y6(){V2=!1,Zu!==null&&zx(Zu)&&(Zu=null),Xu!==null&&zx(Xu)&&(Xu=null),ec!==null&&zx(ec)&&(ec=null),ly.forEach(nN),uy.forEach(nN)}function Ux(l,p){l.blockedOn===p&&(l.blockedOn=null,V2||(V2=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,y6)))}var Vx=null;function aN(l){Vx!==l&&(Vx=l,e.unstable_scheduleCallback(e.unstable_NormalPriority,function(){Vx===l&&(Vx=null);for(var p=0;p<l.length;p+=3){var f=l[p],b=l[p+1],A=l[p+2];if(typeof b!="function"){if(U2(b||f)===null)continue;break}var I=Sr(f);I!==null&&(l.splice(p,3),p-=3,wd(I,{pending:!0,data:A,method:f.method,action:b},b,A))}}))}function dy(l){function p(ce){return Ux(ce,l)}Zu!==null&&Ux(Zu,l),Xu!==null&&Ux(Xu,l),ec!==null&&Ux(ec,l),ly.forEach(p),uy.forEach(p);for(var f=0;f<tc.length;f++){var b=tc[f];b.blockedOn===l&&(b.blockedOn=null)}for(;0<tc.length&&(f=tc[0],f.blockedOn===null);)tN(f),f.blockedOn===null&&tc.shift();if(f=(l.ownerDocument||l).$$reactFormReplay,f!=null)for(b=0;b<f.length;b+=3){var A=f[b],I=f[b+1],W=A[xt]||null;if(typeof I=="function")W||aN(f);else if(W){var J=null;if(I&&I.hasAttribute("formAction")){if(A=I,W=I[xt]||null)J=W.formAction;else if(U2(A)!==null)continue}else J=W.action;typeof J=="function"?f[b+1]=J:(f.splice(b,3),b-=3),aN(f)}}}function W2(l){this._internalRoot=l}Wx.prototype.render=W2.prototype.render=function(l){var p=this._internalRoot;if(p===null)throw Error(a(409));var f=p.current,b=ji();jT(f,b,l,p,null,null)},Wx.prototype.unmount=W2.prototype.unmount=function(){var l=this._internalRoot;if(l!==null){this._internalRoot=null;var p=l.containerInfo;jT(l.current,2,null,l,null,null),Sx(),p[It]=null}};function Wx(l){this._internalRoot=l}Wx.prototype.unstable_scheduleHydration=function(l){if(l){var p=mt();l={blockedOn:null,target:l,priority:p};for(var f=0;f<tc.length&&p!==0&&p<tc[f].priority;f++);tc.splice(f,0,l),f===0&&tN(l)}};var rN=t.version;if(rN!=="19.1.0")throw Error(a(527,rN,"19.1.0"));se.findDOMNode=function(l){var p=l._reactInternals;if(p===void 0)throw typeof l.render=="function"?Error(a(188)):(l=Object.keys(l).join(","),Error(a(268,l)));return l=u(p),l=l!==null?d(l):null,l=l===null?null:l.stateNode,l};var w6={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:Z,reconcilerVersion:"19.1.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var qx=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!qx.isDisabled&&qx.supportsFiber)try{An=qx.inject(w6),tn=qx}catch{}}return hy.createRoot=function(l,p){if(!r(l))throw Error(a(299));var f=!1,b="",A=dx,I=px,W=hx,J=null;return p!=null&&(p.unstable_strictMode===!0&&(f=!0),p.identifierPrefix!==void 0&&(b=p.identifierPrefix),p.onUncaughtError!==void 0&&(A=p.onUncaughtError),p.onCaughtError!==void 0&&(I=p.onCaughtError),p.onRecoverableError!==void 0&&(W=p.onRecoverableError),p.unstable_transitionCallbacks!==void 0&&(J=p.unstable_transitionCallbacks)),p=JT(l,1,!1,null,null,f,b,A,I,W,J,null),l[It]=p.current,k2(l),new W2(p)},hy.hydrateRoot=function(l,p,f){if(!r(l))throw Error(a(299));var b=!1,A="",I=dx,W=px,J=hx,ce=null,Ne=null;return f!=null&&(f.unstable_strictMode===!0&&(b=!0),f.identifierPrefix!==void 0&&(A=f.identifierPrefix),f.onUncaughtError!==void 0&&(I=f.onUncaughtError),f.onCaughtError!==void 0&&(W=f.onCaughtError),f.onRecoverableError!==void 0&&(J=f.onRecoverableError),f.unstable_transitionCallbacks!==void 0&&(ce=f.unstable_transitionCallbacks),f.formState!==void 0&&(Ne=f.formState)),p=JT(l,1,!0,p,f??null,b,A,I,W,J,ce,Ne),p.context=YT(null),f=p.current,b=ji(),b=Me(b),A=Js(b),A.callback=null,Ys(f,A,b),f=b,p.current.lanes=f,us(p,f),Ho(p),l[It]=p.current,k2(l),new Wx(p)},hy.version="19.1.0",hy}var mN;function R6(){if(mN)return H2.exports;mN=1;function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}return e(),H2.exports=N6(),H2.exports}var F6=R6(),D6=Object.defineProperty,O6=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),IA=(e,t)=>{for(var n in t)D6(e,n,{get:t[n],enumerable:!0})},M6={};IA(M6,{Abs:()=>Dm,Acos:()=>bp,Acosh:()=>yp,AdadeltaOptimizer:()=>$E,AdagradOptimizer:()=>JE,AdamOptimizer:()=>YE,AdamaxOptimizer:()=>jE,Add:()=>Mc,AddN:()=>wp,All:()=>Om,Any:()=>Mm,ArgMax:()=>Bm,ArgMin:()=>Lm,Asin:()=>xp,Asinh:()=>vp,Atan:()=>Sp,Atan2:()=>Ap,Atanh:()=>kp,AvgPool:()=>Ep,AvgPool3D:()=>zm,AvgPool3DGrad:()=>p0,AvgPoolGrad:()=>d0,BackendWasm:()=>xU,BatchMatMul:()=>Cp,BatchToSpaceND:()=>Um,Bincount:()=>Vm,BitwiseAnd:()=>Wm,BroadcastArgs:()=>h0,BroadcastTo:()=>C3,Callback:()=>wM,CallbackList:()=>pO,Cast:()=>Ip,Ceil:()=>_p,ClipByValue:()=>Bc,Complex:()=>av,ComplexAbs:()=>f0,Concat:()=>qm,Conv2D:()=>Tp,Conv2DBackpropFilter:()=>rv,Conv2DBackpropInput:()=>Np,Conv3D:()=>Rp,Conv3DBackpropFilterV2:()=>Pm,Conv3DBackpropInputV2:()=>Hm,Cos:()=>Fp,Cosh:()=>Dp,CropAndResize:()=>Km,Cumprod:()=>Gm,Cumsum:()=>Op,CustomCallback:()=>fO,DataStorage:()=>ev,DenseBincount:()=>m0,DepthToSpace:()=>$m,DepthwiseConv2dNative:()=>Mp,DepthwiseConv2dNativeBackpropFilter:()=>iv,DepthwiseConv2dNativeBackpropInput:()=>sv,Diag:()=>g0,Dilation2D:()=>Bp,Dilation2DBackpropFilter:()=>gm,Dilation2DBackpropInput:()=>mm,Draw:()=>ov,ENV:()=>FA,EarlyStopping:()=>xM,Einsum:()=>lv,Elu:()=>zp,EluGrad:()=>Jm,Environment:()=>A3,Equal:()=>Ym,Erf:()=>Up,Exp:()=>Vp,ExpandDims:()=>jm,Expm1:()=>Wp,FFT:()=>uv,Fill:()=>b0,FlipLeftRight:()=>Qm,Floor:()=>qp,FloorDiv:()=>Pp,FromPixels:()=>k1,FusedBatchNorm:()=>Hp,FusedConv2D:()=>Qd,FusedDepthwiseConv2D:()=>Zd,GPGPUContext:()=>f1,GatherNd:()=>Xm,GatherV2:()=>Zm,GraphModel:()=>BI,Greater:()=>eg,GreaterEqual:()=>Gp,History:()=>hO,IFFT:()=>cv,Identity:()=>Kp,Imag:()=>dv,InputSpec:()=>Oa,IsFinite:()=>$p,IsInf:()=>Jp,IsNan:()=>Yp,KernelBackend:()=>u0,LRN:()=>Xp,LRNGrad:()=>og,LayerVariable:()=>rO,LayersModel:()=>eu,LeakyRelu:()=>jp,Less:()=>tg,LessEqual:()=>ng,LinSpace:()=>ag,Log:()=>Qp,Log1p:()=>Zp,LogSoftmax:()=>_3,LogicalAnd:()=>rg,LogicalNot:()=>ig,LogicalOr:()=>sg,LogicalXor:()=>I3,LowerBound:()=>CW,MathBackendCPU:()=>UI,MathBackendWebGL:()=>h_,MatrixBandPart:()=>IW,Max:()=>eh,MaxPool:()=>nh,MaxPool3D:()=>lg,MaxPool3DGrad:()=>w0,MaxPoolGrad:()=>y0,MaxPoolWithArgmax:()=>x0,Maximum:()=>th,Mean:()=>ah,Min:()=>rh,Minimum:()=>ih,MirrorPad:()=>sh,Mod:()=>oh,MomentumOptimizer:()=>QE,Multinomial:()=>ug,Multiply:()=>lh,Neg:()=>cg,NonMaxSuppressionV3:()=>pg,NonMaxSuppressionV4:()=>hg,NonMaxSuppressionV5:()=>fg,NotEqual:()=>dg,OP_SCOPE_SUFFIX:()=>LA,OneHot:()=>uh,OnesLike:()=>mg,Optimizer:()=>uu,OptimizerConstructors:()=>LD,Pack:()=>gg,PadV2:()=>ch,Pool:()=>_W,Pow:()=>dh,Prelu:()=>ph,Prod:()=>hh,RMSPropOptimizer:()=>ZE,RNN:()=>cu,RaggedGather:()=>pv,RaggedRange:()=>hv,RaggedTensorToTensor:()=>fv,Range:()=>v0,Rank:()=>yk,Real:()=>mv,RealDiv:()=>Lp,Reciprocal:()=>fh,Reduction:()=>Wr,Relu:()=>mh,Relu6:()=>yh,Reshape:()=>bg,ResizeBilinear:()=>bh,ResizeBilinearGrad:()=>wg,ResizeNearestNeighbor:()=>gh,ResizeNearestNeighborGrad:()=>yg,Reverse:()=>wh,RotateWithOffset:()=>Og,Round:()=>xh,Rsqrt:()=>vh,SGDOptimizer:()=>Qv,ScatterNd:()=>xg,SearchSorted:()=>Sg,Select:()=>kg,Selu:()=>Sh,Sequential:()=>cS,Sigmoid:()=>Ch,Sign:()=>Eh,Sin:()=>kh,Sinh:()=>Ah,Slice:()=>Ag,Softmax:()=>Nh,Softplus:()=>Ih,SpaceToBatchND:()=>Eg,SparseFillEmptyRows:()=>S0,SparseReshape:()=>Ig,SparseSegmentMean:()=>k0,SparseSegmentSum:()=>A0,SparseToDense:()=>_g,SplitV:()=>Cg,Sqrt:()=>_h,Square:()=>E0,SquaredDifference:()=>Rh,StaticRegexReplace:()=>C0,Step:()=>zc,StridedSlice:()=>Tg,StringNGrams:()=>I0,StringSplit:()=>_0,StringToHashBucketFast:()=>T0,Sub:()=>Fh,Sum:()=>Th,SymbolicTensor:()=>uo,Tan:()=>Dh,Tanh:()=>Oh,Tensor:()=>$t,TensorBuffer:()=>Ma,TensorScatterUpdate:()=>vg,Tile:()=>Lc,TopK:()=>Ng,Transform:()=>Rg,Transpose:()=>Xl,Unique:()=>N0,Unpack:()=>Fg,UnsortedSegmentSum:()=>R0,UpperBound:()=>TW,Variable:()=>Xd,ZerosLike:()=>Dg,_FusedMatMul:()=>jd,abs:()=>Da,acos:()=>qA,acosh:()=>PA,add:()=>Oe,addN:()=>nF,all:()=>xv,any:()=>jy,argMax:()=>ap,argMin:()=>HA,asin:()=>GA,asinh:()=>KA,atan:()=>$A,atan2:()=>JA,atanh:()=>YA,avgPool:()=>su,avgPool3d:()=>QA,backend:()=>zA,backend_util:()=>P,basicLSTMCell:()=>sF,batchNorm:()=>Mh,batchNorm2d:()=>ZA,batchNorm3d:()=>XA,batchNorm4d:()=>eE,batchToSpaceND:()=>z0,bincount:()=>tE,bitwiseAnd:()=>oF,booleanMaskAsync:()=>jF,broadcastArgs:()=>lF,broadcastTo:()=>Gd,broadcast_util:()=>Mg,browser:()=>Q0,buffer:()=>Zt,callbacks:()=>AZ,cast:()=>je,ceil:()=>nE,clipByValue:()=>Rr,clone:()=>tl,complex:()=>nu,concat:()=>Gn,concat1d:()=>aE,concat2d:()=>rE,concat3d:()=>iE,concat4d:()=>sE,constraints:()=>lO,conv1d:()=>vv,conv2d:()=>Hr,conv2dTranspose:()=>Sv,conv3d:()=>lE,conv3dTranspose:()=>uE,copyRegisteredKernels:()=>DW,cos:()=>U0,cosh:()=>kv,cosineWindow:()=>Kv,cumprod:()=>Xy,cumsum:()=>Av,customGrad:()=>sl,data:()=>HM,denseBincount:()=>C1,deprecationWarn:()=>q3,depthToSpace:()=>cE,depthwiseConv2d:()=>Bh,deregisterOp:()=>IZ,device_util:()=>M0,diag:()=>cF,dilation2d:()=>dE,disableDeprecationWarnings:()=>uq,dispose:()=>Wt,disposeVariables:()=>cq,div:()=>it,divNoNan:()=>pE,dot:()=>hE,dropout:()=>qE,einsum:()=>Ud,elu:()=>Bg,enableDebugMode:()=>lq,enableProdMode:()=>oq,enclosingPowerOfTwo:()=>PE,engine:()=>_s,ensureShape:()=>pF,env:()=>Ae,equal:()=>Fi,erf:()=>Ev,euclideanNorm:()=>gE,exp:()=>Fr,expandDims:()=>sr,expm1:()=>bE,eye:()=>Cv,fft:()=>Y0,fill:()=>Ni,findBackend:()=>gq,findBackendFactory:()=>bq,floor:()=>zg,floorDiv:()=>wv,forceHalfFloat:()=>fL,fused:()=>Am,gather:()=>Ug,gatherND:()=>eD,gather_util:()=>tC,getBackend:()=>P3,getGradient:()=>gk,getKernel:()=>$y,getKernelsForBackend:()=>A1,getThreadsCount:()=>RSe,gpgpu_util:()=>G4,grad:()=>YP,grads:()=>jP,greater:()=>Yr,greaterEqual:()=>ou,ifft:()=>km,imag:()=>V0,image:()=>Zi,inTopKAsync:()=>tD,initializers:()=>uO,input:()=>_O,io:()=>xr,irfft:()=>Uv,isFinite:()=>yE,isInf:()=>wE,isNaN:()=>xE,keep:()=>Ga,kernel_impls:()=>cl,layers:()=>cO,leakyRelu:()=>W0,less:()=>wm,lessEqual:()=>Vc,linalg:()=>KE,linspace:()=>bF,loadGraphModel:()=>DX,loadGraphModelSync:()=>OX,loadLayersModel:()=>wj,localResponseNormalization:()=>vE,log:()=>Di,log1p:()=>q0,logSigmoid:()=>SE,logSoftmax:()=>_v,logSumExp:()=>P0,logicalAnd:()=>Rs,logicalNot:()=>H0,logicalOr:()=>Tv,logicalXor:()=>kE,losses:()=>hD,lowerBound:()=>wF,matMul:()=>jt,math:()=>AD,max:()=>ns,maxPool:()=>ar,maxPool3d:()=>AE,maxPoolWithArgmax:()=>xF,maximum:()=>ul,mean:()=>ya,memory:()=>Ek,meshgrid:()=>vF,metrics:()=>gM,min:()=>ym,minimum:()=>Ac,mirrorPad:()=>EE,mod:()=>CE,model:()=>Sj,models:()=>bM,moments:()=>G0,movingAverage:()=>QF,mul:()=>pe,multiRNNCell:()=>SF,multinomial:()=>kF,neg:()=>ia,nextFrame:()=>nC,norm:()=>Lg,notEqual:()=>sp,oneHot:()=>xm,ones:()=>oi,onesLike:()=>Oi,op:()=>le,outerProduct:()=>AF,pad:()=>ho,pad1d:()=>EF,pad2d:()=>CF,pad3d:()=>IF,pad4d:()=>_F,pool:()=>IE,pow:()=>il,prelu:()=>$0,print:()=>WA,prod:()=>_E,profile:()=>dq,raggedGather:()=>TF,raggedRange:()=>NF,raggedTensorToTensor:()=>RF,rand:()=>FF,randomGamma:()=>BF,randomNormal:()=>Rv,randomStandardNormal:()=>LF,randomUniform:()=>Wc,randomUniformInt:()=>zF,range:()=>op,ready:()=>fq,real:()=>vm,reciprocal:()=>DE,registerBackend:()=>yv,registerCallbackConstructor:()=>Aj,registerGradient:()=>T3,registerKernel:()=>F0,registerOp:()=>CZ,regularizers:()=>yM,relu:()=>zn,relu6:()=>Fv,removeBackend:()=>mq,reshape:()=>ge,reverse:()=>is,reverse1d:()=>UF,reverse2d:()=>VF,reverse3d:()=>WF,reverse4d:()=>qF,rfft:()=>j0,round:()=>Dv,rsqrt:()=>Ov,scalar:()=>gt,scatterND:()=>ZF,scatter_util:()=>qv,searchSorted:()=>Nv,selu:()=>Mv,separableConv2d:()=>Vg,sequential:()=>kj,serialization:()=>We,setBackend:()=>hq,setPlatform:()=>yq,setThreadsCount:()=>NSe,setWasmPath:()=>_Se,setWasmPaths:()=>TSe,setWebGLContext:()=>m4,setdiff1dAsync:()=>PF,shared:()=>VI,sigmoid:()=>Ns,sign:()=>OE,signal:()=>pD,sin:()=>Bv,sinh:()=>Lv,slice:()=>un,slice1d:()=>J0,slice2d:()=>zv,slice3d:()=>Wg,slice4d:()=>Sm,slice_util:()=>$a,softmax:()=>qc,softplus:()=>Lh,spaceToBatchND:()=>K0,sparse:()=>fD,sparseToDense:()=>XF,spectral:()=>dD,split:()=>li,sqrt:()=>ur,square:()=>Hn,squaredDifference:()=>Vv,squeeze:()=>Pc,stack:()=>Ba,step:()=>zh,stridedSlice:()=>ME,string:()=>mD,sub:()=>at,sum:()=>lt,sumOutType:()=>bv,tan:()=>BE,tanh:()=>kc,tensor:()=>Pr,tensor1d:()=>Dn,tensor2d:()=>nl,tensor3d:()=>Wv,tensor4d:()=>Ec,tensor5d:()=>HF,tensor6d:()=>GF,tensorScatterUpdate:()=>$F,tensor_util:()=>ro,test_util:()=>DF,tidy:()=>be,tile:()=>Ti,time:()=>pq,topk:()=>zE,train:()=>Bd,transpose:()=>Qt,truncatedNormal:()=>Hv,unique:()=>UE,unregisterGradient:()=>FW,unregisterKernel:()=>RW,unsortedSegmentSum:()=>Gv,unstack:()=>Aa,upcastType:()=>as,upperBound:()=>JF,util:()=>O,valueAndGrad:()=>QP,valueAndGrads:()=>ZP,variable:()=>VE,variableGrads:()=>yF,version:()=>zSe,version_converter:()=>BX,version_core:()=>S7,version_cpu:()=>Lte,version_layers:()=>EC,version_wasm:()=>FSe,version_webgl:()=>Cue,webgl:()=>Iue,webgl_util:()=>f4,where:()=>lr,whereAsync:()=>WE,zeros:()=>wa,zerosLike:()=>gn});var B6=Object.create,_A=Object.defineProperty,L6=Object.getOwnPropertyDescriptor,z6=Object.getOwnPropertyNames,U6=Object.getPrototypeOf,V6=Object.prototype.hasOwnProperty,za=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),qt=(e,t)=>{for(var n in t)_A(e,n,{get:t[n],enumerable:!0})},W6=(e,t,n,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of z6(t))!V6.call(e,r)&&r!==n&&_A(e,r,{get:()=>t[r],enumerable:!(a=L6(t,r))||a.enumerable});return e},Oc=(e,t,n)=>(n=e!=null?B6(U6(e)):{},W6(!e||!e.__esModule?_A(n,"default",{value:e,enumerable:!0}):n,e)),q6=za((e,t)=>{t.exports=a;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function a(z,ae,ue){this.low=z|0,this.high=ae|0,this.unsigned=!!ue}a.prototype.__isLong__,Object.defineProperty(a.prototype,"__isLong__",{value:!0});function r(z){return(z&&z.__isLong__)===!0}a.isLong=r;var i={},s={};function o(z,ae){var ue,he,Z;return ae?(z>>>=0,(Z=0<=z&&z<256)&&(he=s[z],he)?he:(ue=d(z,(z|0)<0?-1:0,!0),Z&&(s[z]=ue),ue)):(z|=0,(Z=-128<=z&&z<128)&&(he=i[z],he)?he:(ue=d(z,z<0?-1:0,!1),Z&&(i[z]=ue),ue))}a.fromInt=o;function u(z,ae){if(isNaN(z))return ae?N:T;if(ae){if(z<0)return N;if(z>=S)return j}else{if(z<=-9223372036854776e3)return te;if(z+1>=E)return K}return z<0?u(-z,ae).neg():d(z%v|0,z/v|0,ae)}a.fromNumber=u;function d(z,ae,ue){return new a(z,ae,ue)}a.fromBits=d;var c=Math.pow;function h(z,ae,ue){if(z.length===0)throw Error("empty string");if(z==="NaN"||z==="Infinity"||z==="+Infinity"||z==="-Infinity")return T;if(typeof ae=="number"?(ue=ae,ae=!1):ae=!!ae,ue=ue||10,ue<2||36<ue)throw RangeError("radix");var he;if((he=z.indexOf("-"))>0)throw Error("interior hyphen");if(he===0)return h(z.substring(1),ae,ue).neg();for(var Z=u(c(ue,8)),se=T,de=0;de<z.length;de+=8){var Ce=Math.min(8,z.length-de),Y=parseInt(z.substring(de,de+Ce),ue);if(Ce<8){var ie=u(c(ue,Ce));se=se.mul(ie).add(u(Y))}else se=se.mul(Z),se=se.add(u(Y))}return se.unsigned=ae,se}a.fromString=h;function m(z,ae){return typeof z=="number"?u(z,ae):typeof z=="string"?h(z,ae):d(z.low,z.high,typeof ae=="boolean"?ae:z.unsigned)}a.fromValue=m;var g=65536,x=1<<24,v=g*g,S=v*v,E=S/2,C=o(x),T=o(0);a.ZERO=T;var N=o(0,!0);a.UZERO=N;var D=o(1);a.ONE=D;var q=o(1,!0);a.UONE=q;var H=o(-1);a.NEG_ONE=H;var K=d(-1,2147483647,!1);a.MAX_VALUE=K;var j=d(-1,-1,!0);a.MAX_UNSIGNED_VALUE=j;var te=d(0,-2147483648,!1);a.MIN_VALUE=te;var Q=a.prototype;Q.toInt=function(){return this.unsigned?this.low>>>0:this.low},Q.toNumber=function(){return this.unsigned?(this.high>>>0)*v+(this.low>>>0):this.high*v+(this.low>>>0)},Q.toString=function(z){if(z=z||10,z<2||36<z)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(te)){var ae=u(z),ue=this.div(ae),he=ue.mul(ae).sub(this);return ue.toString(z)+he.toInt().toString(z)}else return"-"+this.neg().toString(z);for(var Z=u(c(z,6),this.unsigned),se=this,de="";;){var Ce=se.div(Z),Y=se.sub(Ce.mul(Z)).toInt()>>>0,ie=Y.toString(z);if(se=Ce,se.isZero())return ie+de;for(;ie.length<6;)ie="0"+ie;de=""+ie+de}},Q.getHighBits=function(){return this.high},Q.getHighBitsUnsigned=function(){return this.high>>>0},Q.getLowBits=function(){return this.low},Q.getLowBitsUnsigned=function(){return this.low>>>0},Q.getNumBitsAbs=function(){if(this.isNegative())return this.eq(te)?64:this.neg().getNumBitsAbs();for(var z=this.high!=0?this.high:this.low,ae=31;ae>0&&!(z&1<<ae);ae--);return this.high!=0?ae+33:ae+1},Q.isZero=function(){return this.high===0&&this.low===0},Q.eqz=Q.isZero,Q.isNegative=function(){return!this.unsigned&&this.high<0},Q.isPositive=function(){return this.unsigned||this.high>=0},Q.isOdd=function(){return(this.low&1)===1},Q.isEven=function(){return(this.low&1)===0},Q.equals=function(z){return r(z)||(z=m(z)),this.unsigned!==z.unsigned&&this.high>>>31===1&&z.high>>>31===1?!1:this.high===z.high&&this.low===z.low},Q.eq=Q.equals,Q.notEquals=function(z){return!this.eq(z)},Q.neq=Q.notEquals,Q.ne=Q.notEquals,Q.lessThan=function(z){return this.comp(z)<0},Q.lt=Q.lessThan,Q.lessThanOrEqual=function(z){return this.comp(z)<=0},Q.lte=Q.lessThanOrEqual,Q.le=Q.lessThanOrEqual,Q.greaterThan=function(z){return this.comp(z)>0},Q.gt=Q.greaterThan,Q.greaterThanOrEqual=function(z){return this.comp(z)>=0},Q.gte=Q.greaterThanOrEqual,Q.ge=Q.greaterThanOrEqual,Q.compare=function(z){if(r(z)||(z=m(z)),this.eq(z))return 0;var ae=this.isNegative(),ue=z.isNegative();return ae&&!ue?-1:!ae&&ue?1:this.unsigned?z.high>>>0>this.high>>>0||z.high===this.high&&z.low>>>0>this.low>>>0?-1:1:this.sub(z).isNegative()?-1:1},Q.comp=Q.compare,Q.negate=function(){return!this.unsigned&&this.eq(te)?te:this.not().add(D)},Q.neg=Q.negate,Q.add=function(z){r(z)||(z=m(z));var ae=this.high>>>16,ue=this.high&65535,he=this.low>>>16,Z=this.low&65535,se=z.high>>>16,de=z.high&65535,Ce=z.low>>>16,Y=z.low&65535,ie=0,xe=0,me=0,_e=0;return _e+=Z+Y,me+=_e>>>16,_e&=65535,me+=he+Ce,xe+=me>>>16,me&=65535,xe+=ue+de,ie+=xe>>>16,xe&=65535,ie+=ae+se,ie&=65535,d(me<<16|_e,ie<<16|xe,this.unsigned)},Q.subtract=function(z){return r(z)||(z=m(z)),this.add(z.neg())},Q.sub=Q.subtract,Q.multiply=function(z){if(this.isZero())return T;if(r(z)||(z=m(z)),n){var ae=n.mul(this.low,this.high,z.low,z.high);return d(ae,n.get_high(),this.unsigned)}if(z.isZero())return T;if(this.eq(te))return z.isOdd()?te:T;if(z.eq(te))return this.isOdd()?te:T;if(this.isNegative())return z.isNegative()?this.neg().mul(z.neg()):this.neg().mul(z).neg();if(z.isNegative())return this.mul(z.neg()).neg();if(this.lt(C)&&z.lt(C))return u(this.toNumber()*z.toNumber(),this.unsigned);var ue=this.high>>>16,he=this.high&65535,Z=this.low>>>16,se=this.low&65535,de=z.high>>>16,Ce=z.high&65535,Y=z.low>>>16,ie=z.low&65535,xe=0,me=0,_e=0,Le=0;return Le+=se*ie,_e+=Le>>>16,Le&=65535,_e+=Z*ie,me+=_e>>>16,_e&=65535,_e+=se*Y,me+=_e>>>16,_e&=65535,me+=he*ie,xe+=me>>>16,me&=65535,me+=Z*Y,xe+=me>>>16,me&=65535,me+=se*Ce,xe+=me>>>16,me&=65535,xe+=ue*ie+he*Y+Z*Ce+se*de,xe&=65535,d(_e<<16|Le,xe<<16|me,this.unsigned)},Q.mul=Q.multiply,Q.divide=function(z){if(r(z)||(z=m(z)),z.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&z.low===-1&&z.high===-1)return this;var ae=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,z.low,z.high);return d(ae,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?N:T;var ue,he,Z;if(this.unsigned){if(z.unsigned||(z=z.toUnsigned()),z.gt(this))return N;if(z.gt(this.shru(1)))return q;Z=N}else{if(this.eq(te)){if(z.eq(D)||z.eq(H))return te;if(z.eq(te))return D;var se=this.shr(1);return ue=se.div(z).shl(1),ue.eq(T)?z.isNegative()?D:H:(he=this.sub(z.mul(ue)),Z=ue.add(he.div(z)),Z)}else if(z.eq(te))return this.unsigned?N:T;if(this.isNegative())return z.isNegative()?this.neg().div(z.neg()):this.neg().div(z).neg();if(z.isNegative())return this.div(z.neg()).neg();Z=T}for(he=this;he.gte(z);){ue=Math.max(1,Math.floor(he.toNumber()/z.toNumber()));for(var de=Math.ceil(Math.log(ue)/Math.LN2),Ce=de<=48?1:c(2,de-48),Y=u(ue),ie=Y.mul(z);ie.isNegative()||ie.gt(he);)ue-=Ce,Y=u(ue,this.unsigned),ie=Y.mul(z);Y.isZero()&&(Y=D),Z=Z.add(Y),he=he.sub(ie)}return Z},Q.div=Q.divide,Q.modulo=function(z){if(r(z)||(z=m(z)),n){var ae=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,z.low,z.high);return d(ae,n.get_high(),this.unsigned)}return this.sub(this.div(z).mul(z))},Q.mod=Q.modulo,Q.rem=Q.modulo,Q.not=function(){return d(~this.low,~this.high,this.unsigned)},Q.and=function(z){return r(z)||(z=m(z)),d(this.low&z.low,this.high&z.high,this.unsigned)},Q.or=function(z){return r(z)||(z=m(z)),d(this.low|z.low,this.high|z.high,this.unsigned)},Q.xor=function(z){return r(z)||(z=m(z)),d(this.low^z.low,this.high^z.high,this.unsigned)},Q.shiftLeft=function(z){return r(z)&&(z=z.toInt()),(z&=63)===0?this:z<32?d(this.low<<z,this.high<<z|this.low>>>32-z,this.unsigned):d(0,this.low<<z-32,this.unsigned)},Q.shl=Q.shiftLeft,Q.shiftRight=function(z){return r(z)&&(z=z.toInt()),(z&=63)===0?this:z<32?d(this.low>>>z|this.high<<32-z,this.high>>z,this.unsigned):d(this.high>>z-32,this.high>=0?0:-1,this.unsigned)},Q.shr=Q.shiftRight,Q.shiftRightUnsigned=function(z){if(r(z)&&(z=z.toInt()),z&=63,z===0)return this;var ae=this.high;if(z<32){var ue=this.low;return d(ue>>>z|ae<<32-z,ae>>>z,this.unsigned)}else return z===32?d(ae,0,this.unsigned):d(ae>>>z-32,0,this.unsigned)},Q.shru=Q.shiftRightUnsigned,Q.shr_u=Q.shiftRightUnsigned,Q.toSigned=function(){return this.unsigned?d(this.low,this.high,!1):this},Q.toUnsigned=function(){return this.unsigned?this:d(this.low,this.high,!0)},Q.toBytes=function(z){return z?this.toBytesLE():this.toBytesBE()},Q.toBytesLE=function(){var z=this.high,ae=this.low;return[ae&255,ae>>>8&255,ae>>>16&255,ae>>>24,z&255,z>>>8&255,z>>>16&255,z>>>24]},Q.toBytesBE=function(){var z=this.high,ae=this.low;return[z>>>24,z>>>16&255,z>>>8&255,z&255,ae>>>24,ae>>>16&255,ae>>>8&255,ae&255]},a.fromBytes=function(z,ae,ue){return ue?a.fromBytesLE(z,ae):a.fromBytesBE(z,ae)},a.fromBytesLE=function(z,ae){return new a(z[0]|z[1]<<8|z[2]<<16|z[3]<<24,z[4]|z[5]<<8|z[6]<<16|z[7]<<24,ae)},a.fromBytesBE=function(z,ae){return new a(z[4]<<24|z[5]<<16|z[6]<<8|z[7],z[0]<<24|z[1]<<16|z[2]<<8|z[3],ae)}}),P6=za(()=>{}),H6=za(()=>{}),G6=za((e,t)=>{(function(n,a,r){function i(d){var c=this,h=u();c.next=function(){var m=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=m-(c.c=m|0)},c.c=1,c.s0=h(" "),c.s1=h(" "),c.s2=h(" "),c.s0-=h(d),c.s0<0&&(c.s0+=1),c.s1-=h(d),c.s1<0&&(c.s1+=1),c.s2-=h(d),c.s2<0&&(c.s2+=1),h=null}function s(d,c){return c.c=d.c,c.s0=d.s0,c.s1=d.s1,c.s2=d.s2,c}function o(d,c){var h=new i(d),m=c&&c.state,g=h.next;return g.int32=function(){return h.next()*4294967296|0},g.double=function(){return g()+(g()*2097152|0)*11102230246251565e-32},g.quick=g,m&&(typeof m=="object"&&s(m,h),g.state=function(){return s(h,{})}),g}function u(){var d=4022871197,c=function(h){h=String(h);for(var m=0;m<h.length;m++){d+=h.charCodeAt(m);var g=.02519603282416938*d;d=g>>>0,g-=d,g*=d,d=g>>>0,g-=d,d+=g*4294967296}return(d>>>0)*23283064365386963e-26};return c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),K6=za((e,t)=>{(function(n,a,r){function i(u){var d=this,c="";d.x=0,d.y=0,d.z=0,d.w=0,d.next=function(){var m=d.x^d.x<<11;return d.x=d.y,d.y=d.z,d.z=d.w,d.w^=d.w>>>19^m^m>>>8},u===(u|0)?d.x=u:c+=u;for(var h=0;h<c.length+64;h++)d.x^=c.charCodeAt(h)|0,d.next()}function s(u,d){return d.x=u.x,d.y=u.y,d.z=u.z,d.w=u.w,d}function o(u,d){var c=new i(u),h=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,x=(c.next()>>>0)/4294967296,v=(g+x)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,h&&(typeof h=="object"&&s(h,c),m.state=function(){return s(c,{})}),m}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),$6=za((e,t)=>{(function(n,a,r){function i(u){var d=this,c="";d.next=function(){var m=d.x^d.x>>>2;return d.x=d.y,d.y=d.z,d.z=d.w,d.w=d.v,(d.d=d.d+362437|0)+(d.v=d.v^d.v<<4^(m^m<<1))|0},d.x=0,d.y=0,d.z=0,d.w=0,d.v=0,u===(u|0)?d.x=u:c+=u;for(var h=0;h<c.length+64;h++)d.x^=c.charCodeAt(h)|0,h==c.length&&(d.d=d.x<<10^d.x>>>4),d.next()}function s(u,d){return d.x=u.x,d.y=u.y,d.z=u.z,d.w=u.w,d.v=u.v,d.d=u.d,d}function o(u,d){var c=new i(u),h=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,x=(c.next()>>>0)/4294967296,v=(g+x)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,h&&(typeof h=="object"&&s(h,c),m.state=function(){return s(c,{})}),m}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),J6=za((e,t)=>{(function(n,a,r){function i(u){var d=this;d.next=function(){var h=d.x,m=d.i,g,x;return g=h[m],g^=g>>>7,x=g^g<<24,g=h[m+1&7],x^=g^g>>>10,g=h[m+3&7],x^=g^g>>>3,g=h[m+4&7],x^=g^g<<7,g=h[m+7&7],g=g^g<<13,x^=g^g<<9,h[m]=x,d.i=m+1&7,x};function c(h,m){var g,x=[];if(m===(m|0))x[0]=m;else for(m=""+m,g=0;g<m.length;++g)x[g&7]=x[g&7]<<15^m.charCodeAt(g)+x[g+1&7]<<13;for(;x.length<8;)x.push(0);for(g=0;g<8&&x[g]===0;++g);for(g==8?x[7]=-1:x[g],h.x=x,h.i=0,g=256;g>0;--g)h.next()}c(d,u)}function s(u,d){return d.x=u.x.slice(),d.i=u.i,d}function o(u,d){u==null&&(u=+new Date);var c=new i(u),h=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,x=(c.next()>>>0)/4294967296,v=(g+x)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,h&&(h.x&&s(h,c),m.state=function(){return s(c,{})}),m}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Y6=za((e,t)=>{(function(n,a,r){function i(u){var d=this;d.next=function(){var h=d.w,m=d.X,g=d.i,x,v;return d.w=h=h+1640531527|0,v=m[g+34&127],x=m[g=g+1&127],v^=v<<13,x^=x<<17,v^=v>>>15,x^=x>>>12,v=m[g]=v^x,d.i=g,v+(h^h>>>16)|0};function c(h,m){var g,x,v,S,E,C=[],T=128;for(m===(m|0)?(x=m,m=null):(m=m+"\0",x=0,T=Math.max(T,m.length)),v=0,S=-32;S<T;++S)m&&(x^=m.charCodeAt((S+32)%m.length)),S===0&&(E=x),x^=x<<10,x^=x>>>15,x^=x<<4,x^=x>>>13,S>=0&&(E=E+1640531527|0,g=C[S&127]^=x+E,v=g==0?v+1:0);for(v>=128&&(C[(m&&m.length||0)&127]=-1),v=127,S=4*128;S>0;--S)x=C[v+34&127],g=C[v=v+1&127],x^=x<<13,g^=g<<17,x^=x>>>15,g^=g>>>12,C[v]=x^g;h.w=E,h.X=C,h.i=v}c(d,u)}function s(u,d){return d.i=u.i,d.w=u.w,d.X=u.X.slice(),d}function o(u,d){u==null&&(u=+new Date);var c=new i(u),h=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,x=(c.next()>>>0)/4294967296,v=(g+x)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,h&&(h.X&&s(h,c),m.state=function(){return s(c,{})}),m}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),j6=za((e,t)=>{(function(n,a,r){function i(u){var d=this,c="";d.next=function(){var m=d.b,g=d.c,x=d.d,v=d.a;return m=m<<25^m>>>7^g,g=g-x|0,x=x<<24^x>>>8^v,v=v-m|0,d.b=m=m<<20^m>>>12^g,d.c=g=g-x|0,d.d=x<<16^g>>>16^v,d.a=v-m|0},d.a=0,d.b=0,d.c=-1640531527,d.d=1367130551,u===Math.floor(u)?(d.a=u/4294967296|0,d.b=u|0):c+=u;for(var h=0;h<c.length+20;h++)d.b^=c.charCodeAt(h)|0,d.next()}function s(u,d){return d.a=u.a,d.b=u.b,d.c=u.c,d.d=u.d,d}function o(u,d){var c=new i(u),h=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,x=(c.next()>>>0)/4294967296,v=(g+x)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,h&&(typeof h=="object"&&s(h,c),m.state=function(){return s(c,{})}),m}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Q6=za(()=>{}),Z6=za((e,t)=>{(function(n,a,r){var i=256,s=6,o=52,u="random",d=r.pow(i,s),c=r.pow(2,o),h=c*2,m=i-1,g;function x(D,q,H){var K=[];q=q==!0?{entropy:!0}:q||{};var j=C(E(q.entropy?[D,N(a)]:D??T(),3),K),te=new v(K),Q=function(){for(var z=te.g(s),ae=d,ue=0;z<c;)z=(z+ue)*i,ae*=i,ue=te.g(1);for(;z>=h;)z/=2,ae/=2,ue>>>=1;return(z+ue)/ae};return Q.int32=function(){return te.g(4)|0},Q.quick=function(){return te.g(4)/4294967296},Q.double=Q,C(N(te.S),a),(q.pass||H||function(z,ae,ue,he){return he&&(he.S&&S(he,te),z.state=function(){return S(te,{})}),ue?(r[u]=z,ae):z})(Q,j,"global"in q?q.global:this==r,q.state)}function v(D){var q,H=D.length,K=this,j=0,te=K.i=K.j=0,Q=K.S=[];for(H||(D=[H++]);j<i;)Q[j]=j++;for(j=0;j<i;j++)Q[j]=Q[te=m&te+D[j%H]+(q=Q[j])],Q[te]=q;(K.g=function(z){for(var ae,ue=0,he=K.i,Z=K.j,se=K.S;z--;)ae=se[he=m&he+1],ue=ue*i+se[m&(se[he]=se[Z=m&Z+ae])+(se[Z]=ae)];return K.i=he,K.j=Z,ue})(i)}function S(D,q){return q.i=D.i,q.j=D.j,q.S=D.S.slice(),q}function E(D,q){var H=[],K=typeof D,j;if(q&&K=="object")for(j in D)try{H.push(E(D[j],q-1))}catch{}return H.length?H:K=="string"?D:D+"\0"}function C(D,q){for(var H=D+"",K,j=0;j<H.length;)q[m&j]=m&(K^=q[m&j]*19)+H.charCodeAt(j++);return N(q)}function T(){try{var D;return g&&(D=g.randomBytes)?D=D(i):(D=new Uint8Array(i),(n.crypto||n.msCrypto).getRandomValues(D)),N(D)}catch{var q=n.navigator,H=q&&q.plugins;return[+new Date,n,H,n.screen,N(a)]}}function N(D){return String.fromCharCode.apply(0,D)}if(C(r.random(),a),typeof t=="object"&&t.exports){t.exports=x;try{g=Q6()}catch{}}else typeof define=="function"&&define.amd?define(function(){return x}):r["seed"+u]=x})(typeof self<"u"?self:e,[],Math)}),X1=za((e,t)=>{var n=G6(),a=K6(),r=$6(),i=J6(),s=Y6(),o=j6(),u=Z6();u.alea=n,u.xor128=a,u.xorwow=r,u.xorshift7=i,u.xor4096=s,u.tychei=o,t.exports=u}),p3=za(()=>{}),TA=za(()=>{}),h3=za(()=>{}),X6=za(()=>{}),eW=za(()=>{}),tW=za(()=>{}),nW=za((e,t)=>{var n=(()=>{var a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(a=a||__filename),function(r){r=r||{};function i(){return de.buffer!=Ke&&Nt(de.buffer),rt}function s(){return de.buffer!=Ke&&Nt(de.buffer),ht}function o(){return de.buffer!=Ke&&Nt(de.buffer),kt}function u(){return de.buffer!=Ke&&Nt(de.buffer),_t}function d(){return de.buffer!=Ke&&Nt(de.buffer),ln}var c=typeof r<"u"?r:{},h,m;c.ready=new Promise(function(re,Ie){h=re,m=Ie});var g;typeof process<"u"&&process.listeners&&(g={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var x=Object.assign({},c),v=(re,Ie)=>{throw Ie},S=typeof window=="object",E=typeof importScripts=="function",C=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",T=c.ENVIRONMENT_IS_PTHREAD||!1,N="";function D(re){return c.locateFile?c.locateFile(re,N):N+re}var q,H,K;function j(re){re instanceof fi||he("exiting due to exception: "+re)}if(C){var te=TA(),Q=h3();E?N=Q.dirname(N)+"/":N=__dirname+"/",q=(Ie,Ye)=>(Ie=ze(Ie)?new URL(Ie):Q.normalize(Ie),te.readFileSync(Ie,Ye?void 0:"utf8")),K=Ie=>{var Ye=q(Ie,!0);return Ye.buffer||(Ye=new Uint8Array(Ye)),Ye},H=(Ie,Ye,bt)=>{Ie=ze(Ie)?new URL(Ie):Q.normalize(Ie),te.readFile(Ie,function(At,Mt){At?bt(At):Ye(Mt.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Ie){if(!(Ie instanceof fi))throw Ie}),process.on("unhandledRejection",function(Ie){throw Ie}),v=(Ie,Ye)=>{if(en())throw process.exitCode=Ie,Ye;j(Ye),process.exit(Ie)},c.inspect=function(){return"[Emscripten Module object]"};let re;try{re=X6()}catch(Ie){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Ie}global.Worker=re.Worker}else(S||E)&&(E?N=self.location.href:typeof document<"u"&&document.currentScript&&(N=document.currentScript.src),typeof a<"u"&&a&&(N=a),N.indexOf("blob:")!==0?N=N.substr(0,N.replace(/[?#].*/,"").lastIndexOf("/")+1):N="",C||(q=re=>{var Ie=new XMLHttpRequest;return Ie.open("GET",re,!1),Ie.send(null),Ie.responseText},E&&(K=re=>{var Ie=new XMLHttpRequest;return Ie.open("GET",re,!1),Ie.responseType="arraybuffer",Ie.send(null),new Uint8Array(Ie.response)}),H=(re,Ie,Ye)=>{var bt=new XMLHttpRequest;bt.open("GET",re,!0),bt.responseType="arraybuffer",bt.onload=()=>{if(bt.status==200||bt.status==0&&bt.response){Ie(bt.response);return}Ye()},bt.onerror=Ye,bt.send(null)}));C&&typeof performance>"u"&&(global.performance=eW().performance);var z=console.log.bind(console),ae=console.warn.bind(console);C&&(z=re=>te.writeSync(1,re+`
`),ae=re=>te.writeSync(2,re+`
`));var ue=c.print||z,he=c.printErr||ae;Object.assign(c,x),x=null,c.arguments&&c.arguments,c.thisProgram&&c.thisProgram,c.quit&&(v=c.quit);var Z;c.wasmBinary&&(Z=c.wasmBinary);var se=c.noExitRuntime||!0;typeof WebAssembly!="object"&&ne("no native wasm support detected");var de,Ce,Y=!1,ie;function xe(re,Ie){re||ne(Ie)}var me=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function _e(re,Ie,Ye){Ie>>>=0;for(var bt=Ie+Ye,At=Ie;re[At]&&!(At>=bt);)++At;if(At-Ie>16&&re.buffer&&me)return me.decode(re.buffer instanceof SharedArrayBuffer?re.slice(Ie,At):re.subarray(Ie,At));for(var Mt="";Ie<At;){var et=re[Ie++];if(!(et&128)){Mt+=String.fromCharCode(et);continue}var st=re[Ie++]&63;if((et&224)==192){Mt+=String.fromCharCode((et&31)<<6|st);continue}var Rn=re[Ie++]&63;if((et&240)==224?et=(et&15)<<12|st<<6|Rn:et=(et&7)<<18|st<<12|Rn<<6|re[Ie++]&63,et<65536)Mt+=String.fromCharCode(et);else{var qa=et-65536;Mt+=String.fromCharCode(55296|qa>>10,56320|qa&1023)}}return Mt}function Le(re,Ie){return re>>>=0,re?_e(s(),re,Ie):""}function qe(re,Ie,Ye,bt){if(Ye>>>=0,!(bt>0))return 0;for(var At=Ye,Mt=Ye+bt-1,et=0;et<re.length;++et){var st=re.charCodeAt(et);if(st>=55296&&st<=57343){var Rn=re.charCodeAt(++et);st=65536+((st&1023)<<10)|Rn&1023}if(st<=127){if(Ye>=Mt)break;Ie[Ye++>>>0]=st}else if(st<=2047){if(Ye+1>=Mt)break;Ie[Ye++>>>0]=192|st>>6,Ie[Ye++>>>0]=128|st&63}else if(st<=65535){if(Ye+2>=Mt)break;Ie[Ye++>>>0]=224|st>>12,Ie[Ye++>>>0]=128|st>>6&63,Ie[Ye++>>>0]=128|st&63}else{if(Ye+3>=Mt)break;Ie[Ye++>>>0]=240|st>>18,Ie[Ye++>>>0]=128|st>>12&63,Ie[Ye++>>>0]=128|st>>6&63,Ie[Ye++>>>0]=128|st&63}}return Ie[Ye>>>0]=0,Ye-At}function $e(re,Ie,Ye){return qe(re,s(),Ie,Ye)}var Ke,rt,ht,kt,_t,ln;T&&(Ke=c.buffer);function Nt(re){Ke=re,c.HEAP8=rt=new Int8Array(re),c.HEAP16=new Int16Array(re),c.HEAP32=kt=new Int32Array(re),c.HEAPU8=ht=new Uint8Array(re),c.HEAPU16=new Uint16Array(re),c.HEAPU32=_t=new Uint32Array(re),c.HEAPF32=new Float32Array(re),c.HEAPF64=ln=new Float64Array(re)}var Pt=c.INITIAL_MEMORY||16777216;if(T)de=c.wasmMemory,Ke=c.buffer;else if(c.wasmMemory)de=c.wasmMemory;else if(de=new WebAssembly.Memory({initial:Pt/65536,maximum:65536,shared:!0}),!(de.buffer instanceof SharedArrayBuffer))throw he("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),C&&he("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");de&&(Ke=de.buffer),Pt=Ke.byteLength,Nt(Ke);var Re,ft=[],wt=[],oa=[];function en(){return se}function Ht(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)pa(c.preRun.shift());cn(ft)}function Jn(){!T&&cn(wt)}function kn(){if(!T){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)An(c.postRun.shift());cn(oa)}}function pa(re){ft.unshift(re)}function Na(re){wt.unshift(re)}function An(re){oa.unshift(re)}var tn=0,G=null;function F(re){tn++,c.monitorRunDependencies&&c.monitorRunDependencies(tn)}function L(re){if(tn--,c.monitorRunDependencies&&c.monitorRunDependencies(tn),tn==0&&G){var Ie=G;G=null,Ie()}}function ne(re){c.onAbort&&c.onAbort(re),re="Aborted("+re+")",he(re),Y=!0,ie=1,re+=". Build with -sASSERTIONS for more info.";var Ie=new WebAssembly.RuntimeError(re);throw m(Ie),Ie}var ke="data:application/octet-stream;base64,";function ve(re){return re.startsWith(ke)}function ze(re){return re.startsWith("file://")}var ot;ot="tfjs-backend-wasm-threaded-simd.wasm",ve(ot)||(ot=D(ot));function Lt(re){try{if(re==ot&&Z)return new Uint8Array(Z);if(K)return K(re);throw"both async and sync fetching of the wasm failed"}catch(Ie){ne(Ie)}}function Rt(){if(!Z&&(S||E)){if(typeof fetch=="function"&&!ze(ot))return fetch(ot,{credentials:"same-origin"}).then(function(re){if(!re.ok)throw"failed to load wasm binary file at '"+ot+"'";return re.arrayBuffer()}).catch(function(){return Lt(ot)});if(H)return new Promise(function(re,Ie){H(ot,function(Ye){re(new Uint8Array(Ye))},Ie)})}return Promise.resolve().then(function(){return Lt(ot)})}function on(){var re={env:fl,wasi_snapshot_preview1:fl};function Ie(et,st){var Rn=et.exports;if(c.asm=Rn,Li(c.asm._emscripten_tls_init),Re=c.asm.__indirect_function_table,Na(c.asm.__wasm_call_ctors),Ce=st,!T){var qa=Ze.unusedWorkers.length;Ze.unusedWorkers.forEach(function(gi){Ze.loadWasmModuleToWorker(gi,function(){--qa||L()})})}}T||F();function Ye(et){Ie(et.instance,et.module)}function bt(et){return Rt().then(function(st){return WebAssembly.instantiate(st,re)}).then(function(st){return st}).then(et,function(st){he("failed to asynchronously prepare wasm: "+st),ne(st)})}function At(){return!Z&&typeof WebAssembly.instantiateStreaming=="function"&&!ve(ot)&&!ze(ot)&&!C&&typeof fetch=="function"?fetch(ot,{credentials:"same-origin"}).then(function(et){var st=WebAssembly.instantiateStreaming(et,re);return st.then(Ye,function(Rn){return he("wasm streaming compile failed: "+Rn),he("falling back to ArrayBuffer instantiation"),bt(Ye)})}):bt(Ye)}if(c.instantiateWasm)try{var Mt=c.instantiateWasm(re,Ie);return Mt}catch(et){he("Module.instantiateWasm callback failed with error: "+et),m(et)}return At().catch(m),{}}var hn={};function fi(re){this.name="ExitStatus",this.message="Program terminated with exit("+re+")",this.status=re}function ls(re){var Ie=Ze.pthreads[re];delete Ze.pthreads[re],Ie.terminate(),Mr(re),Ze.runningWorkers.splice(Ze.runningWorkers.indexOf(Ie),1),Ie.pthread_ptr=0}function us(re){var Ie=Ze.pthreads[re];Ie.postMessage({cmd:"cancel"})}function Va(re){var Ie=Ze.pthreads[re];xe(Ie),Ze.returnWorkerToPool(Ie)}function cs(re){var Ie=Ze.getNewWorker();if(!Ie)return 6;Ze.runningWorkers.push(Ie),Ze.pthreads[re.pthread_ptr]=Ie,Ie.pthread_ptr=re.pthread_ptr;var Ye={cmd:"run",start_routine:re.startRoutine,arg:re.arg,pthread_ptr:re.pthread_ptr};return Ie.runPthread=()=>{C&&Ie.ref(),Ie.postMessage(Ye,re.transferList),delete Ie.runPthread},Ie.loaded&&Ie.runPthread(),0}function mo(re){if(T)return ps(1,1,re);ie=re,en()||(Ze.terminateAllThreads(),c.onExit&&c.onExit(re),Y=!0),v(re,new fi(re))}function Me(re,Ie){if(ie=re,!Ie&&T)throw xt(re),"unwind";mo(re)}var Je=Me;function mt(re){if(re instanceof fi||re=="unwind")return ie;v(1,re)}var Ze={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){T?Ze.initWorker():Ze.initMainThread()},initMainThread:function(){for(var re=8;re--;)Ze.allocateUnusedWorker()},initWorker:function(){se=!1},setExitStatus:function(re){ie=re},terminateAllThreads:function(){for(var re of Object.values(Ze.pthreads))Ze.returnWorkerToPool(re);for(var re of Ze.unusedWorkers)re.terminate();Ze.unusedWorkers=[]},returnWorkerToPool:function(re){var Ie=re.pthread_ptr;delete Ze.pthreads[Ie],Ze.unusedWorkers.push(re),Ze.runningWorkers.splice(Ze.runningWorkers.indexOf(re),1),re.pthread_ptr=0,C&&re.unref(),Mr(Ie)},receiveObjectTransfer:function(re){},threadInitTLS:function(){Ze.tlsInitFunctions.forEach(re=>re())},loadWasmModuleToWorker:function(re,Ie){re.onmessage=Mt=>{var et=Mt.data,st=et.cmd;if(re.pthread_ptr&&(Ze.currentProxiedOperationCallerThread=re.pthread_ptr),et.targetThread&&et.targetThread!=ei()){var Rn=Ze.pthreads[et.targetThread];Rn?Rn.postMessage(et,et.transferList):he('Internal error! Worker sent a message "'+st+'" to target pthread '+et.targetThread+", but that thread no longer exists!"),Ze.currentProxiedOperationCallerThread=void 0;return}st==="processProxyingQueue"?ha(et.queue):st==="spawnThread"?cs(et):st==="cleanupThread"?Va(et.thread):st==="killThread"?ls(et.thread):st==="cancelThread"?us(et.thread):st==="loaded"?(re.loaded=!0,C&&re.unref(),Ie&&Ie(re),re.runPthread&&re.runPthread()):st==="print"?ue("Thread "+et.threadId+": "+et.text):st==="printErr"?he("Thread "+et.threadId+": "+et.text):st==="alert"?alert("Thread "+et.threadId+": "+et.text):et.target==="setimmediate"?re.postMessage(et):st==="callHandler"?c[et.handler](...et.args):st&&he("worker sent an unknown command "+st),Ze.currentProxiedOperationCallerThread=void 0},re.onerror=Mt=>{var et="worker sent an error!";throw he(et+" "+Mt.filename+":"+Mt.lineno+": "+Mt.message),Mt},C&&(re.on("message",function(Mt){re.onmessage({data:Mt})}),re.on("error",function(Mt){re.onerror(Mt)}),re.on("detachedExit",function(){}));var Ye=[],bt=["onExit","onAbort","print","printErr"];for(var At of bt)c.hasOwnProperty(At)&&Ye.push(At);re.postMessage({cmd:"load",handlers:Ye,urlOrBlob:c.mainScriptUrlOrBlob||a,wasmMemory:de,wasmModule:Ce})},allocateUnusedWorker:function(){var re,Ie=D("tfjs-backend-wasm-threaded-simd.worker.js");re=new Worker(Ie),Ze.unusedWorkers.push(re)},getNewWorker:function(){return Ze.unusedWorkers.length==0&&(Ze.allocateUnusedWorker(),Ze.loadWasmModuleToWorker(Ze.unusedWorkers[0])),Ze.unusedWorkers.pop()}};c.PThread=Ze;function cn(re){for(;re.length>0;)re.shift()(c)}function Gt(){var re=ei(),Ie=o()[re+52>>>2],Ye=o()[re+56>>>2],bt=Ie-Ye;Xc(Ie,bt),gl(Ie)}c.establishStackSpace=Gt;function xt(re){if(T)return ps(2,0,re);try{Je(re)}catch(Ie){mt(Ie)}}var It=[];function Xn(re){var Ie=It[re];return Ie||(re>=It.length&&(It.length=re+1),It[re]=Ie=Re.get(re)),Ie}function Wa(re,Ie){var Ye=Xn(re)(Ie);en()?Ze.setExitStatus(Ye):xu(Ye)}c.invokeEntryPoint=Wa;function Li(re){Ze.tlsInitFunctions.push(re)}function go(re){wu(re,!E,1,!S),Ze.threadInitTLS()}function mi(re){T?postMessage({cmd:"cleanupThread",thread:re}):Va(re)}function bo(re,Ie,Ye,bt){return T?ps(3,1,re,Ie,Ye,bt):On(re,Ie,Ye,bt)}function On(re,Ie,Ye,bt){if(typeof SharedArrayBuffer>"u")return he("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var At=[],Mt=0;if(T&&(At.length===0||Mt))return bo(re,Ie,Ye,bt);var et={startRoutine:Ye,pthread_ptr:re,arg:bt,transferList:At};return T?(et.cmd="spawnThread",postMessage(et,At),0):cs(et)}function Sr(){return 65536}var zi=!0;function yo(){return zi}function ha(re){Atomics.store(o(),re>>2,1),ei()&&fa(re),Atomics.compareExchange(o(),re>>2,1,0)}c.executeNotifiedProxyingQueue=ha;function $h(re,Ie,Ye,bt){if(re==Ie)setTimeout(()=>ha(bt));else if(T)postMessage({targetThread:re,cmd:"processProxyingQueue",queue:bt});else{var At=Ze.pthreads[re];if(!At)return;At.postMessage({cmd:"processProxyingQueue",queue:bt})}return 1}function pu(re,Ie,Ye){return-1}function Qr(){ne("")}function pr(re){pr.shown||(pr.shown={}),pr.shown[re]||(pr.shown[re]=1,C&&(re="warning: "+re),he(re))}function wo(){C||E||pr("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function hu(){return Date.now()}function fu(){return 4294901760}function Ms(){return fu()}var ds;C?ds=()=>{var re=process.hrtime();return re[0]*1e3+re[1]/1e6}:ds=()=>performance.timeOrigin+performance.now();function mu(re,Ie,Ye){s().copyWithin(re>>>0,Ie>>>0,Ie+Ye>>>0)}function Zr(){return C?tW().cpus().length:navigator.hardwareConcurrency}function gu(re){var Ie=ml(),Ye=re();return gl(Ie),Ye}function ps(re,Ie){var Ye=arguments.length-2,bt=arguments;return gu(()=>{for(var At=Ye,Mt=vu(At*8),et=Mt>>3,st=0;st<Ye;st++){var Rn=bt[2+st];d()[et+st>>>0]=Rn}return zs(re,At,Mt,Ie)})}var Ui=[];function pl(re,Ie,Ye){Ui.length=Ie;for(var bt=Ye>>3,At=0;At<Ie;At++)Ui[At]=d()[bt+At>>>0];var Mt=re<0,et=Mt?hn[-re-1]:Zc[re];return et.apply(null,Ui)}function xo(re){try{return de.grow(re-Ke.byteLength+65535>>>16),Nt(de.buffer),1}catch{}}function nb(re){var Ie=s().length;if(re=re>>>0,re<=Ie)return!1;var Ye=fu();if(re>Ye)return!1;let bt=(Rn,qa)=>Rn+(qa-Rn%qa)%qa;for(var At=1;At<=4;At*=2){var Mt=Ie*(1+.2/At);Mt=Math.min(Mt,re+100663296);var et=Math.min(Ye,bt(Math.max(re,Mt),65536)),st=xo(et);if(st)return!0}return!1}function Qc(){throw"unwind"}function kr(re){return T?ps(4,1,re):52}function Xr(re,Ie,Ye,bt,At){return T?ps(5,1,re,Ie,Ye,bt,At):70}var hl=[null,[],[]];function hs(re,Ie){var Ye=hl[re];Ie===0||Ie===10?((re===1?ue:he)(_e(Ye,0)),Ye.length=0):Ye.push(Ie)}function Bs(re,Ie,Ye,bt){if(T)return ps(6,1,re,Ie,Ye,bt);for(var At=0,Mt=0;Mt<Ye;Mt++){var et=u()[Ie>>>2],st=u()[Ie+4>>>2];Ie+=8;for(var Rn=0;Rn<st;Rn++)hs(re,s()[et+Rn>>>0]);At+=st}return u()[bt>>>2]=At,0}function Ls(re){var Ie=c["_"+re];return Ie}function bu(re,Ie){i().set(re,Ie>>>0)}function hr(re,Ie,Ye,bt,At){var Mt={string:Mn=>{var Br=0;if(Mn!=null&&Mn!==0){var wl=(Mn.length<<2)+1;Br=vu(wl),$e(Mn,Br,wl)}return Br},array:Mn=>{var Br=vu(Mn.length);return bu(Mn,Br),Br}};function et(Mn){return Ie==="string"?Le(Mn):Ie==="boolean"?!!Mn:Mn}var st=Ls(re),Rn=[],qa=0;if(bt)for(var gi=0;gi<bt.length;gi++){var yl=Mt[Ye[gi]];yl?(qa===0&&(qa=ml()),Rn[gi]=yl(bt[gi])):Rn[gi]=bt[gi]}var vo=st.apply(null,Rn);function Jh(Mn){return qa!==0&&gl(qa),et(Mn)}return vo=Jh(vo),vo}function yu(re,Ie,Ye,bt){Ye=Ye||[];var At=Ye.every(et=>et==="number"||et==="boolean"),Mt=Ie!=="string";return Mt&&At&&!bt?Ls(re):function(){return hr(re,Ie,Ye,arguments)}}Ze.init();var Zc=[null,mo,xt,bo,kr,Xr,Bs],fl={__emscripten_init_main_thread_js:go,__emscripten_thread_cleanup:mi,__pthread_create_js:On,_emscripten_default_pthread_stack_size:Sr,_emscripten_get_now_is_monotonic:yo,_emscripten_notify_task_queue:$h,_emscripten_set_offscreencanvas_size:pu,abort:Qr,emscripten_check_blocking_allowed:wo,emscripten_date_now:hu,emscripten_get_heap_max:Ms,emscripten_get_now:ds,emscripten_memcpy_big:mu,emscripten_num_logical_cores:Zr,emscripten_receive_on_main_thread_js:pl,emscripten_resize_heap:nb,emscripten_unwind_to_js_event_loop:Qc,exit:Je,fd_close:kr,fd_seek:Xr,fd_write:Bs,memory:de||c.wasmMemory};on(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Acos=function(){return(c._Acos=c.asm.Acos).apply(null,arguments)},c._Acosh=function(){return(c._Acosh=c.asm.Acosh).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._ArgMin=function(){return(c._ArgMin=c.asm.ArgMin).apply(null,arguments)},c._Asin=function(){return(c._Asin=c.asm.Asin).apply(null,arguments)},c._Asinh=function(){return(c._Asinh=c.asm.Asinh).apply(null,arguments)},c._Atan=function(){return(c._Atan=c.asm.Atan).apply(null,arguments)},c._Atan2=function(){return(c._Atan2=c.asm.Atan2).apply(null,arguments)},c._Atanh=function(){return(c._Atanh=c.asm.Atanh).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._AvgPool3D=function(){return(c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},c._AvgPool3DGrad=function(){return(c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},c._AvgPoolGrad=function(){return(c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Bincount=function(){return(c._Bincount=c.asm.Bincount).apply(null,arguments)},c._BitwiseAnd=function(){return(c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Conv3D=function(){return(c._Conv3D=c.asm.Conv3D).apply(null,arguments)},c._Conv3DBackpropFilterV2=function(){return(c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},c._Conv3DBackpropInputV2=function(){return(c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DenseBincount=function(){return(c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Diag=function(){return(c._Diag=c.asm.Diag).apply(null,arguments)},c._Dilation2D=function(){return(c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},c._Dilation2DBackpropFilter=function(){return(c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},c._Dilation2DBackpropInput=function(){return(c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._EluGrad=function(){return(c._EluGrad=c.asm.EluGrad).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Erf=function(){return(c._Erf=c.asm.Erf).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._Expm1=function(){return(c._Expm1=c.asm.Expm1).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._IsFinite=function(){return(c._IsFinite=c.asm.IsFinite).apply(null,arguments)},c._IsInf=function(){return(c._IsInf=c.asm.IsInf).apply(null,arguments)},c._IsNan=function(){return(c._IsNan=c.asm.IsNan).apply(null,arguments)},c._LRN=function(){return(c._LRN=c.asm.LRN).apply(null,arguments)},c._LRNGrad=function(){return(c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._LinSpace=function(){return(c._LinSpace=c.asm.LinSpace).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._Log1p=function(){return(c._Log1p=c.asm.Log1p).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._MaxPool3D=function(){return(c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},c._MaxPool3DGrad=function(){return(c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},c._MaxPoolGrad=function(){return(c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},c._MaxPoolWithArgmax=function(){return(c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Mod=function(){return(c._Mod=c.asm.Mod).apply(null,arguments)},c._Multinomial=function(){return(c._Multinomial=c.asm.Multinomial).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Reciprocal=function(){return(c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeBilinearGrad=function(){return(c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._ResizeNearestNeighborGrad=function(){return(c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SearchSorted=function(){return(c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Selu=function(){return(c._Selu=c.asm.Selu).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sign=function(){return(c._Sign=c.asm.Sign).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Sinh=function(){return(c._Sinh=c.asm.Sinh).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._Softplus=function(){return(c._Softplus=c.asm.Softplus).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._SparseToDense=function(){return(c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._TensorScatterUpdate=function(){return(c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)};var ei=c._pthread_self=function(){return(ei=c._pthread_self=c.asm.pthread_self).apply(null,arguments)};c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)};var wu=c.__emscripten_thread_init=function(){return(wu=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)};c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var zs=c._emscripten_run_in_main_runtime_thread_js=function(){return(zs=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var fa=c.__emscripten_proxy_execute_task_queue=function(){return(fa=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},Mr=c.__emscripten_thread_free_data=function(){return(Mr=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},xu=c.__emscripten_thread_exit=function(){return(xu=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},Xc=c._emscripten_stack_set_limits=function(){return(Xc=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},ml=c.stackSave=function(){return(ml=c.stackSave=c.asm.stackSave).apply(null,arguments)},gl=c.stackRestore=function(){return(gl=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},vu=c.stackAlloc=function(){return(vu=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)},c.keepRuntimeAlive=en,c.wasmMemory=de,c.cwrap=yu,c.ExitStatus=fi,c.PThread=Ze;var fs;G=function re(){fs||bl(),fs||(G=re)};function bl(re){if(tn>0)return;if(T){h(c),Jn(),startWorker(c);return}if(Ht(),tn>0)return;function Ie(){fs||(fs=!0,c.calledRun=!0,!Y&&(Jn(),h(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),kn()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),Ie()},1)):Ie()}if(c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();bl();var Us;g&&(Us={uncaughtException:process.listeners("uncaughtException").filter(function(re){return!g.uncaughtException.indexOf(re)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(re){return!g.unhandledRejection.indexOf(re)>-1})});var ti;if(typeof WasmBackendModule<"u")ti=WasmBackendModule;else if(typeof r<"u")ti=r;else throw new Error("Could not find wasm module in post.js");if(Us){var Vs=ti._dispose;ti._dispose=function(){Vs(),Us.uncaughtException.forEach(function(re){process.removeListener("uncaughtException",re)}),Us.unhandledRejection.forEach(function(re){process.removeListener("unhandledRejection",re)})}}return r.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),aW=za((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),rW=za((e,t)=>{var n=(()=>{var a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(a=a||__filename),function(r){r=r||{};var i=typeof r<"u"?r:{},s,o;i.ready=new Promise(function(Me,Je){s=Me,o=Je});var u;typeof process<"u"&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d=Object.assign({},i),c=typeof window=="object",h=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",g="";function x(Me){return i.locateFile?i.locateFile(Me,g):g+Me}var v,S,E;if(m){var C=TA(),T=h3();h?g=T.dirname(g)+"/":g=__dirname+"/",v=(Me,Je)=>(Me=Pt(Me)?new URL(Me):T.normalize(Me),C.readFileSync(Me,Je?void 0:"utf8")),E=Me=>{var Je=v(Me,!0);return Je.buffer||(Je=new Uint8Array(Je)),Je},S=(Me,Je,mt)=>{Me=Pt(Me)?new URL(Me):T.normalize(Me),C.readFile(Me,function(Ze,cn){Ze?mt(Ze):Je(cn.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Me){if(!(Me instanceof en))throw Me}),process.on("unhandledRejection",function(Me){throw Me}),i.inspect=function(){return"[Emscripten Module object]"}}else(c||h)&&(h?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),a&&(g=a),g.indexOf("blob:")!==0?g=g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):g="",v=Me=>{var Je=new XMLHttpRequest;return Je.open("GET",Me,!1),Je.send(null),Je.responseText},h&&(E=Me=>{var Je=new XMLHttpRequest;return Je.open("GET",Me,!1),Je.responseType="arraybuffer",Je.send(null),new Uint8Array(Je.response)}),S=(Me,Je,mt)=>{var Ze=new XMLHttpRequest;Ze.open("GET",Me,!0),Ze.responseType="arraybuffer",Ze.onload=()=>{if(Ze.status==200||Ze.status==0&&Ze.response){Je(Ze.response);return}mt()},Ze.onerror=mt,Ze.send(null)});var N=i.print||console.log.bind(console),D=i.printErr||console.warn.bind(console);Object.assign(i,d),d=null,i.arguments&&i.arguments,i.thisProgram&&i.thisProgram,i.quit&&i.quit;var q;i.wasmBinary&&(q=i.wasmBinary),i.noExitRuntime,typeof WebAssembly!="object"&&_t("no native wasm support detected");var H,K=!1,j=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function te(Me,Je,mt){Je>>>=0;for(var Ze=Je+mt,cn=Je;Me[cn]&&!(cn>=Ze);)++cn;if(cn-Je>16&&Me.buffer&&j)return j.decode(Me.subarray(Je,cn));for(var Gt="";Je<cn;){var xt=Me[Je++];if(!(xt&128)){Gt+=String.fromCharCode(xt);continue}var It=Me[Je++]&63;if((xt&224)==192){Gt+=String.fromCharCode((xt&31)<<6|It);continue}var Xn=Me[Je++]&63;if((xt&240)==224?xt=(xt&15)<<12|It<<6|Xn:xt=(xt&7)<<18|It<<12|Xn<<6|Me[Je++]&63,xt<65536)Gt+=String.fromCharCode(xt);else{var Wa=xt-65536;Gt+=String.fromCharCode(55296|Wa>>10,56320|Wa&1023)}}return Gt}function Q(Me,Je){return Me>>>=0,Me?te(Z,Me,Je):""}function z(Me,Je,mt,Ze){if(mt>>>=0,!(Ze>0))return 0;for(var cn=mt,Gt=mt+Ze-1,xt=0;xt<Me.length;++xt){var It=Me.charCodeAt(xt);if(It>=55296&&It<=57343){var Xn=Me.charCodeAt(++xt);It=65536+((It&1023)<<10)|Xn&1023}if(It<=127){if(mt>=Gt)break;Je[mt++>>>0]=It}else if(It<=2047){if(mt+1>=Gt)break;Je[mt++>>>0]=192|It>>6,Je[mt++>>>0]=128|It&63}else if(It<=65535){if(mt+2>=Gt)break;Je[mt++>>>0]=224|It>>12,Je[mt++>>>0]=128|It>>6&63,Je[mt++>>>0]=128|It&63}else{if(mt+3>=Gt)break;Je[mt++>>>0]=240|It>>18,Je[mt++>>>0]=128|It>>12&63,Je[mt++>>>0]=128|It>>6&63,Je[mt++>>>0]=128|It&63}}return Je[mt>>>0]=0,mt-cn}function ae(Me,Je,mt){return z(Me,Z,Je,mt)}var ue,he,Z,se;function de(Me){ue=Me,i.HEAP8=he=new Int8Array(Me),i.HEAP16=new Int16Array(Me),i.HEAP32=new Int32Array(Me),i.HEAPU8=Z=new Uint8Array(Me),i.HEAPU16=new Uint16Array(Me),i.HEAPU32=se=new Uint32Array(Me),i.HEAPF32=new Float32Array(Me),i.HEAPF64=new Float64Array(Me)}i.INITIAL_MEMORY;var Ce=[],Y=[],ie=[];function xe(){if(i.preRun)for(typeof i.preRun=="function"&&(i.preRun=[i.preRun]);i.preRun.length;)Le(i.preRun.shift());Ht(Ce)}function me(){Ht(Y)}function _e(){if(i.postRun)for(typeof i.postRun=="function"&&(i.postRun=[i.postRun]);i.postRun.length;)$e(i.postRun.shift());Ht(ie)}function Le(Me){Ce.unshift(Me)}function qe(Me){Y.unshift(Me)}function $e(Me){ie.unshift(Me)}var Ke=0,rt=null;function ht(Me){Ke++,i.monitorRunDependencies&&i.monitorRunDependencies(Ke)}function kt(Me){if(Ke--,i.monitorRunDependencies&&i.monitorRunDependencies(Ke),Ke==0&&rt){var Je=rt;rt=null,Je()}}function _t(Me){i.onAbort&&i.onAbort(Me),Me="Aborted("+Me+")",D(Me),K=!0,Me+=". Build with -sASSERTIONS for more info.";var Je=new WebAssembly.RuntimeError(Me);throw o(Je),Je}var ln="data:application/octet-stream;base64,";function Nt(Me){return Me.startsWith(ln)}function Pt(Me){return Me.startsWith("file://")}var Re;Re="tfjs-backend-wasm.wasm",Nt(Re)||(Re=x(Re));function ft(Me){try{if(Me==Re&&q)return new Uint8Array(q);if(E)return E(Me);throw"both async and sync fetching of the wasm failed"}catch(Je){_t(Je)}}function wt(){if(!q&&(c||h)){if(typeof fetch=="function"&&!Pt(Re))return fetch(Re,{credentials:"same-origin"}).then(function(Me){if(!Me.ok)throw"failed to load wasm binary file at '"+Re+"'";return Me.arrayBuffer()}).catch(function(){return ft(Re)});if(S)return new Promise(function(Me,Je){S(Re,function(mt){Me(new Uint8Array(mt))},Je)})}return Promise.resolve().then(function(){return ft(Re)})}function oa(){var Me={env:Rt,wasi_snapshot_preview1:Rt};function Je(xt,It){var Xn=xt.exports;i.asm=Xn,H=i.asm.memory,de(H.buffer),i.asm.__indirect_function_table,qe(i.asm.__wasm_call_ctors),kt()}ht();function mt(xt){Je(xt.instance)}function Ze(xt){return wt().then(function(It){return WebAssembly.instantiate(It,Me)}).then(function(It){return It}).then(xt,function(It){D("failed to asynchronously prepare wasm: "+It),_t(It)})}function cn(){return!q&&typeof WebAssembly.instantiateStreaming=="function"&&!Nt(Re)&&!Pt(Re)&&!m&&typeof fetch=="function"?fetch(Re,{credentials:"same-origin"}).then(function(xt){var It=WebAssembly.instantiateStreaming(xt,Me);return It.then(mt,function(Xn){return D("wasm streaming compile failed: "+Xn),D("falling back to ArrayBuffer instantiation"),Ze(mt)})}):Ze(mt)}if(i.instantiateWasm)try{var Gt=i.instantiateWasm(Me,Je);return Gt}catch(xt){D("Module.instantiateWasm callback failed with error: "+xt),o(xt)}return cn().catch(o),{}}function en(Me){this.name="ExitStatus",this.message="Program terminated with exit("+Me+")",this.status=Me}function Ht(Me){for(;Me.length>0;)Me.shift()(i)}function Jn(){_t("")}function kn(){return 4294901760}function pa(){return kn()}function Na(Me,Je,mt){Z.copyWithin(Me>>>0,Je>>>0,Je+mt>>>0)}function An(Me){try{return H.grow(Me-ue.byteLength+65535>>>16),de(H.buffer),1}catch{}}function tn(Me){var Je=Z.length;Me=Me>>>0;var mt=kn();if(Me>mt)return!1;let Ze=(Xn,Wa)=>Xn+(Wa-Xn%Wa)%Wa;for(var cn=1;cn<=4;cn*=2){var Gt=Je*(1+.2/cn);Gt=Math.min(Gt,Me+100663296);var xt=Math.min(mt,Ze(Math.max(Me,Gt),65536)),It=An(xt);if(It)return!0}return!1}function G(Me){return 52}function F(Me,Je,mt,Ze,cn){return 70}var L=[null,[],[]];function ne(Me,Je){var mt=L[Me];Je===0||Je===10?((Me===1?N:D)(te(mt,0)),mt.length=0):mt.push(Je)}function ke(Me,Je,mt,Ze){for(var cn=0,Gt=0;Gt<mt;Gt++){var xt=se[Je>>>2],It=se[Je+4>>>2];Je+=8;for(var Xn=0;Xn<It;Xn++)ne(Me,Z[xt+Xn>>>0]);cn+=It}return se[Ze>>>2]=cn,0}function ve(Me){var Je=i["_"+Me];return Je}function ze(Me,Je){he.set(Me,Je>>>0)}function ot(Me,Je,mt,Ze,cn){var Gt={string:On=>{var Sr=0;if(On!=null&&On!==0){var zi=(On.length<<2)+1;Sr=fi(zi),ae(On,Sr,zi)}return Sr},array:On=>{var Sr=fi(On.length);return ze(On,Sr),Sr}};function xt(On){return Je==="string"?Q(On):Je==="boolean"?!!On:On}var It=ve(Me),Xn=[],Wa=0;if(Ze)for(var Li=0;Li<Ze.length;Li++){var go=Gt[mt[Li]];go?(Wa===0&&(Wa=on()),Xn[Li]=go(Ze[Li])):Xn[Li]=Ze[Li]}var mi=It.apply(null,Xn);function bo(On){return Wa!==0&&hn(Wa),xt(On)}return mi=bo(mi),mi}function Lt(Me,Je,mt,Ze){mt=mt||[];var cn=mt.every(xt=>xt==="number"||xt==="boolean"),Gt=Je!=="string";return Gt&&cn&&!Ze?ve(Me):function(){return ot(Me,Je,mt,arguments)}}var Rt={abort:Jn,emscripten_get_heap_max:pa,emscripten_memcpy_big:Na,emscripten_resize_heap:tn,fd_close:G,fd_seek:F,fd_write:ke};oa(),i.___wasm_call_ctors=function(){return(i.___wasm_call_ctors=i.asm.__wasm_call_ctors).apply(null,arguments)},i._init=function(){return(i._init=i.asm.init).apply(null,arguments)},i._init_with_threads_count=function(){return(i._init_with_threads_count=i.asm.init_with_threads_count).apply(null,arguments)},i._get_threads_count=function(){return(i._get_threads_count=i.asm.get_threads_count).apply(null,arguments)},i._register_tensor=function(){return(i._register_tensor=i.asm.register_tensor).apply(null,arguments)},i._dispose_data=function(){return(i._dispose_data=i.asm.dispose_data).apply(null,arguments)},i._dispose=function(){return(i._dispose=i.asm.dispose).apply(null,arguments)},i._Abs=function(){return(i._Abs=i.asm.Abs).apply(null,arguments)},i._Acos=function(){return(i._Acos=i.asm.Acos).apply(null,arguments)},i._Acosh=function(){return(i._Acosh=i.asm.Acosh).apply(null,arguments)},i._Add=function(){return(i._Add=i.asm.Add).apply(null,arguments)},i._AddN=function(){return(i._AddN=i.asm.AddN).apply(null,arguments)},i._All=function(){return(i._All=i.asm.All).apply(null,arguments)},i._Any=function(){return(i._Any=i.asm.Any).apply(null,arguments)},i._ArgMax=function(){return(i._ArgMax=i.asm.ArgMax).apply(null,arguments)},i._ArgMin=function(){return(i._ArgMin=i.asm.ArgMin).apply(null,arguments)},i._Asin=function(){return(i._Asin=i.asm.Asin).apply(null,arguments)},i._Asinh=function(){return(i._Asinh=i.asm.Asinh).apply(null,arguments)},i._Atan=function(){return(i._Atan=i.asm.Atan).apply(null,arguments)},i._Atan2=function(){return(i._Atan2=i.asm.Atan2).apply(null,arguments)},i._Atanh=function(){return(i._Atanh=i.asm.Atanh).apply(null,arguments)},i._AvgPool=function(){return(i._AvgPool=i.asm.AvgPool).apply(null,arguments)},i._AvgPool3D=function(){return(i._AvgPool3D=i.asm.AvgPool3D).apply(null,arguments)},i._AvgPool3DGrad=function(){return(i._AvgPool3DGrad=i.asm.AvgPool3DGrad).apply(null,arguments)},i._AvgPoolGrad=function(){return(i._AvgPoolGrad=i.asm.AvgPoolGrad).apply(null,arguments)},i._BatchMatMul=function(){return(i._BatchMatMul=i.asm.BatchMatMul).apply(null,arguments)},i._Bincount=function(){return(i._Bincount=i.asm.Bincount).apply(null,arguments)},i._BitwiseAnd=function(){return(i._BitwiseAnd=i.asm.BitwiseAnd).apply(null,arguments)},i._Ceil=function(){return(i._Ceil=i.asm.Ceil).apply(null,arguments)},i._ClipByValue=function(){return(i._ClipByValue=i.asm.ClipByValue).apply(null,arguments)},i._Conv2D=function(){return(i._Conv2D=i.asm.Conv2D).apply(null,arguments)},i._Conv2DBackpropInput=function(){return(i._Conv2DBackpropInput=i.asm.Conv2DBackpropInput).apply(null,arguments)},i._Conv3D=function(){return(i._Conv3D=i.asm.Conv3D).apply(null,arguments)},i._Conv3DBackpropFilterV2=function(){return(i._Conv3DBackpropFilterV2=i.asm.Conv3DBackpropFilterV2).apply(null,arguments)},i._Conv3DBackpropInputV2=function(){return(i._Conv3DBackpropInputV2=i.asm.Conv3DBackpropInputV2).apply(null,arguments)},i._Cos=function(){return(i._Cos=i.asm.Cos).apply(null,arguments)},i._Cosh=function(){return(i._Cosh=i.asm.Cosh).apply(null,arguments)},i._CropAndResize=function(){return(i._CropAndResize=i.asm.CropAndResize).apply(null,arguments)},i._Cumprod=function(){return(i._Cumprod=i.asm.Cumprod).apply(null,arguments)},i._Cumsum=function(){return(i._Cumsum=i.asm.Cumsum).apply(null,arguments)},i._DenseBincount=function(){return(i._DenseBincount=i.asm.DenseBincount).apply(null,arguments)},i._DepthToSpace=function(){return(i._DepthToSpace=i.asm.DepthToSpace).apply(null,arguments)},i._DepthwiseConv2dNative=function(){return(i._DepthwiseConv2dNative=i.asm.DepthwiseConv2dNative).apply(null,arguments)},i._Diag=function(){return(i._Diag=i.asm.Diag).apply(null,arguments)},i._Dilation2D=function(){return(i._Dilation2D=i.asm.Dilation2D).apply(null,arguments)},i._Dilation2DBackpropFilter=function(){return(i._Dilation2DBackpropFilter=i.asm.Dilation2DBackpropFilter).apply(null,arguments)},i._Dilation2DBackpropInput=function(){return(i._Dilation2DBackpropInput=i.asm.Dilation2DBackpropInput).apply(null,arguments)},i._Elu=function(){return(i._Elu=i.asm.Elu).apply(null,arguments)},i._EluGrad=function(){return(i._EluGrad=i.asm.EluGrad).apply(null,arguments)},i._Equal=function(){return(i._Equal=i.asm.Equal).apply(null,arguments)},i._Erf=function(){return(i._Erf=i.asm.Erf).apply(null,arguments)},i._Exp=function(){return(i._Exp=i.asm.Exp).apply(null,arguments)},i._Expm1=function(){return(i._Expm1=i.asm.Expm1).apply(null,arguments)},i._FlipLeftRight=function(){return(i._FlipLeftRight=i.asm.FlipLeftRight).apply(null,arguments)},i._Floor=function(){return(i._Floor=i.asm.Floor).apply(null,arguments)},i._FloorDiv=function(){return(i._FloorDiv=i.asm.FloorDiv).apply(null,arguments)},i._FusedBatchNorm=function(){return(i._FusedBatchNorm=i.asm.FusedBatchNorm).apply(null,arguments)},i._FusedConv2D=function(){return(i._FusedConv2D=i.asm.FusedConv2D).apply(null,arguments)},i._FusedDepthwiseConv2D=function(){return(i._FusedDepthwiseConv2D=i.asm.FusedDepthwiseConv2D).apply(null,arguments)},i._Gather=function(){return(i._Gather=i.asm.Gather).apply(null,arguments)},i._GatherNd=function(){return(i._GatherNd=i.asm.GatherNd).apply(null,arguments)},i._Greater=function(){return(i._Greater=i.asm.Greater).apply(null,arguments)},i._GreaterEqual=function(){return(i._GreaterEqual=i.asm.GreaterEqual).apply(null,arguments)},i._IsFinite=function(){return(i._IsFinite=i.asm.IsFinite).apply(null,arguments)},i._IsInf=function(){return(i._IsInf=i.asm.IsInf).apply(null,arguments)},i._IsNan=function(){return(i._IsNan=i.asm.IsNan).apply(null,arguments)},i._LRN=function(){return(i._LRN=i.asm.LRN).apply(null,arguments)},i._LRNGrad=function(){return(i._LRNGrad=i.asm.LRNGrad).apply(null,arguments)},i._LeakyRelu=function(){return(i._LeakyRelu=i.asm.LeakyRelu).apply(null,arguments)},i._Less=function(){return(i._Less=i.asm.Less).apply(null,arguments)},i._LessEqual=function(){return(i._LessEqual=i.asm.LessEqual).apply(null,arguments)},i._LinSpace=function(){return(i._LinSpace=i.asm.LinSpace).apply(null,arguments)},i._Log=function(){return(i._Log=i.asm.Log).apply(null,arguments)},i._Log1p=function(){return(i._Log1p=i.asm.Log1p).apply(null,arguments)},i._LogicalAnd=function(){return(i._LogicalAnd=i.asm.LogicalAnd).apply(null,arguments)},i._LogicalNot=function(){return(i._LogicalNot=i.asm.LogicalNot).apply(null,arguments)},i._LogicalOr=function(){return(i._LogicalOr=i.asm.LogicalOr).apply(null,arguments)},i._LogicalXor=function(){return(i._LogicalXor=i.asm.LogicalXor).apply(null,arguments)},i._Max=function(){return(i._Max=i.asm.Max).apply(null,arguments)},i._MaxPool=function(){return(i._MaxPool=i.asm.MaxPool).apply(null,arguments)},i._MaxPool3D=function(){return(i._MaxPool3D=i.asm.MaxPool3D).apply(null,arguments)},i._MaxPool3DGrad=function(){return(i._MaxPool3DGrad=i.asm.MaxPool3DGrad).apply(null,arguments)},i._MaxPoolGrad=function(){return(i._MaxPoolGrad=i.asm.MaxPoolGrad).apply(null,arguments)},i._MaxPoolWithArgmax=function(){return(i._MaxPoolWithArgmax=i.asm.MaxPoolWithArgmax).apply(null,arguments)},i._Maximum=function(){return(i._Maximum=i.asm.Maximum).apply(null,arguments)},i._Mean=function(){return(i._Mean=i.asm.Mean).apply(null,arguments)},i._Min=function(){return(i._Min=i.asm.Min).apply(null,arguments)},i._Minimum=function(){return(i._Minimum=i.asm.Minimum).apply(null,arguments)},i._MirrorPad=function(){return(i._MirrorPad=i.asm.MirrorPad).apply(null,arguments)},i._Mod=function(){return(i._Mod=i.asm.Mod).apply(null,arguments)},i._Multinomial=function(){return(i._Multinomial=i.asm.Multinomial).apply(null,arguments)},i._Multiply=function(){return(i._Multiply=i.asm.Multiply).apply(null,arguments)},i._Neg=function(){return(i._Neg=i.asm.Neg).apply(null,arguments)},i._NonMaxSuppressionV3=function(){return(i._NonMaxSuppressionV3=i.asm.NonMaxSuppressionV3).apply(null,arguments)},i._NonMaxSuppressionV4=function(){return(i._NonMaxSuppressionV4=i.asm.NonMaxSuppressionV4).apply(null,arguments)},i._NonMaxSuppressionV5=function(){return(i._NonMaxSuppressionV5=i.asm.NonMaxSuppressionV5).apply(null,arguments)},i._NotEqual=function(){return(i._NotEqual=i.asm.NotEqual).apply(null,arguments)},i._OneHot=function(){return(i._OneHot=i.asm.OneHot).apply(null,arguments)},i._PadV2=function(){return(i._PadV2=i.asm.PadV2).apply(null,arguments)},i._Pow=function(){return(i._Pow=i.asm.Pow).apply(null,arguments)},i._Prelu=function(){return(i._Prelu=i.asm.Prelu).apply(null,arguments)},i._Prod=function(){return(i._Prod=i.asm.Prod).apply(null,arguments)},i._RealDiv=function(){return(i._RealDiv=i.asm.RealDiv).apply(null,arguments)},i._Reciprocal=function(){return(i._Reciprocal=i.asm.Reciprocal).apply(null,arguments)},i._Relu=function(){return(i._Relu=i.asm.Relu).apply(null,arguments)},i._Relu6=function(){return(i._Relu6=i.asm.Relu6).apply(null,arguments)},i._ResizeBilinear=function(){return(i._ResizeBilinear=i.asm.ResizeBilinear).apply(null,arguments)},i._ResizeBilinearGrad=function(){return(i._ResizeBilinearGrad=i.asm.ResizeBilinearGrad).apply(null,arguments)},i._ResizeNearestNeighbor=function(){return(i._ResizeNearestNeighbor=i.asm.ResizeNearestNeighbor).apply(null,arguments)},i._ResizeNearestNeighborGrad=function(){return(i._ResizeNearestNeighborGrad=i.asm.ResizeNearestNeighborGrad).apply(null,arguments)},i._Reverse=function(){return(i._Reverse=i.asm.Reverse).apply(null,arguments)},i._RotateWithOffset=function(){return(i._RotateWithOffset=i.asm.RotateWithOffset).apply(null,arguments)},i._Round=function(){return(i._Round=i.asm.Round).apply(null,arguments)},i._Rsqrt=function(){return(i._Rsqrt=i.asm.Rsqrt).apply(null,arguments)},i._ScatterNd=function(){return(i._ScatterNd=i.asm.ScatterNd).apply(null,arguments)},i._SearchSorted=function(){return(i._SearchSorted=i.asm.SearchSorted).apply(null,arguments)},i._SelectV2=function(){return(i._SelectV2=i.asm.SelectV2).apply(null,arguments)},i._Selu=function(){return(i._Selu=i.asm.Selu).apply(null,arguments)},i._Sigmoid=function(){return(i._Sigmoid=i.asm.Sigmoid).apply(null,arguments)},i._Sign=function(){return(i._Sign=i.asm.Sign).apply(null,arguments)},i._Sin=function(){return(i._Sin=i.asm.Sin).apply(null,arguments)},i._Sinh=function(){return(i._Sinh=i.asm.Sinh).apply(null,arguments)},i._Softmax=function(){return(i._Softmax=i.asm.Softmax).apply(null,arguments)},i._Softplus=function(){return(i._Softplus=i.asm.Softplus).apply(null,arguments)},i._SparseFillEmptyRows=function(){return(i._SparseFillEmptyRows=i.asm.SparseFillEmptyRows).apply(null,arguments)},i._SparseReshape=function(){return(i._SparseReshape=i.asm.SparseReshape).apply(null,arguments)},i._SparseSegmentReduction=function(){return(i._SparseSegmentReduction=i.asm.SparseSegmentReduction).apply(null,arguments)},i._SparseToDense=function(){return(i._SparseToDense=i.asm.SparseToDense).apply(null,arguments)},i._Sqrt=function(){return(i._Sqrt=i.asm.Sqrt).apply(null,arguments)},i._Square=function(){return(i._Square=i.asm.Square).apply(null,arguments)},i._SquaredDifference=function(){return(i._SquaredDifference=i.asm.SquaredDifference).apply(null,arguments)},i._Step=function(){return(i._Step=i.asm.Step).apply(null,arguments)},i._StridedSlice=function(){return(i._StridedSlice=i.asm.StridedSlice).apply(null,arguments)},i._Sub=function(){return(i._Sub=i.asm.Sub).apply(null,arguments)},i._Sum=function(){return(i._Sum=i.asm.Sum).apply(null,arguments)},i._Tan=function(){return(i._Tan=i.asm.Tan).apply(null,arguments)},i._Tanh=function(){return(i._Tanh=i.asm.Tanh).apply(null,arguments)},i._TensorScatterUpdate=function(){return(i._TensorScatterUpdate=i.asm.TensorScatterUpdate).apply(null,arguments)},i._Tile=function(){return(i._Tile=i.asm.Tile).apply(null,arguments)},i._TopK=function(){return(i._TopK=i.asm.TopK).apply(null,arguments)},i._Transform=function(){return(i._Transform=i.asm.Transform).apply(null,arguments)},i._Transpose=function(){return(i._Transpose=i.asm.Transpose).apply(null,arguments)},i.__FusedMatMul=function(){return(i.__FusedMatMul=i.asm._FusedMatMul).apply(null,arguments)},i._malloc=function(){return(i._malloc=i.asm.malloc).apply(null,arguments)},i._free=function(){return(i._free=i.asm.free).apply(null,arguments)},i.___errno_location=function(){return(i.___errno_location=i.asm.__errno_location).apply(null,arguments)};var on=i.stackSave=function(){return(on=i.stackSave=i.asm.stackSave).apply(null,arguments)},hn=i.stackRestore=function(){return(hn=i.stackRestore=i.asm.stackRestore).apply(null,arguments)},fi=i.stackAlloc=function(){return(fi=i.stackAlloc=i.asm.stackAlloc).apply(null,arguments)};i.dynCall_iijjiiii=function(){return(i.dynCall_iijjiiii=i.asm.dynCall_iijjiiii).apply(null,arguments)},i.dynCall_jiji=function(){return(i.dynCall_jiji=i.asm.dynCall_jiji).apply(null,arguments)},i.cwrap=Lt;var ls;rt=function Me(){ls||us(),ls||(rt=Me)};function us(Me){if(Ke>0||(xe(),Ke>0))return;function Je(){ls||(ls=!0,i.calledRun=!0,!K&&(me(),s(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),_e()))}i.setStatus?(i.setStatus("Running..."),setTimeout(function(){setTimeout(function(){i.setStatus("")},1),Je()},1)):Je()}if(i.preInit)for(typeof i.preInit=="function"&&(i.preInit=[i.preInit]);i.preInit.length>0;)i.preInit.pop()();us();var Va;u&&(Va={uncaughtException:process.listeners("uncaughtException").filter(function(Me){return!u.uncaughtException.indexOf(Me)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(Me){return!u.unhandledRejection.indexOf(Me)>-1})});var cs;if(typeof r<"u")cs=r;else if(typeof WasmBackendModuleThreadedSimd<"u")cs=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Va){var mo=cs._dispose;cs._dispose=function(){mo(),Va.uncaughtException.forEach(function(Me){process.removeListener("uncaughtException",Me)}),Va.unhandledRejection.forEach(function(Me){process.removeListener("unhandledRejection",Me)})}}return r.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),ev=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},u0=class{refCount(e){return ki("refCount")}incRef(e){return ki("incRef")}timerAvailable(){return!0}time(e){return ki("time")}read(e){return ki("read")}readSync(e){return ki("readSync")}readToGPU(e,t){return ki("readToGPU")}numDataIds(){return ki("numDataIds")}disposeData(e,t){return ki("disposeData")}write(e,t,n){return ki("write")}move(e,t,n,a,r){return ki("move")}createTensorFromGPUData(e,t,n){return ki("createTensorFromGPUData")}memory(){return ki("memory")}floatPrecision(){return ki("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return ki("dispose")}};function ki(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function f3(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,x1(e,t,n)}function iW(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,a=0;for(;n>0;)a=Math.random()*n|0,n--,x1(e,n,a),x1(t,n,a)}function Gy(e,t,n){return Math.max(e,Math.min(t,n))}function sW(e){return e%2===0?e:e+1}function x1(e,t,n){let a=e[t];e[t]=e[n],e[n]=a}function oW(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function lW(e,t){let n=Math.random();return t*n+(1-n)*e}function uW(e,t){let n=0;for(let a=0;a<e.length;a++){let r=Number(e[a])-Number(t[a]);n+=r*r}return n}function ee(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function $r(e,t,n=""){ee(ru(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function gp(e){ee(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Un(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function cW(e){return e.length===0}function m3(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function ru(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function fm(e){return e%1===0}function dW(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function pW(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function hW(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return f3(t),t}function Ly(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function fW(e,t=r=>0,n,a){return new Promise((r,i)=>{let s=0,o=()=>{if(e()){r();return}s++;let u=t(s);if(n!=null&&s>=n){i();return}a!=null?a(o,u):setTimeout(o,u)};o()})}function mW(e,t){let n=1,a=-1;for(let i=0;i<e.length;++i)if(e[i]>=0)n*=e[i];else if(e[i]===-1){if(a!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${a} and dim ${i}`);a=i}else if(e[i]<0)throw Error(`Shapes can not be < 0. Found ${e[i]} at dim ${i}`);if(a===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let r=e.slice();return r[a]=t/n,r}function Fs(e,t){let n=t.length;return e=e==null?t.map((a,r)=>r):[].concat(e),ee(e.every(a=>a>=-n&&a<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),ee(e.every(a=>fm(a)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(a=>a<0?n+a:a)}function g3(e,t){let n=[],a=[],r=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||r?null:Fs(t,e).sort(),s=0;for(let o=0;o<e.length;++o){if(i!=null){if(i[s]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(i[s]==null||i[s]>o)&&e[o]===1&&(n.push(e[o]),a.push(o)),i[s]<=o&&s++}e[o]!==1&&(n.push(e[o]),a.push(o))}return{newShape:n,keptDims:a}}function b3(e,t){return NA(e,t)}function NA(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function y3(e,t){for(let n=0;n<e.length;n++){let a=e[n];if(isNaN(a)||!isFinite(a))throw Error(`A tensor of type ${t} being uploaded contains ${a}.`)}}function w3(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function gW(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function v1(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function x3(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function dc(e){return typeof e=="string"||e instanceof String}function v3(e){return typeof e=="boolean"}function S3(e){return typeof e=="number"}function c0(e){return Array.isArray(e)?c0(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":S3(e)?"float32":dc(e)?"string":v3(e)?"bool":"float32"}function yc(e){return!!(e&&e.constructor&&e.call&&e.apply)}function S1(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Fm(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function k3(e,t,n,a=!1){let r=new Array;if(t.length===1){let i=t[0]*(a?2:1);for(let s=0;s<i;s++)r[s]=n[e+s]}else{let i=t[0],s=t.slice(1),o=s.reduce((u,d)=>u*d)*(a?2:1);for(let u=0;u<i;u++)r[u]=k3(e+u*o,s,n,a)}return r}function lm(e,t,n=!1){if(e.length===0)return t[0];let a=e.reduce((r,i)=>r*i)*(n?2:1);if(a===0)return[];if(a!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return k3(0,e,t,n)}function bW(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function RA(e,t){let n=tv(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function tv(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function yW(e,t){let n=e.reduce((a,r)=>a*r,1);if(t==null||t==="float32")return lm(e,new Float32Array(n));if(t==="int32")return lm(e,new Int32Array(n));if(t==="bool")return lm(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Bi(e){e.forEach(t=>{ee(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function wW(e,t,n){if(t===0)return 0;if(t===1)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function xW(e,t,n){if(t===0)return[];if(t===1)return[e];let a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function nv(e){return e&&e.then&&typeof e.then=="function"}var gN="tfjsflags",A3=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=vW,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Ae().getBool("IS_TEST")||Ae().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let a=this.urlFlags[e];Ae().getBool("IS_TEST")||Ae().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${a}.`),this.set(e,a)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(nv(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);gN in e&&e[gN].split(",").forEach(t=>{let[n,a]=t.split(":");this.urlFlags[n]=kW(n,a)})}};function vW(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...a)=>(SW(t,a[0],a[1]),a.join("="))),t}function SW(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function kW(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function Ae(){return FA}var FA=null;function AW(e){FA=e}var J2;function E3(){if(J2==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");J2=e}return J2}function EW(){let e=E3();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function DA(e,t){let n=EW();if(n.has(e))return n.get(e);{let a=t();return n.set(e,a),n.get(e)}}var Dm="Abs",bp="Acos",yp="Acosh",Mc="Add",wp="AddN",Om="All",Mm="Any",Bm="ArgMax",Lm="ArgMin",xp="Asin",vp="Asinh",Sp="Atan",kp="Atanh",Ap="Atan2",Ep="AvgPool",d0="AvgPoolGrad",zm="AvgPool3D",p0="AvgPool3DGrad",Cp="BatchMatMul",Um="BatchToSpaceND",Vm="Bincount",Wm="BitwiseAnd",C3="BroadcastTo",h0="BroadcastArgs",Ip="Cast",_p="Ceil",Bc="ClipByValue",av="Complex",f0="ComplexAbs",qm="Concat",Tp="Conv2D",rv="Conv2DBackpropFilter",Np="Conv2DBackpropInput",Rp="Conv3D",Pm="Conv3DBackpropFilterV2",Hm="Conv3DBackpropInputV2",Fp="Cos",Dp="Cosh",Gm="Cumprod",Op="Cumsum",Km="CropAndResize",m0="DenseBincount",$m="DepthToSpace",Mp="DepthwiseConv2dNative",iv="DepthwiseConv2dNativeBackpropFilter",sv="DepthwiseConv2dNativeBackpropInput",g0="Diag",Bp="Dilation2D",mm="Dilation2DBackpropInput",gm="Dilation2DBackpropFilter",ov="Draw",Lp="RealDiv",lv="Einsum",zp="Elu",Jm="EluGrad",Up="Erf",Ym="Equal",Vp="Exp",jm="ExpandDims",Wp="Expm1",uv="FFT",b0="Fill",Qm="FlipLeftRight",qp="Floor",Pp="FloorDiv",Hp="FusedBatchNorm",Zm="GatherV2",Xm="GatherNd",eg="Greater",Gp="GreaterEqual",Kp="Identity",cv="IFFT",dv="Imag",$p="IsFinite",Jp="IsInf",Yp="IsNan",jp="LeakyRelu",tg="Less",ng="LessEqual",ag="LinSpace",Qp="Log",Zp="Log1p",rg="LogicalAnd",ig="LogicalNot",sg="LogicalOr",I3="LogicalXor",_3="LogSoftmax",CW="LowerBound",Xp="LRN",og="LRNGrad",IW="MatrixBandPart",eh="Max",th="Maximum",nh="MaxPool",y0="MaxPoolGrad",lg="MaxPool3D",w0="MaxPool3DGrad",x0="MaxPoolWithArgmax",ah="Mean",rh="Min",ih="Minimum",sh="MirrorPad",oh="Mod",ug="Multinomial",lh="Multiply",cg="Neg",dg="NotEqual",pg="NonMaxSuppressionV3",hg="NonMaxSuppressionV4",fg="NonMaxSuppressionV5",mg="OnesLike",uh="OneHot",gg="Pack",ch="PadV2",_W="Pool",dh="Pow",ph="Prelu",hh="Prod",pv="RaggedGather",hv="RaggedRange",fv="RaggedTensorToTensor",v0="Range",mv="Real",fh="Reciprocal",mh="Relu",bg="Reshape",gh="ResizeNearestNeighbor",yg="ResizeNearestNeighborGrad",bh="ResizeBilinear",wg="ResizeBilinearGrad",yh="Relu6",wh="Reverse",xh="Round",vh="Rsqrt",xg="ScatterNd",vg="TensorScatterUpdate",Sg="SearchSorted",kg="Select",Sh="Selu",Ag="Slice",kh="Sin",Ah="Sinh",Eh="Sign",Ch="Sigmoid",Ih="Softplus",_h="Sqrt",Th="Sum",Eg="SpaceToBatchND",Cg="SplitV",Nh="Softmax",S0="SparseFillEmptyRows",Ig="SparseReshape",k0="SparseSegmentMean",A0="SparseSegmentSum",_g="SparseToDense",Rh="SquaredDifference",E0="Square",C0="StaticRegexReplace",Tg="StridedSlice",I0="StringNGrams",_0="StringSplit",T0="StringToHashBucketFast",Fh="Sub",Dh="Tan",Oh="Tanh",Lc="Tile",Ng="TopK",Rg="Transform",Xl="Transpose",N0="Unique",Fg="Unpack",R0="UnsortedSegmentSum",TW="UpperBound",Dg="ZerosLike",zc="Step",k1="FromPixels",Og="RotateWithOffset",jd="_FusedMatMul",Qd="FusedConv2D",Zd="FusedDepthwiseConv2D";function cc(...e){Ae().getBool("IS_TEST")||Ae().getBool("PROD")||console.warn(...e)}function NW(...e){Ae().getBool("IS_TEST")||Ae().getBool("PROD")||console.log(...e)}var bm=DA("kernelRegistry",()=>new Map),Ky=DA("gradRegistry",()=>new Map);function $y(e,t){let n=OA(e,t);return bm.get(n)}function gk(e){return Ky.get(e)}function A1(e){let t=bm.entries(),n=[];for(;;){let{done:a,value:r}=t.next();if(a)break;let[i,s]=r,[o]=i.split("_");o===e&&n.push(s)}return n}function F0(e){let{kernelName:t,backendName:n}=e,a=OA(t,n);bm.has(a)&&cc(`The kernel '${t}' for backend '${n}' is already registered`),bm.set(a,e)}function T3(e){let{kernelName:t}=e;Ky.has(t)&&Ae().getBool("DEBUG")&&cc(`Overriding the gradient for '${t}'`),Ky.set(t,e)}function RW(e,t){let n=OA(e,t);if(!bm.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);bm.delete(n)}function FW(e){if(!Ky.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);Ky.delete(e)}function DW(e,t){A1(e).forEach(n=>{let a=Object.assign({},n,{backendName:t});F0(a)})}function OA(e,t){return`${t}_${e}`}var O={};qt(O,{arraysEqual:()=>ru,arraysEqualWithNull:()=>m3,assert:()=>ee,assertNonNegativeIntegerDimensions:()=>Bi,assertNonNull:()=>gp,assertShapesMatch:()=>$r,bytesFromStringArray:()=>x3,bytesPerElement:()=>v1,checkConversionForErrors:()=>y3,clamp:()=>Gy,computeStrides:()=>Fm,convertBackendValuesAndArrayBuffer:()=>bW,createScalarValue:()=>UW,createShuffledIndices:()=>hW,decodeString:()=>E1,distSquared:()=>uW,encodeString:()=>O0,fetch:()=>WW,fingerPrint64:()=>zW,flatten:()=>wc,getArrayFromDType:()=>NA,getTypedArrayFromDType:()=>b3,hasEncodingLoss:()=>gW,hexToLong:()=>D0,indexToLoc:()=>xW,inferDtype:()=>c0,inferFromImplicitShape:()=>mW,isBoolean:()=>v3,isFunction:()=>yc,isInt:()=>fm,isNumber:()=>S3,isPromise:()=>nv,isScalarShape:()=>cW,isString:()=>dc,isTypedArray:()=>ir,isValidDtype:()=>w3,locToIndex:()=>wW,makeOnesTypedArray:()=>RA,makeZerosNestedTypedArray:()=>yW,makeZerosTypedArray:()=>tv,nearestDivisor:()=>S1,nearestLargerEven:()=>sW,now:()=>Jy,parseAxisParam:()=>Fs,randUniform:()=>lW,repeatedTry:()=>fW,rightPad:()=>Ly,shuffle:()=>f3,shuffleCombo:()=>iW,sizeFromShape:()=>Un,sizeToSquarishShape:()=>pW,squeezeShape:()=>g3,sum:()=>oW,swap:()=>x1,tanh:()=>dW,toNestedArray:()=>lm,toTypedArray:()=>gv});function N3(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var bN=Oc(q6()),zd=bN.default||bN;function D0(e){return zd.fromString(e,!0,16)}var R3=D0("c3a5c85c97cb3127"),Md=D0("b492b66fbe98f273"),Vr=D0("9ae16a3b2f90404f");function bk(e){return e.xor(e.shru(47))}function F3(e,t,n){let a=e.slice(t,t+n);return zd.fromBytes(Array.from(a),!0,!0)}function ra(e,t){return F3(e,t,8)}function yN(e,t){return F3(e,t,4)}function rr(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function mc(e,t,n=D0("9ddfea08eb382d69")){let a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function OW(e,t,n,a,r,i){r=r.add(e),i=rr(i.add(r).add(a),21);let s=r;return r=r.add(t),r=r.add(n),i=i.add(rr(r,44)),[r.add(a),i.add(s)]}function Px(e,t,n,a){return OW(ra(e,t),ra(e,t+8),ra(e,t+16),ra(e,t+24),n,a)}function MW(e,t=e.length){if(t>=8){let n=Vr.add(t*2),a=ra(e,0).add(Vr),r=ra(e,t-8),i=rr(r,37).mul(n).add(a),s=rr(a,25).add(r).mul(n);return mc(i,s,n)}if(t>=4){let n=Vr.add(t*2),a=yN(e,0);return mc(a.shl(3).add(t),yN(e,t-4),n)}if(t>0){let n=e[0],a=e[t>>1],r=e[t-1],i=n+(a<<8),s=t+(r<<2);return bk(Vr.mul(i).xor(R3.mul(s))).mul(Vr)}return Vr}function BW(e,t=e.length){let n=Vr.add(t*2),a=ra(e,0).mul(Md),r=ra(e,8),i=ra(e,t-8).mul(n),s=ra(e,t-16).mul(Vr);return mc(rr(a.add(r),43).add(rr(i,30)).add(s),a.add(rr(r.add(Vr),18)).add(i),n)}function LW(e,t=e.length){let n=Vr.add(t*2),a=ra(e,0).mul(Vr),r=ra(e,8),i=ra(e,t-8).mul(n),s=ra(e,t-16).mul(Vr),o=rr(a.add(r),43).add(rr(i,30)).add(s),u=mc(o,a.add(rr(r.add(Vr),18)).add(i),n),d=ra(e,16).mul(n),c=ra(e,24),h=o.add(ra(e,t-32)).mul(n),m=u.add(ra(e,t-24)).mul(n);return mc(rr(d.add(c),43).add(rr(h,30)).add(m),d.add(rr(c.add(a),18)).add(h),n)}function zW(e,t=e.length){let n=zd.fromNumber(81,!0);if(t<=32)return t<=16?MW(e,t):BW(e,t);if(t<=64)return LW(e,t);let a=n,r=n.mul(Md).add(113),i=bk(r.mul(Vr).add(113)).mul(Vr),s=[zd.UZERO,zd.UZERO],o=[zd.UZERO,zd.UZERO];a=a.mul(Vr).add(ra(e,0));let u=0,d=(t-1>>6)*64,c=d+(t-1&63)-63;do a=rr(a.add(r).add(s[0]).add(ra(e,u+8)),37).mul(Md),r=rr(r.add(s[1]).add(ra(e,u+48)),42).mul(Md),a=a.xor(o[1]),r=r.add(s[0]).add(ra(e,u+40)),i=rr(i.add(o[0]),33).mul(Md),s=Px(e,u,s[1].mul(Md),a.add(o[0])),o=Px(e,u+32,i.add(o[1]),r.add(ra(e,u+16))),[i,a]=[a,i],u+=64;while(u!==d);let h=Md.add(i.and(255).shl(1));return u=c,o[0]=o[0].add(t-1&63),s[0]=s[0].add(o[0]),o[0]=o[0].add(s[0]),a=rr(a.add(r).add(s[0]).add(ra(e,u+8)),37).mul(h),r=rr(r.add(s[1]).add(ra(e,u+48)),42).mul(h),a=a.xor(o[1].mul(9)),r=r.add(s[0].mul(9).add(ra(e,u+40))),i=rr(i.add(o[0]),33).mul(h),s=Px(e,u,s[1].mul(h),a.add(o[0])),o=Px(e,u+32,i.add(o[1]),r.add(ra(e,u+16))),[i,a]=[a,i],mc(mc(s[0],o[0],h).add(bk(r).mul(R3)).add(i),mc(s[1],o[1],h).add(a),h)}function UW(e,t){return t==="string"?O0(e):gv([e],t)}function VW(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function gv(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=wc(e)),Ae().getBool("DEBUG")&&y3(e,t),VW(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let a=0;a<n.length;++a)Math.round(e[a])!==0&&(n[a]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Jy(){return Ae().platform.now()}function WW(e,t){return Ae().platform.fetch(e,t)}function O0(e,t="utf-8"){return t=t||"utf-8",Ae().platform.encode(e,t)}function E1(e,t="utf-8"){return t=t||"utf-8",Ae().platform.decode(e,t)}function ir(e){return Ae().platform.isTypedArray!=null?Ae().platform.isTypedArray(e):N3(e)}function wc(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||nv(e)||e==null||ir(e)&&n)t.push(e);else if(Array.isArray(e)||ir(e))for(let a=0;a<e.length;++a)wc(e[a],t,n);else{let a=-1;for(let r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(a=Math.max(a,Number(r)));for(let r=0;r<=a;r++)wc(e[r],t,n)}return t}var qW=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new HW)}profileKernel(e,t,n){let a,r=()=>{a=n()},i,s=Jy();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(r);else{r();for(let o of a)o.dataSync();i=Promise.resolve({kernelMs:Jy()-s})}if(Ae().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<a.length;o++){let u=a[o];u.data().then(d=>{PW(d,u.dtype,e)})}return{kernelName:e,outputs:a,inputs:t,timeMs:i.then(o=>o.kernelMs),extraInfo:i.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:i}=e;n.forEach(s=>{Promise.all([s.data(),a,i]).then(o=>{this.logger.logKernelProfile(t,s,o[0],o[1],r,o[2])})})}};function PW(e,t,n){if(t!=="float32")return!1;for(let a=0;a<e.length;a++){let r=e[a];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}var HW=class{logKernelProfile(e,t,n,a,r,i){let s=typeof a=="number"?Ly(`${a}ms`,9):a.error,o=Ly(e,25),u=t.rank,d=t.size,c=Ly(t.shape.toString(),14),h="";for(let m in r){let g=r[m];if(g!=null){let x=g.shape||t.shape,v=x.length;h+=`${m}: ${v}D ${v>0?x:""} `}}console.log(`%c${o}	%c${s}	%c${u}D ${c}	%c${d}	%c${h}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function GW(e,t,n){let a={},r={};for(let u=0;u<t.length;u++)a[t[u].id]=!0;for(let u=0;u<e.length;u++){let d=e[u],c=d.inputs;for(let h in c){let m=c[h],g=!1;for(let x=0;x<t.length;x++)if(a[m.id]){d.outputs.forEach(v=>a[v.id]=!0),g=!0,r[d.id]=!0;break}if(g)break}}let i={};i[n.id]=!0;let s={};for(let u=e.length-1;u>=0;u--){let d=e[u],c=d.inputs;for(let h=0;h<d.outputs.length;h++)if(i[d.outputs[h].id]){for(let m in c)i[c[m].id]=!0,s[d.id]=!0;break}}let o=[];for(let u=0;u<e.length;u++){let d=e[u];if(r[d.id]&&s[d.id]){let c={};for(let m in d.inputs){let g=d.inputs[m];a[g.id]&&(c[m]=g)}let h=Object.assign({},d);h.inputs=c,h.outputs=d.outputs,o.push(h)}}return o}function KW(e,t,n,a){for(let r=t.length-1;r>=0;r--){let i=t[r],s=[];if(i.outputs.forEach(u=>{let d=e[u.id];d!=null?s.push(d):s.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);let o=i.gradient(s);for(let u in i.inputs){if(!(u in o))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(o)}.`);let d=n(()=>o[u]());if(d.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${d.dtype}'`);let c=i.inputs[u];if(!ru(d.shape,c.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${u}' has shape '${d.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=d;else{let h=e[c.id];e[c.id]=a(h,d),h.dispose()}}}}var wN=20,fy=3,Y2=7;function $W(e,t,n,a){let r=Fm(t),i=JW(e,t,n,r),s=t.length,o=o1(e,t,n,r,i),u=["Tensor"];return a&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${s}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map(d=>"    "+d).join(`
`)),u.join(`
`)}function JW(e,t,n,a){let r=Un(t),i=a[a.length-1],s=new Array(i).fill(0),o=t.length,u=n==="complex64"?Sy(e):e;if(o>1)for(let d=0;d<r/i;d++){let c=d*i;for(let h=0;h<i;h++)s[h]=Math.max(s[h],vy(u[c+h],0,n).length)}return s}function vy(e,t,n){let a;return Array.isArray(e)?a=`${parseFloat(e[0].toFixed(Y2))} + ${parseFloat(e[1].toFixed(Y2))}j`:dc(e)?a=`'${e}'`:n==="bool"?a=D3(e):a=parseFloat(e.toFixed(Y2)).toString(),Ly(a,t)}function D3(e){return e===0?"false":"true"}function o1(e,t,n,a,r,i=!0){let s=n==="complex64"?2:1,o=t[0],u=t.length;if(u===0){if(n==="complex64"){let v=Sy(e);return[vy(v[0],0,n)]}return n==="bool"?[D3(e[0])]:[e[0].toString()]}if(u===1){if(o>wN){let v=fy*s,S=Array.from(e.slice(0,v)),E=Array.from(e.slice((o-fy)*s,o*s));return n==="complex64"&&(S=Sy(S),E=Sy(E)),["["+S.map((C,T)=>vy(C,r[T],n)).join(", ")+", ..., "+E.map((C,T)=>vy(C,r[o-fy+T],n)).join(", ")+"]"]}return["["+(n==="complex64"?Sy(e):Array.from(e)).map((v,S)=>vy(v,r[S],n)).join(", ")+"]"]}let d=t.slice(1),c=a.slice(1),h=a[0]*s,m=[];if(o>wN){for(let v=0;v<fy;v++){let S=v*h,E=S+h;m.push(...o1(e.slice(S,E),d,n,c,r,!1))}m.push("...");for(let v=o-fy;v<o;v++){let S=v*h,E=S+h;m.push(...o1(e.slice(S,E),d,n,c,r,v===o-1))}}else for(let v=0;v<o;v++){let S=v*h,E=S+h;m.push(...o1(e.slice(S,E),d,n,c,r,v===o-1))}let g=u===2?",":"";m[0]="["+(o>0?m[0]+g:"");for(let v=1;v<m.length-1;v++)m[v]=" "+m[v]+g;let x=`,
`;for(let v=2;v<u;v++)x+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":x),m}function Sy(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Ma=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Un(e),n!=null){let a=n.length;ee(a===this.size,()=>`Length of values '${a}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||NA(t,this.size),this.strides=Fm(e)}set(e,...t){t.length===0&&(t=[0]),ee(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let a of e){if(a<0||a>=this.shape[t]){let r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let n=e[e.length-1];for(let a=0;a<e.length-1;++a)n+=this.strides[a]*e[a];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ao().makeTensor(this.values,this.shape,this.dtype)}},ao=null,rm=null;function YW(e){ao=e}function jW(e){rm=e}var $t=class{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Un(e),this.strides=Fm(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return rm.buffer(this.shape,this.dtype,e)}bufferSync(){return rm.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return lm(this.shape,e,this.dtype==="complex64")}arraySync(){return lm(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=ao().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>E1(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ao().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=ao().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>E1(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await ao().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ao().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return rm.print(this,e)}clone(){return this.throwIfDisposed(),rm.clone(this)}toString(e=!1){let t=this.dataSync();return $W(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),rm.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),ao().makeVariable(this,e,t,n)}};Object.defineProperty($t,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Be(){return DA("Tensor",()=>$t)}Be();var Xd=class extends $t{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ru(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ao().disposeTensor(this),this.dataId=e.dataId,ao().incRef(this,null)}dispose(){ao().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Xd,Symbol.hasInstance,{value:e=>e instanceof $t&&e.assign!=null&&e.assign instanceof Function});var ro={};qt(ro,{assertTypesMatch:()=>B3,getTensorsInContainer:()=>MA,isTensorInList:()=>ZW,makeTypesMatch:()=>va});var yk;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(yk||(yk={}));var wk;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(wk||(wk={}));var xk;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(xk||(xk={}));var vk;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(vk||(vk={}));var Sk;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(Sk||(Sk={}));var QW={float32:vk,int32:wk,bool:xk,complex64:Sk};function as(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return QW[e][t]}function bv(e){return as(e,"int32")}function O3(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function M3(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function va(e,t){if(e.dtype===t.dtype)return[e,t];let n=as(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function B3(e,t){ee(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function ZW(e,t){return t.some(n=>n.id===e.id)}function MA(e){let t=[];return L3(e,t,new Set),t}function L3(e,t,n){if(e==null)return;if(e instanceof $t){t.push(e);return}if(!XW(e))return;let a=e;for(let r in a){let i=a[r];n.has(i)||(n.add(i),L3(i,t,n))}}function XW(e){return Array.isArray(e)||typeof e=="object"}function j2(e){return e.kernelName!=null}var xN=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},BA=class kk{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new xN}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n];if(await this.initializeBackend(a).success){await this.setBackend(a);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,a=1){return t in this.registryFactory?(cc(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:a},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:a}=this.initializeBackend(t);if(!(a?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new qW(this.backendInstance),!0}setupRegisteredKernels(){A1(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){A1(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let a=n.factory();if(a&&!(a instanceof u0)&&typeof a.then=="function"){let r=++this.pendingBackendInitId,i=a.then(s=>r<this.pendingBackendInitId?!1:(this.registry[t]=s,this.pendingBackendInit=null,!0)).catch(s=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,cc(`Initialization of backend ${t} failed`),cc(s.stack||s.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=a,{success:!0,asyncInit:!1}}catch(a){return cc(`Initialization of backend ${t} failed`),cc(a.stack||a.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n],{success:r,asyncInit:i}=this.initializeBackend(a);if(i||r)return{name:a,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let a=this.state.tensorInfo.get(n),r=a.backend,i=this.readSync(n),s=r.refCount(n);r.disposeData(n,!0),a.backend=t,t.move(n,i,a.shape,a.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let a=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=t}let r;return this.scopedRun(()=>this.startScope(a),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,n,a){t();try{let r=a();return n(),r}catch(r){throw n(),r}}nextTensorId(){return kk.nextTensorId++}nextVariableId(){return kk.nextVariableId++}clone(t){let n=oe.runKernel(Kp,{x:t}),a={x:t},r=s=>({x:()=>{let o="float32",u={x:s},d={dtype:o};return oe.runKernel(Ip,u,d)}}),i=[];return this.addTapeNode(this.state.activeScope.name,a,[n],r,i,{}),n}runKernel(t,n,a){if(this.backendName==null&&this.backend,$y(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:a})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,a){let r=this.backend.numDataIds(),i=0;a.forEach(u=>{i+=u.dtype==="complex64"?3:1});let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-n-i-s;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,a=[],r=this.isTapeOn(),i=this.state.numBytes,s=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let u,d=j2(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(j2(t)){let{kernelName:x,inputs:v,attrs:S}=t;this.backendName==null&&this.backend;let E=$y(x,this.backendName);ee(E!=null,()=>`Cannot find registered kernel '${x}' for backend '${this.backendName}'`),o=()=>{let C=this.backend.numDataIds();u=E.kernelFunc({inputs:v,attrs:S,backend:this.backend});let T=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(x,C,T);let N=T.map(D=>D.rank!=null?D:this.makeTensorFromTensorInfo(D));if(r){let D=this.getTensorsForGradient(x,v,N);a=this.saveTensorsForBackwardMode(D)}return N}}else{let{forwardFunc:x}=t,v=S=>{r&&(a=S.map(E=>this.keep(this.clone(E))))};o=()=>{let S=this.backend.numDataIds();u=this.tidy(()=>x(this.backend,v));let E=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,S,E),E}}let{inputs:c,attrs:h}=t,m=j2(t)?null:t.backwardsFunc,g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(g=this.profiler.profileKernel(d,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),n=g.outputs)}),r&&this.addTapeNode(d,c,n,m,a,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:d,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(x=>c[x]!=null?c[x].shape:null),outputShapes:n.map(x=>x.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,a){let r=gk(t);if(r!=null){let i=r.inputsToSave||[],s=r.outputsToSave||[],o;r.saveAllInputs?(ee(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(d=>n[d])):o=i.map(d=>n[d]);let u=a.filter((d,c)=>s[c]);return o.concat(u)}return[]}makeTensor(t,n,a,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");a=a||"float32",r=r||this.backend;let i=t;a==="string"&&dc(t[0])&&(i=t.map(u=>O0(u)));let s=r.write(i,n,a),o=new $t(n,a,s,this.nextTensorId());if(this.trackTensor(o,r),a==="string"){let u=this.state.tensorInfo.get(s),d=x3(i);this.state.numBytes+=d-u.bytes,u.bytes=d}return o}makeTensorFromDataId(t,n,a,r){a=a||"float32";let i={dataId:t,shape:n,dtype:a};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(t,n){let{dataId:a,shape:r,dtype:i}=t,s=new $t(r,i,a,this.nextTensorId());return this.trackTensor(s,n),s}makeVariable(t,n=!0,a,r){a=a||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));let i=new Xd(t,n,a,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let a=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(a=t.size*v1(t.dtype)),this.state.numBytes+=a,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:a})),t instanceof Xd||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let a=t.size*v1(t.dtype);this.state.numBytes-=a}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,a=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-a;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,a,r,i,s){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:a,saved:i},u=gk(t);u!=null&&(r=u.gradFunc),r!=null&&(o.gradient=d=>(d=d.map((c,h)=>{if(c==null){let m=a[h],g=tv(m.size,m.dtype);return this.makeTensor(g,m.shape,m.dtype)}return c}),r(d.length>1?d:d[0],i,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=MA(t),a=new Set(n.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){let s=this.state.activeScope.track[i];!s.kept&&!a.has(s.id)&&s.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(t,n,a,r=!1){if(ee(n.length>0,()=>"gradients() received an empty list of xs."),a!=null&&a.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${a.dtype}'`);let i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));ee(i instanceof $t,()=>"The result y returned by f() must be a tensor.");let s=GW(this.state.activeTape,n,i);if(!r&&s.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[i.id]=a??eq(i.shape),KW(o,s,d=>this.tidy(d),tq);let u=n.map(d=>o[d.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(d=>{for(let c of d.saved)c.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(t){return ee(yc(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{ee(n.every(o=>o instanceof $t),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let a,r={};n.forEach((o,u)=>{r[u]=o});let i=(o,u)=>(a=t(...n,u),ee(a.value instanceof $t,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),ee(yc(a.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),a.value),s=(o,u)=>{let d=a.gradFunc(o,u),c=Array.isArray(d)?d:[d];ee(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),ee(c.every(m=>m instanceof $t),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let h={};return c.forEach((m,g)=>{h[g]=()=>m}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:s,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=Jy(),a=await this.backend.time(t);return a.wallMs=Jy()-n,a}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new xN;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};BA.nextTensorId=0;BA.nextVariableId=0;function eq(e){let t=RA(Un(e),"float32");return oe.makeTensor(t,e,"float32")}function z3(){let e=E3();if(e._tfengine==null){let t=new A3(e);e._tfengine=new BA(t)}return AW(e._tfengine.ENV),YW(()=>e._tfengine),e._tfengine}var oe=z3();function tq(e,t){let n={a:e,b:t};return oe.runKernel(Mc,n)}var M0={};qt(M0,{isBrowser:()=>U3,isMobile:()=>rq,mockIsMobile:()=>aq});function nq(){return typeof navigator<"u"&&navigator!=null}var Ak;function aq(e){Ak=e}function rq(e){if(Ak!==void 0)return Ak;if(e||nq()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function U3(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var ci=Ae();ci.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ci.registerFlag("IS_BROWSER",()=>U3());ci.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ci.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ci.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));ci.registerFlag("PROD",()=>!1);ci.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ci.getBool("DEBUG"));ci.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ci.registerFlag("IS_TEST",()=>!1);ci.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ci.getBool("DEBUG"));ci.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ci.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ci.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function rl(e,t){let n=e;if(ir(e))return t==="string"?[]:[e.length];if(O3(e)){let r=e.channels||"RGBA";return[e.height,e.width*r.length]}else if(M3(e))return[e.buffer.size/(t==null?4:v1(t))];if(!Array.isArray(e))return[];let a=[];for(;Array.isArray(n)||ir(n)&&t!=="string";)a.push(n.length),n=n[0];return Array.isArray(e)&&Ae().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&V3(e,a,[]),a}function V3(e,t,n){if(n=n||[],!Array.isArray(e)&&!ir(e)){ee(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}ee(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),ee(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let a=t.slice(1);for(let r=0;r<e.length;++r)V3(e[r],a,n.concat(r))}function vN(e,t,n,a){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${a}' must be ${e} tensor, but got ${t} tensor`)}}function $(e,t,n,a="numeric"){if(e instanceof Be())return vN(a,e.dtype,t,n),e;let r=c0(e);if(r!=="string"&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),vN(a,r,t,n),e==null||!ir(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let i=rl(e,r);!ir(e)&&!Array.isArray(e)&&(e=[e]);let s=r!=="string"?gv(e,r):wc(e,[],!0);return oe.makeTensor(s,i,r)}function Yy(e,t,n,a="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((r,i)=>$(r,`${t}[${i}]`,n,a))}var LA="__op";function le(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+LA;let r=(...i)=>{oe.startScope(n);try{let s=a(...i);return nv(s)&&console.error("Cannot return a Promise inside of tidy."),oe.endScope(s),s}catch(s){throw oe.endScope(null),s}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}function iq(e,t){let n=$(e,"real","complex"),a=$(t,"imag","complex");$r(n.shape,a.shape,`real and imag shapes, ${n.shape} and ${a.shape}, must match in call to tf.complex().`);let r={real:n,imag:a};return oe.runKernel(av,r)}var nu=le({complex_:iq});function Uc(e,t,n,a){if(a==null)a=c0(e);else if(a==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(M3(e)||O3(e)){if(a!=="float32"&&a!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${a}.`);return oe.backend.createTensorFromGPUData(e,t||n,a)}if(!ir(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Bi(t);let r=Un(t),i=Un(n);ee(r===i,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${i}`);for(let s=0;s<n.length;++s){let o=n[s],u=s===n.length-1?o!==Un(t.slice(s)):!0;ee(n[s]===t[s]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!ir(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=a!=="string"?gv(e,a):wc(e,[],!0),oe.makeTensor(e,t,a)}function Pr(e,t,n){let a=rl(e,n);return Uc(e,t,a,n)}var ep={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},iu=class W3{static join(t){return new W3(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(a=>ir(a)?a.buffer:a),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let a=0;a<t.length;a++){let r=t[a];a!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let i=n+r.byteLength;this.shards.push({buffer:r,start:n,end:i}),n=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let a=this.findShardForByte(t);if(a===-1)throw new Error(`Could not find start shard for byte ${t}`);let r=n-t,i=new ArrayBuffer(r),s=new Uint8Array(i),o=0;for(let u=a;u<this.shards.length;u++){let d=this.shards[u],c=t+o-d.start,h=o,m=Math.min(n,d.end)-d.start,g=new Uint8Array(d.buffer,c,m-c);if(s.set(g,h),o+=g.length,n<d.end)break}return i}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(r){return t<r.start?-1:t>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let a=sq(this.shards,n);return a===-1?-1:(this.previousShardIndex=a,this.previousShardIndex)}};function sq(e,t){let n=0,a=e.length;for(;n<=a;){let r=Math.floor((a-n)/2)+n,i=t(e[r]);if(i===0)return r;i<0?a=r:n=r+1}return-1}function oq(){Ae().set("PROD",!0)}function lq(){Ae().set("DEBUG",!0)}function uq(){Ae().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function q3(e){Ae().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function cq(){oe.disposeVariables()}function _s(){return oe}function Ek(){return oe.memory()}function dq(e){return oe.profile(e)}function be(e,t){return oe.tidy(e,t)}function Wt(e){MA(e).forEach(t=>t.dispose())}function Ga(e){return oe.keep(e)}function pq(e){return oe.time(e)}function hq(e){return oe.setBackend(e)}function fq(){return oe.ready()}function P3(){return oe.backendName}function mq(e){oe.removeBackend(e)}function gq(e){return oe.findBackend(e)}function bq(e){return oe.findBackendFactory(e)}function yv(e,t,n=1){return oe.registerBackend(e,t,n)}function zA(){return oe.backend}function yq(e,t){Ae().setPlatform(e,t)}var xc=4;async function wq(e,t){let n=[],a=[],r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);for(let s=0;s<r.length;++s){let o=r[s],u=Array.isArray(e)?e[s].tensor:e[o];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${u.dtype}`);let d={name:o,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let c=new Promise(async h=>{let m=await u.bytes(),g=m.reduce((S,E)=>S+E.length,0)+xc*m.length,x=new Uint8Array(g),v=0;for(let S=0;S<m.length;S++){let E=m[S],C=new Uint8Array(new Uint32Array([E.length]).buffer);x.set(C,v),v+=xc,x.set(E,v),v+=E.length}h(x)});a.push(c)}else a.push(u.data());t!=null&&(d.group=t),n.push(d)}let i=await Promise.all(a);return{data:Sq(i),specs:n}}function H3(e,t){let n=new iu(e),a={},r=0;for(let i of t){let s=xq(i,(o,u)=>n.slice(r+o,r+u));a[i.name]=G3(i,n.slice(r,r+s)),r+=s}return a}function xq(e,t){let n=Un(e.shape),a;if("quantization"in e){let r=e.quantization;a=ep[r.dtype]}else if(e.dtype==="string"){let r=0;for(let i=0;i<n;i++)r+=xc+new Uint32Array(t(r,r+xc))[0];return r}else a=ep[e.dtype];return n*a}async function vq(e,t){let n=Un(e.shape),a;if("quantization"in e){let r=e.quantization;a=ep[r.dtype]}else if(e.dtype==="string"){let r=0;for(let i=0;i<n;i++)r+=xc+new Uint32Array(await t(r,r+xc))[0];return r}else a=ep[e.dtype];return n*a}function G3(e,t){let n=e.name,a=e.dtype,r=e.shape,i=Un(r),s,o=0;if("quantization"in e){let u=e.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${e.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${e.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let d=ep[u.dtype],c=u.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(a==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){s=new Float32Array(c.length);for(let h=0;h<c.length;h++){let m=c[h];s[h]=m*u.scale+u.min}}else if(u.dtype==="float16")s=Tq()(c);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(a==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);s=new Int32Array(c.length);for(let h=0;h<c.length;h++){let m=c[h];s[h]=Math.round(m*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=i*d}else if(a==="string"){let u=Un(e.shape);s=[];for(let d=0;d<u;d++){let c=new Uint32Array(t.slice(o,o+xc))[0];o+=xc;let h=new Uint8Array(t.slice(o,o+c));s.push(h),o+=c}}else{let u=ep[a];if(a==="float32")s=new Float32Array(t);else if(a==="int32")s=new Int32Array(t);else if(a==="bool")s=new Uint8Array(t);else if(a==="complex64"){s=new Float32Array(t);let d=new Float32Array(s.length/2),c=new Float32Array(s.length/2);for(let x=0;x<d.length;x++)d[x]=s[x*2],c[x]=s[x*2+1];let h=Pr(d,r,"float32"),m=Pr(c,r,"float32"),g=nu(h,m);return h.dispose(),m.dispose(),g}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=i*u}return Pr(s,r,a)}async function SN(e,t,n){let a=new Uint8Array(t);for(;a.byteLength<n;){let{done:r,value:i}=await e.read();if(r&&i==null){let o=n-a.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let s=new Uint8Array(a.length+i.byteLength);s.set(a,0),s.set(new Uint8Array(i),a.length),a=s}return a.buffer}async function K3(e,t){let n={},a=e.getReader(),r=new ArrayBuffer(0);for(let i of t){let s=await vq(i,async(d,c)=>(r=await SN(a,r,c),r.slice(d,c)));r=await SN(a,r,s);let o=r.slice(0,s);r=r.slice(s);let u=G3(i,o);if(n[i.name]=u,P3()==="webgpu"){let d=zA();"uploadToGPU"in d&&Un(u.shape)>=Ae().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&d.uploadToGPU(u.dataId)}}return n}function Sq(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(i=>{if(t+=i.byteLength,n.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});let a=new Uint8Array(t),r=0;return n.forEach(i=>{a.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),a.buffer}var UA=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function kN(e){return UA?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function kq(e){if(UA)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}function Aq(e){if(UA){let a=Buffer.from(e,"base64");return a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}function Eq(e){return iu.join(e)}function AN(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function $3(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function J3(e,t,n){let a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(a.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return e.signature!=null&&(a.signature=e.signature),e.userDefinedMetadata!=null&&(a.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(a.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(a.initializerSignature=e.initializerSignature),a}async function VA(e,t){let n,a;return e.weightsManifest!=null&&([n,a]=await t(e.weightsManifest)),J3(e,n,a)}function B0(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:kN(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:kN(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new iu(e.weightData).byteLength}}function Ck(e){let t=[];for(let n of e)t.push(...n.weights);return t}function Cq(){let e=n=>{let a=n<<13,r=0;for(;!(a&8388608);)r-=8388608,a<<=1;return a&=-8388609,r+=947912704,a|r},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function Iq(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function _q(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function Tq(){let e=Cq(),t=Iq(),n=_q();return a=>{let r=new ArrayBuffer(4*a.length),i=new Uint32Array(r);for(let s=0;s<a.length;s++){let o=a[s],u=e[n[o>>10]+(o&1023)]+t[o>>10];i[s]=u}return new Float32Array(r)}}var rs=class eo{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return eo.instance==null&&(eo.instance=new eo),eo.instance}static registerSaveRouter(t){eo.getInstance().saveRouters.push(t)}static registerLoadRouter(t){eo.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return eo.getHandlers(t,"save")}static getLoadHandlers(t,n){return eo.getHandlers(t,"load",n)}static getHandlers(t,n,a){let r=[];return(n==="load"?eo.getInstance().loadRouters:eo.getInstance().saveRouters).forEach(i=>{let s=i(t,a);s!==null&&r.push(s)}),r}},Nq=e=>rs.registerSaveRouter(e),Rq=e=>rs.registerLoadRouter(e),Fq=e=>rs.getSaveHandlers(e),Dq=(e,t)=>rs.getLoadHandlers(e,t),Ik="tensorflowjs",_k=1,Pd="models_store",pc="model_info_store";function Y3(){if(!Ae().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Tk(e){let t=e.result;t.createObjectStore(Pd,{keyPath:"modelPath"}),t.createObjectStore(pc,{keyPath:"modelPath"})}var tp=class{constructor(e){if(this.indexedDB=Y3(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,a)=>{let r=this.indexedDB.open(Ik,_k);r.onupgradeneeded=()=>Tk(r),r.onsuccess=()=>{let i=r.result;if(t==null){let s=i.transaction(Pd,"readonly"),o=s.objectStore(Pd).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return i.close(),a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=u=>(i.close(),a(o.error)),s.oncomplete=()=>i.close()}else{t.weightData=iu.join(t.weightData);let s=B0(t),o=i.transaction(pc,"readwrite"),u=o.objectStore(pc),d;try{d=u.put({modelPath:this.modelPath,modelArtifactsInfo:s})}catch(h){return a(h)}let c;d.onsuccess=()=>{c=i.transaction(Pd,"readwrite");let h=c.objectStore(Pd),m;try{m=h.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:s})}catch(g){return a(g)}m.onsuccess=()=>n({modelArtifactsInfo:s}),m.onerror=g=>{u=o.objectStore(pc);let x=u.delete(this.modelPath);x.onsuccess=()=>(i.close(),a(m.error)),x.onerror=v=>(i.close(),a(m.error))}},d.onerror=h=>(i.close(),a(d.error)),o.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}}},r.onerror=i=>a(r.error)})}};tp.URL_SCHEME="indexeddb://";var j3=e=>Ae().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(tp.URL_SCHEME)?Oq(e.slice(tp.URL_SCHEME.length)):null;rs.registerSaveRouter(j3);rs.registerLoadRouter(j3);function Oq(e){return new tp(e)}function Mq(e){return e.startsWith(tp.URL_SCHEME)?e.slice(tp.URL_SCHEME.length):e}var Bq=class{constructor(){this.indexedDB=Y3()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(Ik,_k);n.onupgradeneeded=()=>Tk(n),n.onsuccess=()=>{let a=n.result,r=a.transaction(pc,"readonly"),i=r.objectStore(pc).getAll();i.onsuccess=()=>{let s={};for(let o of i.result)s[o.modelPath]=o.modelArtifactsInfo;e(s)},i.onerror=s=>(a.close(),t(i.error)),r.oncomplete=()=>a.close()},n.onerror=a=>t(n.error)})}async removeModel(e){return e=Mq(e),new Promise((t,n)=>{let a=this.indexedDB.open(Ik,_k);a.onupgradeneeded=()=>Tk(a),a.onsuccess=()=>{let r=a.result,i=r.transaction(pc,"readwrite"),s=i.objectStore(pc),o=s.get(e),u;o.onsuccess=()=>{if(o.result==null)return r.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let d=s.delete(e),c=()=>{u=r.transaction(Pd,"readwrite");let h=u.objectStore(Pd).delete(e);h.onsuccess=()=>t(o.result.modelArtifactsInfo),h.onerror=m=>n(o.error)};d.onsuccess=c,d.onerror=h=>(c(),r.close(),n(o.error))}},o.onerror=d=>(r.close(),n(o.error)),i.oncomplete=()=>{u==null?r.close():u.oncomplete=()=>r.close()}},a.onerror=r=>n(a.error)})}},jl="/",im="tensorflowjs_models",Q3="info",Lq="model_topology",zq="weight_specs",Uq="weight_data",Vq="model_metadata";function Z3(e){return{info:[im,e,Q3].join(jl),topology:[im,e,Lq].join(jl),weightSpecs:[im,e,zq].join(jl),weightData:[im,e,Uq].join(jl),modelMetadata:[im,e,Vq].join(jl)}}function X3(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function Wq(e){let t=e.split(jl);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(jl)}function qq(e){return e.startsWith(np.URL_SCHEME)?e.slice(np.URL_SCHEME.length):e}var np=class{constructor(e){if(!Ae().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Z3(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),a=B0(e),r=iu.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,kq(r));let i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:a}}catch{throw X3(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(a==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=a;let r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){let s=JSON.parse(r);t.format=s.format,t.generatedBy=s.generatedBy,t.convertedBy=s.convertedBy,s.signature!=null&&(t.signature=s.signature),s.userDefinedMetadata!=null&&(t.userDefinedMetadata=s.userDefinedMetadata),s.modelInitializer!=null&&(t.modelInitializer=s.modelInitializer),s.initializerSignature!=null&&(t.initializerSignature=s.initializerSignature),s.trainingConfig!=null&&(t.trainingConfig=s.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Aq(i),t}};np.URL_SCHEME="localstorage://";var eF=e=>Ae().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(np.URL_SCHEME)?Pq(e.slice(np.URL_SCHEME.length)):null;rs.registerSaveRouter(eF);rs.registerLoadRouter(eF);function Pq(e){return new np(e)}var Hq=class{constructor(){ee(Ae().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),ee(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=im+jl,n=jl+Q3;for(let a=0;a<this.LS.length;++a){let r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){let i=Wq(r);e[i]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=qq(e);let t=Z3(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return X3(t),n}},um="://",vc=class ic{constructor(){this.managers={}}static getInstance(){return ic.instance==null&&(ic.instance=new ic),ic.instance}static registerManager(t,n){ee(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(um)&&(t=t.slice(0,t.indexOf(um))),ee(t.length>0,()=>"scheme must not be an empty string.");let a=ic.getInstance();ee(a.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),a.managers[t]=n}static getManager(t){let n=ic.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(ic.getInstance().managers)}};function l1(e){if(e.indexOf(um)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${vc.getSchemes().join(",")}`);return{scheme:e.split(um)[0],path:e.split(um)[1]}}async function tF(e,t,n=!1){ee(e!==t,()=>`Old path and new path are the same: '${e}'`);let a=rs.getLoadHandlers(e);ee(a.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),ee(a.length<2,()=>`Copying failed because more than one (${a.length}) load handlers for source URL ${e}.`);let r=a[0],i=rs.getSaveHandlers(t);ee(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),ee(i.length<2,()=>`Copying failed because more than one (${a.length}) save handlers for destination URL ${t}.`);let s=i[0],o=l1(e).scheme,u=l1(e).path,d=o===l1(e).scheme,c=await r.load();n&&d&&await vc.getManager(o).removeModel(u);let h=await s.save(c);return n&&!d&&await vc.getManager(o).removeModel(u),h.modelArtifactsInfo}async function Gq(){let e=vc.getSchemes(),t={};for(let n of e){let a=await vc.getManager(n).listModels();for(let r in a){let i=n+um+r;t[i]=a[r]}}return t}async function Kq(e){let t=l1(e);return vc.getManager(t.scheme).removeModel(t.path)}async function $q(e,t){return tF(e,t,!1)}async function Jq(e,t){return tF(e,t,!0)}var Yq=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!Ae().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let a=this.functionRefs[n.data.index];a(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return N3(e)}};if(Ae().get("IS_BROWSER")){Ae().setPlatform("browser",new Yq);try{vc.registerManager(np.URL_SCHEME,new Hq)}catch{}try{vc.registerManager(tp.URL_SCHEME,new Bq)}catch{}}var jq={importFetch:()=>P6()},Q2,Qq=class{constructor(){this.util=H6(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Ae().global.fetch!=null?Ae().global.fetch(e,t):(Q2==null&&(Q2=jq.importFetch()),Q2(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};Ae().get("IS_NODE")&&!Ae().get("IS_BROWSER")&&Ae().setPlatform("node",new Qq);function Zt(e,t="float32",n){return t=t||"float32",Bi(e),new Ma(e,t,n)}function Zq(e,t){let n=$(e,"x","cast");if(!w3(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let a={x:n},r={dtype:t};return oe.runKernel(Ip,a,r)}var je=le({cast_:Zq});function Xq(e){let t={x:$(e,"x","clone","string_or_numeric")};return oe.runKernel(Kp,t)}var tl=le({clone_:Xq});function WA(e,t=!1){console.log(e.toString(t))}z3();var e5={buffer:Zt,cast:je,clone:tl,print:WA};jW(e5);function t5(e,t){let n=$(e,"a","add"),a=$(t,"b","add");[n,a]=va(n,a);let r={a:n,b:a};return oe.runKernel(Mc,r)}var Oe=le({add_:t5});function n5(e,t){let n=$(e,"a","floorDiv"),a=$(t,"b","floorDiv");[n,a]=va(n,a);let r={a:n,b:a};return oe.runKernel(Pp,r)}var wv=le({floorDiv_:n5});function a5(e,t){let n=$(e,"a","div"),a=$(t,"b","div");if([n,a]=va(n,a),n.dtype==="int32"&&a.dtype==="int32")return wv(n,a);let r={a:n,b:a},i={};return oe.runKernel(Lp,r,i)}var it=le({div_:a5});function r5(e,t){let n=$(e,"a","mul"),a=$(t,"b","mul");[n,a]=va(n,a);let r={a:n,b:a};return oe.runKernel(lh,r)}var pe=le({mul_:r5});function i5(e){let t=$(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return oe.runKernel(f0,n)}else{let n={x:t};return oe.runKernel(Dm,n)}}var Da=le({abs_:i5});function s5(e){let t={x:$(e,"x","acos")};return oe.runKernel(bp,t)}var qA=le({acos_:s5});function o5(e){let t={x:$(e,"x","acosh")};return oe.runKernel(yp,t)}var PA=le({acosh_:o5});function l5(e){ee(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),ee(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((r,i)=>$(r,`tensors${i}`,"addN")),n=t[0];t.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!ru(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let a=t;return oe.runKernel(wp,a)}var nF=le({addN_:l5});function u5(e,t=null,n=!1){let a={x:$(e,"x","all","bool")},r={axis:t,keepDims:n};return oe.runKernel(Om,a,r)}var xv=le({all_:u5});function c5(e,t=null,n=!1){let a={x:$(e,"x","any","bool")},r={axis:t,keepDims:n};return oe.runKernel(Mm,a,r)}var jy=le({any_:c5});function d5(e,t=0){let n={x:$(e,"x","argMax")},a={axis:t};return oe.runKernel(Bm,n,a)}var ap=le({argMax_:d5});function p5(e,t=0){let n={x:$(e,"x","argMin")},a={axis:t};return oe.runKernel(Lm,n,a)}var HA=le({argMin_:p5});function h5(e){let t={x:$(e,"x","asin")};return oe.runKernel(xp,t)}var GA=le({asin_:h5});function f5(e){let t={x:$(e,"x","asinh")};return oe.runKernel(vp,t)}var KA=le({asinh_:f5});function m5(e){let t={x:$(e,"x","atan")};return oe.runKernel(Sp,t)}var $A=le({atan_:m5});function g5(e,t){let n=$(e,"a","atan2"),a=$(t,"b","atan2");[n,a]=va(n,a);let r={a:n,b:a};return oe.runKernel(Ap,r)}var JA=le({atan2_:g5});function b5(e){let t={x:$(e,"x","atanh")};return oe.runKernel(kp,t)}var YA=le({atanh_:b5});function y5(e,t,n,a,r="NHWC",i){let s=e[3],o=[...t,s],u=iF(r);return L0(e,o,n,i,a,null,null,u)}function aF(e,t,n,a,r,i,s="channelsLast"){let[o,u]=Qy(t),d;if(s==="channelsLast")d=[o,u,e[3],e[3]];else if(s==="channelsFirst")d=[o,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${s}`);return L0(e,d,n,a,r,i,!1,s)}function w5(e,t,n,a,r,i,s="NDHWC"){let[o,u,d]=Nk(t),c,h;if(s==="NDHWC")h="channelsLast",c=[o,u,d,e[4],e[4]];else if(s==="NCDHW")h="channelsFirst",c=[o,u,d,e[1],e[1]];else throw new Error(`Unknown dataFormat ${s}`);return rF(e,c,n,a,r,!1,h,i)}function L0(e,t,n,a,r,i,s=!1,o="channelsLast"){let[u,d,c,h]=[-1,-1,-1,-1];if(o==="channelsLast")[u,d,c,h]=e;else if(o==="channelsFirst")[u,h,d,c]=e;else throw new Error(`Unknown dataFormat ${o}`);let[m,g,,x]=t,[v,S]=Qy(n),[E,C]=Qy(a),T=cm(m,E),N=cm(g,C),{padInfo:D,outHeight:q,outWidth:H}=S5(r,d,c,v,S,T,N,i,o),K=s?x*h:x,j;return o==="channelsFirst"?j=[u,K,q,H]:o==="channelsLast"&&(j=[u,q,H,K]),{batchSize:u,dataFormat:o,inHeight:d,inWidth:c,inChannels:h,outHeight:q,outWidth:H,outChannels:K,padInfo:D,strideHeight:v,strideWidth:S,filterHeight:m,filterWidth:g,effectiveFilterHeight:T,effectiveFilterWidth:N,dilationHeight:E,dilationWidth:C,inShape:e,outShape:j,filterShape:t}}function rF(e,t,n,a,r,i=!1,s="channelsLast",o){let[u,d,c,h,m]=[-1,-1,-1,-1,-1];if(s==="channelsLast")[u,d,c,h,m]=e;else if(s==="channelsFirst")[u,m,d,c,h]=e;else throw new Error(`Unknown dataFormat ${s}`);let[g,x,v,,S]=t,[E,C,T]=Nk(n),[N,D,q]=Nk(a),H=cm(g,N),K=cm(x,D),j=cm(v,q),{padInfo:te,outDepth:Q,outHeight:z,outWidth:ae}=k5(r,d,c,h,E,C,T,H,K,j,o),ue=i?S*m:S,he;return s==="channelsFirst"?he=[u,ue,Q,z,ae]:s==="channelsLast"&&(he=[u,Q,z,ae,ue]),{batchSize:u,dataFormat:s,inDepth:d,inHeight:c,inWidth:h,inChannels:m,outDepth:Q,outHeight:z,outWidth:ae,outChannels:ue,padInfo:te,strideDepth:E,strideHeight:C,strideWidth:T,filterDepth:g,filterHeight:x,filterWidth:v,effectiveFilterDepth:H,effectiveFilterHeight:K,effectiveFilterWidth:j,dilationDepth:N,dilationHeight:D,dilationWidth:q,inShape:e,outShape:he,filterShape:t}}function x5(e,t,n,a,r){a==null&&(a=jA(e,t,n));let i=e[0],s=e[1],o=Zy((i-t+2*a)/n+1,r),u=Zy((s-t+2*a)/n+1,r);return[o,u]}function v5(e,t,n,a,r,i){r==null&&(r=jA(e,t[0],a[0]));let s=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*r>=t[o]&&(s[o]=Zy((e[o]-t[o]+2*r)/a[o]+1,i));return s}function jA(e,t,n,a=1){let r=cm(t,a);return Math.floor((e[0]*(n-1)-n+r)/2)}function Qy(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function Nk(e){return typeof e=="number"?[e,e,e]:e}function cm(e,t){return t<=1?e:e+(e-1)*(t-1)}function S5(e,t,n,a,r,i,s,o,u){let d,c,h;if(typeof e=="number"){d={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let m=x5([t,n],i,a,e,o);c=m[0],h=m[1]}else if(e==="same"){c=Math.ceil(t/a),h=Math.ceil(n/r);let m=Math.max(0,(c-1)*a+i-t),g=Math.max(0,(h-1)*r+s-n),x=Math.floor(m/2),v=m-x,S=Math.floor(g/2),E=g-S;d={top:x,bottom:v,left:S,right:E,type:"SAME"}}else if(e==="valid")d={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-i+1)/a),h=Math.ceil((n-s+1)/r);else if(typeof e=="object"){let m=u==="channelsLast"?e[1][0]:e[2][0],g=u==="channelsLast"?e[1][1]:e[2][1],x=u==="channelsLast"?e[2][0]:e[3][0],v=u==="channelsLast"?e[2][1]:e[3][1];d={top:m,bottom:g,left:x,right:v,type:m===0&&g===0&&x===0&&v===0?"VALID":"EXPLICIT"},c=Zy((t-i+m+g)/a+1,o),h=Zy((n-s+x+v)/r+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outHeight:c,outWidth:h}}function k5(e,t,n,a,r,i,s,o,u,d,c){let h,m,g,x;if(e==="valid"&&(e=0),typeof e=="number"){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let v=v5([t,n,a,1],[o,u,d],1,[r,i,s],e,c);m=v[0],g=v[1],x=v[2]}else if(e==="same"){m=Math.ceil(t/r),g=Math.ceil(n/i),x=Math.ceil(a/s);let v=(m-1)*r+o-t,S=(g-1)*i+u-n,E=(x-1)*s+d-a,C=Math.floor(v/2),T=v-C,N=Math.floor(S/2),D=S-N,q=Math.floor(E/2),H=E-q;h={top:N,bottom:D,left:q,right:H,front:C,back:T,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:h,outDepth:m,outHeight:g,outWidth:x}}function Zy(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Sc(e){let[t,n,a]=Qy(e);return t===1&&n===1&&a===1}function ll(e,t){return Sc(e)||Sc(t)}function rp(e){return Qy(e).every(t=>t>0)}function iF(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Jr(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")ee(fm(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(a=>{a.forEach(r=>{ee(fm(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function A5(e,t){let n={x:$(e,"x","reshape","string_or_numeric")},a={shape:t};return oe.runKernel(bg,n,a)}var ge=le({reshape_:A5});function E5(e,t,n,a,r){let i=$(e,"x","avgPool","float32"),s=1;ee(ll(n,s),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let o=i,u=!1;i.rank===3&&(u=!0,o=ge(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ee(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Jr("avgPool",a,r);let d={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r},h=oe.runKernel(Ep,d,c);return h=je(h,i.dtype),u?ge(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var su=le({avgPool_:E5});function C5(e,t,n,a,r,i="NDHWC"){let s=$(e,"x","avgPool3d","float32"),o=s,u=!1;s.rank===4&&(u=!0,o=ge(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),ee(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),ee(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),ee(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Jr("avgPool3d",a,r);let d={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:i},h=oe.runKernel(zm,d,c);return h=je(h,o.dtype),u?ge(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var QA=le({avgPool3d_:C5});function I5(e,t=0){ee(e.length>=1,()=>"Pass at least one tensor to concat");let n=Yy(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),n.length===1)return tl(n[0]);let a=n,r={axis:t};return oe.runKernel(qm,a,r)}var Gn=le({concat_:I5});function _5(e,t,n=!1,a=!1){let r=$(e,"a","matMul"),i=$(t,"b","matMul");[r,i]=va(r,i);let s={a:r,b:i},o={transposeA:n,transposeB:a};return oe.runKernel(Cp,s,o)}var jt=le({matMul_:_5});function T5(e){let t={x:$(e,"x","sigmoid","float32")};return oe.runKernel(Ch,t)}var Ns=le({sigmoid_:T5});function N5(e,t,n){let a=$(e,"x","slice","string_or_numeric");if(a.rank===0)throw new Error("Slicing scalar is not possible");let r={x:a},i={begin:t,size:n};return oe.runKernel(Ag,r,i)}var un=le({slice_:N5});function R5(e){let t={x:$(e,"x","tanh","float32")};return oe.runKernel(Oh,t)}var kc=le({tanh_:R5});function F5(e,t,n,a,r,i){let s=$(e,"forgetBias","basicLSTMCell"),o=$(t,"lstmKernel","basicLSTMCell"),u=$(n,"lstmBias","basicLSTMCell"),d=$(a,"data","basicLSTMCell"),c=$(r,"c","basicLSTMCell"),h=$(i,"h","basicLSTMCell"),m=Gn([d,h],1),g=jt(m,o),x=Oe(g,u),v=x.shape[0],S=x.shape[1]/4,E=[v,S],C=un(x,[0,0],E),T=un(x,[0,S],E),N=un(x,[0,S*2],E),D=un(x,[0,S*3],E),q=Oe(pe(Ns(C),kc(T)),pe(c,Ns(Oe(s,N)))),H=pe(kc(q),Ns(D));return[q,H]}var sF=le({basicLSTMCell_:F5});function D5(e,t,n){let a=$(e,"x","batchToSpaceND"),r=t.reduce((o,u)=>o*u);ee(a.rank>=1+t.length,()=>`input rank is ${a.rank} but should be > than blockShape.length ${t.length}`),ee(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),ee(a.shape[0]%r===0,()=>`input tensor batch is ${a.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);let i={x:a},s={blockShape:t,crops:n};return oe.runKernel(Um,i,s)}var z0=le({batchToSpaceND_:D5});function O5(e){let t;return e.rank===0||e.rank===1?t=ge(e,[1,1,1,e.size]):e.rank===2?t=ge(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=ge(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function M5(e,t,n,a,r,i){i==null&&(i=.001);let s=$(e,"x","batchNorm"),o=$(t,"mean","batchNorm"),u=$(n,"variance","batchNorm"),d;r!=null&&(d=$(r,"scale","batchNorm"));let c;a!=null&&(c=$(a,"offset","batchNorm")),ee(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ee(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ee(d==null||o.rank===d.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let h={x:O5(s),scale:d,offset:c,mean:o,variance:u},m={varianceEpsilon:i},g=oe.runKernel(Hp,h,m);return ge(g,s.shape)}var Mh=le({batchNorm_:M5});function B5(e,t,n,a,r,i){let s=$(e,"x","batchNorm"),o=$(t,"mean","batchNorm"),u=$(n,"variance","batchNorm"),d;r!=null&&(d=$(r,"scale","batchNorm"));let c;return a!=null&&(c=$(a,"offset","batchNorm")),ee(s.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${s.rank}.`),ee(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),ee(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),d!=null&&ee(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${d.rank}.`),c!=null&&ee(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Mh(s,o,u,c,d,i)}var ZA=le({batchNorm2d_:B5});function L5(e,t,n,a,r,i){let s=$(e,"x","batchNorm"),o=$(t,"mean","batchNorm"),u=$(n,"variance","batchNorm"),d;r!=null&&(d=$(r,"scale","batchNorm"));let c;return a!=null&&(c=$(a,"offset","batchNorm")),ee(s.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${s.rank}.`),ee(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),ee(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),d!=null&&ee(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${d.rank}.`),c!=null&&ee(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Mh(s,o,u,c,d,i)}var XA=le({batchNorm3d_:L5});function z5(e,t,n,a,r,i){let s=$(e,"x","batchNorm"),o=$(t,"mean","batchNorm"),u=$(n,"variance","batchNorm"),d;r!=null&&(d=$(r,"scale","batchNorm"));let c;return a!=null&&(c=$(a,"offset","batchNorm")),ee(s.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${s.rank}.`),ee(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),ee(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),d!=null&&ee(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${d.rank}.`),c!=null&&ee(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Mh(s,o,u,c,d,i)}var eE=le({batchNorm4d_:z5});function U5(e,t,n){let a=$(e,"x","bincount"),r=$(t,"weights","bincount");ee(a.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${a.dtype}`),ee(n>=0,()=>`size must be non-negative, but got ${n}.`),ee(r.size===a.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${a.shape}, weights shape: ${r.shape}.`);let i={x:a,weights:r},s={size:n};return oe.runKernel(Vm,i,s)}var tE=le({bincount_:U5});function V5(e,t){let n=$(e,"x","bitwiseAnd"),a=$(t,"y","bitwiseAnd");if(!ru(n.shape,a.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${a.shape}`);if(n.dtype!=="int32"||a.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${a.dtype}`);let r={a:n,b:a};return oe.runKernel(Wm,r)}var oF=le({bitwiseAnd_:V5});function W5(e,t){let n=$(e,"s0","broadcastArgs","int32"),a=$(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(a.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);let r={s0:n,s1:a};return oe.runKernel(h0,r)}var lF=le({broadcastArgs_:W5});function q5(e,t){let n=$(e,"broadcastTo","x"),a=n.shape;if(Bi(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let u=n.shape.slice();for(;u.length<t.length;)u.unshift(1);n=ge(n,u)}let r=n.shape,i=Array.from(t);for(let u=t.length-1;u>=0;u--)if(r[u]===t[u])i[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${t}].`);if(i.map((u,d)=>u>1?d:-1).filter(u=>u>=0).length===0)return tl(n);let s={x:n},o={reps:i};return oe.runKernel(Lc,s,o)}var Gd=le({broadcastTo_:q5});function P5(e){let t={x:$(e,"x","ceil","float32")};return oe.runKernel(_p,t)}var nE=le({ceil_:P5});function Ni(e,t,n){Bi(e),n=n||c0(t);let a={shape:e,value:t,dtype:n};return oe.runKernel(b0,{},a)}function H5(e,t,n){let a=$(e,"x","clipByValue");if(ee(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Ni(a.shape,t,a.dtype);let r={x:a},i={clipValueMin:t,clipValueMax:n};return oe.runKernel(Bc,r,i)}var Rr=le({clipByValue_:H5});function G5(e){return Gn(e,0)}var aE=le({concat1d_:G5});function K5(e,t){return Gn(e,t)}var rE=le({concat2d_:K5});function $5(e,t){return Gn(e,t)}var iE=le({concat3d_:$5});function J5(e,t){return Gn(e,t)}var sE=le({concat4d_:J5});function Y5(e,t,n,a,r="NHWC",i=[1,1],s){let o=$(e,"x","conv2d","float32"),u=$(t,"filter","conv2d","float32"),d=o,c=!1;o.rank===3&&(c=!0,d=ge(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ee(d.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${d.rank}.`),ee(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Jr("conv2d",a,s);let h=r==="NHWC"?d.shape[3]:d.shape[1];ee(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),ee(ll(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),ee(rp(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),ee(rp(n),()=>"Error in conv2D: Strides should be larger than 0.");let m={x:d,filter:u},g={strides:n,pad:a,dataFormat:r,dilations:i,dimRoundingMode:s},x=oe.runKernel(Tp,m,g);return c?ge(x,[x.shape[1],x.shape[2],x.shape[3]]):x}var Hr=le({conv2d_:Y5});function j5(e,t,n,a,r="NWC",i=1,s){let o=$(e,"x","conv1d"),u=$(t,"filter","conv1d"),d=o,c=!1;o.rank===2&&(c=!0,d=ge(o,[1,o.shape[0],o.shape[1]])),ee(d.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${d.rank}.`),ee(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Jr("conv1d",a,s),ee(d.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${d.shape[2]}) must match input depth for filter ${u.shape[1]}.`),ee(ll(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),ee(rp(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),ee(rp(n),()=>"Error in conv1D: Stride should be larger than 0."),ee(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);let h=ge(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=ge(d,[d.shape[0],1,d.shape[1],d.shape[2]]),g=Hr(m,h,[1,n],a,"NHWC",[1,i],s);return c?ge(g,[g.shape[2],g.shape[3]]):ge(g,[g.shape[0],g.shape[2],g.shape[3]])}var vv=le({conv1d_:j5});function Q5(e,t,n,a,r,i="NHWC",s){ee(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,u=t,d=!1;t.rank===3&&(d=!0,u=ge(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),ee(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),ee(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),ee(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let c=i==="NHWC"?o[3]:o[1],h=i==="NHWC"?u.shape[3]:u.shape[1];ee(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),ee(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),Jr("conv2dDerInput",r,s);let m={dy:u,filter:n},g={strides:a,pad:r,dataFormat:i,dimRoundingMode:s,inputShape:o},x=oe.runKernel(Np,m,g);return d?ge(x,[x.shape[1],x.shape[2],x.shape[3]]):x}var oE=le({conv2DBackpropInput_:Q5});function Z5(e,t,n,a,r,i){let s=$(e,"x","conv2dTranspose"),o=$(t,"filter","conv2dTranspose");return oE(n,s,o,a,r,"NHWC",i)}var Sv=le({conv2dTranspose_:Z5});function X5(e,t,n,a,r="NDHWC",i=[1,1,1]){let s=$(e,"x","conv3d"),o=$(t,"filter","conv3d"),u=s,d=!1;s.rank===4&&(d=!0,u=ge(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),ee(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),ee(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),ee(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),ee(ll(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),ee(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),ee(rp(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),ee(rp(n),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:u,filter:o},h={strides:n,pad:a,dataFormat:r,dilations:i},m=oe.runKernel(Rp,c,h);return d?ge(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var lE=le({conv3d_:X5});function eP(e,t,n,a,r){ee(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,s=t,o=!1;t.rank===4&&(o=!0,s=ge(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,e[0],e[1],e[2],e[3]]);let u=i[4],d=s.shape[4];ee(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),ee(s.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${s.rank}`),ee(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),ee(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),ee(d===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[4]}.`);let c={dy:s,filter:n},h={pad:r,strides:a,inputShape:i},m=oe.runKernel(Hm,c,h);return o?ge(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var uF=le({conv3DBackpropInput_:eP});function tP(e,t,n,a,r){let i=$(e,"x","conv3dTranspose"),s=$(t,"filter","conv3dTranspose");return uF(n,i,s,a,r)}var uE=le({conv3dTranspose_:tP});function nP(e){let t={x:$(e,"x","cos","float32")};return oe.runKernel(Fp,t)}var U0=le({cos_:nP});function aP(e){let t={x:$(e,"x","cosh","float32")};return oe.runKernel(Dp,t)}var kv=le({cosh_:aP});function rP(e,t=0,n=!1,a=!1){let r={x:$(e,"x","cumprod")},i={axis:t,exclusive:n,reverse:a};return oe.runKernel(Gm,r,i)}var Xy=le({cumprod_:rP});function iP(e,t=0,n=!1,a=!1){let r={x:$(e,"x","cumsum")},i={axis:t,exclusive:n,reverse:a};return oe.runKernel(Op,r,i)}var Av=le({cumsum_:iP});function sP(e,t,n,a=!1){let r=$(e,"x","denseBincount"),i=$(t,"weights","denseBincount");ee(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),ee(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),ee(n>=0,()=>`size must be non-negative, but got ${n}.`),ee(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);let s={x:r,weights:i},o={size:n,binaryOutput:a};return oe.runKernel(m0,s,o)}var C1=le({denseBincount_:sP});function oP(e,t,n="NHWC"){let a=$(e,"x","depthToSpace","float32"),r=n==="NHWC"?a.shape[1]:a.shape[2],i=n==="NHWC"?a.shape[2]:a.shape[3],s=n==="NHWC"?a.shape[3]:a.shape[1];ee(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),ee(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${a.shape}`),ee(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t} for depthToSpace with input shape
        ${a.shape}`),ee(s%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${s} for depthToSpace with input shape ${a.shape}`);let o={x:a},u={blockSize:t,dataFormat:n};return oe.runKernel($m,o,u)}var cE=le({depthToSpace_:oP});function lP(e,t,n,a,r="NHWC",i=[1,1],s){let o=$(e,"x","depthwiseConv2d","float32"),u=$(t,"filter","depthwiseConv2d","float32"),d=o,c=!1;o.rank===3&&(c=!0,d=ge(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ee(d.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),ee(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);let h=r==="NHWC"?d.shape[3]:d.shape[1];ee(h===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`),Jr("depthwiseConv2d",a,s);let m={x:d,filter:u},g={strides:n,pad:a,dataFormat:r,dilations:i,dimRoundingMode:s},x=oe.runKernel(Mp,m,g);return c?ge(x,[x.shape[1],x.shape[2],x.shape[3]]):x}var Bh=le({depthwiseConv2d_:lP});function uP(e){let t={x:$(e,"x","diag")};return oe.runKernel(g0,t)}var cF=le({diag_:uP});function cP(e,t,n,a,r=[1,1],i="NHWC"){let s=$(e,"x","dilation2d"),o=$(t,"filter","dilation2d");ee(s.rank===3||s.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${s.rank}.`),ee(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),ee(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let u=s,d=!1;s.rank===3&&(u=ge(s,[1,s.shape[0],s.shape[1],s.shape[2]]),d=!0),ee(u.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`);let c={x:u,filter:o},h={strides:n,pad:a,dilations:r},m=oe.runKernel(Bp,c,h);return d?ge(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var dE=le({dilation2d_:cP}),Mg={};qt(Mg,{assertAndGetBroadcastShape:()=>Kn,getBroadcastDims:()=>dF,getReductionAxes:()=>La});function dF(e,t){let n=e.length,a=[];for(let r=0;r<n;r++){let i=n-1-r,s=e[i]||1;(t[t.length-1-r]||1)>1&&s===1&&a.unshift(i)}return a}function La(e,t){let n=[];for(let a=0;a<t.length;a++){let r=e[e.length-a-1],i=t.length-a-1,s=t[i];(r==null||r===1&&s>1)&&n.unshift(i)}return n}function Kn(e,t){let n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let i=e[e.length-r-1];i==null&&(i=1);let s=t[t.length-r-1];if(s==null&&(s=1),i===1)a[n-r-1]=s;else if(s===1)a[n-r-1]=i;else if(i!==s){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else a[n-r-1]=i}return a}function dP(e,t){let n=$(e,"a","equal","string_or_numeric"),a=$(t,"b","equal","string_or_numeric");[n,a]=va(n,a),Kn(n.shape,a.shape);let r={a:n,b:a};return oe.runKernel(Ym,r)}var Fi=le({equal_:dP});function pP(e,t,n){let a=$(t,"a","where"),r=$(n,"b","where"),i=$(e,"condition","where","bool"),s=Kn(Kn(i.shape,a.shape),r.shape),o=Gd(i,s),u=Gd(a,s),d=Gd(r,s),c={condition:o,t:u,e:d};return oe.runKernel(kg,c)}var lr=le({where_:pP});function hP(e){let t={x:$(e,"x","zerosLike")};return oe.runKernel(Dg,t)}var gn=le({zerosLike_:hP});function fP(e,t){let n=$(e,"a","div"),a=$(t,"b","div");[n,a]=va(n,a);let r=it(n,a),i=gn(r),s=Fi(a,i);return lr(s,i,r)}var pE=le({divNoNan_:fP});function mP(e,t){let n=$(e,"t1","dot"),a=$(t,"t2","dot");ee((n.rank===1||n.rank===2)&&(a.rank===1||a.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`);let r=n.rank===1?n.size:n.shape[1],i=a.rank===1?a.size:a.shape[0];if(ee(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),n.rank===1&&a.rank===1){let s=ge(n,[1,-1]),o=ge(a,[-1,1]),u=jt(s,o);return ge(u,[])}else if(n.rank===1&&a.rank===2){let s=ge(n,[1,-1]),o=ge(a,[a.shape[0],a.shape[1]]),u=jt(s,o);return ge(u,[u.size])}else if(n.rank===2&&a.rank===1){let s=ge(a,[-1,1]),o=jt(n,s);return ge(o,[o.size])}else{let s=ge(a,[a.shape[0],a.shape[1]]);return jt(n,s)}}var hE=le({dot_:mP});function gP(e,...t){let n=t.map((r,i)=>$(r,`tensors${i}`,"einsum")),a={equation:e};return oe.runKernel(lv,n,a)}var Ud=le({einsum_:gP});function bP(e){let t={x:$(e,"x","elu","float32")};return oe.runKernel(zp,t)}var Bg=le({elu_:bP});function yP(e,t){let n=$(e,"x","ensureShape","string_or_numeric");if(!m3(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var pF=le({ensureShape_:yP});function wP(e){let t=$(e,"x","erf");ee(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=je(t,"float32"));let n={x:t};return oe.runKernel(Up,n)}var Ev=le({erf_:wP});function fE(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function hF(e,t,n){let a=e.length+t.length,r=[],i=0,s=0;for(let o=0;o<a;o++)n.indexOf(o)===-1?r.push(e[i++]):r.push(t[s++]);return r}function fF(e,t){let n=[],a=e.length;for(let i=0;i<a;i++)t.indexOf(i)===-1&&n.push(e[i]);let r=t.map(i=>e[i]);return[n,r]}function ip(e,t){let n=t.map(a=>1);return hF(e,n,t)}function xP(e,t,n){ee(fE(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function mF(e,t){if(fE(e,t))return null;let n=[];for(let a=0;a<t;++a)e.indexOf(a)===-1&&n.push(a);return e.forEach(a=>n.push(a)),n}function mE(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function vP(e,t){let n=[];for(let a=t-e;a<t;++a)n.push(a);return n}function SP(e,t=null,n=!1){let a={x:$(e,"x","max")},r={reductionIndices:t,keepDims:n};return oe.runKernel(eh,a,r)}var ns=le({max_:SP});function kP(e,t=null,n=!1){let a={x:$(e,"x","min")},r={axis:t,keepDims:n};return oe.runKernel(rh,a,r)}var ym=le({min_:kP});function AP(e,t){let n=$(e,"base","pow"),a=$(t,"exp","pow");[n,a]=va(n,a);let r={a:n,b:a};return oe.runKernel(dh,r)}var il=le({pow_:AP});function gt(e,t){if((ir(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&ir(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Uc(e,[],[],t)}function EP(e){let t={x:$(e,"x","sqrt","float32")};return oe.runKernel(_h,t)}var ur=le({sqrt_:EP});function CP(e){let t=$(e,"x","square"),n={};return oe.runKernel("Square",{x:t},n)}var Hn=le({square_:CP});function IP(e,t=null,n=!1){let a=$(e,"x","sum");a.dtype==="bool"&&(a=je(a,"int32"));let r={x:a},i={axis:t,keepDims:n};return oe.runKernel(Th,r,i)}var lt=le({sum_:IP});function _P(e,t="euclidean",n=null,a=!1){e=$(e,"x","norm");let r=gF(e,t,n),i=r.shape;if(a){let s=Fs(n,e.shape);i=ip(r.shape,s)}return ge(r,i)}function gF(e,t,n=null){if(e.rank===0)return Da(e);if(e.rank!==1&&n===null)return gF(ge(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return lt(Da(e),n);if(t===1/0)return ns(Da(e),n);if(t===-1/0)return ym(Da(e),n);if(t==="euclidean"||t===2)return ur(lt(il(Da(e),gt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return ns(lt(Da(e),n[0]),n[1]-1);if(t===1/0)return ns(lt(Da(e),n[1]),n[0]);if(t===-1/0)return ym(lt(Da(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return ur(lt(Hn(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var Lg=le({norm_:_P});function TP(e,t=null,n=!1){return Lg(e,"euclidean",t,n)}var gE=le({euclideanNorm_:TP});function NP(e){let t={x:$(e,"x","exp")};return oe.runKernel(Vp,t)}var Fr=le({exp_:NP});function RP(e,t=0){let n=$(e,"x","expandDims","string_or_numeric");ee(t<=n.rank,()=>"Axis must be <= rank of the tensor");let a={input:n},r={dim:t};return oe.runKernel(jm,a,r)}var sr=le({expandDims_:RP});function FP(e){let t={x:$(e,"x","expm1")};return oe.runKernel(Wp,t)}var bE=le({expm1_:FP});function DP(e,t){let n=$(e,"x","tile","string_or_numeric");ee(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let a={x:n},r={reps:t};return oe.runKernel(Lc,a,r)}var Ti=le({tile_:DP});function OP(e,t,n,a="float32"){t==null&&(t=e);let r=Zt([e,t],a),i=e<=t?e:t;for(let o=0;o<i;++o)r.set(1,o,o);let s=ge(r.toTensor(),[e,t]);if(n==null)return s;if(n.length===1)return Ti(sr(s,0),[n[0],1,1]);if(n.length===2)return Ti(sr(sr(s,0),0),[n[0],n[1],1,1]);if(n.length===3)return Ti(sr(sr(sr(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var Cv=le({eye_:OP});function MP(e){let t={x:$(e,"x","floor","float32")};return oe.runKernel(qp,t)}var zg=le({floor_:MP});function BP(e,t,n=0,a=0){let r=$(e,"x","gather"),i=$(t,"indices","gather","int32"),s={x:r,indices:i},o={axis:n,batchDims:a};return oe.runKernel(Zm,s,o)}var Ug=le({gather_:BP});function LP(e,t){let n=$(e,"a","greater","string_or_numeric"),a=$(t,"b","greater","string_or_numeric");[n,a]=va(n,a),Kn(n.shape,a.shape);let r={a:n,b:a};return oe.runKernel(eg,r)}var Yr=le({greater_:LP});function zP(e,t){let n=$(e,"a","greaterEqual","string_or_numeric"),a=$(t,"b","greaterEqual","string_or_numeric");[n,a]=va(n,a),Kn(n.shape,a.shape);let r={a:n,b:a};return oe.runKernel(Gp,r)}var ou=le({greaterEqual_:zP});function UP(e){let t={input:$(e,"input","imag")};return oe.runKernel(dv,t)}var V0=le({imag_:UP});function VP(e){let t={x:$(e,"x","isFinite")};return oe.runKernel($p,t)}var yE=le({isFinite_:VP});function WP(e){let t={x:$(e,"x","isInf")};return oe.runKernel(Jp,t)}var wE=le({isInf_:WP});function qP(e){let t={x:$(e,"x","isNaN")};return oe.runKernel(Yp,t)}var xE=le({isNaN_:qP});function PP(e,t=.2){let n={x:$(e,"x","leakyRelu")},a={alpha:t};return oe.runKernel(jp,n,a)}var W0=le({leakyRelu_:PP});function HP(e,t){let n=$(e,"a","less","string_or_numeric"),a=$(t,"b","less","string_or_numeric");[n,a]=va(n,a),Kn(n.shape,a.shape);let r={a:n,b:a};return oe.runKernel(tg,r)}var wm=le({less_:HP});function GP(e,t){let n=$(e,"a","lessEqual","string_or_numeric"),a=$(t,"b","lessEqual","string_or_numeric");[n,a]=va(n,a),Kn(n.shape,a.shape);let r={a:n,b:a};return oe.runKernel(ng,r)}var Vc=le({lessEqual_:GP});function bF(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let a={start:e,stop:t,num:n};return oe.runKernel(ag,{},a)}function KP(e,t=5,n=1,a=1,r=.5){let i=$(e,"x","localResponseNormalization");ee(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),ee(fm(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let s=i,o=!1;i.rank===3&&(o=!0,s=ge(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let u={x:s},d={depthRadius:t,bias:n,alpha:a,beta:r},c=oe.runKernel(Xp,u,d);return o?ge(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var vE=le({localResponseNormalization_:KP});function $P(e){let t={x:$(e,"x","log","float32")};return oe.runKernel(Qp,t)}var Di=le({log_:$P});function JP(e){let t={x:$(e,"x","log1p")};return oe.runKernel(Zp,t)}var q0=le({log1p_:JP});function YP(e){return ee(yc(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let a=$(t,"x","tf.grad","string_or_numeric"),r=n!=null?$(n,"dy","tf.grad"):null;return oe.tidy(()=>{let{value:i,grads:s}=oe.gradients(()=>e(a),[a],r);return r!=null&&$r(i.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Iv(s),s[0]})}}function jP(e){return ee(yc(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{ee(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let a=Yy(t,"args","tf.grads","string_or_numeric"),r=n!=null?$(n,"dy","tf.grads"):null;return oe.tidy(()=>{let{value:i,grads:s}=oe.gradients(()=>e(...a),a,r);return r!=null&&$r(i.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Iv(s),s})}}function QP(e){return ee(yc(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{ee(t instanceof $t,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),ee(n==null||n instanceof $t,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:a,value:r}=oe.gradients(()=>e(t),[t],n);return Iv(a),{grad:a[0],value:r}}}function ZP(e){return ee(yc(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{ee(Array.isArray(t)&&t.every(r=>r instanceof $t),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),ee(n==null||n instanceof $t,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let a=oe.gradients(()=>e(...t),t,n);return n!=null&&$r(a.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Iv(a.grads),a}}function yF(e,t){ee(yc(e),()=>"The f passed in variableGrads(f) must be a function"),ee(t==null||Array.isArray(t)&&t.every(d=>d instanceof Xd),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let d in oe.registeredVariables)t.push(oe.registeredVariables[d])}let a=n?t.filter(d=>!d.trainable):null,r=t.length;t=t.filter(d=>d.trainable),ee(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);let i=!0,{value:s,grads:o}=oe.gradients(e,t,null,i);ee(o.some(d=>d!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),ee(s.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);let u={};return t.forEach((d,c)=>{o[c]!=null&&(u[d.name]=o[c])}),a!=null&&a.forEach(d=>u[d.name]=null),{value:s,grads:u}}function sl(e){return oe.customGrad(e)}function Iv(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function XP(e){let t={x:$(e,"x","neg")};return oe.runKernel(cg,t)}var ia=le({neg_:XP});function eH(e){let t={x:$(e,"x","softplus")};return oe.runKernel(Ih,t)}var Lh=le({softplus_:eH});function tH(e){let t=$(e,"x","logSigmoid");return sl(n=>({value:ia(Lh(ia(n))),gradFunc:a=>pe(a,Ns(ia(n)))}))(t)}var SE=le({logSigmoid_:tH});function nH(e,t){let n=$(e,"a","sub"),a=$(t,"b","sub");[n,a]=va(n,a);let r={a:n,b:a};return oe.runKernel(Fh,r)}var at=le({sub_:nH});function aH(e,t=-1){let n=$(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return sl((a,r)=>{let i=ns(a,t,!0),s=at(a,i),o=at(je(s,"float32"),Di(lt(Fr(s),t,!0)));return r([o]),{value:o,gradFunc:(u,d)=>{let[c]=d,h=!0,m=Fr(c);return at(u,pe(lt(u,t,h),m))}}})(n)}var _v=le({logSoftmax_:aH});function rH(e,t=null,n=!1){let a=$(e,"x","logSumExp"),r=Fs(t,a.shape),i=ns(a,r,!0),s=at(a,i),o=Fr(s),u=lt(o,r),d=Di(u),c=Oe(ge(i,d.shape),d);if(n){let h=ip(c.shape,r);return ge(c,h)}return c}var P0=le({logSumExp_:rH});function iH(e,t){let n=$(e,"a","logicalAnd","bool"),a=$(t,"b","logicalAnd","bool");Kn(n.shape,a.shape);let r={a:n,b:a};return oe.runKernel(rg,r)}var Rs=le({logicalAnd_:iH});function sH(e){let t={x:$(e,"x","logicalNot","bool")};return oe.runKernel(ig,t)}var H0=le({logicalNot_:sH});function oH(e,t){let n=$(e,"a","logicalOr","bool"),a=$(t,"b","logicalOr","bool");Kn(n.shape,a.shape);let r={a:n,b:a};return oe.runKernel(sg,r)}var Tv=le({logicalOr_:oH});function lH(e,t){let n=$(e,"a","logicalXor","bool"),a=$(t,"b","logicalXor","bool");return Kn(n.shape,a.shape),Rs(Tv(e,t),H0(Rs(e,t)))}var kE=le({logicalXor_:lH}),Hx=2147483648;function uH(e,t,n="left"){let a=$(e,"sortedSequence","searchSorted"),r=$(t,"values","searchSorted"),i=a.shape[a.shape.length-1],s=r.shape[r.shape.length-1],o=ge(a,[-1,i]),u=ge(r,[-1,s]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Un(u.shape)>=Hx)throw new Error(`values tensor size must less than ${Hx}`);if(o.shape[1]>=Hx)throw new Error(`trailing dim_size must less than ${Hx} for int32 output type, was ${o.shape[1]}`);let d={sortedSequence:o,values:u},c={side:n};return oe.runKernel(Sg,d,c)}var Nv=le({searchSorted_:uH});function wF(e,t){return Nv(e,t,"left")}function cH(e,t,n,a,r){let i=$(e,"x","maxPool"),s=1,o=i,u=!1;i.rank===3&&(u=!0,o=ge(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ee(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),ee(ll(n,s),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),Jr("maxPool",a,r);let d={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r},h=oe.runKernel(nh,d,c);return u?ge(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var ar=le({maxPool_:cH});function dH(e,t=[1,1,1],n,a,r,i="NDHWC"){let s=$(e,"x","maxPool3d"),o=s,u=!1;s.rank===4&&(u=!0,o=ge(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),ee(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),ee(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Jr("maxPool3d",a,r);let d={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:i},h=oe.runKernel(lg,d,c);return u?ge(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var AE=le({maxPool3d_:dH});function pH(e,t,n,a,r=!1){let i={x:$(e,"x","maxPoolWithArgmax")},s={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},o=oe.runKernel(x0,i,s);return{result:o[0],indexes:o[1]}}var xF=le({maxPoolWithArgmax_:pH});function hH(e,t){let n=$(e,"a","maximum"),a=$(t,"b","maximum");[n,a]=va(n,a),n.dtype==="bool"&&(n=je(n,"int32"),a=je(a,"int32")),Kn(n.shape,a.shape);let r={a:n,b:a};return oe.runKernel(th,r)}var ul=le({maximum_:hH});function fH(e,t=null,n=!1){let a={x:$(e,"x","mean")},r={axis:t,keepDims:n};return oe.runKernel(ah,a,r)}var ya=le({mean_:fH});function wa(e,t="float32"){if(Bi(e),t==="complex64"){let a=wa(e,"float32"),r=wa(e,"float32");return nu(a,r)}let n=tv(Un(e),t);return oe.makeTensor(n,e,t)}function oi(e,t="float32"){if(Bi(e),t==="complex64"){let a=oi(e,"float32"),r=wa(e,"float32");return nu(a,r)}let n=RA(Un(e),t);return oe.makeTensor(n,e,t)}function vF(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let a=$(e,"x","meshgrid",e instanceof $t?e.dtype:"float32");if(t===void 0)return[a];let r=$(t,"y","meshgrid",t instanceof $t?t.dtype:"float32"),i=Un(a.shape),s=Un(r.shape);return n==="xy"?(a=ge(a,[1,-1]),r=ge(r,[-1,1]),[jt(oi([s,1],a.dtype),a),jt(r,oi([1,i],r.dtype))]):(a=ge(a,[-1,1]),r=ge(r,[1,-1]),[jt(a,oi([1,s],a.dtype)),jt(oi([i,1],r.dtype),r)])}function mH(e,t){let n=$(e,"a","minimum"),a=$(t,"b","minimum");[n,a]=va(n,a),n.dtype==="bool"&&(n=je(n,"int32"),a=je(a,"int32")),Kn(n.shape,a.shape);let r={a:n,b:a};return oe.runKernel(ih,r)}var Ac=le({minimum_:mH});function gH(e,t,n){ee(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let a=$(e,"x","mirrorPad");if(a.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");ee(t.length===a.rank,()=>`Padding doesn't match input. Must be ${a.rank}. Got ${t.length}.`);let r=n==="reflect"?1:0;for(let o=0;o<a.rank;o++)ee(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ee(t[o][0]>=0&&t[o][0]<=a.shape[o]-r&&t[o][1]>=0&&t[o][1]<=a.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${a.shape[o]-r} or less than 0 for input of shape ${a.shape}`);let i={paddings:t,mode:n},s={x:a};return oe.runKernel(sh,s,i)}var EE=le({mirrorPad_:gH});function bH(e,t){let n=$(e,"a","mod"),a=$(t,"b","mod");[n,a]=va(n,a);let r={a:n,b:a};return oe.runKernel(oh,r)}var CE=le({mod_:bH});function yH(e,t=null,n=!1){e=$(e,"x","moments");let a=Fs(t,e.shape),r=ya(e,a,n),i=r.shape;n||(i=ip(r.shape,a));let s=Hn(at(je(e,"float32"),ge(r,i))),o=ya(s,a,n);return{mean:r,variance:o}}var G0=le({moments_:yH});function wH(e,t,n,a){let r=$(t,"data","multiRNNCell"),i=Yy(n,"c","multiRNNCell"),s=Yy(a,"h","multiRNNCell"),o=r,u=[];for(let h=0;h<e.length;h++){let m=e[h](o,i[h],s[h]);u.push(m[0]),u.push(m[1]),o=m[1]}let d=[],c=[];for(let h=0;h<u.length;h+=2)d.push(u[h]),c.push(u[h+1]);return[d,c]}var SF=le({multiRNNCell_:wH});function xH(e,t,n,a=!1){let r=$(e,"logits","multinomial"),i=r.size,s=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(s>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${s}`);n=n||Math.random();let o={logits:s===1?ge(r,[1,-1]):r},u={numSamples:t,seed:n,normalized:a},d=oe.runKernel(ug,o,u);return s===1?ge(d,[d.size]):d}var kF=le({multinomial_:xH});function vH(e,t){let n=$(e,"a","notEqual","string_or_numeric"),a=$(t,"b","notEqual","string_or_numeric");[n,a]=va(n,a),Kn(n.shape,a.shape);let r={a:n,b:a};return oe.runKernel(dg,r)}var sp=le({notEqual_:vH});function SH(e,t,n=1,a=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let i={indices:$(e,"indices","oneHot","int32")},s={dtype:r,depth:t,onValue:n,offValue:a};return oe.runKernel(uh,i,s)}var xm=le({oneHot_:SH});function kH(e){let t={x:$(e,"x","onesLike")};return oe.runKernel(mg,t)}var Oi=le({onesLike_:kH});function AH(e,t){let n=$(e,"v1","outerProduct"),a=$(t,"v2","outerProduct");ee(n.rank===1&&a.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${a.rank}.`);let r=ge(n,[-1,1]),i=ge(a,[1,-1]);return jt(r,i)}var AF=le({outerProduct_:AH});function EH(e,t,n=0){let a=$(e,"x","pad");if(a.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let r={paddings:t,constantValue:n},i={x:a};return oe.runKernel(ch,i,r)}var ho=le({pad_:EH});function CH(e,t,n=0){return ee(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),ho(e,[t],n)}var EF=le({pad1d_:CH});function IH(e,t,n=0){return ee(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(e,t,n)}var CF=le({pad2d_:IH});function _H(e,t,n=0){return ee(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(e,t,n)}var IF=le({pad3d_:_H});function TH(e,t,n=0){return ee(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(e,t,n)}var _F=le({pad4d_:TH});function NH(e,t,n){let a=$(e,"x","spaceToBatchND");ee(a.rank>=1+t.length,()=>`input rank ${a.rank} should be > than [blockShape] ${t.length}`),ee(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),ee(a.shape.reduce((s,o,u)=>u>0&&u<=t.length?s&&(o+n[u-1][0]+n[u-1][1])%t[u-1]===0:s,!0),()=>`input spatial dimensions ${a.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let r={x:a},i={blockShape:t,paddings:n};return oe.runKernel(Eg,r,i)}var K0=le({spaceToBatchND_:NH});function RH(e,t,n,a,r,i,s){r==null&&(r=[1,1]),i==null&&(i=1),a===0&&(a="valid");let o=$(e,"x","maxPool"),u=o,d=!1;o.rank===3&&(d=!0,u=ge(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ee(ll(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);let c=aF(u.shape,t,i,r,a),h=[c.dilationHeight,c.dilationWidth],m;a==="same"?m=DH([c.filterHeight,c.filterWidth],h):m=[[0,0],[0,0]];let g=h[0]===1&&h[1]===1,[x,v]=FH([c.inHeight,c.inWidth],h,m),S=g?a:"valid",E=g?u:K0(u,h,x),C=(n==="avg"?()=>su(E,t,i,S,s):()=>ar(E,t,i,S,s))(),T=g?C:z0(C,h,v);return d?ge(T,[T.shape[1],T.shape[2],T.shape[3]]):T}function FH(e,t,n){let a=n.map(c=>c[0]),r=n.map(c=>c[1]),i=e.concat(a,r),s=t.map((c,h)=>(c-i[h]%c)%c),o=r.map((c,h)=>c+s[h]),u=t.map((c,h)=>[a[h],o[h]]),d=t.map((c,h)=>[0,s[h]]);return[u,d]}function DH(e,t){let n=e.map((i,s)=>i+(i-1)*(t[s]-1)).map(i=>i-1),a=n.map(i=>Math.floor(i/2)),r=n.map((i,s)=>i-a[s]);return n.map((i,s)=>[a[s],r[s]])}var IE=le({pool_:RH});function OH(e,t){let n=$(e,"x","prelu"),a=$(t,"alpha","prelu"),r={x:n,alpha:a};return oe.runKernel(ph,r)}var $0=le({prelu_:OH});function MH(e,t=null,n=!1){let a=$(e,"x","prod");a.dtype==="bool"&&(a=je(a,"int32"));let r={x:a},i={axis:t,keepDims:n};return oe.runKernel(hh,r,i)}var _E=le({prod_:MH});function BH(e,t,n,a){let r=e.map((c,h)=>$(c,`tensors${h}`,"raggedGather","int32")),i=$(t,"paramsDenseValues","raggedGather"),s=$(n,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:i,indices:s},u={outputRaggedRank:a},d=oe.runKernel(pv,o,u);return{outputNestedSplits:d.slice(0,d.length-1),outputDenseValues:d[d.length-1]}}var TF=le({raggedGather_:BH});function LH(e,t,n){let a=$(e,"starts","raggedRange"),r=$(t,"limits","raggedRange",a.dtype),i=$(n,"deltas","raggedRange",a.dtype),s={starts:a,limits:r,deltas:i},o=oe.runKernel(hv,s);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var NF=le({raggedRange_:LH});function zH(e,t,n,a,r){let i=$(e,"shape","raggedTensorToTensor","int32"),s=$(t,"values","raggedTensorToTensor"),o=$(n,"defaultValue","raggedTensorToTensor",s.dtype),u=a.map((h,m)=>$(h,`tensors${m}`,"raggedTensorToTensor","int32")),d={shape:i,values:s,defaultValue:o,rowPartitionTensors:u},c={rowPartitionTypes:r};return oe.runKernel(fv,d,c)}var RF=le({raggedTensorToTensor_:zH});function UH(e,t,n){Bi(e);let a=Un(e),r=null;if(n==null||n==="float32")r=new Float32Array(a);else if(n==="int32")r=new Int32Array(a);else if(n==="bool")r=new Uint8Array(a);else throw new Error(`Unknown data type ${n}`);for(let i=0;i<a;i++)r[i]=t();return oe.makeTensor(r,e,n)}var FF=le({rand_:UH}),TE=Oc(X1()),DF={};qt(DF,{TEST_EPSILON_FLOAT16:()=>OF,createVideoElement:()=>$H,encodeStrings:()=>MF,expectArrayBuffersEqual:()=>KH,expectArraysClose:()=>WH,expectArraysEqual:()=>PH,expectNumbersClose:()=>HH,expectPromiseToFail:()=>qH,expectValuesInRange:()=>GH,play:()=>JH,testEpsilon:()=>NE});var VH=.001,OF=.1;function WH(e,t,n){return n==null&&(n=NE()),Rk(e,t,(a,r)=>RE(a,r,n))}function NE(){return oe.backend.floatPrecision()===32?VH:OF}function Rk(e,t,n){let a=!0;if((ir(e)||ir(t))&&(a=!1),ir(e)&&ir(t)&&(a=!0),a){let s=e.constructor.name,o=t.constructor.name;if(s!==o)throw new Error(`Arrays are of different type. Actual: ${s}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let s=rl(e),o=rl(t);if(!ru(s,o))throw new Error(`Arrays have different shapes. Actual: [${s}]. Expected: [${o}]`)}let r=ir(e)?e:wc(e),i=ir(t)?t:wc(t);if(r.length!==i.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${i.length}.
Actual:   ${r}.
Expected: ${i}.`);for(let s=0;s<i.length;++s){let o=r[s],u=i[s];if(!n(o,u))throw new Error(`Arrays differ: actual[${s}] = ${o}, expected[${s}] = ${u}.
Actual:   ${r}.
Expected: ${i}.`)}typeof expect<"u"&&expect().nothing()}function qH(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function PH(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return dc(e)||dc(e[0])||dc(t)||dc(t[0])?Rk(e,n,(a,r)=>a==r):Rk(e,t,(a,r)=>RE(a,r,0))}function HH(e,t,n){if(n==null&&(n=NE()),!RE(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function RE(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function GH(e,t,n){for(let a=0;a<e.length;a++)if(e[a]<t||e[a]>n)throw new Error(`Value out of range:${e[a]} low: ${t}, high: ${n}`)}function KH(e,t){let n=new Float32Array(e),a=new Float32Array(t);if(n.length!==a.length)throw new Error(`Expected ArrayBuffer to be of length ${a.length}, but it was ${n.length}`);for(let r=0;r<a.length;r++)if(n[r]!==a[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${a[r]} but got ${n[r]} instead`)}function MF(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?MF(n):e[t]=O0(n)}return e}function $H(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",a=>n(t)),t.load()})}async function JH(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var FE=class{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=r||Math.random();this.random=TE.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let a=this.nextVal;return this.nextVal=NaN,a}let e,t,n=!1;for(;!n;){let a,r,i;do a=2*this.random()-1,r=2*this.random()-1,i=a*a+r*r;while(i>=1||i===0);let s=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*a*s,t=this.mean+this.stdDev*r*s,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},YH=class{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;let r=a||Math.random();this.randu=TE.alea(r.toString()),this.randn=new FE(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,i;for(;;){do a=this.randn.nextValue(),i=1+this.c*a;while(i<=0);if(i*=i*i,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-i+Math.log(i)),r=this.randu(),r<t||Math.log(r)<n)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},jH=class{constructor(e=0,t=1,n,a){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,a==null&&(a=Math.random()),typeof a=="number"&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=TE.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function QH(e,t,n=1,a="float32",r){if(Bi(e),n==null&&(n=1),a==null&&(a="float32"),a!=="float32"&&a!=="int32")throw new Error(`Unsupported data type ${a}`);let i=new YH(t,n,a,r),s=Zt(e,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var BF=le({randomGamma_:QH});function ZH(e,t=0,n=1,a,r){if(Bi(e),a!=null&&a==="bool")throw new Error(`Unsupported data type ${a}`);let i=new FE(t,n,a,!1,r),s=Zt(e,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var Rv=le({randomNormal_:ZH});function XH(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return Rv(e,0,1,t,n)}var LF=le({randomStandardNormal_:XH});function e8(e,t=0,n=1,a="float32",r){Bi(e);let i=Zt(e,a),s=new jH(t,n,null,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Wc=le({randomUniform_:e8});function t8(e,t,n,a){return Wc(e,t,n,"int32",a)}var zF=le({randomUniformInt_:t8});function op(e,t,n=1,a="float32"){if(n===0)throw new Error("Cannot have a step of zero");let r={start:e,stop:t,step:n,dtype:a};return oe.runKernel(v0,{},r)}function n8(e){let t={input:$(e,"input","real")};return oe.runKernel(mv,t)}var vm=le({real_:n8});function a8(e){let t={x:$(e,"x","reciprocal")};return oe.runKernel(fh,t)}var DE=le({reciprocal_:a8});function r8(e){let t={x:$(e,"x","relu")};return oe.runKernel(mh,t)}var zn=le({relu_:r8});function i8(e){let t={x:$(e,"x","relu6")};return oe.runKernel(yh,t)}var Fv=le({relu6_:i8});function s8(e,t){let n={x:$(e,"x","reverse")},a={dims:t};return oe.runKernel(wh,n,a)}var is=le({reverse_:s8});function o8(e){let t=$(e,"x","reverse");return ee(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),is(t,0)}var UF=le({reverse1d_:o8});function l8(e,t){let n=$(e,"x","reverse");return ee(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),is(n,t)}var VF=le({reverse2d_:l8});function u8(e,t){let n=$(e,"x","reverse");return ee(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),is(n,t)}var WF=le({reverse3d_:u8});function c8(e,t){let n=$(e,"x","reverse");return ee(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),is(n,t)}var qF=le({reverse4d_:c8});function d8(e){let t={x:$(e,"x","round")};return oe.runKernel(xh,t)}var Dv=le({round_:d8});function p8(e){let t={x:$(e,"x","rsqrt","float32")};return oe.runKernel(vh,t)}var Ov=le({rsqrt_:p8});function h8(e){let t={x:$(e,"x","selu")};return oe.runKernel(Sh,t)}var Mv=le({selu_:h8});function f8(e,t,n,a,r,i=[1,1],s="NHWC"){let o=$(e,"x","separableConv2d"),u=$(t,"depthwiseFilter","separableConv2d"),d=$(n,"pointwiseFilter","separableConv2d"),c=o,h=!1;if(o.rank===3&&(h=!0,c=ge(o,[1,o.shape[0],o.shape[1],o.shape[2]])),s==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ee(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),ee(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),ee(d.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),ee(d.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${d.shape[0]}.`),ee(d.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${d.shape[1]}.`);let m=u.shape[2],g=u.shape[3];ee(d.shape[2]===m*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*g}, but got ${d.shape[2]}.`);let x=Bh(c,u,a,r,s,i),v=Hr(x,d,1,"valid",s);return h?ge(v,[v.shape[1],v.shape[2],v.shape[3]]):v}var Vg=le({separableConv2d_:f8});async function m8(e,t){let n=$(e,"x","setdiff1d"),a=$(t,"y","setdiff1d");ee(n.dtype===a.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`),ee(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),ee(a.rank===1,()=>`y should be 1D tensor, but got y (${a.shape}).`);let r=await n.data(),i=await a.data(),s=new Set(i),o=0;for(let c=0;c<r.length;c++)s.has(r[c])||o++;let u=new Ma([o],n.dtype),d=new Ma([o],"int32");for(let c=0,h=0;c<r.length;c++)s.has(r[c])||(u.values[h]=r[c],d.values[h]=c,h++);return[u.toTensor(),d.toTensor()]}var PF=m8;function g8(e){let t={x:$(e,"x","sign")};return oe.runKernel(Eh,t)}var OE=le({sign_:g8});function b8(e){let t={x:$(e,"x","sin","float32")};return oe.runKernel(kh,t)}var Bv=le({sin_:b8});function y8(e){let t={x:$(e,"x","sinh")};return oe.runKernel(Ah,t)}var Lv=le({sinh_:y8});function w8(e,t,n){let a=$(e,"x","slice1d");return ee(a.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${a.rank} tensor`),un(a,[t],[n])}var J0=le({slice1d_:w8});function x8(e,t,n){let a=$(e,"x","slice2d");return ee(a.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${a.rank} tensor`),un(a,t,n)}var zv=le({slice2d_:x8});function v8(e,t,n){let a=$(e,"x","slice3d");return ee(a.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${a.rank} tensor`),un(a,t,n)}var Wg=le({slice3d_:v8});function S8(e,t,n){let a=$(e,"x","slice4d");return ee(a.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${a.rank} tensor`),un(a,t,n)}var Sm=le({slice4d_:S8});function k8(e,t=-1){let n=$(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let a={logits:n},r={dim:t};return oe.runKernel(Nh,a,r)}var qc=le({softmax_:k8});function A8(e){ee(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return oe.runKernel(uv,t)}var Y0=le({fft_:A8});function E8(e){ee(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return oe.runKernel(cv,t)}var km=le({ifft_:E8});function C8(e){let t=e.shape[e.shape.length-1],n=e.size/t,a;if(t<=2){let r=ge(e,[n,t]);a=km(r)}else{let r=[n,2*(t-1)],i=ge(vm(e),[n,t]),s=ge(V0(e),[n,t]),o=is(un(i,[0,1],[n,t-2]),1),u=pe(is(un(s,[0,1],[n,t-2]),1),gt(-1)),d=Gn([i,o],1),c=Gn([s,u],1),h=ge(nu(d,c),[r[0],r[1]]);a=km(h)}if(a=vm(a),e.rank===3&&e.shape[0]!==0){let r=a,i=e.shape[0];a=ge(a,[i,a.shape[0]/i,a.shape[1]]),r.dispose()}return a}var Uv=le({irfft_:C8});function I8(e,t,n=0){let a={x:$(e,"x","split")},r={numOrSizeSplits:t,axis:n};return oe.runKernel(Cg,a,r)}var li=le({split_:I8});function _8(e,t){ee(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],a=e.size/n,r;if(t!=null&&t<n){let x=e.shape.map(S=>0),v=e.shape.map(S=>S);v[e.shape.length-1]=t,r=un(e,x,v),n=t}else if(t!=null&&t>n){let x=e.shape.map(v=>v);x[e.shape.length-1]=t-n,r=Gn([e,wa(x)],e.shape.length-1),n=t}else r=e;let i=gn(r),s=ge(nu(r,i),[a,n]),o=Y0(s),u=Math.floor(n/2)+1,d=vm(o),c=V0(o),h=li(d,[u,n-u],d.shape.length-1),m=li(c,[u,n-u],c.shape.length-1),g=r.shape.slice();return g[r.shape.length-1]=u,ge(nu(h[0],m[0]),g)}var j0=le({rfft_:_8});function T8(e,t){let n=$(e,"a","squaredDifference"),a=$(t,"b","squaredDifference");[n,a]=va(n,a),Kn(n.shape,a.shape);let r={a:n,b:a},i={};return oe.runKernel(Rh,r,i)}var Vv=le({squaredDifference_:T8});function N8(e,t){let n=$(e,"x","squeeze","string_or_numeric");return ge(n,g3(n.shape,t).newShape)}var Pc=le({squeeze_:N8});function R8(e,t=0){let n=Yy(e,"tensors","stack","string_or_numeric");ee(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&ee(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let a=n,r={axis:t};return oe.runKernel(gg,a,r)}var Ba=le({stack_:R8});function F8(e,t=0){let n={x:$(e,"x","step")},a={alpha:t};return oe.runKernel(zc,n,a)}var zh=le({step_:F8});function D8(e,t,n,a,r=0,i=0,s=0,o=0,u=0){let d={x:$(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:a,beginMask:r,endMask:i,ellipsisMask:s,newAxisMask:o,shrinkAxisMask:u};return oe.runKernel(Tg,d,c)}var ME=le({stridedSlice_:D8});function O8(e){let t={x:$(e,"x","tan","float32")};return oe.runKernel(Dh,t)}var BE=le({tan_:O8});function Dn(e,t){gp(e);let n=rl(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Uc(e,null,n,t)}function nl(e,t,n){if(gp(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let a=rl(e,n);if(a.length!==2&&a.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Uc(e,t,a,n)}function Wv(e,t,n){if(gp(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let a=rl(e,n);if(a.length!==3&&a.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Uc(e,t,a,n)}function Ec(e,t,n){if(gp(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let a=rl(e,n);if(a.length!==4&&a.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Uc(e,t,a,n)}function HF(e,t,n){if(gp(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let a=rl(e,n);if(a.length!==5&&a.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Uc(e,t,a,n)}function GF(e,t,n){if(gp(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let a=rl(e,n);if(a.length!==6&&a.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||a,Uc(e,t,a,n)}var qv={};qt(qv,{calculateShapes:()=>KF,validateInput:()=>Pv,validateUpdateShape:()=>LE});function LE(e,t,n){let a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${a}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(i+` update.rank < ${r}. `);if(e.length<a+(n.rank-r))throw new Error(i+` Output shape length < ${a+(n.rank-r)}`);if(n.rank!==r+e.length-a)throw new Error(i+` update.rank != ${r+e.length-a}`);for(let s=0;s<r;++s)if(n.shape[s]!==t.shape[s])throw new Error(i+` updates.shape[${s}] (${n.shape[s]}) != indices.shape[${s}] (${t.shape[s]}).`);for(let s=0;s<n.rank-r;++s)if(n.shape[s+r]!==e[s+a])throw new Error(i+` updates.shape[${s+r}] (${n.shape[s+r]}) != shape[${s+r}] (${e[s+r]})`)}function Pv(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}LE(n,t,e)}function KF(e,t,n){let a=t.shape.length,r=a>1?t.shape[a-1]:1,i=n.length,s=1;for(let h=r;h<i;++h)s*=n[h];let o=r<1?1:r,u=Un(t.shape)/o,d=[...Fm(n.slice(0,r)),1],c=Un(n);return{sliceRank:r,numUpdates:u,sliceSize:s,strides:d,outputSize:c}}function M8(e,t,n){let a=$(e,"tensor","tensorScatterupdate"),r=$(t,"indices","tensorScatterupdate","int32"),i=$(n,"updates","tensorScatterupdate");if(Pv(i,r,a.shape),a.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${a.dtype} and ${i.dtype}.`);let s={tensor:a,indices:r,updates:i},o={};return oe.runKernel(vg,s,o)}var $F=le({tensorScatterUpdate_:M8});function B8(e,t=1,n=!0){let a=$(e,"x","topk");if(a.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let r=a.shape[a.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);let i={x:a},s={k:t,sorted:n},[o,u]=oe.runKernel(Ng,i,s);return{values:o,indices:u}}var zE=le({topk_:B8});function L8(e,t=0,n=1,a,r){if(Bi(e),a!=null&&a==="bool")throw new Error("Unsupported data type $ { dtype }");let i=new FE(t,n,a,!0,r),s=Zt(e,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var Hv=le({truncatedNormal_:L8});function z8(e,t=0){let n=$(e,"x","unique","string_or_numeric");ee(n.rank>0,()=>"The input tensor must be at least 1D");let a={x:n},r={axis:t},[i,s]=oe.runKernel(N0,a,r);return{values:i,indices:s}}var UE=le({unique_:z8});function U8(e,t,n){let a=$(e,"x","unsortedSegmentSum"),r=$(t,"segmentIds","unsortedSegmentSum","int32");ee(fm(n),()=>"numSegments must be of dtype int");let i={x:a,segmentIds:r},s={numSegments:n};return oe.runKernel(R0,i,s)}var Gv=le({unsortedSegmentSum_:U8});function V8(e,t=0){let n=$(e,"x","unstack","string_or_numeric");ee(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let a={value:n},r={axis:t};return oe.runKernel(Fg,a,r)}var Aa=le({unstack_:V8});function JF(e,t){return Nv(e,t,"right")}function VE(e,t=!0,n,a){return oe.makeVariable(e,t,n,a)}function YF(e,t){let n=[];for(let i=0;i<t.length;i++)t[i]&&n.push(i);let a=Zt(e,"int32"),r=Zt([n.length,e.length],"int32");for(let i=0;i<n.length;i++){let s=a.indexToLoc(n[i]),o=i*e.length;r.values.set(s,o)}return r.toTensor()}async function W8(e){let t=$(e,"condition","whereAsync","bool"),n=await t.data(),a=YF(t.shape,n);return e!==t&&t.dispose(),a}var WE=W8;async function q8(e,t,n){let a=$(e,"tensor","boolMask"),r=$(t,"mask","boolMask","bool"),i=n??0,s=r.rank,o=a.shape;ee(s>0,()=>"mask cannot be scalar"),$r(o.slice(i,i+s),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let v=i;v<i+s;v++)u*=o[v];let d=o.slice(0,i).concat([u],o.slice(i+s)),c=ge(a,d),h=ge(r,[-1]),m=await WE(h),g=Pc(m,[1]),x=Ug(c,g,i);return e!==a&&a.dispose(),t!==r&&r.dispose(),g.dispose(),c.dispose(),h.dispose(),m.dispose(),x}var jF=q8;function P8(e,t,n){let a=$(e,"x","transpose");if(t==null&&(t=a.shape.map((s,o)=>o).reverse()),ee(a.rank===t.length,()=>`Error in transpose: rank of input ${a.rank} must match length of perm ${t}.`),t.forEach(s=>{ee(s>=0&&s<a.rank,()=>`All entries in 'perm' must be between 0 and ${a.rank-1} but got ${t}`)}),a.rank<=1)return a.clone();let r={x:a},i={perm:t};return a.dtype==="complex64"?be(()=>{let s=vm(a),o=V0(a);return s=oe.runKernel(Xl,{x:s},i),o=oe.runKernel(Xl,{x:o},i),n&&(o=ia(o)),nu(s,o)}):oe.runKernel(Xl,r,i)}var Qt=le({transpose_:P8});function H8(e,t,n,a,r=!0){let i=$(e,"v","movingAverage"),s=$(t,"x","movingAverage"),o=$(n,"decay","movingAverage");B3(i,s),ee(ru(i.shape,s.shape),()=>"Shape mismatch in v and x");let u=gt(1),d=at(u,o),c=pe(at(s,i),d);if(r){ee(a!=null,()=>"When using zeroDebias: true, step is required.");let h=$(a,"step","movingAverage");c=it(c,at(u,il(o,h)))}return Oe(i,c)}var QF=le({movingAverage_:H8});function G8(e,t,n){Bi(n);let a=$(e,"indices","scatterND","int32"),r=$(t,"updates","scatterND");Pv(r,a,n);let i={indices:a,updates:r},s={shape:n};return oe.runKernel(xg,i,s)}var ZF=le({scatterND_:G8});function K8(e,t,n,a){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let r=e.rank>0?e.shape[0]:1,i=e.rank>1?e.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);let s=t.size;if(!(t.rank===0||t.rank===1&&s===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function $8(e,t,n,a=0){Bi(n);let r=$(e,"sparseIndices","sparseToDense","int32"),i=$(t,"sparseValues","sparseToDense","string_or_numeric"),s=$(a,"defaultValue","sparseToDense",i.dtype);K8(r,i,n,s);let o={sparseIndices:r,sparseValues:i,defaultValue:s},u={outputShape:n};return oe.runKernel(_g,o,u)}var XF=le({sparseToDense_:$8});function J8(e,t){let n=$(t,"indices","gatherND","int32"),a={params:$(e,"x","gatherND","string_or_numeric"),indices:n};return oe.runKernel(Xm,a)}var eD=le({gatherND_:J8});function Y8(e,t){if(t==null)return e.shape.slice();if(ru(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let a=0;a<e.shape.length;a++)t[a]==null&&e.shape[a]!=null?n.push(e.shape[a]):n.push(t[a]);return n}return t}function j8(e,t,n,a){let r=$(e,"x","dropout");if(ee(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),ee(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof $t?r.clone():r;let i=Y8(r,n),s=1-t,o=it(zg(Oe(Wc(i,0,1,"float32",a),s)),s);return pe(r,o)}var qE=le({dropout_:j8});function PE(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Kv(e,t,n){let a=1-e%2,r=new Float32Array(e);for(let i=0;i<e;++i){let s=2*Math.PI*i/(e+a-1);r[i]=t-n*Math.cos(s)}return Dn(r,"float32")}async function Q8(e,t,n=1){let a=$(e,"predictions","inTopK"),r=$(t,"targets","inTopK");ee(a.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`),ee(a.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${r.rank}`),$r(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let i=a.shape[a.shape.length-1];ee(n>0&&n<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${n}`);let s=await a.data(),o=await r.data(),[u,d]=[s.length/i,i],c=b3("bool",u);for(let h=0;h<u;h++){let m=h*d,g=s.subarray(m,m+d),x=[];for(let v=0;v<g.length;v++)x.push({value:g[v],index:v});x.sort((v,S)=>S.value-v.value),c[h]=0;for(let v=0;v<n;v++)if(x[v].index===o[h]){c[h]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),Pr(c,r.shape,"bool")}var tD=Q8,Am={};qt(Am,{conv2d:()=>eG,depthwiseConv2d:()=>rG,matMul:()=>sG});function Z8(e,t,n,a,r,i="NHWC",s){let o=e;e.rank===3&&(o=ge(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=ge(t,[1,t.shape[0],t.shape[1],t.shape[2]])),ee(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),ee(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),ee(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let d=i==="NHWC"?o.shape[3]:o.shape[1],c=i==="NHWC"?u.shape[3]:u.shape[1];ee(d===n[2],()=>`Error in conv2dDerFilter: depth of input ${d}) must match input depth in filter (${n[2]}.`),ee(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Jr("conv2dDerFilter",r,s);let h={x:o,dy:u},m={strides:a,pad:r,dataFormat:i,dimRoundingMode:s,filterShape:n};return oe.runKernel(rv,h,m)}var HE=le({conv2DBackpropFilter_:Z8});function $v(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return pe(e,zh(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Jv(e,t){let n=t,a=La(e.shape,t.shape);return a.length>0&&(n=lt(n,a)),ge(n,e.shape)}function Yv(e,t,n,a){if(t==="linear")return e;if(t==="relu")return zn(e);if(t==="elu")return Bg(e);if(t==="relu6")return Fv(e);if(t==="prelu")return $0(e,n);if(t==="leakyrelu")return W0(e,a);if(t==="sigmoid")return Ns(e);throw new Error(`Unknown fused activation ${t}.`)}var jv=(e,t)=>!(e>0)||t==="linear";function X8({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:s,bias:o,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:c}){if(u=u||"linear",jv(oe.state.gradientDepth,u)===!1){ee(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let q=Hr(e,t,n,a,r,i,s);return o!=null&&(q=Oe(q,o)),Yv(q,u,d,c)}let h=$(e,"x","conv2d","float32"),m=$(t,"filter","conv2d","float32"),g=h,x=!1;h.rank===3&&(x=!0,g=ge(h,[1,h.shape[0],h.shape[1],h.shape[2]])),ee(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),ee(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Jr("fused conv2d",a,s);let v=r==="NHWC"?g.shape[3]:g.shape[1];ee(m.shape[2]===v,()=>`Error in conv2d: depth of input (${v}) must match input depth for filter ${m.shape[2]}.`),ee(ll(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let S=L0(g.shape,m.shape,n,i,a,s),E;o!=null&&(E=$(o,"bias","fused conv2d"),[E]=va(E,h),r==="NHWC"?Kn(S.outShape,E.shape):(ee(E.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${E.shape.length}.`),ee(E.shape.length===0||E.shape[0]===S.outChannels||E.shape[0]===1,()=>`Error in fused conv2d: bias shape (${E.shape}) is not compatible with the number of output channels (${S.outChannels})`)));let C;if(d!=null){let q=d.shape;if(ee(q.length<=1||q.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${q.length}.`),q.length===1)ee(q[0]===1||q[0]===S.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${q}) is not compatible with the number of output channels (${S.outChannels}).`);else if(q.length===3)try{Kn(q,S.outShape)}catch{let K=`Error in fused conv2d: PReLU activation weights (${q}) is not compatible with the output shape of the conv2d (${S.outShape}).`;throw Error(K)}C=$(d,"prelu weights","fused conv2d")}let T=(q,H)=>{ee(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);let[K,j,te,Q]=H,z=$v(q,te,u);ee(Sc(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);let ae=oE(j.shape,z,K,n,a),ue=HE(j,z,K.shape,n,a),he=[ae,ue];if(Q!=null){let Z=Jv(Q,z);he.push(Z)}return he},N={x:g,filter:m,bias:E,preluActivationWeights:C},D={strides:n,pad:a,dataFormat:r,dilations:i,dimRoundingMode:s,activation:u,leakyreluAlpha:c};return o==null?sl((q,H,K)=>{let j=oe.runKernel(Qd,N,D);return K([H,q,j]),x&&(j=ge(j,[j.shape[1],j.shape[2],j.shape[3]])),{value:j,gradFunc:T}})(g,m):sl((q,H,K,j)=>{let te=oe.runKernel(Qd,N,D);return j([H,q,te,K]),x&&(te=ge(te,[te.shape[1],te.shape[2],te.shape[3]])),{value:te,gradFunc:T}})(g,m,E)}var eG=le({fusedConv2d_:X8});function tG(e,t,n,a,r,i=[1,1],s){let o=e;e.rank===3&&(o=ge(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=ge(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let d={x:o,dy:u},c={strides:a,pad:r,dimRoundingMode:s,dilations:i,filterShape:n};return oe.runKernel(iv,d,c)}var nD=le({depthwiseConv2dNativeBackpropFilter_:tG});function nG(e,t,n,a,r,i=[1,1],s){let o=t,u=!1;t.rank===3&&(u=!0,o=ge(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let d={dy:o,filter:n},c={strides:a,pad:r,dimRoundingMode:s,dilations:i,inputShape:e},h=oe.runKernel(sv,d,c);return u?ge(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var aD=le({depthwiseConv2dNativeBackpropInput_:nG});function aG({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:s,bias:o,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:c}){if(jv(oe.state.gradientDepth,u)===!1){let D=Bh(e,t,n,a,r,i,s);return o!=null&&(D=Oe(D,o)),Yv(D,u,d,c)}let h=$(e,"x","depthwiseConv2d","float32"),m=$(t,"filter","depthwiseConv2d","float32"),g=h,x=!1;h.rank===3&&(x=!0,g=ge(h,[1,h.shape[0],h.shape[1],h.shape[2]])),ee(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),ee(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),ee(g.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),i==null&&(i=[1,1]),ee(ll(n,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Jr("fused depthwiseConv2d",a,s);let v=L0(g.shape,m.shape,n,i,a,s,!0),S;o!=null&&(S=$(o,"bias","fused conv2d"),[S]=va(S,h),Kn(v.outShape,S.shape));let E;d!=null&&(E=$(d,"prelu weights","fused depthwiseConv2d"));let C=(D,q)=>{ee(Sc(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[H,K,j,te]=q,Q=$v(D,j,u),z=aD(K.shape,Q,H,n,a,i,s),ae=nD(K,Q,H.shape,n,a,i,s);if(te!=null){let ue=Jv(S,Q);return[z,ae,ue]}return[z,ae]},T={x:g,filter:m,bias:S,preluActivationWeights:E},N={strides:n,pad:a,dataFormat:r,dilations:i,dimRoundingMode:s,activation:u,leakyreluAlpha:c};return o==null?sl((D,q,H)=>{let K=oe.runKernel(Zd,T,N);return H([q,D,K]),x&&(K=ge(K,[K.shape[1],K.shape[2],K.shape[3]])),{value:K,gradFunc:C}})(g,m):sl((D,q,H,K)=>{let j=oe.runKernel(Zd,T,N);return K([q,D,j,H]),x&&(j=ge(j,[j.shape[1],j.shape[2],j.shape[3]])),{value:j,gradFunc:C}})(g,m,S)}var rG=le({fusedDepthwiseConv2d_:aG});function iG({a:e,b:t,transposeA:n=!1,transposeB:a=!1,bias:r,activation:i="linear",preluActivationWeights:s,leakyreluAlpha:o=.2}){if(jv(oe.state.gradientDepth,i)===!1){let te=jt(e,t,n,a);return r!=null&&(te=Oe(te,r)),Yv(te,i,s,o)}let u=$(e,"a","fused matMul"),d=$(t,"b","fused matMul");[u,d]=va(u,d);let c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=a?d.shape[d.rank-1]:d.shape[d.rank-2],m=n?u.shape[u.rank-1]:u.shape[u.rank-2],g=a?d.shape[d.rank-2]:d.shape[d.rank-1],x=u.shape.slice(0,-2),v=d.shape.slice(0,-2),S=Un(x),E=Un(v);ee(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${d.shape} and transposeA=${n} and transposeB=${a} must match.`);let C=Kn(u.shape.slice(0,-2),d.shape.slice(0,-2)).concat([m,g]),T=n?ge(u,[S,c,m]):ge(u,[S,m,c]),N=a?ge(d,[E,g,h]):ge(d,[E,h,g]),D;r!=null&&(D=$(r,"bias","fused matMul"),[D]=va(D,u),Kn(C,D.shape));let q;s!=null&&(q=$(s,"prelu weights","fused matMul"));let H=(te,Q)=>{let[z,ae,ue,he]=Q,Z=$v(ge(te,ue.shape),ue,i),se,de;if(!n&&!a?(se=jt(Z,ae,!1,!0),de=jt(z,Z,!0,!1)):!n&&a?(se=jt(Z,ae,!1,!1),de=jt(Z,z,!0,!1)):n&&!a?(se=jt(ae,Z,!1,!0),de=jt(z,Z,!1,!1)):(se=jt(ae,Z,!0,!0),de=jt(Z,z,!0,!0)),r!=null){let Ce=Jv(he,Z);return[se,de,Ce]}else return[se,de]},K={a:T,b:N,bias:D,preluActivationWeights:q},j={transposeA:n,transposeB:a,activation:i,leakyreluAlpha:o};return r==null?sl((te,Q,z)=>{let ae=oe.runKernel(jd,K,j);return z([te,Q,ae]),{value:ge(ae,C),gradFunc:H}})(T,N):sl((te,Q,z,ae)=>{let ue=oe.runKernel(jd,K,j);return ae([te,Q,ue,z]),{value:ge(ue,C),gradFunc:H}})(T,N,D)}var sG=le({fusedMatMul_:iG});function oG(e){return Kv(e,.54,.46)}var lG=le({hammingWindow_:oG});function uG(e){return Kv(e,.5,.5)}var rD=le({hannWindow_:uG});function cG(e,t,n,a=!1,r=0){let i=0,s=[];for(;i+t<=e.size;)s.push(un(e,i,t)),i+=n;if(a)for(;i<e.size;){let o=i+t-e.size,u=Gn([un(e,i,t-o),Ni([o],r)]);s.push(u),i+=n}return s.length===0?nl([],[0,t]):ge(Gn(s),[s.length,t])}var iD=le({frame_:cG});function dG(e,t,n,a,r=rD){a==null&&(a=PE(t));let i=iD(e,t,n),s=pe(i,r(t));return j0(s,a)}var pG=le({stft_:dG});function hG(e,t,n,a,r="bilinear",i=0){let s=$(e,"image","cropAndResize"),o=$(t,"boxes","cropAndResize","float32"),u=$(n,"boxInd","cropAndResize","int32"),d=o.shape[0];ee(s.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${s.rank}.`),ee(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${d},4] but had shape ${o.shape}.`),ee(u.rank===1&&u.shape[0]===d,()=>`Error in cropAndResize: boxInd must be have size [${d}] but had shape ${o.shape}.`),ee(a.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${a.length}.`),ee(a[0]>=1&&a[1]>=1,()=>`cropSize must be atleast [1,1], but was ${a}`),ee(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);let c={image:s,boxes:o,boxInd:u},h={method:r,extrapolationValue:i,cropSize:a};return oe.runKernel(Km,c,h)}var fG=le({cropAndResize_:hG});function mG(e){let t=$(e,"image","flipLeftRight","float32");ee(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return oe.runKernel(Qm,n,{})}var gG=le({flipLeftRight_:mG});function bG(e){let t=$(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];ee(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),ee(a===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${a}.`);let r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,Ti(t,r)}var yG=le({grayscaleToRGB_:bG});function wG(e){let t=$(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];ee(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),ee(a===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${a}.`);let r=t.dtype,i=je(t,"float32"),s=Dn([.2989,.587,.114]),o;switch(t.rank){case 2:o=Ud("ij,j->i",i,s);break;case 3:o=Ud("ijk,k->ij",i,s);break;case 4:o=Ud("ijkl,l->ijk",i,s);break;case 5:o=Ud("ijklm,m->ijkl",i,s);break;case 6:o=Ud("ijklmn,n->ijklm",i,s);break;default:throw new Error("Not a valid tensor rank.")}return o=sr(o,-1),je(o,r)}var xG=le({rgbToGrayscale_:wG});function vG(e,t,n=0,a=.5){let r=$(e,"image","rotateWithOffset","float32");ee(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);let i={image:r},s={radians:t,fillValue:n,center:a};return oe.runKernel(Og,i,s)}var SG=le({rotateWithOffset_:vG});function qg(e,t,n,a,r,i){a==null&&(a=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);let s=e.shape[0];return n=Math.min(n,s),ee(0<=a&&a<=1,()=>`iouThreshold must be in [0, 1], but was '${a}'`),ee(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),ee(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),ee(t.rank===1,()=>"scores must be a 1D tensor"),ee(t.shape[0]===s,()=>`scores has incompatible shape with boxes. Expected ${s}, but was ${t.shape[0]}`),ee(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:i}}function kG(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let i=$(e,"boxes","nonMaxSuppression","float32"),s=$(t,"scores","nonMaxSuppression","float32"),o=qg(i,s,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return oe.runKernel(pg,{boxes:i,scores:s},u)}var AG=le({nonMaxSuppression_:kG});function EG(e,t,n){let a=CG(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function CG(e,t,n){return _G(e,t,n||IG)}function IG(e,t){return e>t?1:e<t?-1:0}function _G(e,t,n){let a=0,r=e.length,i=0,s=!1;for(;a<r;){i=a+(r-a>>>1);let o=n(t,e[i]);o>0?a=i+1:(r=i,s=!o)}return s?a:-a-1}function sD(e,t,n,a,r){return GE(e,t,n,a,r,0)}function oD(e,t,n,a,r,i){return GE(e,t,n,a,r,0,!1,i,!0)}function lD(e,t,n,a,r,i){return GE(e,t,n,a,r,i,!0)}function GE(e,t,n,a,r,i,s=!1,o=!1,u=!1){let d=[];for(let S=0;S<t.length;S++)t[S]>r&&d.push({score:t[S],boxIndex:S,suppressBeginIndex:0});d.sort(EN);let c=i>0?-.5/i:0,h=[],m=[];for(;h.length<n&&d.length>0;){let S=d.pop(),{score:E,boxIndex:C,suppressBeginIndex:T}=S;if(E<r)break;let N=!1;for(let D=h.length-1;D>=T;--D){let q=TG(e,C,h[D]);if(q>=a){N=!0;break}if(S.score=S.score*NG(a,c,q),S.score<=r)break}S.suppressBeginIndex=h.length,N||(S.score===E?(h.push(C),m.push(S.score)):S.score>r&&EG(d,S,EN))}let g=h.length,x=n-g;o&&x>0&&(h.push(...new Array(x).fill(0)),m.push(...new Array(x).fill(0)));let v={selectedIndices:h};return s&&(v.selectedScores=m),u&&(v.validOutputs=g),v}function TG(e,t,n){let a=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),i=Math.min(a[0],a[2]),s=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),u=Math.max(a[1],a[3]),d=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),g=(o-i)*(u-s),x=(h-d)*(m-c);if(g<=0||x<=0)return 0;let v=Math.max(i,d),S=Math.max(s,c),E=Math.min(o,h),C=Math.min(u,m),T=Math.max(E-v,0)*Math.max(C-S,0);return T/(g+x-T)}function NG(e,t,n){let a=Math.exp(t*n*n);return n<=e?a:0}function EN(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function RG(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let i=$(e,"boxes","nonMaxSuppressionAsync"),s=$(t,"scores","nonMaxSuppressionAsync"),o=qg(i,s,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let u=await Promise.all([i.data(),s.data()]),d=u[0],c=u[1],{selectedIndices:h}=sD(d,c,n,a,r);return i!==e&&i.dispose(),s!==t&&s.dispose(),Dn(h,"int32")}var FG=RG;function DG(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,i=0){let s=$(e,"boxes","nonMaxSuppression"),o=$(t,"scores","nonMaxSuppression"),u=qg(s,o,n,a,r,i);n=u.maxOutputSize,a=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;let d={boxes:s,scores:o},c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:i},h=oe.runKernel(fg,d,c);return{selectedIndices:h[0],selectedScores:h[1]}}var OG=le({nonMaxSuppressionWithScore_:DG});async function MG(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,i=0){let s=$(e,"boxes","nonMaxSuppressionAsync"),o=$(t,"scores","nonMaxSuppressionAsync"),u=qg(s,o,n,a,r,i);n=u.maxOutputSize,a=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;let d=await Promise.all([s.data(),o.data()]),c=d[0],h=d[1],{selectedIndices:m,selectedScores:g}=lD(c,h,n,a,r,i);return s!==e&&s.dispose(),o!==t&&o.dispose(),{selectedIndices:Dn(m,"int32"),selectedScores:Dn(g)}}var BG=MG;function LG(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,i=!1){let s=$(e,"boxes","nonMaxSuppression"),o=$(t,"scores","nonMaxSuppression"),u=qg(s,o,n,a,r,null),d=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,m={boxes:s,scores:o},g={maxOutputSize:d,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:i},x=oe.runKernel(hg,m,g);return{selectedIndices:x[0],validOutputs:x[1]}}var zG=le({nonMaxSuppressionPadded_:LG});async function UG(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,i=!1){let s=$(e,"boxes","nonMaxSuppressionAsync"),o=$(t,"scores","nonMaxSuppressionAsync"),u=qg(s,o,n,a,r,null),d=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,[m,g]=await Promise.all([s.data(),o.data()]),{selectedIndices:x,validOutputs:v}=oD(m,g,d,c,h,i);return s!==e&&s.dispose(),o!==t&&o.dispose(),{selectedIndices:Dn(x,"int32"),validOutputs:gt(v,"int32")}}var VG=UG;function WG(e,t,n=!1,a=!1){let r=$(e,"images","resizeBilinear");ee(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),ee(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),ee(a===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,s=!1;r.rank===3&&(s=!0,i=ge(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let o={images:i},u={alignCorners:n,halfPixelCenters:a,size:t},d=oe.runKernel(bh,o,u);return s?ge(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var uD=le({resizeBilinear_:WG});function qG(e,t,n=!1,a=!1){let r=$(e,"images","resizeNearestNeighbor");ee(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),ee(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),ee(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),ee(a===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,s=!1;r.rank===3&&(s=!0,i=ge(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let o={images:i},u={alignCorners:n,halfPixelCenters:a,size:t},d=oe.runKernel(gh,o,u);return s?ge(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var cD=le({resizeNearestNeighbor_:qG});function PG(e,t="binary",n=!1,a=.5){let r=$(e,"image","threshold"),i=.2989,s=.587,o=.114,u=r.shape[0]*r.shape[1],d=pe(Dn([a]),255),c,h,m,g;if(ee(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),ee(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),ee(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),ee(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[c,h,m]=li(r,[1,1,1],-1);let v=pe(c,i),S=pe(h,s),E=pe(m,o);g=Oe(Oe(v,S),E)}else g=e;if(t==="otsu"){let v=tE(je(Dv(g),"int32"),Pr([]),256);d=HG(v,u)}let x=n?Vc(g,d):Yr(g,d);return je(pe(x,255),"int32")}function HG(e,t){let n=Dn([-1]),a=Dn([0]),r=Dn([0]),i,s,o,u,d,c;for(let h=0;h<e.size-1;h++){i=un(e,0,h+1),s=un(e,h+1),d=it(lt(i),t),c=it(lt(s),t);let m=lt(pe(i,op(0,i.size)));o=it(m,lt(i));let g=Ni(s.shape,i.size),x=Oe(op(0,s.size),g),v=pe(s,x);u=it(lt(v),lt(s));let S=at(o,u),E=at(o,u),C=pe(d,c);r=pe(pe(C,S),E);let T=Yr(r,a);a=lr(T,r,a),n=lr(T,Dn([h]),n)}return n}var GG=le({threshold_:PG});function KG(e,t,n="nearest",a="constant",r=0,i){let s=$(e,"image","transform","float32"),o=$(t,"transforms","transform","float32");ee(s.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${s.rank}.`),ee(o.rank===2&&(o.shape[0]===s.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),ee(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);let u={image:s,transforms:o},d={interpolation:n,fillMode:a,fillValue:r,outputShape:i};return oe.runKernel(Rg,u,d)}var $G=le({transform_:KG});function JG(e,t,n){let a=$(e,"a","bandPart");ee(a.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${a.rank}.`);let r=a.shape,[i,s]=a.shape.slice(-2),o,u;typeof t=="number"?(ee(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),ee(t<=i,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`),o=$(t<0?i:t,"numLower","bandPart")):(ee(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=lr(wm(t,0),i,Ac(t,i))),typeof n=="number"?(ee(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),ee(n<=s,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${s}).`),u=$(n<0?s:n,"numUpper","bandPart")):(ee(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=lr(wm(n,0),s,Ac(n,s)));let d=ge(op(0,i,1,"int32"),[-1,1]),c=op(0,s,1,"int32"),h=at(d,c),m=Rs(Vc(h,o),ou(h,ia(u))),g=wa([i,s],a.dtype);return ge(Ba(Aa(ge(a,[-1,i,s])).map(x=>lr(m,x,g))),r)}var YG=le({bandPart_:JG});function jG(e){let t;if(Array.isArray(e)){t=!1,ee(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let r=e[0].shape[0];for(let i=1;i<e.length;++i)ee(e[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[i].shape[0]} vs. ${r})`)}else t=!0,e=li(e,e.shape[0],0).map(r=>Pc(r,[0]));ee(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],a=e;for(let r=0;r<e.length;++r)n.push(oe.tidy(()=>{let i=a[r];if(r>0)for(let s=0;s<r;++s){let o=pe(lt(pe(n[s],i)),n[s]);i=at(i,o)}return it(i,Lg(i,"euclidean"))}));return t?Ba(n,0):n}var QG=le({gramSchmidt_:jG});function ZG(e,t=!1){if(ee(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return CN(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((u,d)=>u*d),a=Aa(ge(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],i=[];a.forEach(u=>{let[d,c]=CN(u,t);r.push(d),i.push(c)});let s=ge(Ba(r,0),e.shape),o=ge(Ba(i,0),e.shape);return[s,o]}}function CN(e,t=!1){return oe.tidy(()=>{ee(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],a=e.shape[1],r=Cv(n),i=tl(e),s=nl([[1]],[1,1]),o=tl(s),u=n>=a?a:n;for(let d=0;d<u;++d){let c=i,h=o,m=r;[o,i,r]=oe.tidy(()=>{let g=un(i,[d,d],[n-d,1]),x=Lg(g),v=un(i,[d,d],[1,1]),S=lr(Yr(v,0),nl([[-1]]),nl([[1]])),E=at(v,pe(S,x)),C=it(g,E);C.shape[0]===1?o=tl(s):o=Gn([s,un(C,[1,0],[C.shape[0]-1,C.shape[1]])],0);let T=ia(it(jt(S,E),x)),N=un(i,[d,0],[n-d,a]),D=pe(T,o),q=Qt(o);if(d===0)i=at(N,jt(D,jt(q,N)));else{let j=at(N,jt(D,jt(q,N)));i=Gn([un(i,[0,0],[d,a]),j],0)}let H=Qt(D),K=un(r,[0,d],[n,r.shape[1]-d]);if(d===0)r=at(K,jt(jt(K,o),H));else{let j=at(K,jt(jt(K,o),H));r=Gn([un(r,[0,0],[n,d]),j],1)}return[o,i,r]}),Wt([c,h,m])}return!t&&n>a&&(r=un(r,[0,0],[n,a]),i=un(i,[0,0],[a,a])),[r,i]})}var XG=le({qr_:ZG}),Wr;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Wr||(Wr={}));function eK(e,t,n=Wr.SUM_BY_NONZERO_WEIGHTS){let a=$(e,"losses","computeWeightedLoss"),r=null;t!=null&&(r=$(t,"weights","computeWeightedLoss"));let i=r==null?a:pe(a,r);if(n===Wr.NONE)return i;if(n===Wr.SUM)return lt(i);if(n===Wr.MEAN){if(r==null)return ya(i);{let s=a.size/r.size,o=it(lt(i),lt(r));return s>1?it(o,gt(s)):o}}if(n===Wr.SUM_BY_NONZERO_WEIGHTS){if(r==null)return it(lt(i),gt(a.size));{let s=pe(r,oi(a.shape)),o=je(lt(sp(s,gt(0))),"float32");return it(lt(i),o)}}throw Error(`Unknown reduction: ${n}`)}var lu=le({computeWeightedLoss_:eK});function tK(e,t,n,a=Wr.SUM_BY_NONZERO_WEIGHTS){let r=$(e,"labels","absoluteDifference"),i=$(t,"predictions","absoluteDifference"),s=null;n!=null&&(s=$(n,"weights","absoluteDifference")),$r(r.shape,i.shape,"Error in absoluteDifference: ");let o=Da(at(r,i));return lu(o,s,a)}var nK=le({absoluteDifference_:tK});function aK(e,t,n,a,r=Wr.SUM_BY_NONZERO_WEIGHTS){let i=$(e,"labels","cosineDistance"),s=$(t,"predictions","cosineDistance"),o=null;a!=null&&(o=$(a,"weights","cosineDistance")),$r(i.shape,s.shape,"Error in cosineDistance: ");let u=gt(1),d=at(u,lt(pe(i,s),n,!0));return lu(d,o,r)}var rK=le({cosineDistance_:aK});function iK(e,t,n,a=Wr.SUM_BY_NONZERO_WEIGHTS){let r=$(e,"labels","hingeLoss"),i=$(t,"predictions","hingeLoss"),s=null;n!=null&&(s=$(n,"weights","hingeLoss")),$r(r.shape,i.shape,"Error in hingeLoss: ");let o=gt(1);r=at(pe(gt(2),r),o);let u=zn(at(o,pe(r,i)));return lu(u,s,a)}var sK=le({hingeLoss_:iK});function oK(e,t,n,a=1,r=Wr.SUM_BY_NONZERO_WEIGHTS){let i=$(e,"labels","huberLoss"),s=$(t,"predictions","huberLoss"),o=null;n!=null&&(o=$(n,"weights","huberLoss")),$r(i.shape,s.shape,"Error in huberLoss: ");let u=gt(a),d=Da(at(s,i)),c=Ac(d,u),h=at(d,c),m=Oe(pe(gt(.5),Hn(c)),pe(u,h));return lu(m,o,r)}var lK=le({huberLoss_:oK});function uK(e,t,n,a=1e-7,r=Wr.SUM_BY_NONZERO_WEIGHTS){let i=$(e,"labels","logLoss"),s=$(t,"predictions","logLoss"),o=null;n!=null&&(o=$(n,"weights","logLoss")),$r(i.shape,s.shape,"Error in logLoss: ");let u=gt(1),d=gt(a),c=ia(pe(i,Di(Oe(s,d)))),h=pe(at(u,i),Di(Oe(at(u,s),d))),m=at(c,h);return lu(m,o,r)}var cK=le({logLoss_:uK});function dK(e,t,n,a=Wr.SUM_BY_NONZERO_WEIGHTS){let r=$(e,"labels","meanSquaredError"),i=$(t,"predictions","meanSquaredError"),s=null;n!=null&&(s=$(n,"weights","meanSquaredError")),$r(r.shape,i.shape,"Error in meanSquaredError: ");let o=Vv(r,i);return lu(o,s,a)}var pK=le({meanSquaredError_:dK});function hK(e,t){let n=$(e,"labels","sigmoidCrossEntropyWithLogits"),a=$(t,"logits","sigmoidCrossEntropyWithLogits");$r(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");let r=zn(a),i=pe(a,n),s=q0(Fr(ia(Da(a))));return Oe(at(r,i),s)}function fK(e,t,n,a=0,r=Wr.SUM_BY_NONZERO_WEIGHTS){let i=$(e,"multiClassLabels","sigmoidCrossEntropy"),s=$(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=$(n,"weights","sigmoidCrossEntropy")),$r(i.shape,s.shape,"Error in sigmoidCrossEntropy: "),a>0){let d=gt(a),c=gt(1),h=gt(.5);i=Oe(pe(i,at(c,d)),pe(h,d))}let u=hK(i,s);return lu(u,o,r)}var mK=le({sigmoidCrossEntropy_:fK});function gK(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return sl((a,r,i)=>{let s=P0(r,[n],!0),o=at(je(r,"float32"),s);i([a,o]);let u=ia(pe(o,a));return{value:lt(u,[n]),gradFunc:(d,c)=>{let[h,m]=c,g=ip(d.shape,[n]);return[pe(ge(d,g),at(je(h,"float32"),Fr(m))),pe(ge(d,g),at(Fr(m),je(h,"float32")))]}}})(e,t)}function bK(e,t,n,a=0,r=Wr.SUM_BY_NONZERO_WEIGHTS){let i=$(e,"onehotLabels","softmaxCrossEntropy"),s=$(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=$(n,"weights","softmaxCrossEntropy")),$r(i.shape,s.shape,"Error in softmaxCrossEntropy: "),a>0){let d=gt(a),c=gt(1),h=gt(i.shape[1]);i=Oe(pe(i,at(c,d)),it(d,h))}let u=gK(i,s);return lu(u,o,r)}var yK=le({softmaxCrossEntropy_:bK});function wK(e,t,n,a){let r=$(e,"indices","sparseFillEmptyRows","int32"),i=$(t,"values","sparseFillEmptyRows"),s=$(n,"denseShape","sparseFillEmptyRows","int32"),o=$(a,"defaultValue","sparseFillEmptyRows",i.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(s.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let u={indices:r,values:i,denseShape:s,defaultValue:o},d=oe.runKernel(S0,u);return{outputIndices:d[0],outputValues:d[1],emptyRowIndicator:d[2],reverseIndexMap:d[3]}}var xK=le({sparseFillEmptyRows_:wK});function vK(e,t,n){let a=$(e,"inputIndices","sparseReshape","int32"),r=$(t,"inputShape","sparseReshape","int32"),i=$(n,"newShape","sparseReshape","int32");if(a.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${a.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);let s={inputIndices:a,inputShape:r,newShape:i},o=oe.runKernel(Ig,s);return{outputIndices:o[0],outputShape:o[1]}}var SK=le({sparseReshape_:vK});function kK(e,t,n){let a=$(e,"data","sparseSegmentMean"),r=$(t,"indices","sparseSegmentMean","int32"),i=$(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);let s={data:a,indices:r,segmentIds:i};return oe.runKernel(k0,s)}var AK=le({sparseSegmentMean_:kK});function EK(e,t,n){let a=$(e,"data","sparseSegmentSum"),r=$(t,"indices","sparseSegmentSum","int32"),i=$(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);let s={data:a,indices:r,segmentIds:i};return oe.runKernel(A0,s)}var CK=le({sparseSegmentSum_:EK});function IK(e,t,n,a,r,i,s,o){let u=$(e,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let d=$(t,"dataSplits","stringNGrams");if(d.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:a,leftPad:r,rightPad:i,padWidth:s,preserveShortSequences:o},h={data:u,dataSplits:d},m=oe.runKernel(I0,h,c);return{nGrams:m[0],nGramsSplits:m[1]}}var _K=le({stringNGrams_:IK});function TK(e,t,n=!0){let a=$(e,"input","stringSplit","string"),r=$(t,"delimiter","stringSplit","string");if(a.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${a.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);let i={skipEmpty:n},s={input:a,delimiter:r},o=oe.runKernel(_0,s,i);return{indices:o[0],values:o[1],shape:o[2]}}var NK=le({stringSplit_:TK});function RK(e,t){let n=$(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let r={input:n};return oe.runKernel(T0,r,a)}var FK=le({stringToHashBucketFast_:RK});function DK(e,t,n,a=!0){let r=$(e,"input","staticRegexReplace","string"),i={pattern:t,rewrite:n,replaceGlobal:a};return oe.runKernel(C0,{x:r},i)}var OK=le({staticRegexReplace_:DK}),dD={fft:Y0,ifft:km,rfft:j0,irfft:Uv},pD={hammingWindow:lG,hannWindow:rD,frame:iD,stft:pG},Zi={flipLeftRight:gG,grayscaleToRGB:yG,resizeNearestNeighbor:cD,resizeBilinear:uD,rgbToGrayscale:xG,rotateWithOffset:SG,cropAndResize:fG,nonMaxSuppression:AG,nonMaxSuppressionAsync:FG,nonMaxSuppressionWithScore:OG,nonMaxSuppressionWithScoreAsync:BG,nonMaxSuppressionPadded:zG,nonMaxSuppressionPaddedAsync:VG,threshold:GG,transform:$G},KE={bandPart:YG,gramSchmidt:QG,qr:XG},hD={absoluteDifference:nK,computeWeightedLoss:lu,cosineDistance:rK,hingeLoss:sK,huberLoss:lK,logLoss:cK,meanSquaredError:pK,sigmoidCrossEntropy:mK,softmaxCrossEntropy:yK},fD={sparseFillEmptyRows:xK,sparseReshape:SK,sparseSegmentMean:AK,sparseSegmentSum:CK},mD={stringNGrams:_K,stringSplit:NK,stringToHashBucketFast:FK,staticRegexReplace:OK},We={};qt(We,{Serializable:()=>gD,SerializationMap:()=>bD,getRegisteredName:()=>BK,registerClass:()=>yD});var MK=new Map,Fk=new Map,gD=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},bD=class sm{constructor(){this.classNameMap={}}static getMap(){return sm.instance==null&&(sm.instance=new sm),sm.instance}static register(t){sm.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function yD(e,t,n){ee(e.className!=null,()=>"Class being registered does not have the static className property defined."),ee(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),ee(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let a=n,r=t+">"+a;return bD.register(e),MK.set(r,e),Fk.set(e,r),e}function BK(e){return Fk.has(e)?Fk.get(e):e.className}var uu=class extends gD{minimize(e,t=!1,n){let{value:a,grads:r}=this.computeGradients(e,n);if(n!=null){let i=n.map(s=>({name:s.name,tensor:r[s.name]}));this.applyGradients(i)}else this.applyGradients(r);return Wt(r),t?a:(a.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return yF(e,t)}dispose(){this.iterations_!=null&&Wt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:gt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(uu,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var $E=class extends uu{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=oe.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=oe.registeredVariables[t],r=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:be(()=>gn(a).variable(r))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:be(()=>gn(a).variable(r))});let i=Array.isArray(e)?e[n].tensor:e[t];if(i==null)return;let s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;be(()=>{let u=Oe(pe(s,this.rho),pe(Hn(i),1-this.rho)),d=pe(it(ur(Oe(o,this.epsilon)),ur(Oe(s,this.epsilon))),i),c=Oe(pe(o,this.rho),pe(Hn(d),1-this.rho));s.assign(u),o.assign(c);let h=Oe(pe(d,-this.learningRate),a);a.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Wt(this.accumulatedGrads.map(e=>e.variable)),Wt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},JE=class extends uu{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=oe.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:be(()=>Ni(a.shape,this.initialAccumulatorValue).variable(!1))});let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let i=this.accumulatedGrads[n].variable;be(()=>{let s=Oe(i,Hn(r));i.assign(s);let o=Oe(pe(it(r,ur(Oe(s,oe.backend.epsilon()))),-this.learningRate),a);a.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Wt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},YE=class extends uu{static get className(){return"Adam"}constructor(e,t,n,a=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],be(()=>{this.accBeta1=gt(t).variable(),this.accBeta2=gt(n).variable()}),a==null&&(this.epsilon=oe.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);be(()=>{let n=at(1,this.accBeta1),a=at(1,this.accBeta2);t.forEach((r,i)=>{let s=oe.registeredVariables[r],o=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${r}/m`,variable:be(()=>gn(s).variable(o))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${r}/v`,variable:be(()=>gn(s).variable(o))});let u=Array.isArray(e)?e[i].tensor:e[r];if(u==null)return;let d=this.accumulatedFirstMoment[i].variable,c=this.accumulatedSecondMoment[i].variable,h=Oe(pe(d,this.beta1),pe(u,1-this.beta1)),m=Oe(pe(c,this.beta2),pe(Hn(u),1-this.beta2)),g=it(h,n),x=it(m,a);d.assign(h),c.assign(m);let v=Oe(pe(it(g,Oe(ur(x),this.epsilon)),-this.learningRate),s);s.assign(v)}),this.accBeta1.assign(pe(this.accBeta1,this.beta1)),this.accBeta2.assign(pe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Wt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Wt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),be(()=>{this.accBeta1.assign(il(this.beta1,this.iterations_+1)),this.accBeta2.assign(il(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},jE=class extends uu{static get className(){return"Adamax"}constructor(e,t,n,a=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],be(()=>{this.iteration=gt(0).variable(),this.accBeta1=gt(t).variable()}),a==null&&(this.epsilon=oe.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);be(()=>{let n=at(1,this.accBeta1),a=it(-this.learningRate,Oe(pe(this.iteration,this.decay),1));t.forEach((r,i)=>{let s=oe.registeredVariables[r],o=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${r}/m`,variable:gn(s).variable(o)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${r}/v`,variable:gn(s).variable(o)});let u=Array.isArray(e)?e[i].tensor:e[r];if(u==null)return;let d=this.accumulatedFirstMoment[i].variable,c=this.accumulatedWeightedInfNorm[i].variable,h=Oe(pe(d,this.beta1),pe(u,1-this.beta1)),m=pe(c,this.beta2),g=Da(u),x=ul(m,g);d.assign(h),c.assign(x);let v=Oe(pe(it(a,n),it(h,Oe(x,this.epsilon))),s);s.assign(v)}),this.iteration.assign(Oe(this.iteration,1)),this.accBeta1.assign(pe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Wt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Wt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},Qv=class extends uu{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let r=oe.registeredVariables[t];be(()=>{let i=Oe(pe(this.c,a),r);r.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ga(gt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},QE=class extends Qv{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=gt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=oe.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:be(()=>gn(a).variable(!1))});let r=this.accumulations[n].variable,i=Array.isArray(e)?e[n].tensor:e[t];i!=null&&be(()=>{let s,o=Oe(pe(this.m,r),i);this.useNesterov?s=Oe(pe(this.c,Oe(i,pe(o,this.m))),a):s=Oe(pe(this.c,o),a),r.assign(o),a.assign(s)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Wt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},ZE=class extends uu{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,a=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,a==null&&(this.epsilon=oe.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=oe.registeredVariables[t],r=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:be(()=>gn(a).variable(r))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:be(()=>gn(a).variable(r))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:be(()=>gn(a).variable(r))});let i=Array.isArray(e)?e[n].tensor:e[t];if(i==null)return;let s=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;be(()=>{let u=Oe(pe(s,this.decay),pe(Hn(i),1-this.decay));if(this.centered){let d=this.accumulatedMeanGrads[n].variable,c=Oe(pe(d,this.decay),pe(i,1-this.decay)),h=it(pe(i,this.learningRate),ur(at(u,Oe(Hn(c),this.epsilon)))),m=Oe(pe(o,this.momentum),h);s.assign(u),d.assign(c),o.assign(m);let g=at(a,m);a.assign(g)}else{let d=Oe(pe(s,this.decay),pe(Hn(i),1-this.decay)),c=Oe(pe(o,this.momentum),it(pe(i,this.learningRate),ur(Oe(d,this.epsilon))));s.assign(d),o.assign(c);let h=at(a,c);a.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Wt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Wt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Wt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},LK=[$E,JE,YE,jE,QE,ZE,Qv];function zK(){for(let e of LK)yD(e)}var xr={};qt(xr,{CompositeArrayBuffer:()=>iu,browserFiles:()=>GK,browserHTTPRequest:()=>QK,concatenateArrayBuffers:()=>Eq,copyModel:()=>$q,decodeWeights:()=>H3,decodeWeightsStream:()=>K3,encodeWeights:()=>wq,fromMemory:()=>XK,fromMemorySync:()=>kD,getLoadHandlers:()=>Dq,getModelArtifactsForJSON:()=>VA,getModelArtifactsForJSONSync:()=>J3,getModelArtifactsInfoForJSON:()=>B0,getSaveHandlers:()=>Fq,getWeightSpecs:()=>Ck,http:()=>eC,isHTTPScheme:()=>Ok,listModels:()=>Gq,loadWeights:()=>$K,moveModel:()=>Jq,registerLoadRouter:()=>Rq,registerSaveRouter:()=>Nq,removeModel:()=>Kq,weightsLoaderFactory:()=>xD,withSaveHandler:()=>e7,withSaveHandlerSync:()=>t7});var UK="model",VK=".json",WK=".weights.bin";function IN(e){return new Promise(t=>setTimeout(t)).then(e)}var I1=class Dk{constructor(t){if(!Ae().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Dk.URL_SCHEME)&&(t=t.slice(Dk.URL_SCHEME.length)),(t==null||t.length===0)&&(t=UK),this.modelJsonFileName=t+VK,this.weightDataFileName=t+WK}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=iu.join(t.weightData),a=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],i=$3(t,r),s=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=s,await IN(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=a,await IN(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:B0(t)}}}};I1.URL_SCHEME="downloads://";var qK=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=a=>{let r=JSON.parse(a.target.result),i=r.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}let s=VA(r,o=>this.loadWeights(o));e(s)},n.onerror=a=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let i of e)t.push(...i.weights),n.push(...i.paths);let a=this.checkManifestAndWeightFiles(e),r=n.map(i=>this.loadWeightsFile(i,a[i]));return Promise.all(r).then(i=>[t,i])}loadWeightsFile(e,t){return new Promise((n,a)=>{let r=new FileReader;r.onload=i=>{let s=i.target.result;n(s)},r.onerror=i=>a(`Failed to weights data from file of path '${e}'.`),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(r=>AN(r.name)),a={};for(let r of e)r.paths.forEach(i=>{let s=AN(i);if(t.indexOf(s)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),n.indexOf(s)===-1)throw new Error(`Weight file with basename '${s}' is not provided.`);a[i]=this.weightsFiles[n.indexOf(s)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return a}},PK=e=>Ae().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(I1.URL_SCHEME)?HK(e.slice(I1.URL_SCHEME.length)):null;rs.registerSaveRouter(PK);function HK(e="model"){return new I1(e)}function GK(e){return new qK(e)}function _N(e,t,n,a){s(e),n=n??0,a=a??1,o(n,a);let r=0,i=u=>(u.then(d=>{let c=n+ ++r/e.length*(a-n);return t(c),d}),u);function s(u){ee(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function o(u,d){ee(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),ee(d>=0&&d<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${d}`),ee(d>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${d}`)}return Promise.all(e.map(i))}async function wD(e,t){t==null&&(t={});let n=t.fetchFunc==null?Ae().platform.fetch:t.fetchFunc,a=e.map(i=>n(i,t.requestInit,{isBinary:!0})),r=(t.onProgress==null?await Promise.all(a):await _N(a,t.onProgress,0,.5)).map(i=>i.arrayBuffer());return t.onProgress==null?await Promise.all(r):await _N(r,t.onProgress,.5,1)}function KK(e,t){var n;let a=t.fetchFunc==null?Ae().platform.fetch:t.fetchFunc,r=0,i;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async s=>{for(var o;r<e.length;){i||(i=(await a(e[r],t.requestInit,{isBinary:!0})).body.getReader());let{done:u,value:d}=await i.read();if(u){r++,i=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,r/e.length);continue}s.enqueue(d);return}s.close()}})}async function $K(e,t="",n,a){return xD(r=>wD(r,{requestInit:a}))(e,t,n)}function xD(e){return async(t,n="",a)=>{let r=t.map(()=>!1),i={},s=a!=null?a.map(()=>!1):[],o=[];if(t.forEach((g,x)=>{let v=0;g.weights.forEach(S=>{let E="quantization"in S?S.quantization.dtype:S.dtype,C=ep[E]*Un(S.shape),T=()=>{r[x]=!0,i[x]==null&&(i[x]=[]),i[x].push({manifestEntry:S,groupOffset:v,sizeBytes:C})};a!=null?a.forEach((N,D)=>{N===S.name&&(T(),s[D]=!0)}):T(),o.push(S.name),v+=C})}),!s.every(g=>g)){let g=a.filter((x,v)=>!s[v]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let u=r.reduce((g,x,v)=>(x&&g.push(v),g),[]),d=[];u.forEach(g=>{t[g].paths.forEach(x=>{let v=n+(n.endsWith("/")?"":"/")+x;d.push(v)})});let c=await e(d),h={},m=0;return u.forEach(g=>{let x=t[g].paths.length,v=new iu(c.slice(m,m+x));i[g].forEach(S=>{let E=v.slice(S.groupOffset,S.groupOffset+S.sizeBytes),C=H3(E,[S.manifestEntry]);for(let T in C)h[T]=C[T]}),m+=x}),h}}var JK="application/octet-stream",YK="application/json",XE=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(ee(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Ae().platform.fetch,ee(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&ee(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],a=$3(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(a)],{type:YK}),"model.json"),e.weightData!=null){let i=iu.join(e.weightData);t.body.append("model.weights.bin",new Blob([i],{type:JK}),"model.weights.bin")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:B0(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}let n=t.modelTopology,a=t.weightsManifest;if(n==null&&a==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return VA(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=Ck(e.weightsManifest),a=()=>KK(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:a})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=jK(t),r=this.weightPathPrefix||n,i=[],s=[];for(let o of e)for(let u of o.paths)this.weightUrlConverter!=null?s.push(this.weightUrlConverter(u)):i.push(r+u+a);return this.weightUrlConverter&&i.push(...await Promise.all(s)),i}async loadWeights(e){let t=await this.getWeightUrls(e),n=Ck(e),a=await wD(t,this.loadOptions);return[n,a]}};XE.URL_SCHEME_REGEX=/^https?:\/\//;function jK(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}function Ok(e){return e.match(XE.URL_SCHEME_REGEX)!=null}var vD=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(a=>Ok(a)):n=Ok(e),n)return eC(e,t)}return null};rs.registerSaveRouter(vD);rs.registerLoadRouter(vD);function eC(e,t){return new XE(e,t)}function QK(e,t){return eC(e,t)}var Z2=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},SD=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},ZK=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function XK(e,t,n,a){let r=arguments;return new ZK(kD(...r))}function kD(e,t,n,a){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new Z2(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Z2({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Z2({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a}))}function e7(e){return new SD(e)}function t7(e){return new SD(e)}var AD={};qt(AD,{confusionMatrix:()=>a7});function n7(e,t,n){let a=$(e,"labels","confusionMatrix"),r=$(t,"predictions","confusionMatrix");ee(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),ee(a.rank===1,()=>`Expected the rank of labels to be 1, but got ${a.rank}`),ee(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),ee(a.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${a.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),ee(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let i=xm(je(a,"int32"),n),s=xm(je(r,"int32"),n),o=Qt(i),u=jt(o,s);return je(u,"int32")}var a7=le({confusionMatrix_:n7}),Q0={};qt(Q0,{draw:()=>d7,fromPixels:()=>p7,fromPixelsAsync:()=>l7,toPixels:()=>c7});var Dd,TN=!1;function ED(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,i=!1,s=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)a=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)i=!0;else if(e.getContext!=null)s=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if($y(k1,oe.backendName)!=null){let m={pixels:e},g={numChannels:t};return oe.runKernel(k1,m,g)}let[u,d]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height],c;if(s)c=e.getContext("2d").getImageData(0,0,u,d).data;else if(a||n)c=e.data;else if(i||r||o){if(Dd==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Dd=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Dd=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Dd.canvas.width=u,Dd.canvas.height=d,Dd.drawImage(e,0,0,u,d),c=Dd.getImageData(0,0,u,d).data}let h;if(t===4)h=new Int32Array(c);else{let m=u*d;h=new Int32Array(m*t);for(let g=0;g<m;g++)for(let x=0;x<t;++x)h[g*t+x]=c[g*4+x]}return Wv(h,[d,u,t],"int32")}function r7(e){return e!=null&&e.data instanceof Uint8Array}function i7(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function s7(e){return e!=null&&e.width!==0&&e.height!==0}function o7(e){return i7()&&!(e instanceof ImageBitmap)&&s7(e)&&!r7(e)}async function l7(e,t=3){let n=null;if(Ae().getBool("WRAP_TO_IMAGEBITMAP")&&o7(e)){let a;try{a=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{a=null}a!=null&&a.width===e.width&&a.height===e.height?n=a:n=e}else n=e;return ED(n,t)}function CD(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function u7(e){let t=(e==null?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function c7(e,t){let n=$(e,"img","toPixels");if(!(e instanceof $t)){let d=n;n=je(d,"int32"),d.dispose()}CD(n);let[a,r]=n.shape.slice(0,2),i=n.rank===2?1:n.shape[2],s=await n.data(),o=n.dtype==="float32"?255:1,u=new Uint8ClampedArray(r*a*4);for(let d=0;d<a*r;++d){let c=[0,0,0,255];for(let m=0;m<i;m++){let g=s[d*i+m];if(n.dtype==="float32"){if(g<0||g>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`)}else if(n.dtype==="int32"&&(g<0||g>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);i===1?(c[0]=g*o,c[1]=g*o,c[2]=g*o):c[m]=g*o}let h=d*4;u[h+0]=Math.round(c[0]),u[h+1]=Math.round(c[1]),u[h+2]=Math.round(c[2]),u[h+3]=Math.round(c[3])}if(t!=null){TN||$y(ov,oe.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),TN=!0),t.width=r,t.height=a;let d=t.getContext("2d"),c=new ImageData(u,r,a);d.putImageData(c,0,0)}return n!==e&&n.dispose(),u}function d7(e,t,n){let a=$(e,"img","draw");if(!(e instanceof $t)){let s=a;a=je(s,"int32"),s.dispose()}CD(a),u7(n==null?void 0:n.imageOptions);let r={image:a},i={canvas:t,options:n};oe.runKernel(ov,r,i)}var p7=le({fromPixels_:ED}),tC={};qt(tC,{prepareAndValidate:()=>ID});function ID(e,t){let n=e.shape.length,a=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(a<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${a}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[a-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[a-1]} vs. ${n}`);if(Un(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let r=t.shape,i=r[r.length-1],s=1;for(let h=0;h<r.length-1;++h)s*=r[h];let o=e.shape,u=r.slice();u.pop();let d=1;for(let h=i;h<n;++h)d*=o[h],u.push(o[h]);let c=[...Fm(e.shape).map(h=>h/d),1].slice(0,i);return[u,s,d,c]}var $a={};qt($a,{assertParamsValid:()=>f7,computeFlatOffset:()=>w7,computeOutShape:()=>g7,getNormalizedAxes:()=>b7,isSliceContinous:()=>y7,maskToAxes:()=>m7,parseSliceParams:()=>BD,sliceInfo:()=>x7,startForAxis:()=>OD,startIndicesWithElidedDims:()=>RD,stopForAxis:()=>MD,stopIndicesWithElidedDims:()=>FD,stridesForAxis:()=>DD,stridesWithElidedDims:()=>_D});var Mk=-2,h7=-1;function f7(e,t,n){let a=e.shape.length;ee(a===t.length,()=>`Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`),ee(a===n.length,()=>`Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`);for(let r=0;r<a;++r)ee(t[r]+n[r]<=e.shape[r],()=>`Error in slice${a}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function m7(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function g7(e,t,n){let a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function _D(e,t,n,a){let r=[...e];for(let i=r.length;i<a.length;i++)r.push(1);for(let i=0;i<n;i++)i===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function TD(e,t,n){return n<=e?n:n-(t-1)}function ND(e,t){let n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function b7(e,t,n,a,r,i,s,o,u){let d=e.length,c=new Array(d),h=new Array(d),m=new Array(d);if(t.length&&n>0){let g=t[0],x=n+1;c=RD(s,g,x,a,e),h=FD(o,g,x,r,e),m=_D(i,g,x,e)}else for(let g=0;g<d;g++)c[g]=OD(s,a,i,e,g,u),h[g]=MD(o,r,i,e,g,u),m[g]=DD(i,g,u);return{begin:c,end:h,strides:m}}function RD(e,t,n,a,r){let i=[...r],s=ND(n,t);for(let o=0;o<i.length;o++)if(s.indexOf(o)>-1)i[o]=0;else{let u=TD(t,n,o),d=a[u];e&1<<u&&(d=0),i[o]=d}return i}function FD(e,t,n,a,r){let i=[...r],s=ND(n,t);for(let o=0;o<i.length;o++)if(s.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{let u=TD(t,n,o),d=a[u];e&1<<u&&(d=Number.MAX_SAFE_INTEGER),i[o]=d}for(let o=0;o<i.length;o++){let u=r[o];i[o]<0&&(i[o]+=u),i[o]=Gy(0,i[o],r[o])}return i}function DD(e,t,n){let a=e[t];return(n&1<<t||a==null)&&(a=1),a}function OD(e,t,n,a,r,i){let s=t[r],o=n[r]||1;(e&1<<r||i&1<<r||s==null)&&(o>0?s=Number.MIN_SAFE_INTEGER:s=Number.MAX_SAFE_INTEGER);let u=a[r];return s<0&&(s+=u),s=Gy(0,s,u-1),s}function MD(e,t,n,a,r,i){let s=t[r],o=n[r]||1;(e&1<<r||i&1<<r||s==null)&&(o>0?s=Number.MAX_SAFE_INTEGER:s=Number.MIN_SAFE_INTEGER);let u=a[r];return s<0&&(s+=u),o>0?s=Gy(0,s,u):s=Gy(-1,s,u-1),s}function y7(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function w7(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function BD(e,t,n){let a,r=e.shape.length;typeof t=="number"?a=[t,...new Array(r-1).fill(0)]:t.length<r?a=t.concat(new Array(r-t.length).fill(0)):a=t.slice(),a.forEach(s=>{ee(s!==-1,()=>"slice() does not support negative begin indexing.")});let i;return n==null?i=new Array(r).fill(-1):typeof n=="number"?i=[n,...new Array(r-1).fill(-1)]:n.length<r?i=n.concat(new Array(r-n.length).fill(-1)):i=n,i=i.map((s,o)=>s>=0?s:(ee(s===-1,()=>`Negative size values should be exactly -1 but got ${s} for the slice() size at index ${o}.`),e.shape[o]-a[o])),[a,i]}function x7(e,t,n,a,r,i,s,o,u){let d;if(a==null?(d=new Array(t.length),d.fill(1)):d=a,s!=null&&s&s-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,h={dims:d.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:d.slice(),beginMask:r,endMask:i,ellipsisMask:s,newAxisMask:o,shrinkAxisMask:u};for(let C=0;C<h.dims;C++)c&&1<<C&o&&h.numAddAxisAfterEllipsis++,1<<C&s&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);let m={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};v7(h,m);let g=!0,x=!0,v=!0,S=[],E=[];for(let C=0;C<e.length;++C){if(m.strides[C]===0)throw Error(`strides[${C}] must be non-zero`);let T=!!(m.shrinkAxisMask&1<<C),N=e[C];if(N===-1){S.push(T?1:-1);continue}let D=[m.beginMask&1<<C,m.endMask&1<<C],q=[m.strides[C]>0?0:-1,m.strides[C]>0?N:N-1];if(T&&m.strides[C]<=0)throw Error("only stride 1 allowed on non-range indexing.");v=v&&m.strides[C]===1;let H=!!(m.beginMask&1<<C&&m.endMask&1<<C);if(m.beginValid&&m.endValid){if(T){let Q=m.begin[C]<0?N+m.begin[C]:m.begin[C];if(m.begin[C]=Q,m.end[C]=m.begin[C]+1,Q<0||Q>=N)throw Error(`slice index ${m.begin[C]} of dimension ${C} out of bounds.`)}else m.begin[C]=NN(m.begin[C],0,m.strides[C],N,D,q),m.end[C]=NN(m.end[C],1,m.strides[C],N,D,q);let te=m.strides[C]===1&&m.begin[C]===0&&m.end[C]===N;g=g&&te,x=x&&(C===0&&m.strides[C]===1||te)}else g=g&&m.strides[C]===1&&H,x=x&&(C===0&&m.strides[C]===1||H);let K,j=!1;if(m.beginValid&&m.endValid?(K=m.end[C]-m.begin[C],j=!0):T?(K=1,j=!0):H&&N>=0&&(m.strides[C]<0?K=-N:K=N,j=!0),j){let te;K===0||K<0!=m.strides[C]<0?te=0:te=Math.trunc(K/m.strides[C])+(K%m.strides[C]!==0?1:0),S.push(te)}else S.push(-1)}for(let C=0;C<m.finalShapeGatherIndices.length;++C){let T=m.finalShapeGatherIndices[C];T>=0?E.push(S[T]):T===Mk&&E.push(1)}return{finalShapeSparse:E.filter((C,T)=>m.finalShapeGatherIndices[T]!==Mk),finalShape:E,isIdentity:g,sliceDim0:x,isSimpleSlice:v,begin:m.begin,end:m.end,strides:m.strides}}function v7(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){let r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(Mk),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[a]),e.end!=null&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(h7),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}function NN(e,t,n,a,r,i){if(r[t])return n>0?i[t]:i[t+1&1];{let s=e<0?a+e:e;return s<i[0]?i[0]:s>i[1]?i[1]:s}}var S7="4.22.0",LD=class{static sgd(e){return new Qv(e)}static momentum(e,t,n=!1){return new QE(e,t,n)}static rmsprop(e,t=.9,n=0,a=null,r=!1){return new ZE(e,t,n,a,r)}static adam(e=.001,t=.9,n=.999,a=null){return new YE(e,t,n,a)}static adadelta(e=.001,t=.95,n=null){return new $E(e,t,n)}static adamax(e=.002,t=.9,n=.999,a=null,r=0){return new jE(e,t,n,a,r)}static adagrad(e,t=.1){return new JE(e,t)}},Bd=LD,k7=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function nC(){return new Promise(e=>k7(()=>e()))}var P={};qt(P,{ERF_A1:()=>z7,ERF_A2:()=>U7,ERF_A3:()=>V7,ERF_A4:()=>W7,ERF_A5:()=>q7,ERF_P:()=>L7,PARALLELIZE_THRESHOLD:()=>aC,RowPartitionType:()=>jo,SELU_SCALE:()=>UD,SELU_SCALEALPHA:()=>zD,applyActivation:()=>Yv,assertAndGetBroadcastShape:()=>Kn,assertAxesAreInnerMostDims:()=>xP,assertParamsConsistent:()=>A7,assignToTypedArray:()=>J7,axesAreInnerMostDims:()=>fE,calculateShapes:()=>KF,checkEinsumDimSizes:()=>e$,checkPadOnDimRoundingMode:()=>Jr,combineLocations:()=>hF,combineRaggedTensorToTensorShapes:()=>C7,complexWithEvenIndex:()=>G7,complexWithOddIndex:()=>K7,computeConv2DInfo:()=>L0,computeConv3DInfo:()=>rF,computeDefaultPad:()=>jA,computeDilation2DInfo:()=>y5,computeOptimalWindowSize:()=>N7,computeOutAndReduceShapes:()=>fF,computeOutShape:()=>E7,computePool2DInfo:()=>aF,computePool3DInfo:()=>w5,convertConv2DDataFormat:()=>iF,decodeEinsumEquation:()=>Z7,eitherStridesOrDilationsAreOne:()=>ll,expandShapeToKeepDim:()=>ip,exponent:()=>j7,exponents:()=>Y7,fromStringArrayToUint8:()=>v$,fromUint8ToStringArray:()=>x$,getAxesPermutation:()=>mF,getBroadcastDims:()=>dF,getComplexWithIndex:()=>$7,getEinsumComputePath:()=>t$,getEinsumPermutation:()=>X7,getFusedBiasGradient:()=>Jv,getFusedDyActivation:()=>$v,getImageCenter:()=>R7,getInnerMostAxes:()=>vP,getPermuted:()=>D7,getRaggedRank:()=>_7,getReductionAxes:()=>La,getReshaped:()=>F7,getReshapedPermuted:()=>O7,getRowPartitionTypesHelper:()=>I7,getSliceBeginCoords:()=>M7,getSliceSize:()=>B7,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>i$,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>s$,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>o$,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>c$,getSparseReshapeInputOutputMismatchErrorMessage:()=>p$,getSparseReshapeInputOutputMultipleErrorMessage:()=>d$,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>l$,getSparseReshapeNegativeOutputDimErrorMessage:()=>u$,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>g$,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>h$,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>f$,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>m$,getUndoAxesPermutation:()=>mE,isIdentityPermutation:()=>n$,log:()=>NW,mergeRealAndImagArrays:()=>P7,prepareAndValidate:()=>ID,prepareSplitSize:()=>r$,segment_util:()=>VD,shouldFuse:()=>jv,slice_util:()=>$a,splitRealAndImagArrays:()=>H7,stridesOrDilationsArePositive:()=>rp,tupleValuesAreOne:()=>Sc,upcastType:()=>as,validateDefaultValueShape:()=>T7,validateInput:()=>Pv,validateUpdateShape:()=>LE,warn:()=>cc});function A7(e,t){let n=e[0].length;e.forEach((r,i)=>{ee(r.length===n,()=>`Error in concat${n}D: rank of tensors[${i}] must be the same as the rank of the rest (${n})`)}),ee(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let a=e[0];e.forEach((r,i)=>{for(let s=0;s<n;s++)ee(s===t||r[s]===a[s],()=>`Error in concat${n}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${a}) along the non-concatenated axis ${i}.`)})}function E7(e,t){let n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var jo;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(jo||(jo={}));function C7(e,t,n){let a=new Array;if(n==null&&t==null)return a;if(t==null)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(n==null)return a;if(e+n.length!==a.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${a.length}`);for(let r=1;r<n.length;++r){let i=n[r],s=a[a.length-n.length+r],o=a[s];if(i>=0)if(o>=0){if(o!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${i} but shape[${r+e}] = ${o}`)}else a[s]=i}return a}function I7(e){let t={FIRST_DIM_SIZE:jo.FIRST_DIM_SIZE,VALUE_ROWIDS:jo.VALUE_ROWIDS,ROW_LENGTHS:jo.ROW_LENGTHS,ROW_SPLITS:jo.ROW_SPLITS,ROW_LIMITS:jo.ROW_LIMITS,ROW_STARTS:jo.ROW_STARTS},n=[];for(let a of e)if(a in t)n.push(t[a]);else break;return n}function _7(e){return e.length===0?0:e[0]===jo.FIRST_DIM_SIZE?e.length-1:e.length}function T7(e,t){if(e==null||t==null)return;let n=e.length,a=t.length;if(n>=a)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${a})`);for(let r=0;r<Math.min(n,a-1);++r){let i=e[r],s=t[r+1];if(i>=0&&s>=0&&i!==1&&i!==s)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${i} but ragged tensor input.flatValues.shape[${r-e.length}] = ${s}`)}}var aC=30;function N7(e){return e<=aC?e:S1(e,Math.floor(Math.sqrt(e)))}function R7(e,t,n){let a=n*(typeof e=="number"?e:e[0]),r=t*(typeof e=="number"?e:e[1]);return[a,r]}function F7(e,t,n,a=!0){let r=[];if(a)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let i=t.length;for(let s=0;s<i;++s)r=r.concat([e[s+1]/t[s],t[s]]);r=r.concat(e.slice(i+1))}return r}function D7(e,t,n=!0){let a=[];if(n){a.push(t);for(let r=t+1;r<e;++r)r<=2*t?(a.push(r),a.push(r-(t+1))):a.push(r)}else{let r=[],i=[];for(let s=1;s<e;++s)s>=t*2+1||s%2===1?i.push(s):r.push(s);a.push(...r),a.push(0),a.push(...i)}return a}function O7(e,t,n,a=!0){let r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let i=1;i<e.length;++i)i<=t.length?a?r.push(t[i-1]*e[i]):r.push(e[i]/t[i-1]):r.push(e[i]);return r}function M7(e,t){let n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function B7(e,t,n){let a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}var zD=1.7580993408473768,UD=1.0507009873554805,L7=.3275911,z7=.254829592,U7=-.284496736,V7=1.421413741,W7=-1.453152027,q7=1.061405429;function P7(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function H7(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function G7(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function K7(e){let t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function $7(e,t){let n=e[t*2],a=e[t*2+1];return{real:n,imag:a}}function J7(e,t,n,a){e[a*2]=t,e[a*2+1]=n}function Y7(e,t){let n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){let i=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(i),a[r]=Math.sin(i)}return{real:n,imag:a}}function j7(e,t,n){let a=(n?2:-2)*Math.PI*(e/t),r=Math.cos(a),i=Math.sin(a);return{real:r,imag:i}}var X2="->",Q7=/->/g,RN=",",FN="...";function Z7(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(Q7,"").length)/X2.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${X2}").`);let[a,r]=e.split(X2);ee(a.indexOf(FN)===-1,()=>`The ellipsis notation ("${FN}") is not supported yet.`);let i=a.split(RN),s=i.length;if(t!==s)throw new Error(`Expected ${s} input tensors, received ${t}`);if(s>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let m=0;m<r.length;++m){let g=r[m];if(!i.some(x=>x.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);o.indexOf(g)===-1&&o.push(g)}for(let m=0;m<a.length;++m){let g=a[m];o.indexOf(g)===-1&&g!==RN&&o.push(g)}let u=new Array(i.length);for(let m=0;m<s;++m){if(new Set(i[m].split("")).size!==i[m].length)throw new Error(`Found duplicate axes in input component ${i[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let g=0;g<i[m].length;++g)u[m].push(o.indexOf(i[m][g]))}let d=o.length,c=r.length,h=[];for(let m=c;m<d;++m)h.push(m);return{allDims:o,summedDims:h,idDims:u}}function X7(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;let a=[];for(let r=0;r<e;++r)n[r]===-1&&a.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:a}}function e$(e,t,n){let a=new Array(e);for(let r=0;r<n.length;++r){let i=n[r].shape;for(let s=0;s<t[r].length;++s)a[t[r][s]]===void 0?a[t[r][s]]=i[s]:ee(a[t[r][s]]===i[s],()=>`Expected dimension ${a[t[r][s]]} at axis ${s} of input shaped ${JSON.stringify(i)}, but got dimension ${i[s]}`)}}function t$(e,t){let n=e,a=[],r=0;e.length===0&&n.push(-1),r=e.length+1;for(let s=0;s<r;++s)a.push([]);let i=[];for(let s=0;s<n.length;++s){let o=n[s],u=a$(t,o);for(let d of u)i.indexOf(d)===-1&&(a[s].push(d),i.push(d))}return{path:n,steps:a}}function n$(e){return e.every((t,n)=>t===n)}function a$(e,t){let n=[];for(let a=0;a<e.length;++a)(e[a].length===0||e[a].indexOf(t)!==-1||t===-1)&&n.push(a);return n}function r$(e,t,n=0){let a=[];if(typeof t=="number")ee(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),a=new Array(t).fill(e.shape[n]/t);else{let r=t.reduce((s,o)=>(o===-1&&(s+=1),s),0);ee(r<=1,()=>"There should be only one negative value in split array.");let i=t.indexOf(-1);if(i!==-1){let s=t.reduce((o,u)=>u>0?o+u:o);t[i]=e.shape[n]-s}ee(e.shape[n]===t.reduce((s,o)=>s+o),()=>"The sum of sizes must match the size of the axis dimension."),a=t}return a}function i$(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function s$(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function o$(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function l$(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function u$(e,t){return`size ${e} must be non-negative, not ${t}`}function c$(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function d$(e,t){let n=Un(e),a=Un(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${a}. inputShape=${e} outputShape= ${t}`}function p$(e,t){let n=Un(e),a=Un(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${a}. inputShape=${e} outputShape=${t}`}function h$(){return"segment ids must be >= 0"}function f$(){return"segment ids are not increasing"}function m$(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function g$(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var VD={};qt(VD,{collectGatherOpShapeInfo:()=>w$,computeOutShape:()=>y$,segOpComputeOptimalWindowSize:()=>b$});function b$(e,t){let n=!1,a;for(e<=aC?(a=e,n=!0):a=S1(e,Math.floor(Math.sqrt(e)));!n;)a>t||a===e?n=!0:a=S1(e,a+1);return a}function y$(e,t,n){let a=[],r=e.length;for(let i=0;i<r;i++)i!==t?a.push(e[i]):a.push(n);return a}function w$(e,t,n,a){let r=t.shape.length,i=e.shape.length;if(a!==0&&(a<-r||a>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${a}`);if(a<0&&(a+=r),a>i)throw new Error(`batchDims (${a}) must be less than rank(x) (
    ${i}).`);if(n<a)throw new Error(`batchDims (${a}) must be less than or equal to axis (${n}).`);for(let h=0;h<a;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);let s=e.shape[n],o=[],u=1,d=1,c=1;for(let h=0;h<a;++h)o.push(e.shape[h]),u*=e.shape[h];for(let h=a;h<n;h++)o.push(e.shape[h]),d*=e.shape[h];for(let h=a;h<r;h++)o.push(t.shape[h]);for(let h=n+1;h<i;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:u,sliceSize:c,outerSize:d,dimSize:s,outputShape:o}}function x$(e){try{return e.map(t=>E1(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function v$(e){return e.map(t=>O0(t))}var cl={};qt(cl,{nonMaxSuppressionV3Impl:()=>sD,nonMaxSuppressionV4Impl:()=>oD,nonMaxSuppressionV5Impl:()=>lD,whereImpl:()=>YF});zK();var WD={kernelName:Dm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(e,zh(je(n,"float32"),-1))}}},S$={kernelName:bp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=Hn(je(n,"float32")),r=ur(at(gt(1),a));return ia(it(e,r))}}}},k$={kernelName:yp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=ur(at(Hn(je(n,"float32")),1));return it(e,a)}}}},A$={kernelName:Mc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Kn(n.shape,a.shape);return{a:()=>{let i=e,s=La(n.shape,r);return s.length>0&&(i=lt(i,s)),ge(i,n.shape)},b:()=>{let i=e,s=La(a.shape,r);return s.length>0&&(i=lt(i,s)),ge(i,a.shape)}}}},E$={kernelName:wp,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((a,r)=>{n[r]=()=>e.clone()}),n}},C$={kernelName:Bm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>gn(n)}}},I$={kernelName:Lm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>gn(n)}}},_$={kernelName:xp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,ur(at(gt(1),Hn(je(n,"float32")))))}}},T$={kernelName:vp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=ur(Oe(gt(1),Hn(je(n,"float32"))));return it(e,a)}}}},N$={kernelName:Ap,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Kn(n.shape,a.shape);return{a:()=>{let i=Oe(Hn(n),Hn(a)),s=pe(e,it(a,i)),o=La(n.shape,r);return o.length>0&&(s=lt(s,o)),ge(s,n.shape)},b:()=>{let i=Oe(Hn(n),Hn(a)),s=ia(pe(e,it(n,i))),o=La(a.shape,r);return o.length>0&&(s=lt(s,o)),ge(s,a.shape)}}}},R$={kernelName:Sp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,Oe(Hn(je(n,"float32")),1))}}},F$={kernelName:kp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,at(gt(1),Hn(je(n,"float32"))))}}};function D$(e,t,n,a,r,i){let s=$(e,"dy","avgPool3dGrad"),o=$(t,"input","avgPool3dGrad"),u=s,d=o,c=!1;o.rank===4&&(c=!0,u=ge(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),d=ge(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ee(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),ee(d.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),Jr("avgPool3dGrad",r,i);let h={dy:u,input:d},m={filterSize:n,strides:a,pad:r,dimRoundingMode:i},g=oe.runKernel(p0,h,m);return c?ge(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var O$=le({avgPool3dGrad_:D$}),M$={kernelName:zm,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:i,pad:s,dimRoundingMode:o}=n;return{x:()=>O$(e,a,r,i,s,o)}}};function B$(e,t,n,a,r){let i=$(e,"dy","avgPoolGrad"),s=$(t,"input","avgPoolGrad");ee(s.rank===i.rank,()=>`Rank of input (${s.rank}) does not match rank of dy (${i.rank})`);let o=s,u=i,d=!1;s.rank===3&&(d=!0,o=ge(s,[1,s.shape[0],s.shape[1],s.shape[2]]),u=ge(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ee(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),ee(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let c={dy:u,input:o},h={filterSize:n,strides:a,pad:r},m=oe.runKernel(d0,c,h);return d?ge(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var L$=le({avgPoolGrad_:B$}),z$={kernelName:Ep,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:i,pad:s}=n;return{x:()=>L$(e,a,r,i,s)}}},U$={kernelName:Cp,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[a,r]=t,{transposeA:i,transposeB:s}=n;return!i&&!s?{a:()=>jt(e,r,!1,!0),b:()=>jt(a,e,!0,!1)}:!i&&s?{a:()=>jt(e,r,!1,!1),b:()=>jt(e,a,!0,!1)}:i&&!s?{a:()=>jt(r,e,!1,!0),b:()=>jt(a,e,!1,!1)}:{a:()=>jt(r,e,!0,!0),b:()=>jt(e,a,!0,!0)}}},V$={kernelName:Um,gradFunc:(e,t,n)=>{let{blockShape:a,crops:r}=n;return{x:()=>K0(e,a,r)}}},W$={kernelName:C3,gradFunc:(e,t,n)=>{let a=n,r=a.inputShape,i=a.shape,s=Array.from(i);for(let u=r.length-1;u>=0;u--)if(r[u]===i[u])s[u]=1;else if(r[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);let o=[];for(let u=0;u<s.length;u++)s[u]>1&&o.push(u);return{x:()=>lt(e,o,!0)}}},q$={kernelName:Ip,gradFunc:e=>({x:()=>e.clone()})},P$={kernelName:_p,gradFunc:e=>({x:()=>gn(e)})},H$={kernelName:Bc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{clipValueMin:r,clipValueMax:i}=n;return{x:()=>lr(Rs(ou(a,r),Vc(a,i)),e,gn(e))}}},G$={kernelName:f0,inputsToSave:["x"],gradFunc:WD.gradFunc},K$={kernelName:qm,saveAllInputs:!0,gradFunc:(e,t,n)=>{let a=t.map(o=>o.shape),{axis:r}=n,i=Fs(r,t[0].shape)[0],s=a.map(o=>o[i]);return li(e,s,i).map(o=>()=>o)}},$$={kernelName:Tp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,{dilations:i,strides:s,pad:o,dataFormat:u}=n;return ee(Sc(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>oE(a.shape,e,r,s,o,u),filter:()=>HE(a,e,r.shape,s,o,u)}}},J$={kernelName:Np,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,{strides:i,pad:s,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>Hr(e,r,i,s,o,1,u),filter:()=>HE(e,a,r.shape,i,s,o,u)}}};function Y$(e,t,n,a,r){let i=e;e.rank===4&&(i=ge(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let s=t;s.rank===4&&(s=ge(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),ee(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),ee(s.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${s.shape}.`),ee(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),ee(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),ee(s.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${s.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:i,dy:s},u={strides:a,pad:r,filterShape:n};return oe.runKernel(Pm,o,u)}var j$=le({conv3DBackpropFilter_:Y$}),Q$={kernelName:Rp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:i}=n;ee(Sc(a),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let[s,o]=t;return{x:()=>uF(s.shape,e,o,r,i),filter:()=>j$(s,e,o.shape,r,i)}}},Z$={kernelName:Fp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(ia(Bv(je(n,"float32"))),e)}}},X$={kernelName:Dp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(Lv(je(n,"float32")),e)}}},eJ={kernelName:Op,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r,exclusive:i,reverse:s}=n;return{x:()=>{let o=mF([r],a.rank),u=Av(e,r,i,!s);return o!=null&&(u=Qt(u,o)),u}}}},tJ={kernelName:Mp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:i,dimRoundingMode:s}=n,o=a??[1,1];ee(Sc(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[u,d]=t;return ee(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),ee(d.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${d.rank}.`),ee(u.shape[3]===d.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),ee(ll(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),Jr("depthwiseConv2d",i,s),{x:()=>aD(u.shape,e,d,r,i,o,s),filter:()=>nD(u,e,d.shape,r,i,o,s)}}},nJ={kernelName:Bp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,i={x:a,filter:r,dy:e},s={x:a,filter:r,dy:e};return{x:()=>oe.runKernel(mm,i,n),filter:()=>oe.runKernel(gm,s,n)}}},aJ={kernelName:zp,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,a={dy:e,y:n};return{x:()=>oe.runKernel(Jm,a)}}},rJ={kernelName:Up,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,a=pe(Fr(ia(Hn(n))),2/Math.sqrt(Math.PI));return{x:()=>pe(e,a)}}},iJ={kernelName:Vp,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(e,n)}}},sJ={kernelName:jm,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>ge(e,n.shape)}}},oJ={kernelName:Wp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(e,Fr(n))}}},lJ={kernelName:qp,gradFunc:e=>({x:()=>gn(e)})},uJ={kernelName:Pp,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Kn(n.shape,a.shape);return{a:()=>{let i=it(e,je(a,"float32")),s=La(n.shape,r);return s.length>0?ge(lt(i,s),n.shape):i},b:()=>{let i=pe(e,je(n,"float32")),s=La(a.shape,r);s.length>0&&(i=ge(lt(i,s),a.shape));let o=Hn(a);return ia(it(i,je(o,"float32")))}}}},cJ={kernelName:Hp,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:a}=n,[r,i,s,o]=t,u=o??gt(1),d=La(i.shape,r.shape),c=[];if(i.rank===1){for(let v=0;v<r.shape.length-1;++v)c.push(r.shape[v]);c.push(1)}let h=at(r,i),m=pe(e,u),g=Ov(Oe(s,gt(a))),x=pe(pe(pe(g,g),g),gt(-.5));return{x:()=>i.rank===1?ge(pe(pe(e,Ti(ge(g,[1,1,1,i.shape[0]]),c)),u),r.shape):ge(pe(pe(e,g),u),r.shape),mean:()=>{let v=pe(pe(g,gt(-1)),m);return i.rank===1&&(v=lt(v,d)),ge(v,i.shape)},variance:()=>{let v=pe(pe(x,h),m);return i.rank===1&&(v=lt(v,d)),ge(v,i.shape)},scale:()=>{let v=pe(h,g),S=pe(e,v);return i.rank===1&&(S=lt(S,d)),ge(S,i.shape)},offset:()=>{let v=e;return i.rank===1&&(v=lt(v,d)),ge(v,i.shape)}}}},dJ={kernelName:Zm,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[a,r]=t,{axis:i,batchDims:s}=n,o=Fs(i,a.shape)[0],u=(d,c,h)=>()=>{let m=d.shape,g=c.size,x=m.slice(0,o),v=x.length,S=m.slice(i,m.length).slice(1),E=S.length,C=DN(0,v),T=DN(v+1,v+1+E),N=ON([x,[g],S]),D=ge(h,N),q=ge(c,[g]),H=ON([[v],C,T]),K=Qt(D,H),j=Gv(K,q,d.shape[o]),te=mE(H);return j=Qt(j,te),j};if(s===1){let d=a.shape[0],c=a.split(d,0);return{x:()=>Ba(c.map((h,m)=>u(h,r.slice(m,1),e.slice(m,1))())).reshape(a.shape),indices:()=>r}}else return{x:u(a,r,e),indices:()=>r}}};function DN(e,t){let n=[];for(let a=e;a<t;++a)n.push(a);return n}function ON(e){let t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}var pJ={kernelName:Gp,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>gn(n),b:()=>gn(a)}}},hJ={kernelName:Kp,gradFunc:e=>({x:()=>je(e,"float32")})},fJ={kernelName:$p,gradFunc:e=>({x:()=>gn(e)})},mJ={kernelName:Jp,gradFunc:e=>({x:()=>gn(e)})},gJ={kernelName:Yp,gradFunc:e=>({x:()=>gn(e)})},bJ={kernelName:jp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{alpha:r}=n,i=Yr(a,0);return{x:()=>lr(i,e,pe(e,r))}}},yJ={kernelName:Zp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,Oe(n,1))}}},wJ={kernelName:Qp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,je(n,"float32"))}}},xJ={kernelName:_3,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n;return{logits:()=>{let i=Fr(a);return at(e,pe(lt(e,r,!0),i))}}}};function vJ(e,t,n,a=5,r=1,i=1,s=.5){let o={x:e,y:t,dy:n},u={depthRadius:a,bias:r,alpha:i,beta:s};return oe.runKernel(og,o,u)}var SJ=le({localResponseNormalizationBackprop_:vJ}),kJ={kernelName:Xp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{depthRadius:i,bias:s,alpha:o,beta:u}=n;return{x:()=>SJ(a,r,e,i,s,o,u)}}};function qD(e,t,n,a){return t.rank<n.rank&&(t=ge(t,ip(t.shape,a))),e.rank<n.rank&&(e=ge(e,ip(e.shape,a))),{x:()=>pe(e,je(Fi(n,t),e.dtype))}}var MN={kernelName:eh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{reductionIndices:r}=a,i=t[0],s=t[1],o=Fs(r,i.shape),u=qD(e,s,i,o);return{x:()=>u.x()}}},AJ={kernelName:th,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>pe(e,je(ou(n,a),"float32")),b:()=>pe(e,je(wm(n,a),"float32"))}}};function EJ(e,t,n,a,r,i,s){let o=$(e,"dy","maxPool3dGrad"),u=$(t,"input","maxPool3dGrad"),d=$(n,"output","maxPool3dGrad"),c=o,h=u,m=d,g=!1;u.rank===4&&(g=!0,c=ge(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=ge(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=ge(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),ee(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),ee(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),ee(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Jr("maxPool3dGrad",i,s);let x={dy:c,input:h,output:m},v={filterSize:a,strides:r,pad:i,dimRoundingMode:s},S=oe.runKernel(w0,x,v);return g?ge(S,[S.shape[1],S.shape[2],S.shape[3],S.shape[4]]):S}var CJ=le({maxPool3dGrad_:EJ}),IJ={kernelName:lg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:u}=n;return{x:()=>CJ(e,a,r,i,s,o,u)}}};function _J(e,t,n,a,r,i,s){let o=$(e,"dy","maxPoolGrad"),u=$(t,"input","maxPoolGrad"),d=$(n,"output","maxPoolGrad");ee(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),ee(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),ee(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Jr("maxPoolGrad",i,s);let c={dy:o,input:u,output:d},h={filterSize:a,strides:r,pad:i,dimRoundingMode:s};return oe.runKernel(y0,c,h)}var TJ=le({maxPoolGrad_:_J}),NJ={kernelName:nh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:i,strides:s,pad:o}=n;return{x:()=>TJ(e,a,r,i,s,o)}}},RJ={kernelName:ah,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,i=Fs(r,a.shape),s=fF(a.shape,i)[1],o=Un(s);return{x:()=>{let u=a.shape.slice();i.forEach(c=>{u[c]=1});let d=ge(e,u);return it(pe(d,oi(a.shape,"float32")),o)}}}},FJ={kernelName:rh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{axis:r}=a,[i,s]=t,o=Fs(r,i.shape),u=qD(e,s,i,o);return{x:()=>u.x()}}},DJ={kernelName:ih,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>pe(e,je(Vc(n,a),"float32")),b:()=>pe(e,je(Yr(n,a),"float32"))}}},OJ={kernelName:sh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,i=r.map(s=>s[0]);return{x:()=>un(e,i,a.shape)}}},MJ={kernelName:oh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Kn(n.shape,a.shape);return{a:()=>{let i=La(n.shape,r);return i.length>0?ge(lt(e,i),n.shape):e},b:()=>{let i=pe(e,ia(zg(it(n,a)))),s=La(a.shape,r);return s.length>0?ge(lt(i,s),a.shape):i}}}},BJ={kernelName:lh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Kn(n.shape,a.shape);return{a:()=>{let i=pe(e,je(a,"float32")),s=La(n.shape,r);return s.length>0?ge(lt(i,s),n.shape):i},b:()=>{let i=pe(e,je(n,"float32")),s=La(a.shape,r);return s.length>0?ge(lt(i,s),a.shape):i}}}},LJ={kernelName:cg,gradFunc:e=>({x:()=>ia(e)})},zJ={kernelName:uh,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>wa(n.shape,"float32")}}},UJ={kernelName:mg,gradFunc:e=>({x:()=>gn(e)})},VJ={kernelName:gg,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:a}=n;return Aa(e,a).map(r=>()=>r)}},BN={kernelName:ch,inputsToSave:["x"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,i=r.map(s=>s[0]);return{x:()=>un(e,i,a.shape)}}},WJ={kernelName:dh,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,a,r]=t,i=n,s=a,o=Kn(i.shape,s.shape);return{a:()=>{let u=je(s,"float32"),d=pe(e,pe(u,il(i,at(u,gt(1))))),c=La(i.shape,o);return c.length>0&&(d=lt(d,c)),ge(d,i.shape)},b:()=>{let u=Yr(i,0),d=lr(u,Di(i),gn(i)),c=pe(e,pe(r,d)),h=La(s.shape,o);return h.length>0&&(c=lt(c,h)),ge(c,s.shape)}}}},qJ={kernelName:ph,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,a]=t,r=Yr(n,0);return{x:()=>lr(r,e,pe(e,a)),alpha:()=>{let i=lr(r,gn(e),pe(e,n)),s=La(a.shape,e.shape);return s.length>0&&(i=lt(i,s)),ge(i,a.shape)}}}};function PJ(e,t,n){let a=e.shape.slice();a[n]=1;let r=ge(t,a),i=Xy(e,n,!0,!1),s=Xy(e,n,!0,!0),o=pe(i,s);return pe(r,o)}function HJ(e,t,n){let a=e.shape.length,r=a-n.length,i=P.getAxesPermutation(n,a),s=e;i!=null&&(s=Qt(e,i));let o=s.shape.slice(),u=o.splice(a-n.length,n.length).reduce((h,m)=>h*m,1);o.push(u);let d=s.reshape(o),c=PJ(d,t,r);if(c=c.reshape(s.shape),i!=null){let h=P.getUndoAxesPermutation(i);c=Qt(c,h)}return c}var GJ={kernelName:hh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,i=[];return r==null?i=a.shape.map((s,o)=>o):typeof r=="number"?i=[r]:i=r,{x:()=>HJ(a,e,i)}}},KJ={kernelName:Lp,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Kn(n.shape,a.shape);return{a:()=>{let i=it(e,je(a,"float32")),s=La(n.shape,r);return s.length>0?ge(lt(i,s),n.shape):i},b:()=>{let i=pe(e,je(n,"float32")),s=La(a.shape,r);s.length>0&&(i=ge(lt(i,s),a.shape));let o=Hn(a);return ia(it(i,je(o,"float32")))}}}},$J={kernelName:fh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,ia(Hn(n)))}}},JJ={kernelName:yh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,a=pe(Vc(n,6),zh(n));return{x:()=>pe(e,je(a,"float32"))}}},YJ={kernelName:mh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(e,je(zh(n),"float32"))}}},jJ={kernelName:bg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ge(e,n.shape)}}},QJ={kernelName:bh,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>oe.runKernel(wg,r,n)}}},ZJ={kernelName:gh,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>oe.runKernel(yg,r,n)}}},XJ={kernelName:wh,gradFunc:(e,t,n)=>{let{dims:a}=n,r=Fs(a,e.shape);return{x:()=>is(e,r)}}},eY={kernelName:xh,gradFunc:e=>({x:()=>gn(e)})},tY={kernelName:vh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ia(it(e,pe(il(n,1.5),2)))}}},nY={kernelName:kg,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>je(gn(n),"float32"),t:()=>pe(e,je(n,e.dtype)),e:()=>pe(e,je(H0(n),e.dtype))}}},aY={kernelName:Sh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=Yr(n,gt(0)),r=gt(zD),i=gt(UD),s=pe(e,i),o=pe(pe(e,r),Fr(je(n,"float32")));return lr(a,s,o)}}}},rY={kernelName:Ch,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(e,pe(n,at(gt(1),n)))}}},iY={kernelName:Eh,gradFunc:e=>({x:()=>gn(e)})},sY={kernelName:kh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(U0(je(n,"float32")),e)}}},oY={kernelName:Ah,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(kv(je(n,"float32")),e)}}},lY={kernelName:Ag,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{begin:r,size:i}=n,s=a.shape,[o,u]=BD(a,r,i),d=[];for(let c=0;c<e.rank;c++)d.push([o[c],s[c]-o[c]-u[c]]);return{x:()=>ho(e,d)}}},uY={kernelName:Nh,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{dim:r}=n,i=!0,s=pe(e,a);return{logits:()=>at(s,pe(lt(s,[r],i),a))}}},cY={kernelName:Ih,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(e,Ns(n))}}},LN={kernelName:Eg,gradFunc:(e,t,n)=>{let{blockShape:a,paddings:r}=n;return{x:()=>z0(e,a,r)}}},zN={kernelName:Cg,gradFunc:(e,t,n)=>{let{axis:a}=n;return{x:()=>Gn(e,a)}}},dY={kernelName:_h,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,pe(ur(je(n,"float32")),2))}}},pY={kernelName:E0,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(e,pe(je(n,"float32"),2))}}},hY={kernelName:Rh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=gt(2);return{a:()=>pe(e,pe(r,at(n,a))),b:()=>pe(e,pe(r,at(a,n)))}}},fY={kernelName:zc,gradFunc:e=>({x:()=>gn(e)})},mY={kernelName:Fh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Kn(n.shape,a.shape);return{a:()=>{let i=e,s=La(n.shape,r);return s.length>0&&(i=lt(i,s)),ge(i,n.shape)},b:()=>{let i=e,s=La(a.shape,r);return s.length>0&&(i=lt(i,s)),ge(ia(i),a.shape)}}}},gY={kernelName:Th,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,r=a.shape.slice(),{axis:i}=n;Fs(i,a.shape).forEach(u=>{r[u]=1});let s=ge(e,r),o=pe(s,oi(a.shape,"float32"));return{x:()=>o}}},bY={kernelName:Dh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,Hn(U0(n)))}}},yY={kernelName:Oh,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(at(gt(1),Hn(n)),e)}}},wY={kernelName:Lc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{reps:r}=n;return{x:()=>{let i=gn(a);if(a.rank===1)for(let s=0;s<r[0];++s)i=Oe(i,un(e,[s*a.shape[0]],[a.shape[0]]));else if(a.rank===2)for(let s=0;s<r[0];++s)for(let o=0;o<r[1];++o)i=Oe(i,un(e,[s*a.shape[0],o*a.shape[1]],[a.shape[0],a.shape[1]]));else if(a.rank===3)for(let s=0;s<r[0];++s)for(let o=0;o<r[1];++o)for(let u=0;u<r[2];++u)i=Oe(i,un(e,[s*a.shape[0],o*a.shape[1],u*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else if(a.rank===4)for(let s=0;s<r[0];++s)for(let o=0;o<r[1];++o)for(let u=0;u<r[2];++u)for(let d=0;d<r[3];++d)i=Oe(i,un(e,[s*a.shape[0],o*a.shape[1],u*a.shape[2],d*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${a.rank} tensors yet.`);return i}}}},xY={kernelName:Xl,gradFunc:(e,t,n)=>{let a=n,{perm:r}=a,i=mE(r);return{x:()=>Qt(e,i)}}},vY={kernelName:Fg,gradFunc:(e,t,n)=>{let a=n,{axis:r}=a;return{value:()=>Ba(e,r)}}},SY={kernelName:R0,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>kY(e,n)}}};function kY(e,t){let n=ul(t,gn(t)),a=Ug(e,n),r=ou(t,gt(0,"int32")),i=a.rank-r.rank;for(let o=0;o<i;++o)r=sr(r,o+1);r=Rs(r,oi(a.shape,"bool"));let s=gn(a);return lr(r,a,s)}var AY={kernelName:Dg,gradFunc:e=>({x:()=>gn(e)})},EY=[WD,S$,k$,A$,E$,C$,I$,_$,T$,N$,R$,F$,M$,z$,U$,V$,W$,q$,P$,H$,G$,K$,J$,$$,Q$,Z$,X$,eJ,tJ,nJ,KJ,aJ,rJ,iJ,sJ,oJ,uJ,lJ,cJ,dJ,pJ,hJ,fJ,mJ,gJ,bJ,yJ,wJ,xJ,kJ,MN,MN,AJ,IJ,NJ,RJ,FJ,DJ,OJ,MJ,BJ,LJ,zJ,UJ,VJ,BN,BN,WJ,qJ,GJ,$J,JJ,YJ,jJ,QJ,ZJ,XJ,eY,tY,nY,aY,rY,iY,sY,oY,lY,uY,cY,LN,LN,zN,zN,dY,hY,pY,fY,mY,gY,bY,yY,wY,xY,vY,SY,AY];for(let e of EY)T3(e);Be().prototype.abs=function(){return this.throwIfDisposed(),Da(this)};Be().prototype.acos=function(){return this.throwIfDisposed(),qA(this)};Be().prototype.acosh=function(){return this.throwIfDisposed(),PA(this)};Be().prototype.add=function(e){return this.throwIfDisposed(),Oe(this,e)};Be().prototype.all=function(e,t){return this.throwIfDisposed(),xv(this,e,t)};Be().prototype.any=function(e,t){return this.throwIfDisposed(),jy(this,e,t)};Be().prototype.argMax=function(e){return this.throwIfDisposed(),ap(this,e)};Be().prototype.argMin=function(e){return this.throwIfDisposed(),HA(this,e)};Be().prototype.asScalar=function(){return this.throwIfDisposed(),ee(this.size===1,()=>"The array must have only 1 element."),ge(this,[])};Be().prototype.asType=function(e){return this.throwIfDisposed(),je(this,e)};Be().prototype.as1D=function(){return this.throwIfDisposed(),ge(this,[this.size])};Be().prototype.as2D=function(e,t){return this.throwIfDisposed(),ge(this,[e,t])};Be().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),ge(this,[e,t,n])};Be().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),ge(this,[e,t,n,a])};Be().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),ge(this,[e,t,n,a,r])};Be().prototype.asin=function(){return this.throwIfDisposed(),GA(this)};Be().prototype.asinh=function(){return this.throwIfDisposed(),KA(this)};Be().prototype.atan=function(){return this.throwIfDisposed(),$A(this)};Be().prototype.atan2=function(e){return this.throwIfDisposed(),JA(this,e)};Be().prototype.atanh=function(){return this.throwIfDisposed(),YA(this)};Be().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),su(this,e,t,n,a)};Be().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),z0(this,e,t)};Be().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),Mh(this,e,t,n,a,r)};Be().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Gd(this,e)};Be().prototype.cast=function(e){return this.throwIfDisposed(),je(this,e)};Be().prototype.ceil=function(){return this.throwIfDisposed(),nE(this)};Be().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Rr(this,e,t)};Be().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof $t&&(e=[e]),Gn([this,...e],t)};Be().prototype.conv1d=function(e,t,n,a,r,i){return this.throwIfDisposed(),vv(this,e,t,n,a,r,i)};Be().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),Sv(this,e,t,n,a,r)};Be().prototype.conv2d=function(e,t,n,a,r,i){return this.throwIfDisposed(),Hr(this,e,t,n,a,r,i)};Be().prototype.cos=function(){return this.throwIfDisposed(),U0(this)};Be().prototype.cosh=function(){return this.throwIfDisposed(),kv(this)};Be().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Xy(this,e,t,n)};Be().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Av(this,e,t,n)};Be().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),cE(this,e,t)};Be().prototype.depthwiseConv2d=function(e,t,n,a,r,i){return this.throwIfDisposed(),Bh(this,e,t,n,a,r,i)};Be().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),dE(this,e,t,n,a,r)};Be().prototype.divNoNan=function(e){return this.throwIfDisposed(),pE(this,e)};Be().prototype.div=function(e){return this.throwIfDisposed(),it(this,e)};Be().prototype.dot=function(e){return this.throwIfDisposed(),hE(this,e)};Be().prototype.elu=function(){return this.throwIfDisposed(),Bg(this)};Be().prototype.equal=function(e){return this.throwIfDisposed(),Fi(this,e)};Be().prototype.erf=function(){return this.throwIfDisposed(),Ev(this)};Be().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),gE(this,e,t)};Be().prototype.exp=function(){return this.throwIfDisposed(),Fr(this)};Be().prototype.expandDims=function(e){return this.throwIfDisposed(),sr(this,e)};Be().prototype.expm1=function(){return this.throwIfDisposed(),bE(this)};Be().prototype.fft=function(){return this.throwIfDisposed(),Y0(this)};Be().prototype.flatten=function(){return this.throwIfDisposed(),ge(this,[this.size])};Be().prototype.floor=function(){return this.throwIfDisposed(),zg(this)};Be().prototype.floorDiv=function(e){return this.throwIfDisposed(),wv(this,e)};Be().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Ug(this,e,t,n)};Be().prototype.greaterEqual=function(e){return this.throwIfDisposed(),ou(this,e)};Be().prototype.greater=function(e){return this.throwIfDisposed(),Yr(this,e)};Be().prototype.ifft=function(){return this.throwIfDisposed(),km(this)};Be().prototype.irfft=function(){return this.throwIfDisposed(),Uv(this)};Be().prototype.isFinite=function(){return this.throwIfDisposed(),yE(this)};Be().prototype.isInf=function(){return this.throwIfDisposed(),wE(this)};Be().prototype.isNaN=function(){return this.throwIfDisposed(),xE(this)};Be().prototype.leakyRelu=function(e){return this.throwIfDisposed(),W0(this,e)};Be().prototype.lessEqual=function(e){return this.throwIfDisposed(),Vc(this,e)};Be().prototype.less=function(e){return this.throwIfDisposed(),wm(this,e)};Be().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),vE(this,e,t,n,a)};Be().prototype.logSigmoid=function(){return this.throwIfDisposed(),SE(this)};Be().prototype.logSoftmax=function(e){return this.throwIfDisposed(),_v(this,e)};Be().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),P0(this,e,t)};Be().prototype.log=function(){return this.throwIfDisposed(),Di(this)};Be().prototype.log1p=function(){return this.throwIfDisposed(),q0(this)};Be().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Rs(this,e)};Be().prototype.logicalNot=function(){return this.throwIfDisposed(),H0(this)};Be().prototype.logicalOr=function(e){return this.throwIfDisposed(),Tv(this,e)};Be().prototype.logicalXor=function(e){return this.throwIfDisposed(),kE(this,e)};Be().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),jt(this,e,t,n)};Be().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),ar(this,e,t,n,a)};Be().prototype.max=function(e,t){return this.throwIfDisposed(),ns(this,e,t)};Be().prototype.maximum=function(e){return this.throwIfDisposed(),ul(this,e)};Be().prototype.mean=function(e,t){return this.throwIfDisposed(),ya(this,e,t)};Be().prototype.min=function(e,t){return this.throwIfDisposed(),ym(this,e,t)};Be().prototype.minimum=function(e){return this.throwIfDisposed(),Ac(this,e)};Be().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),EE(this,e,t)};Be().prototype.mod=function(e){return this.throwIfDisposed(),CE(this,e)};Be().prototype.mul=function(e){return this.throwIfDisposed(),pe(this,e)};Be().prototype.neg=function(){return this.throwIfDisposed(),ia(this)};Be().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Lg(this,e,t,n)};Be().prototype.notEqual=function(e){return this.throwIfDisposed(),sp(this,e)};Be().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),xm(this,e,t,n)};Be().prototype.onesLike=function(){return this.throwIfDisposed(),Oi(this)};Be().prototype.pad=function(e,t){return this.throwIfDisposed(),ho(this,e,t)};Be().prototype.pool=function(e,t,n,a,r,i){return this.throwIfDisposed(),IE(this,e,t,n,a,r,i)};Be().prototype.pow=function(e){return this.throwIfDisposed(),il(this,e)};Be().prototype.prelu=function(e){return this.throwIfDisposed(),$0(this,e)};Be().prototype.prod=function(e,t){return this.throwIfDisposed(),_E(this,e,t)};Be().prototype.reciprocal=function(){return this.throwIfDisposed(),DE(this)};Be().prototype.relu=function(){return this.throwIfDisposed(),zn(this)};Be().prototype.relu6=function(){return this.throwIfDisposed(),Fv(this)};Be().prototype.reshapeAs=function(e){return this.throwIfDisposed(),ge(this,e.shape)};Be().prototype.reshape=function(e){return this.throwIfDisposed(),ge(this,e)};Be().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),uD(this,e,t,n)};Be().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),cD(this,e,t,n)};Be().prototype.reverse=function(e){return this.throwIfDisposed(),is(this,e)};Be().prototype.rfft=function(){return this.throwIfDisposed(),j0(this)};Be().prototype.round=function(){return this.throwIfDisposed(),Dv(this)};Be().prototype.rsqrt=function(){return this.throwIfDisposed(),Ov(this)};Be().prototype.selu=function(){return this.throwIfDisposed(),Mv(this)};Be().prototype.separableConv2d=function(e,t,n,a,r,i){return this.throwIfDisposed(),Vg(this,e,t,n,a,r,i)};Be().prototype.sigmoid=function(){return this.throwIfDisposed(),Ns(this)};Be().prototype.sign=function(){return this.throwIfDisposed(),OE(this)};Be().prototype.sin=function(){return this.throwIfDisposed(),Bv(this)};Be().prototype.sinh=function(){return this.throwIfDisposed(),Lv(this)};Be().prototype.slice=function(e,t){return this.throwIfDisposed(),un(this,e,t)};Be().prototype.softmax=function(e){return this.throwIfDisposed(),qc(this,e)};Be().prototype.softplus=function(){return this.throwIfDisposed(),Lh(this)};Be().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),K0(this,e,t)};Be().prototype.split=function(e,t){return this.throwIfDisposed(),li(this,e,t)};Be().prototype.sqrt=function(){return this.throwIfDisposed(),ur(this)};Be().prototype.square=function(){return this.throwIfDisposed(),Hn(this)};Be().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Vv(this,e)};Be().prototype.squeeze=function(e){return this.throwIfDisposed(),Pc(this,e)};Be().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof $t?[this,e]:[this,...e];return Ba(n,t)};Be().prototype.step=function(e){return this.throwIfDisposed(),zh(this,e)};Be().prototype.stridedSlice=function(e,t,n,a,r,i,s,o){return this.throwIfDisposed(),ME(this,e,t,n,a,r,i,s,o)};Be().prototype.sub=function(e){return this.throwIfDisposed(),at(this,e)};Be().prototype.sum=function(e,t){return this.throwIfDisposed(),lt(this,e,t)};Be().prototype.tan=function(){return this.throwIfDisposed(),BE(this)};Be().prototype.tanh=function(){return this.throwIfDisposed(),kc(this)};Be().prototype.tile=function(e){return this.throwIfDisposed(),Ti(this,e)};Be().prototype.toBool=function(){return this.throwIfDisposed(),je(this,"bool")};Be().prototype.toFloat=function(){return this.throwIfDisposed(),je(this,"float32")};Be().prototype.toInt=function(){return this.throwIfDisposed(),je(this,"int32")};Be().prototype.topk=function(e,t){return this.throwIfDisposed(),zE(this,e,t)};Be().prototype.transpose=function(e){return this.throwIfDisposed(),Qt(this,e)};Be().prototype.unique=function(e){return this.throwIfDisposed(),UE(this,e)};Be().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Gv(this,e,t)};Be().prototype.unstack=function(e){return this.throwIfDisposed(),Aa(this,e)};Be().prototype.where=function(e,t){return this.throwIfDisposed(),lr(e,this,t)};Be().prototype.zerosLike=function(){return this.throwIfDisposed(),gn(this)};var lc=class PD extends Error{constructor(t){super(t),Object.setPrototypeOf(this,PD.prototype)}},Xo=class HD extends Error{constructor(t){super(t),Object.setPrototypeOf(this,HD.prototype)}},we=class GD extends Error{constructor(t){super(t),Object.setPrototypeOf(this,GD.prototype)}},rn=class KD extends Error{constructor(t){super(t),Object.setPrototypeOf(this,KD.prototype)}},CY=class $D extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$D.prototype)}},JD=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function lp(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function Qo(e,t){if(!e)throw new CY(t)}function UN(e,t){let n=0;for(let a of e)a===t&&n++;return n}function si(e){return e.length===1?e[0]:e}function Ln(e){return Array.isArray(e)?e:[e]}function $l(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Vd(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var Cs={};function rC(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Bk(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>Bk(t));else{let t=Object.keys(e);for(let n of t){let a=e[n];a!=null&&typeof a=="object"&&(!Array.isArray(a)&&a.type==="ndarray"&&typeof a.value=="number"?e[n]=a.value:Bk(a))}}}function Z0(e,t={},n={},a="object",r=!1){if(typeof e=="string"){let i=e,s;if(i in n)s=n[i];else if(i in Cs)s=Cs[i];else if(s=t[i],s==null)throw new we(`Unknown ${a}: ${e}. This may be due to one of the following reasons:
1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}else{let i=e;if(i.className==null||i.config==null)throw new we(`${a}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);let s=i.className,o,u;if(s in n?[o,u]=n[s]:s in Cs?[o,u]=Cs.className:s in t&&([o,u]=t[s]),o==null)throw new we(`Unknown ${a}: ${s}. This may be due to one of the following reasons:
1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let d={};for(let g of Object.keys(Cs))d[g]=Cs[g];for(let g of Object.keys(n))d[g]=n[g];let c=i.config;c.customObjects=d;let h=Object.assign({},Cs);for(let g of Object.keys(n))Cs[g]=n[g];Bk(i.config);let m=u(o,i.config,n,r);return Cs=Object.assign({},h),m}else{let d=Object.assign({},Cs);for(let h of Object.keys(n))Cs[h]=n[h];let c=new o(i.config);return Cs=Object.assign({},d),c}}}function IY(e,t){return e<t?-1:e>t?1:0}function Gx(e,t){return-1*IY(e,t)}function gc(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function _Y(e){if(e==null)throw new we(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Uh(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new we(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function iC(e,t,n=0,a=1/0){return Qo(n>=0),Qo(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every(r=>typeof r===t)}function or(e,t){Array.isArray(e)?(O.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,a)=>or(n,`element ${a+1} of ${t}`))):O.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${YD(e)}.`)}function YD(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>YD(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function TY(e,t,n){let a=n!=null?n():O.now(),r;return(...i)=>{let s=n!=null?n():O.now();return s-a<t||(a=s,r=e(...i)),r}}function jD(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var NY=0;function QD(){return NY++}var Kx={};function Zv(e=""){return e in Kx||(Kx[e]=0),Kx[e]+=1,e+Kx[e].toString()}var RY=["channelsFirst","channelsLast"],FY=["nearest","bilinear"],DY=["valid","same","causal"],OY=["max","avg"],MY=["sum","mul","concat","ave"],tm=new Map;function _a(e){Uh(RY,"DataFormat",e)}function BY(e){Uh(FY,"InterpolationFormat",e)}function ss(e){Uh(DY,"PaddingMode",e)}function ZD(e){Uh(OY,"PoolMode",e)}var zy=[],VN="/";function Kd(e,t){zy.push(e);try{let n=t();return zy.pop(),n}catch(n){throw zy.pop(),n}}function LY(){return zy.length===0?"":zy.join(VN)+VN}function XD(e){if(!tO(e))throw new Error("Not a valid tensor name: '"+e+"'");return LY()+e}function eO(e){if(!tO(e))throw new Error("Not a valid tensor name: '"+e+"'");tm.has(e)||tm.set(e,0);let t=tm.get(e);if(tm.set(e,tm.get(e)+1),t>0){let n=`${e}_${t}`;return tm.set(n,1),n}else return e}var zY=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function tO(e){return!!e.match(zY)}function UY(e){return e===parseInt(e.toString(),10)}function bc(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function Em(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a<t&&(t=a)}return t}function Cc(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a>t&&(t=a)}return t}function oo(e,t){if(t<e)throw new we(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let a=e;a<t;++a)n.push(a);return n}var ek;function Ka(){return ek==null&&(ek=zA().epsilon()),ek}function lo(){return"channelsLast"}function au(e,t){return je(e,t)}function X0(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),ge(e,n)}function VY(e,t){return be(()=>{if(e.shape.length!==2)throw new we(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=X0(e,1);return Lk(n,[1,t,1])})}function WY(e){let t=[bc(e.shape)];return ge(e,t)}function qY(e){if(e.rank<=1)throw new we(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],bc(e.shape,1)];return ge(e,t)}function $d(e,t,n){return be(()=>{switch(e.rank){case 1:return J0(e,t,n);case 2:return zv(e,[t,0],[n,e.shape[1]]);case 3:return Wg(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Sm(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return un(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return un(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new we(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function tk(e,t,n){return be(()=>{switch(e.rank){case 1:return J0(e,t,n);case 2:return zv(e,[0,t],[e.shape[0],n]);case 3:return Wg(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Sm(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new we(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function $x(e,t,n,a){return be(()=>{switch(e.rank){case 1:return J0(e,t,n);case 2:switch(a){case 1:return $d(e,t,n);case 2:return tk(e,t,n);default:throw new we(`The axis is not within the rank of the tensor ${a}`)}case 3:switch(a){case 1:return $d(e,t,n);case 2:return Wg(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return tk(e,t,n);default:throw new we(`The axis is not within the rank of the tensor ${a}`)}case 4:switch(a){case 1:return $d(e,t,n);case 2:return Sm(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Sm(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return tk(e,t,n);default:throw new we(`The axis is not within the rank of the tensor ${a}`)}default:throw new we(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function sC(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),Gn(e,t)}function WN(e,t){switch(e.rank){case 1:return aE([e,t]);case 2:return rE([e,t],0);case 3:return iE([e,t],0);case 4:return sE([e,t],0);default:throw new we(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Lk(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new we(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Ti(e,t)}function Xv(e,t=0,n=1,a,r){return Rv(e,t,n,a,r)}function al(e,t,n,a){if(e.rank<2||t.rank<2)throw new rn(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let r=e.shape.slice(-1)[0],i=t.shape.slice(-2)[0];if(r!==i)throw new rn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Am.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?zk(e.rank,a,lo()):null,activation:n});{let r=e.shape.slice(),i=r.pop();e=ge(e,[-1,i]);let s=t.shape.slice(),o=s.pop(),u=s.pop(),d=[...s,o],c=Array.from({length:t.rank},(m,g)=>g===0?t.rank-2:g<=t.rank-2?g-1:g);t=ge(Qt(t,c),[u,-1]);let h=[...r,...d];return ge(Am.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?zk(e.rank,a,lo()):null,activation:n}),h)}}function nO(e,t,n){return be(()=>(Array.isArray(t)?t=Dn(t,"int32"):t=je(t,"int32"),Ug(e,t,n)))}function ew(e){return pe(e,e)}function zk(e,t,n){let a=t.shape;if(t.rank!==1&&t.rank!==e)throw new we(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return a.length===1?ge(t,[1,a[0],1,1,1]):ge(t,[1,a[3],a[0],a[1],a[2]]);if(n==="channelsLast")return a.length===1?ge(t,[1,1,1,1,a[0]]):ge(t,[1].concat(a))}else if(e===4){if(n==="channelsFirst")return a.length===1?ge(t,[1,a[0],1,1]):ge(t,[1,a[2],a[0],a[1]]);if(n==="channelsLast")return a.length===1?ge(t,[1,1,1,a[0]]):ge(t,[1].concat(a))}else if(e===3){if(n==="channelsFirst")return a.length===1?ge(t,[1,a[0],1]):ge(t,[1,a[1],a[0]]);if(n==="channelsLast")return a.length===1?ge(t,[1,1,a[0]]):ge(t,[1].concat(a))}else if(e<3)return t;throw new we(`Unsupported input rank by biasAdd: ${t.rank}`)}function fo(e,t,n){return be(()=>(n==null&&(n=lo()),_a(n),Oe(e,zk(e.rank,t,n))))}function PY(e,t=1){if(t!==1)throw new rn(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Bg(e)}function HY(e){return be(()=>it(e,Oe(Da(e),1)))}function aO(e,t,n,a){return be(()=>qE(e,t,n,a))}function GY(e){return be(()=>{let t=Oe(.5,pe(.2,e));return Rr(t,0,1)})}function tw(e,t,n=!1){return n?e():t()}var KY=["fanIn","fanOut","fanAvg"],$Y=["normal","uniform","truncatedNormal"];function JY(e){Uh(KY,"FanMode",e)}function YY(e){Uh($Y,"Distribution",e)}var Ds=class extends We.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},oC=class extends Ds{apply(e,t){return wa(e,t)}};oC.className="Zeros";We.registerClass(oC);var eS=class extends Ds{apply(e,t){return oi(e,t)}};eS.className="Ones";We.registerClass(eS);var lC=class extends Ds{constructor(e){if(super(),typeof e!="object")throw new we(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new we(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return be(()=>pe(gt(this.value),oi(e,t)))}getConfig(){return{value:this.value}}};lC.className="Constant";We.registerClass(lC);var uC=class extends Ds{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Wc(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};uC.className="RandomUniform";We.registerClass(uC);var cC=class extends Ds{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new rn(`randomNormal does not support dType ${t}.`);return Xv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};cC.className="RandomNormal";We.registerClass(cC);var dC=class extends Ds{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new rn(`truncatedNormal does not support dType ${t}.`);return Hv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};dC.className="TruncatedNormal";We.registerClass(dC);var pC=class extends Ds{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return be(()=>{if(e.length!==2||e[0]!==e[1])throw new we("Identity matrix initializer can only be used for 2D square matrices.");return pe(this.gain,Cv(e[0]))})}getConfig(){return{gain:this.gain}}};pC.className="Identity";We.registerClass(pC);function jY(e,t="channelsLast"){let n,a;if(_a(t),e.length===2)n=e[0],a=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let r=bc(e,2);n=e[1]*r,a=e[0]*r}else if(t==="channelsLast"){let r=bc(e,0,e.length-2);n=e[e.length-2]*r,a=e[e.length-1]*r}}else{let r=bc(e);n=Math.sqrt(r),a=Math.sqrt(r)}return[n,a]}var di=class extends Ds{constructor(e){if(super(),e.scale<0)throw new we(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,JY(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,YY(this.distribution),this.seed=e.seed}apply(e,t){let n=jY(e),a=n[0],r=n[1],i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,a):this.mode==="fanOut"?i/=Math.max(1,r):i/=Math.max(1,(a+r)/2),this.distribution==="normal"){let s=Math.sqrt(i);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new rn(`${this.getClassName()} does not support dType ${t}.`);return Hv(e,0,s,t,this.seed)}else{let s=Math.sqrt(3*i);return Wc(e,-s,s,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};di.className="VarianceScaling";We.registerClass(di);var tS=class extends di{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return di.className}};tS.className="GlorotUniform";We.registerClass(tS);var nS=class extends di{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return di.className}};nS.className="GlorotNormal";We.registerClass(nS);var aS=class extends di{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return di.className}};aS.className="HeNormal";We.registerClass(aS);var rS=class extends di{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return di.className}};rS.className="HeUniform";We.registerClass(rS);var iS=class extends di{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return di.className}};iS.className="LeCunNormal";We.registerClass(iS);var sS=class extends di{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return di.className}};sS.className="LeCunUniform";We.registerClass(sS);var hC=class extends Ds{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return be(()=>{if(e.length<2)throw new rn("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=O.sizeFromShape(e.slice(0,-1)),a=e[e.length-1],r=n*a;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);let i=[Math.max(a,n),Math.min(a,n)],s=Xv(i,0,1,t,this.seed),o=KE.qr(s,!1),u=o[0],d=o[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return u=pe(u,d.sign()),n<a&&(u=u.transpose()),pe(gt(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};hC.className="Orthogonal";We.registerClass(hC);var qN={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function PN(e,t={}){return Z0(e,We.SerializationMap.getMap().classNameMap,t,"initializer")}function xa(e){return rC(e)}function ca(e){if(typeof e=="string"){let t=e in qN?qN[e]:e;if(t==="GlorotNormal")return new nS;if(t==="GlorotUniform")return new tS;if(t==="HeNormal")return new aS;if(t==="HeUniform")return new rS;if(t==="LeCunNormal")return new iS;if(t==="LeCunUniform")return new sS;{let n={};return n.className=t,n.config={},PN(n)}}else return e instanceof Ds?e:PN(e)}function Uk(e){return Array.isArray(e)&&Array.isArray(e[0])}function _1(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Ot(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new we(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function vn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new we(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function T1(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((a,r)=>a*r);return t}var HN="Variable",rO=class{constructor(e,t="float32",n=HN,a=!0,r=null){this.dtype=t??"float32",this.shape=e.shape,this.id=QD(),n=n??HN,this.originalName=XD(n),this.name=eO(this.originalName),this.trainable_=a,this.constraint=r,this.val=VE(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),QY(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function QY(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function Vk(e){return e.map(t=>t.read())}function fC(e){e.forEach(t=>{t[0].write(t[1])})}var Oa=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},uo=class{constructor(e,t,n,a,r,i,s){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=s,this.id=QD(),i!=null&&(this.originalName=XD(i),this.name=eO(this.originalName)),this.rank=t.length}},ZY=0,oS=class{constructor(e,t){this.callArgs=t,this.id=ZY++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},XY=0,sn=class extends We.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=XY++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=$l(n)+"_"+Zv(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),n=[r].concat(e.inputShape)}this.batchInputShape=n;let a=e.dtype;a==null&&(a=e.inputDType),a==null&&(a="float32"),this.dtype=a}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Xo(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new we(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return si(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return si(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new lc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new lc(`Layer ${this.name} is not connected, no input to return.`);return si(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new lc(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new lc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return si(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=Ln(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=Ln(this.inputSpec);if(t.length!==n.length)throw new we(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let a=0;a<t.length;a++){let r=t[a],i=n[a];if(i==null)continue;let s=r.rank;if(i.ndim!=null&&s!==i.ndim)throw new we(`Input ${a} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${s}`);if(i.maxNDim!=null&&s>i.maxNDim)throw new we(`Input ${a} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${s}`);if(i.minNDim!=null&&s<i.minNDim)throw new we(`Input ${a} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${s}.`);if(i.dtype!=null&&r.dtype!==i.dtype)throw new we(`Input ${a} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${r.dtype}.`);if(i.axes){let o=r.shape;for(let u in i.axes){let d=Number(u),c=i.axes[u],h=d>=0?o[d]:o[o.length+d];if(c!=null&&[c,null].indexOf(h)===-1)throw new we(`Input ${a} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${c} but got shape ${o}.`)}}if(i.shape!=null)for(let o=0;o<i.shape.length;++o){let u=i.shape[o],d=r.shape[o];if(u!=null&&d!=null&&u!==d)throw new we(`Input ${a} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=Ln(e),a=n9(e),r=a9(e);if(a===r)throw new we("Arguments to apply() must be all SymbolicTensors or all Tensors");return Kd(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let i=[];for(let s of Ln(e))i.push(s.shape);this.build(si(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let i=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,i);let s=Ln(i),o=[];for(let u of s)n.indexOf(u)!==-1&&(u=u.clone()),o.push(u);if(i=si(o),this.activityRegularizer!=null)throw new rn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=e9(e),s=this.computeOutputShape(i),o,u=t9(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?i[0]:i),s!=null&&s.length>0&&Array.isArray(s[0])?o=s.map((d,c)=>new uo(u,d,this,Ln(e),t,this.name,c)):o=new uo(u,s,this,Ln(e),t,this.name),this.addInboundNode(e,o,null,null,i,s,t),this._refCount++,this.activityRegularizer!=null)throw new rn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,a)=>{n!=null&&e[a]!=null&&e[a]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new lc(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new lc(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Xo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return T1(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Vk(e?this.trainableWeights:this.weights)}setWeights(e){be(()=>{let t=this.weights;if(t.length!==e.length)throw new we(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],a=Vk(t);for(let r=0;r<a.length;++r){let i=a[r],s=t[r],o=e[r];if(!O.arraysEqual(i.shape,o.shape))throw new we(`Layer weight shape ${i.shape} not compatible with provided weight shape ${o.shape}`);n.push([s,o])}fC(n)})}addWeight(e,t,n,a,r,i,s,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new we(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(a=o!=null?o():ca("zeros"));let u=a.apply(t,n),d=new rO(u,n,e,i,s);return u.dispose(),r!=null&&this.addLoss(()=>r.apply(d.read())),i==null&&(i=!0),i?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Ln(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let a=this.computeMask(e,n),r=Ln(t),i=Ln(a);if(r.length!==i.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let s=0;s<r.length;s++)r[s].kerasMask=i[s]}addInboundNode(e,t,n,a,r,i,s=null){let o=Ln(e);t=Ln(t),n=Ln(n),a=Ln(a),r=_1(r),i=_1(i);let u=[],d=[],c=[];for(let h of o)u.push(h.sourceLayer),d.push(h.nodeIndex),c.push(h.tensorIndex);new oS({outboundLayer:this,inboundLayers:u,nodeIndices:d,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:i},s);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function e9(e){e=Ln(e);let t=[];for(let n of e)t.push(n.shape);return si(t)}function t9(e){return"float32"}function iO(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let a=t.inboundNodes[n];if(a.inboundLayers.length===0)return a.inputTensors;{let r=[];for(let i=0;i<a.inboundLayers.length;i++){let s=a.inputTensors[i],o=a.inboundLayers[i],u=a.nodeIndices[i],d=iO(s,o,u);for(let c of d)r.indexOf(c)===-1&&r.push(c)}return r}}}function n9(e){let t=!0;for(let n of Ln(e))if(!(n instanceof uo)){t=!1;break}return t}function a9(e){let t=!0;for(let n of Ln(e))if(n instanceof uo){t=!1;break}return t}var Pg=class extends sn{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Zv("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new we("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new we("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new we("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let a=new uo(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new oS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new we(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};Pg.className="InputLayer";We.registerClass(Pg);function sO(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new we("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new Pg({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function r9(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return je(t,e.dtype)}catch{throw new we(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var om=class oO{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof oO)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,a){if(this.id2Value[t.id]==null)this.id2Value[t.id]=r9(t,n),this.name2Id[t.name]=t.id,a!=null&&(this.id2Mask[t.id]=a);else throw new we(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof uo){if(this.id2Value[t.id]==null)throw new we(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new we(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof uo){if(this.id2Value[t.id]==null)throw new we(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new we(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Wt(this.id2Mask)}},N1=new JD,R1=new JD;function i9(e){N1!=null&&N1.setMaxEntries(e),R1!=null&&R1.setMaxEntries(e)}function ky(e,t,n,a){let r=n==null?!1:n.training,i=Array.isArray(e),s=i?e:[e],o=s.map(x=>x.name),u=[],d=t.names();for(let x of o)d.indexOf(x)!==-1?u.push(t.getValue(x)):u.push(null);let c=o.join(",")+"|"+t.names().sort().join(","),h=N1.get(c),m;if(h==null){let x=s9(s,t);h=x.sorted,m=x.recipientCounts,N1.put(c,h),R1.put(c,m)}m={},r||Object.assign(m,R1.get(c));let g=new om(t);for(let x=0;x<h.length;++x){let v=h[x],S=v.sourceLayer;if(S instanceof Pg)continue;let E=[],C=[],T=[],N=!1;for(let j of v.inputs){let te=g.getValue(j),Q=g.getMask(j);E.push(te),C.push(Q),Q!=null&&(N=!0),r||(m[j.name]--,m[j.name]===0&&!t.hasKey(j)&&o.indexOf(j.name)===-1&&!te.isDisposed&&j.sourceLayer.stateful!==!0&&T.push(te))}N&&(n=n||{},n.mask=C[0]);let D=Ln(S.apply(E,n)),q=null;S.supportsMasking&&(q=S.computeMask(E,C));let H=l9(v),K=Array.isArray(H)?H:[H];for(let j=0;j<K.length;++j){g.hasKey(K[j])||g.add(K[j],D[j],Array.isArray(q)?q[0]:q);let te=o.indexOf(K[j].name);te!==-1&&(u[te]=D[j])}r||Wt(T)}return g.disposeMasks(),i?u:u[0]}function s9(e,t){O.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],a={};if(e.length===1){let r=GN(e[0],t);n=r.sorted,a=r.recipientMap}else{let r=new Set;for(let i of e){let{sorted:s,recipientMap:o}=GN(i,t);for(let u of s)r.has(u.name)||(n.push(u),r.add(u.name));for(let u in o)a[u]==null&&(a[u]=new Set),o[u].forEach(d=>a[u].add(d))}}return{sorted:n,recipientCounts:o9(a)}}function o9(e){let t={};for(let n in e)t[n]=e[n].size;return t}function GN(e,t){let n=new Set,a=[],r={};for(let o of t.names())n.add(o);let i=[],s=[];for(i.push(e);i.length>0;){let o=i[i.length-1];if(n.has(o.name)){i.pop();continue}let u=s[s.length-1]===i.length-1;if(o.inputs.length===0||u)i.pop(),a.push(o),n.add(o.name),u&&s.pop();else{s.push(i.length-1);for(let d of o.inputs)r[d.name]==null&&(r[d.name]=new Set),r[d.name].add(o.name),!n.has(d.name)&&i.push(d)}}return{sorted:a,recipientMap:r}}function l9(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let a=0;a<e.sourceLayer.inboundNodes.length;++a)for(let r of e.sourceLayer.inboundNodes[a].outputTensors)if(r.id===e.id){n=a;break}t=e.sourceLayer.getOutputAt(n)}return t}var u9=Ae();u9.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,i9);var lO={};qt(lO,{maxNorm:()=>c9,minMaxNorm:()=>h9,nonNeg:()=>p9,unitNorm:()=>d9});function mC(e,t){return be(()=>ur(lt(pe(e,e),t,!0)))}var nw=class extends We.Serializable{getConfig(){return{}}},gC=class extends nw{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return be(()=>{let t=mC(e,this.axis),n=Rr(t,0,this.maxValue);return pe(e,it(n,Oe(Ka(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};gC.className="MaxNorm";We.registerClass(gC);var bC=class extends nw{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return be(()=>it(e,Oe(Ka(),mC(e,this.axis))))}getConfig(){return{axis:this.axis}}};bC.className="UnitNorm";We.registerClass(bC);var yC=class extends nw{apply(e){return zn(e)}};yC.className="NonNeg";We.registerClass(yC);var wC=class extends nw{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return be(()=>{let t=mC(e,this.axis),n=Oe(pe(this.rate,Rr(t,this.minValue,this.maxValue)),pe(1-this.rate,t));return pe(e,it(n,Oe(Ka(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};wC.className="MinMaxNorm";We.registerClass(wC);var KN={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ja(e){return rC(e)}function $N(e,t={}){return Z0(e,We.SerializationMap.getMap().classNameMap,t,"constraint")}function Ya(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in KN?KN[e]:e,config:{}};return $N(t)}else return e instanceof nw?e:$N(e)}function c9(e){return new gC(e)}function d9(e){return new bC(e)}function p9(){return new yC}function h9(e){return new wC(e)}var uO={};qt(uO,{constant:()=>g9,glorotNormal:()=>k9,glorotUniform:()=>S9,heNormal:()=>A9,heUniform:()=>E9,identity:()=>x9,leCunNormal:()=>C9,leCunUniform:()=>I9,ones:()=>m9,orthogonal:()=>_9,randomNormal:()=>y9,randomUniform:()=>b9,truncatedNormal:()=>w9,varianceScaling:()=>v9,zeros:()=>f9});function f9(){return new oC}function m9(){return new eS}function g9(e){return new lC(e)}function b9(e){return new uC(e)}function y9(e){return new cC(e)}function w9(e){return new dC(e)}function x9(e){return new pC(e)}function v9(e){return new di(e)}function S9(e){return new tS(e)}function k9(e){return new nS(e)}function A9(e){return new aS(e)}function E9(e){return new rS(e)}function C9(e){return new iS(e)}function I9(e){return new sS(e)}function _9(e){return new hC(e)}var cO={};qt(cO,{Layer:()=>sn,RNN:()=>cu,RNNCell:()=>rw,activation:()=>iQ,add:()=>fQ,alphaDropout:()=>QQ,average:()=>mQ,averagePooling1d:()=>RI,averagePooling2d:()=>FI,averagePooling3d:()=>DI,avgPool1d:()=>AQ,avgPool2d:()=>CQ,avgPool3d:()=>_Q,avgPooling1d:()=>EQ,avgPooling2d:()=>IQ,avgPooling3d:()=>TQ,batchNormalization:()=>vQ,bidirectional:()=>PQ,categoryEncoding:()=>nZ,centerCrop:()=>eZ,concatenate:()=>gQ,conv1d:()=>jj,conv2d:()=>Qj,conv2dTranspose:()=>Zj,conv3d:()=>Xj,conv3dTranspose:()=>eQ,convLstm2d:()=>UQ,convLstm2dCell:()=>VQ,cropping2D:()=>nQ,dense:()=>sQ,depthwiseConv2d:()=>rQ,dot:()=>xQ,dropout:()=>oQ,elu:()=>Hj,embedding:()=>hQ,flatten:()=>uQ,gaussianDropout:()=>jQ,gaussianNoise:()=>YQ,globalAveragePooling1d:()=>NQ,globalAveragePooling2d:()=>RQ,globalMaxPool1d:()=>GQ,globalMaxPool2d:()=>KQ,globalMaxPooling1d:()=>pM,globalMaxPooling2d:()=>hM,gru:()=>DQ,gruCell:()=>OQ,input:()=>_O,inputLayer:()=>Pj,layerNormalization:()=>SQ,leakyReLU:()=>Kj,lstm:()=>MQ,lstmCell:()=>BQ,masking:()=>ZQ,maxPool1d:()=>$Q,maxPool2d:()=>JQ,maxPooling1d:()=>fM,maxPooling2d:()=>mM,maxPooling3d:()=>FQ,maximum:()=>bQ,minimum:()=>yQ,multiply:()=>wQ,permute:()=>pQ,prelu:()=>$j,randomWidth:()=>aZ,reLU:()=>Gj,repeatVector:()=>cQ,rescaling:()=>XQ,reshape:()=>dQ,resizing:()=>tZ,rnn:()=>WQ,separableConv2d:()=>tQ,simpleRNN:()=>LQ,simpleRNNCell:()=>zQ,softmax:()=>Jj,spatialDropout1d:()=>lQ,stackedRNNCells:()=>qQ,thresholdedReLU:()=>Yj,timeDistributed:()=>HQ,upSampling2d:()=>aQ,zeroPadding2d:()=>kQ});async function sc(e){if(e==null)return;let t=[],n=[],a=[];for(let r in e){let i=e[r];if(typeof i!="number"){let s=i;t.push(s.data()),n.push(r),a.push(s)}}if(t.length>0){let r=await Promise.all(t);for(let i=0;i<r.length;++i)e[n[i]]=r[i][0];Wt(a)}}function dO(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var JN;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(JN||(JN={}));var T9=125,Cm=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},pO=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},N9=class extends Cm{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let a in t){let r=t[a];if(typeof r=="number")this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+r*n;else{let i;a in this.totals?i=this.totals[a]:this.totals[a]=0;let s=be(()=>Oe(this.totals[a],pe(r,n)));this.totals[a]=s,i!=null&&i.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:be(()=>{let a=pe(it(1,this.seen),this.totals[n]);t[n]=a,this.totals[n].dispose(),Ga(t[n])}))}},hO=class extends Cm{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let r in this.history){let i=this.history[r];for(let s=0;s<i.length;++s)if(typeof i[s]!="number"){let o=i[s];e.push(o.data()),t.push(r),n.push(s)}}let a=await Promise.all(e);for(let r=0;r<a.length;++r)this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}},fO=class extends Cm{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||nC,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=T9),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");O.isNumber(this.yieldEvery)&&(this.maybeWait=TY(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let a=[];this.yield!=null&&(await sc(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await sc(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await sc(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await sc(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await sc(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):O.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await sc(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await sc(e),await this.trainEnd(e))}};function mO(e,t){return e==null&&(e={}),e instanceof Cm?[e]:Array.isArray(e)&&e[0]instanceof Cm?e:Ln(e).map(n=>new fO(n,t))}var xC=class Ko{constructor(){}static registerCallbackConstructor(t,n){O.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Ko.checkForDuplicate(n),Ko.constructors[t]==null&&(Ko.constructors[t]=[]),Ko.constructors[t].push(n)}static checkForDuplicate(t){for(let n in Ko.constructors)Ko.constructors[+n].forEach(a=>{if(a===t)throw new we("Duplicate callback constructor.")})}static clear(){Ko.constructors={}}static createCallbacks(t){let n=[];for(let a in Ko.constructors){let r=+a;t>=r&&n.push(...Ko.constructors[r])}return n.map(a=>new a)}};xC.constructors={};function gO(e,t,n,a,r,i,s,o,u){let d=new hO,c=[new N9,...xC.createCallbacks(t)];e!=null&&c.push(...e),c.push(d);let h=new pO(c);return h.setParams({epochs:n,initialEpoch:a,samples:r,steps:i,batchSize:s,verbose:t,doValidation:o,metrics:u}),{callbackList:h,history:d}}function io(e,t={},n=!1){return Z0(e,We.SerializationMap.getMap().classNameMap,t,"layer",n)}function F1(e,t){return be(()=>{e.dtype!=="float32"&&(e=je(e,"float32"));let n=lt(ew(e),t,!0),a=Ni(n.shape,Ka()),r=ur(ul(n,a));return it(e,r)})}function Vh(e,t){return be(()=>ya(ew(at(t,e)),-1))}function lS(e,t){return be(()=>ya(Da(at(t,e)),-1))}function Hg(e,t){return be(()=>{let n=at(e,t),a=Rr(Da(e),Ka(),Number.MAX_VALUE),r=Da(it(n,a));return pe(100,ya(r,-1))})}function R9(e,t){return be(()=>{let n=Rr(t,Ka(),Number.MAX_VALUE),a=Di(Oe(1,n)),r=Rr(e,Ka(),Number.MAX_VALUE),i=Di(Oe(1,r));return ya(ew(at(a,i)),-1)})}function F9(e,t){return be(()=>{let n=ul(0,at(1,pe(e,t)));return ya(ew(n),-1)})}function D9(e,t){return be(()=>{let n=ul(0,at(1,pe(e,t)));return ya(n,-1)})}function O9(e,t){return be(()=>{let n=lt(pe(e,t),-1),a=ns(pe(at(1,e),t),-1);return ul(0,Oe(1,at(a,n)))})}function M9(e,t){return be(()=>{let n=Math.log(2),a=at(t,e),r=at(Oe(a,Lh(pe(-2,a))),n);return ya(r,-1)})}function e0(e,t,n=!1){return be(()=>{if(n)t=qc(t);else{let a=lt(t,t.shape.length-1,!0);t=it(t,a)}return t=Rr(t,Ka(),1-Ka()),ia(lt(pe(je(e,"float32"),Di(t)),t.shape.length-1))})}function D1(e,t,n=!1){return be(()=>{let a=je(zg(WY(e)),"int32");t=Rr(t,Ka(),1-Ka());let r=t.shape,i=ge(xm(a,r[r.length-1]),r);return e0(i,t,n)})}function B9(e,t){if(!O.arraysEqual(e.shape,t.shape))throw new we(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return be(()=>{let n=zn(t),a=ia(Da(t));return Oe(at(n,pe(t,e)),q0(Fr(a)))})}function uS(e,t){return be(()=>{let n;return n=Rr(t,Ka(),1-Ka()),n=Di(it(n,at(1,n))),ya(B9(e,n),-1)})}function L9(e,t){return be(()=>{let n=Rr(e,Ka(),1),a=Rr(t,Ka(),1);return lt(pe(e,Di(it(n,a))),-1)})}function z9(e,t){return be(()=>{let n=Di(Oe(Ka(),t));return ya(at(t,pe(e,n)),-1)})}function vC(e,t){return be(()=>{let n=F1(e,-1),a=F1(t,-1),r=pe(n,a);return ia(lt(r,-1))})}var O1={meanSquaredError:Vh,meanAbsoluteError:lS,meanAbsolutePercentageError:Hg,meanSquaredLogarithmicError:R9,squaredHinge:F9,hinge:D9,categoricalHinge:O9,logcosh:M9,categoricalCrossentropy:e0,sparseCategoricalCrossentropy:D1,binaryCrossentropy:uS,kullbackLeiblerDivergence:L9,poisson:z9,cosineProximity:vC};function nk(e){if(typeof e=="string"){if(e in O1)return O1[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new we(t)}else return e}function SC(e,t){return be(()=>{let n=pe(.5,Oi(t)),a=au(Yr(t,n),e.dtype);return ya(Fi(e,a),-1)})}function kC(e,t){return be(()=>au(Fi(ap(e,-1),ap(t,-1)),"float32"))}function bO(e,t){return be(()=>je(lt(Rs(Fi(e,1),Fi(t,1))),"float32"))}function U9(e,t){return be(()=>je(lt(Rs(Fi(e,1),Fi(t,0))),"float32"))}function V9(e,t){return be(()=>je(lt(Rs(Fi(e,0),Fi(t,1))),"float32"))}function yO(e,t){return be(()=>{let n=bO(e,t),a=V9(e,t),r=Oe(n,a);return je(lr(Yr(r,0),it(n,r),0),"float32")})}function W9(e,t){return be(()=>{let n=bO(e,t),a=U9(e,t),r=Oe(n,a);return je(lr(Yr(r,0),it(n,r),0),"float32")})}function wO(e,t){return uS(e,t)}function xO(e,t){return e.rank===t.rank&&(e=Pc(e,[e.rank-1])),t=ap(t,-1),t.dtype!==e.dtype&&(t=je(t,e.dtype)),je(Fi(e,t),"float32")}function q9(e,t){return be(()=>{let n=e.sub(t).square().sum(),a=e.sub(e.mean()).square().sum();return gt(1).sub(n.div(a))})}var P9=Vh,H9=Vh,G9=lS,K9=lS,$9=Hg,J9=Hg,AC=e0,Y9=vC,vO=D1,M1={binaryAccuracy:SC,categoricalAccuracy:kC,precision:yO,categoricalCrossentropy:AC,sparseCategoricalCrossentropy:vO,mse:P9,MSE:H9,mae:G9,MAE:K9,mape:$9,MAPE:J9,cosine:Y9};function j9(e){if(typeof e=="string"&&e in M1)return M1[e];if(typeof e!="string"&&e!=null)return e;throw new we(`Unknown metric ${e}`)}function Jx(e){if(Qo(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(O1))if(O1[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(M1))if(M1[n]===e){t=n;break}return t!==void 0?t:e.name}}function Q9(e){let t={Adagrad:()=>Bd.adagrad(.01),Adadelta:()=>Bd.adadelta(1,.95,Ka()),Adam:()=>Bd.adam(.001,.9,.999,Ka()),Adamax:()=>Bd.adamax(.002,.9,.999,Ka(),0),RMSProp:()=>Bd.rmsprop(.001,.9,0,Ka()),SGD:()=>Bd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new we(`Unknown Optimizer ${e}`)}function YN(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!Wk(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let a=JSON.stringify(e);a.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${a.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Wk(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!Wk(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!Wk(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function Z9(e,t,n,a=console.log){let r=ej(e),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let s;if(!r){i.push("Receives inputs"),s=[];for(let c in e.nodesByDepth)s.push(...e.nodesByDepth[c])}a("_".repeat(t)),B1(i,n,a),a("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)r?tj(o[c],n,a):nj(o[c],n,s,a),a((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let u=X9(e),d=T1(e.nonTrainableWeights);a(`Total params: ${u+d}`),a(`Trainable params: ${u}`),a(`Non-trainable params: ${d}`),a("_".repeat(t))}function X9(e){let t;return e.collectedTrainableWeights!=null?t=T1(e.collectedTrainableWeights):t=T1(e.trainableWeights),t}function ej(e){let t=!0,n=[],a=[];for(let r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(let r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(let r of e.layers){let i=!1;for(let s of r.inboundNodes)if(a.indexOf(s)!==-1)if(i){t=!1;break}else i=!0;if(!t)break}return t}function B1(e,t,n=console.log){let a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function tj(e,t,n){let a,r;try{r=e.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{r="multiple"}try{a=JSON.stringify(e.outputShape)}catch{a="multiple"}let i=e.name,s=e.getClassName(),o=[`${i} (${s})`,r,a,e.countParams().toString()];B1(o,t,n)}function nj(e,t,n,a){let r,i;try{i=e.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let s=[];for(let h of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(h)===-1))for(let m=0;m<h.inboundLayers.length;++m){let g=h.inboundLayers[m].name,x=h.nodeIndices[m],v=h.tensorIndices[m];s.push(`${g}[${x}][${v}]`)}let o=e.name,u=e.getClassName(),d=s.length===0?"":s[0],c=[`${o} (${u})`,i,r,e.countParams().toString(),d];B1(c,t,a);for(let h=1;h<s.length;++h)B1(["","","","",s[h]],t,a)}function SO(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function t0(e,t){if(e===null)return null;if(typeof e=="string")return Vd(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let i=e[r];SO(t,r,i)?n.push(i):n.push(t0(i,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a];if(a==="name"&&typeof r=="string")n[a]=r;else{let i=Vd(a);n[i]=t0(r,i)}}return n}}function qk(e,t){if(e==null)return null;if(typeof e=="string")return $l(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let i=e[r];SO(t,r,i)?n.push(i):n.push(qk(i,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a],i=$l(a);(a==="name"||a==="className")&&typeof r=="string"?n[i]=r:n[i]=qk(r,a)}return n}}var EC="4.22.0",aj=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},rj=class $o extends sn{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let C=this.getClassName().toLowerCase();this.name=Zv(C)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],gc(this.inputs).length!==this.inputs.length)throw new we(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(C=>C.name)}`);gc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(C=>C.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let C of this.outputs){let T=C.sourceLayer,N=C.nodeIndex,D=C.tensorIndex;this.outputLayers.push(T),this.outputLayersNodeIndices.push(N),this.outputLayersTensorIndices.push(D)}for(let C of this.inputs){let T=C.sourceLayer,N=C.nodeIndex,D=C.tensorIndex;Qo(N===0,"input layer has >1 nodes"),Qo(D===0,"input layer has >1 tensors"),this.inputLayers.push(T),this.inputLayersNodeIndices.push(N),this.inputLayersTensorIndices.push(D)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let C=0;C<this.inputLayers.length;C++){let T=this.inputLayers[C];if(!(T instanceof Pg))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${C} (0-based) originates from layer type ${T.getClassName()}.`);this.inputNames.push(T.name),this.feedInputShapes.push(T.batchInputShape),this.feedInputNames.push(T.name)}for(let C of this.outputLayers)this.outputNames.push(C.name);this.internalInputShapes=this.inputs.map(C=>C.shape),this.internalOutputShapes=this.outputs.map(C=>C.shape);let n={},a={},r={},i={},s={},o=[],u=(C,T,N,D,q,H)=>{(D==null||q==null||H==null)&&(D=C.sourceLayer,q=C.nodeIndex,H=C.tensorIndex);let K=D.inboundNodes[q];if(N.indexOf(K)!==-1)throw new Xo(`The tensor ${C.name} at layer "${D.name}" is part of a cycle.`);if(T.indexOf(K)!==-1)return;this.containerNodes.add($o.nodeKey(D,q)),D.id in s||(s[D.id]=Object.keys(s).length),N.indexOf(K)===-1&&N.push(K);let j=K.inboundLayers.length;for(let te=0;te<j;te++){let Q=K.inputTensors[te],z=K.inboundLayers[te],ae=K.nodeIndices[te],ue=K.tensorIndices[te];u(Q,T,N,z,ae,ue)}for(T.push(K);N.indexOf(K)>=0;)N.splice(N.indexOf(K),1);o.push(K)},d=[],c=[];for(let C of this.outputs)u(C,d,c);let h=o.slice().reverse();for(let C of h){a[C.id]=C,C.id in n||(n[C.id]=0);let T=n[C.id],N=r[C.outboundLayer.id]==null?0:r[C.outboundLayer.id];T=Math.max(T,N),r[C.outboundLayer.id]=T,i[C.outboundLayer.id]=C.outboundLayer,n[C.id]=T;for(let D=0;D<C.inboundLayers.length;D++){let q=C.inboundLayers[D],H=C.nodeIndices[D],K=q.inboundNodes[H],j=n[K.id]==null?0:n[K.id];n[K.id]=Math.max(T+1,j),a[K.id]=K}}let m={};for(let C in n){let T=n[C];T in m||(m[T]=[]),m[T].push(a[C])}let g={};for(let C in r){let T=r[C];T in g||(g[T]=[]),g[T].push(i[C])}let x=Object.keys(g).map(C=>parseInt(C,10)).sort(Gx);this.layers=[];for(let C of x){let T=g[C];T.sort((N,D)=>{let q=s[N.id],H=s[D.id];return q<H?-1:q>H?1:0});for(let N of T)N instanceof $o&&this.internalContainerRefs.push(N),this.layers.push(N)}this.layersByDepth=g,x=Object.keys(m).map(C=>parseInt(C,10)).sort(Gx);let v=this.inputs.slice(),S=[];for(let C of x)for(let T of m[C]){let N=T.outboundLayer;if(N!=null){for(let D of T.inputTensors)if(v.indexOf(D)===-1)throw new Xo(`Graph disconnected: cannot obtain value for tensor ${D} at layer "${N.name}". The following previous layers were accessed without issue: ${S}`);for(let D of T.outputTensors)v.push(D);S.push(N.name)}}this.nodesByDepth=m;let E=this.layers.map(C=>C.name);for(let C of E){let T=E.filter(N=>N===C).length;if(T!==1)throw new Xo(`The name "${C}" is used ${T} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(E))}this.outboundNodes=[],this.inboundNodes=[],new oS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(C=>null),outputMasks:this.outputs.map(C=>null),inputShapes:this.inputs.map(C=>C.shape),outputShapes:this.outputs.map(C=>C.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(a=>a.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new we("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let a of this.layers)n.push(...a.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let a={},r=0,i=aj(t);i&&this.parseWeights(t);for(let o of this.layers)for(let[u,d]of o.weights.entries()){let c=i?`${d.name.split("/").slice(0,-1).join("/")+"/"}${u}`:d.originalName;if(a[c]!=null)throw new we(`Duplicate weight name: ${c}`);a[c]=d,r++}let s=[];for(let o in t){let u=o;if(a[o]==null){let d=o.split("/");u=d.slice(0,-2).concat([d[d.length-1]]).join("/")}if(a[u]!=null)s.push([a[u],t[o]]);else if(n)throw new we(`Provided weight data has no target variable: ${o}`);delete a[u]}if(n){let o=[];for(let u in a)o.push(u);if(o.length>0)throw new we(`${o.length} of ${r} weights are not set: ${o}`)}fC(s)}parseWeights(t){for(let n in Object.keys(t)){let a=n.split("/"),r=["vars","layer_checkpoint_dependencies"],i=a.map(s=>s.startsWith("_")?s.slice(1):s).filter(s=>!r.includes(s)).join("/");i!==n&&(t[i]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${EC}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let a=qk(this.updatedConfig());return n?JSON.stringify(a):a}call(t,n){return be(()=>{t=Ln(t);let a=new om;for(let r=0;r<this.inputs.length;++r)a.add(this.inputs[r],t[r]);return ky(this.outputs,a,n)})}computeMask(t,n){return be(()=>{t=Ln(t);let a;return n==null?a=lp(null,t.length):a=Ln(n),this.runInternalGraph(t,a)[1]})}computeOutputShape(t){let n=_1(t);if(n.length!==this.inputLayers.length)throw new we(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let a={};for(let o=0;o<n.length;o++){let u=this.inputLayers[o],d=n[o],c=u.name+"_0_0";a[c]=d}let r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Gx);if(r.length>1)for(let o of r){let u=this.nodesByDepth[o];for(let d of u){let c=d.outboundLayer;if(this.inputLayers.map(v=>v.id).indexOf(c.id)!==-1)continue;let h=[];for(let v=0;v<d.inboundLayers.length;v++){let S=d.inboundLayers[v],E=d.nodeIndices[v],C=d.tensorIndices[v],T=`${S.name}_${E}_${C}`,N=a[T];h.push(N)}let m=c.computeOutputShape(si(h)),g=_1(m),x=c.inboundNodes.indexOf(d);for(let v=0;v<g.length;v++){let S=`${c.name}_${x}_${v}`;a[S]=g[v]}}}let i=[],s=[];for(let o=0;o<this.outputLayers.length;o++){let u=this.outputLayers[o],d=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],h=`${u.name}_${d}_${c}`;s.push(h)}for(let o=0;o<s.length;o++){let u=s[o];Qo(u in a),i.push(a[u])}return si(i)}runInternalGraph(t,n){n==null&&(n=lp(null,t.length));let a={};for(let u=0;u<this.inputs.length;++u){let d=this.inputs[u],c=t[u],h=n[u];a[d.id]=[c,h]}let r=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Gx);for(let u of r){let d=this.nodesByDepth[u];for(let c of d){let h=c.outboundLayer,m=c.inputTensors,g=c.outputTensors,x=new Array;for(let v of m)v.id in a&&x.push(a[v.id]);if(x.length===m.length){let v={},S,E,C,T;if(c.callArgs!=null&&(v=c.callArgs),x.length===1){let[N,D]=x[0];v.mask==null&&(v.mask=D),C=Ln(h.call(N,v)),T=Ln(h.computeMask(N,D)),S=[N],E=[D]}else S=x.map(N=>N[0]),E=x.map(N=>N[1]),v.mask==null&&(v.mask=E),C=Ln(h.call(S,v)),T=Ln(h.computeMask(S,E));if(h.activityRegularizer)throw new rn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let N=0;N<g.length;++N){let D=g[N],q=C[N],H=T[N];a[D.id]=[q,H]}}}}let i=[],s=[],o=[];for(let u of this.outputs){Qo(u.id in a,`Could not compute output ${u.name} : ${u.id}`);let[d,c]=a[u.id];o.push(d.shape),i.push(d),s.push(c)}return[i,s,o]}buildNodeConversionMap(t){let n={},a;for(let r of this.layers){a=r instanceof $o?1:0;for(let i=0;i<r.inboundNodes.length;i++){let s=$o.nodeKey(r,i);this.containerNodes.has(s)&&(n[s]=a,a+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new we("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let a of this.layers)if(a.name===t)return a;throw new we(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new we(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return be(()=>{let t=[];for(let n of this.layers)for(let a=0;a<n.inboundNodes.length;++a){let r=$o.nodeKey(n,a);this.containerNodes.has(r)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),a=[];for(let s of this.layers){let o=s.getClassName(),u=s.getConfig(),d=[];for(let h=0;h<s.inboundNodes.length;h++){let m=s.inboundNodes[h],g=$o.nodeKey(s,h),x={};if(this.containerNodes.has(g)){if(m.callArgs)try{JSON.stringify(m.callArgs),x=m.callArgs}catch{console.warn(`Layer ${s.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),x={}}if(m.inboundLayers.length>0){let v=[];for(let S=0;S<m.inboundLayers.length;S++){let E=m.inboundLayers[S],C=m.nodeIndices[S],T=m.tensorIndices[S],N=$o.nodeKey(E,C),D=n[N];D==null&&(D=0),v.push([E.name,D,T,x])}d.push(v)}}}let c={};c.name=s.name,c.className=o,c.config=u,c.inboundNodes=d,a.push(c)}t.layers=a;let r=[];for(let s=0;s<this.inputLayers.length;s++){let o=this.inputLayers[s],u=this.inputLayersNodeIndices[s],d=$o.nodeKey(o,u);if(!this.containerNodes.has(d))continue;let c=n[d];c==null&&(c=0);let h=this.inputLayersTensorIndices[s];r.push([o.name,c,h])}t.inputLayers=r;let i=[];for(let s=0;s<this.outputLayers.length;s++){let o=this.outputLayers[s],u=this.outputLayersNodeIndices[s],d=$o.nodeKey(o,u);if(!this.containerNodes.has(d))continue;let c=n[d];c==null&&(c=0);let h=this.outputLayersTensorIndices[s];i.push([o.name,c,h])}return t.outputLayers=i,t}static fromConfig(t,n,a={},r=!1){let i={},s={};function o(S,E){S.name in s?s[S.name].push(E):s[S.name]=[E]}function u(S,E){let C=[],T;for(let N of E){let D=N[0],q=N[1],H=N[2];if(T=N[3]==null?{}:N[3],!(D in i)){o(S,E);return}let K=i[D];if(K.inboundNodes.length<=q){o(S,E);return}let j=K.inboundNodes[q];C.push(j.outputTensors[H])}C.length>0&&S.apply(si(C),T)}function d(S){let E=S.name,C=io(S,n.customObjects!=null?n.customObjects:{});C.setFastWeightInitDuringBuild(r),i[E]=C,S.inboundNodes.forEach(T=>{if(!(T instanceof Array))throw new we(`Corrupted configuration, expected array for nodeData: ${T}`);o(C,T)})}let c=n.name,h=n.layers;for(let S of h)d(S);for(;!_Y(s);)for(let S of h){let E=i[S.name];if(E.name in s){let C=s[E.name];delete s[E.name];for(let T of C)u(E,T)}}let m=[],g=[],x=n.inputLayers;for(let S of x){let E=S[0],C=S[1],T=S[2];Qo(E in i);let N=i[E].inboundNodes[C].outputTensors;m.push(N[T])}let v=n.outputLayers;for(let S of v){let E=S[0],C=S[1],T=S[2];Qo(E in i);let N=i[E].inboundNodes[C].outputTensors;g.push(N[T])}return new t({inputs:m,outputs:g,name:c})}get stateful(){if(this._stateful)throw new we("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){be(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function ij(e,t,n){let a=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>null);if(a===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${a} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let r=[];return t.forEach(i=>{i in e?r.push(e[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${a}) outputs, so ${n} must be either an array with ${a} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function kO(e,t){return ij(e,t,"classWeight")}async function AO(e,t,n,a){if(n!=null){let r=be(()=>{if(e.shape.length===1)return tl(e);if(e.shape.length===2){if(e.shape[1]>1)return ap(e,1);if(e.shape[1]===1)return ge(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());Wt(r);let s=[];return i.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);s.push(n[o])}),Dn(s,"float32")}else return null}function sj(e,t){return pe(e,t)}var oj=32;function EO(e,t){let n,a,r=t;n=r.xs,a=r.ys,O.assert(n!=null&&a!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let i=jN("input",e.inputNames,n),s=jN("output",e.outputNames,a),o=i[0].shape[0];O.assert(i.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),O.assert(s.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${s.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let u=0;u<i.length;u++)O.assert(i[u].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[u]} has ${i[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let u=0;u<s.length;u++)O.assert(s[u].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[u]} has ${s[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:i,ys:s}}function jN(e,t,n){if(n instanceof $t)return[n];if(Array.isArray(n))return O.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let a=[];for(let r of t){if(n[r]==null)throw new we(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);a.push(n[r])}return a}}function lj(e){if(e.length===3)throw new rn("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function uj(e,t,n){let a=n.batchesPerEpoch!=null;if(O.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),O.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),O.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),O.assert(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),O.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let r=n.validationData!=null,i,s;if(r)if(QN(n.validationData))O.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let S=lj(n.validationData);i=S.xs,s=S.ys}let o=e.makeTrainFunction(),u=e.getDedupedMetricsNames(),d;r?d=u.slice().concat(u.map(S=>"val_"+S)):d=u.slice();let c=mO(n.callbacks,n.yieldEvery),h=n.verbose==null?1:n.verbose,{callbackList:m,history:g}=gO(c,h,n.epochs,null,null,cj(t,n),null,r,d);m.setModel(e),e.history=g,await m.onTrainBegin(),e.stopTraining_=!1;let x=n.initialEpoch==null?0:n.initialEpoch,v=await t.iterator();for(;x<n.epochs;){let S={};await m.onEpochBegin(x);let E=0,C=0;for(a||(v=await t.iterator());!a||E<n.batchesPerEpoch;){let T=await v.next();if(a&&T.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${E} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(T.value!=null){let{xs:N,ys:D}=EO(e,T.value),q={};q.batch=C,q.size=N[0].shape[0],await m.onBatchBegin(C,q);let H=[];if(n.classWeight!=null){let te=kO(n.classWeight,e.outputNames);for(let Q=0;Q<te.length;++Q)H.push(await AO(D[Q],null,te[Q]))}let K=N.concat(D).concat(H),j=o(K);Wt(K);for(let te=0;te<u.length;++te){let Q=u[te],z=j[te];q[Q]=z,Ga(z)}await m.onBatchEnd(C,q),dO(q),C++,E++}if(a?E>=n.batchesPerEpoch:T.done){if(r){let N;QN(n.validationData)?N=Ln(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):N=Ln(e.evaluate(i,s,{batchSize:n.validationBatchSize==null?oj:n.validationBatchSize,verbose:0}));for(let D=0;D<e.metricsNames.length;++D)S[`val_${e.metricsNames[D]}`]=N[D]}break}if(e.stopTraining_)break}if(await m.onEpochEnd(x,S),x++,e.stopTraining_)break}return await m.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function cj(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function QN(e){return typeof e.iterator=="function"}function dj(e){return typeof e.next=="function"}async function pj(e,t,n){n=n||{};let a=n.batches!=null,r=e.testFunction,i=[];if(n.verbose>0)throw new rn("Verbose mode is not implemented yet.");O.assert(!a||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let s=dj(t)?t:await t.iterator(),o=0,u=0;for(;!a||u<n.batches;){let d=await s.next();if(i=be(()=>{if(d.value){let{xs:c,ys:h}=EO(e,d.value),m=c.concat(h),g=be(()=>r(m));if(Wt(m),u===0)for(let v=0;v<g.length;++v)i.push(gt(0));let x=m[0].shape[0];for(let v=0;v<g.length;++v){let S=g[v],E=i[v];i[v]=be(()=>Oe(i[v],pe(x,S))),u>0&&Wt(E)}Wt(g),o+=x,++u}return i}),d.done){a&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let d=0;d<i.length;++d){let c=i[d];i[d]=it(i[d],o),Wt(c)}return si(i)}function ak(e){O.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function my(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(a=>$d(a,t,n-t)):$d(e,t,n-t)}function Pk(e,t){return be(()=>e==null?null:Array.isArray(e)?e.map(n=>Pk(n,t)):nO(e,t.dtype==="int32"?t:je(t,"int32")))}function rk(e,t){let n=[],a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function CO(e){let t=[];e instanceof $t&&(e=[e]);for(let n=0;n<e.length;++n){let a=e[n];if(a.rank===1)t.push(X0(a,1));else{if(a.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function Xs(e,t){if(e==null)return;let n=[];if(t instanceof $t)n.push(t.id);else if(Array.isArray(t))t.forEach(r=>n.push(r.id));else if(t!=null)for(let r in t){let i=t[r];n.push(i.id)}let a=[];if(e instanceof $t)n.indexOf(e.id)===-1&&a.push(e);else if(Array.isArray(e))e.forEach(r=>{n.indexOf(r.id)===-1&&a.push(r)});else if(e!=null)for(let r in e){let i=e[r];n.indexOf(i.id)===-1&&a.push(i)}a.forEach(r=>{r.isDisposed||r.dispose()})}function hj(e){return e instanceof $t}function Hk(e){return Array.isArray(e)}function ZN(e){return!hj(e)&&!Hk(e)}function XN(e,t,n,a=!0,r=""){if(t==null||t.length===0){if(e!=null){let s=!1;if(Hk(e)&&e.length>0)s=!0;else if(ZN(e)){for(let o in e)if(e.hasOwnProperty(o)){s=!0;break}}else s=!0;if(s)throw new we(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(s=>null);let i;if(ZN(e)){e=e,i=[];for(let s of t){if(e[s]==null)throw new we(`No data provided for "${s}". Need data for each key in: ${t}`);i.push(e[s])}}else if(Hk(e)){if(e=e,e.length!==t.length)throw new we(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);i=e}else{if(e=e,t.length>1)throw new we(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);i=[e]}if(i=CO(i),n!=null)for(let s=0;s<t.length;++s){if(n[s]==null)continue;let o=i[s];if(o.shape.length!==n[s].length)throw new we(`Error when checking ${r}: expected ${t[s]} to have ${n[s].length} dimension(s). but got array with shape ${o.shape}`);for(let u=0;u<n[s].length;++u){if(u===0&&!a)continue;let d=o.shape[u],c=n[s][u];if(c!=null&&c>=0&&d!==c)throw new we(`${r} expected a batch of elements where each example has shape [${n[s].slice(1,n[s].length)}] (i.e.,tensor shape [*,${n[s].slice(1,n[s].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return i}function fj(e,t,n){let a=gc(e.map(i=>i.shape[0]));a.sort();let r=gc(t.map(i=>i.shape[0]));if(r.sort(),a.length>1)throw new we(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(r.length>1)throw new we(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(a.length>0&&r.length>0&&!O.arraysEqual(a,r))throw new we(`Input Tensors should have the same number of samples as target Tensors. Found ${a[0]} input sample(s) and ${r[0]} target sample(s).`)}function mj(e,t,n){let a=[Vh,uS,e0];for(let r=0;r<e.length;++r){let i=e[r],s=t[r],o=n[r];if(s!=null){if(s===e0&&i.shape[i.shape.length-1]===1)throw new we(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(a.indexOf(s)!==-1){let u=i.shape.slice(1),d=o.slice(1);for(let c=0;c<u.length;++c){let h=u[c],m=d[c];if(m!=null&&h!==m)throw new we(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function eR(e,t,n,a=!0,r=""){let i;if(Array.isArray(e)){if(e.length!==t.length)throw new we(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);i=e}else{if(t.length>1)throw new we(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);i=[e]}if(n!=null)for(let s=0;s<t.length;++s){if(n[s]==null)continue;let o=i[s];if(o.shape.length!==n[s].length)throw new we(`Error when checking ${r}: expected ${t[s]} to have ${n[s].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let u=0;u<n[s].length;++u){if(u===0&&!a)continue;let d=o.shape[u],c=n[s][u];if(c!=null&&c!==d)throw new we(`Error when checking ${r}: expected ${t[s]} to have shape ${JSON.stringify(n[s])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function gj(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(a=>n);{let a=[];for(let r of t){let i=n.hasOwnProperty(r)?n[r]:[];Array.isArray(i)||(i=[i]),a.push(i)}return a}}var bj="layers-model",eu=class extends rj{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new we("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Z9(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Q9(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof uu))throw new we("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let i in e.loss)if(this.outputNames.indexOf(i)===-1)throw new we(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(let i of this.outputNames)e.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),t.push(nk(e.loss[i]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new we(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(i=>nk(i))}else{let i=nk(e.loss);this.outputs.forEach(s=>{t.push(i)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let s=this.internalOutputShapes[i],o=this.outputNames[i];this.feedOutputNames.push(o),this.feedOutputShapes.push(s),this.feedLossFns.push(this.lossFunctions[i])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Kd("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let s=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([s,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});let a=gj(e.metrics,this.outputNames),r=(i,s,o)=>{this.outputNames.length>1&&(s=this.outputNames[i]+"_"+s),this.metricsNames.push(s),this.metricsTensors.push([o,i])};Kd("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let s=a[i];(o=>{let u="",d,c,h;for(let m of o){if(typeof m=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(m)!==-1){let x=this.internalOutputShapes[i];x[x.length-1]===1||this.lossFunctions[i]===uS?["accuracy","acc"].indexOf(m)!==-1?c=SC:["crossentropy","ce"].indexOf(m)!==-1&&(c=wO):this.lossFunctions[i]===D1?["accuracy","acc"].indexOf(m)!==-1?c=xO:["crossentropy","ce"].indexOf(m)!==-1&&(c=vO):["accuracy","acc"].indexOf(m)!==-1?c=kC:["crossentropy","ce"].indexOf(m)!==-1&&(c=AC);let v;["accuracy","acc"].indexOf(m)!==-1?v="acc":["crossentropy","ce"].indexOf(m)!==-1&&(v="ce"),h=c,d=u+v}else h=j9(m),d=u+Jx(m);let g;Kd(d,()=>{g=h}),r(i,d,g)}})(s)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let a=n.batchSize==null?32:n.batchSize;ak(a);let r=this.standardizeUserDataXY(e,t,!0,a);try{let i=r[0].concat(r[1]);this.makeTestFunction();let s=this.testFunction,o=this.testLoop(s,i,a,n.verbose,n.steps);return si(o)}finally{Xs(r[0],e),Xs(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),pj(this,e,t)}checkNumSamples(e,t,n,a="steps"){let r;if(n!=null){if(r=null,t!=null)throw new we(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new we(`Either the input data should have a defined shape, or ${a} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new we("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),i=new om;if(e instanceof $t&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new we(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)i.add(this.inputs[o],e[o])}else for(let o of this.inputs){let u=e[o.name];if(u==null)throw new we(`No value is provided for the model's input ${o.name}`);i.add(o,u)}let s=ky(r,i);return n?s:s[0]}retrieveSymbolicTensors(e){let t=lp(null,e.length),n=e.length;for(let a of this.layers){let r=Array.isArray(a.output)?a.output:[a.output],i=r.map(s=>s.name);for(let s=0;s<e.length;++s){let o=i.indexOf(e[s]);if(o!==-1&&(t[s]=r[o],n--),n===0)break}if(n===0)break}if(n>0){let a=[];throw t.forEach((r,i)=>{r==null&&a.push(e[i])}),new we(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(a)}`)}return t}predictLoop(e,t=32,n=!1){return be(()=>{let a=this.checkNumSamples(e);if(n)throw new rn("Verbose predictLoop() is not implemented yet.");let r=rk(a,t),i=this.outputs.map(s=>[]);for(let s=0;s<r.length;++s)be(()=>{let o=r[s][0],u=r[s][1],d=my(e,o,u),c=[];if(Array.isArray(d))for(let m=0;m<d.length;++m)c.push({key:this.inputs[m],value:d[m]});else c.push({key:this.inputs[0],value:d});let h=new om(c);return ky(this.outputs,h)}).forEach((o,u)=>i[u].push(o));return si(i.map(s=>Gn(s,0)))})}predict(e,t={}){let n=CO(e);eR(n,this.inputNames,this.feedInputShapes,!1);try{let a=t.batchSize==null?32:t.batchSize;return ak(a),this.predictLoop(n,a)}finally{Xs(n,e)}}predictOnBatch(e){eR(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,a){if(this.optimizer_==null)throw new Xo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let r=[];for(let i=0;i<this.feedOutputShapes.length;++i){let s=this.feedOutputShapes[i];this.feedLossFns[i]===D1?r.push(s.slice(0,s.length-1).concat([1])):r.push(s)}if(e=XN(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=XN(t,this.feedOutputNames,r,!1,"target"),fj(e,t),mj(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&a!=null&&a>0&&e[0].shape[0]%a!==0)throw new we(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${a}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,a,r=!0,i){let[s,o]=this.standardizeUserDataXY(e,t,r,i);if(n!=null)throw new Error("sample weight is not supported yet.");let u=null;if(a!=null){let d=kO(a,this.outputNames);u=[];for(let c=0;c<d.length;++c)u.push(await AO(o[c],null,d[c]))}return[s,o,u]}testLoop(e,t,n,a=0,r){return be(()=>{let i=this.checkNumSamples(t,n,r,"steps"),s=[];if(a>0)throw new rn("Verbose mode is not implemented yet.");if(r!=null)throw new rn("steps mode in testLoop() is not implemented yet");{let o=rk(i,n),u=Dn(oo(0,i));for(let d=0;d<o.length;++d){let c=o[d][0],h=o[d][1],m=$d(u,c,h-c),g=Pk(t,m),x=e(g);if(d===0)for(let v=0;v<x.length;++v)s.push(gt(0));for(let v=0;v<x.length;++v){let S=x[v];s[v]=Oe(s[v],pe(h-c,S))}}for(let d=0;d<s.length;++d)s[d]=it(s[d],i)}return s})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let a=e[n],r=a;if(UN(e,a)>1){let i=UN(e.slice(0,n),a);r+=`_${i}`}t.push(r)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],s=()=>{let u=[];for(let m=0;m<this.inputs.length;++m)u.push({key:this.inputs[m],value:n[m]});let d=new om(u),c=ky(this.outputs,d,{training:!0}),h;for(let m=0;m<this.lossFunctions.length;++m){let g=this.lossFunctions[m],x=g(a[m],c[m]);r[m]!=null&&(x=sj(x,r[m]));let v=ya(x);t.push(v),m===0?h=x:h=Oe(h,x)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=t[m];else{let x=this.metricsTensors[m][0],v=this.metricsTensors[m][1];g=ya(x(a[v],c[v]))}Ga(g),i.push(g)}return h=ya(h),this.calculateLosses().forEach(m=>{h=Oe(h,m)}),h},o=this.collectedTrainableWeights.map(u=>u.read());return[this.optimizer_.minimize(s,!0,o)].concat(i)}}makeTestFunction(){this.testFunction=e=>be(()=>{let t=[],n,a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let u=0;u<this.inputs.length;++u)i.push({key:this.inputs[u],value:a[u]});let s=new om(i),o=ky(this.outputs,s);for(let u=0;u<this.lossFunctions.length;++u){let d=this.lossFunctions[u],c=ya(d(r[u],o[u]));u===0?n=c:n=Oe(n,c),t.push(n)}for(let u=0;u<this.metricsTensors.length;++u){let d=this.metricsTensors[u][0],c=this.metricsTensors[u][1],h=ya(d(r[c],o[c]));t.push(h)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let a,r,i,s,o,u,d,c,h;try{let m=n.batchSize==null?32:n.batchSize;ak(m);let g=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,m);a=g[0],r=g[1],h=g[2];let x=!1,v;if(n.validationData!=null&&n.validationData.length>0){if(x=!0,n.validationData.length===2)o=n.validationData[0],u=n.validationData[1];else throw n.validationData.length===3?new rn("validationData including sample weights is not supported yet."):new we(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let q=await this.standardizeUserData(o,u,null,null,!0,m);d=q[0],c=q[1],v=d.concat(c)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){x=!0;let q=Math.floor(a[0].shape[0]*(1-n.validationSplit)),H=a[0].shape[0];d=my(a,q,H),i=a,a=my(a,0,q),c=my(r,q,H),s=r,r=my(r,0,q),v=d.concat(c)}else n.validationSteps!=null&&(x=!0);let S=a.concat(r).concat(h);this.checkTrainableWeightsConsistency();let E=this.makeTrainFunction(),C=this.getDedupedMetricsNames(),T,N;x?(this.makeTestFunction(),T=this.testFunction,N=C.slice().concat(C.map(q=>"val_"+q))):(T=null,v=[],N=C.slice());let D=mO(n.callbacks,n.yieldEvery);return await this.fitLoop(E,S,C,m,n.epochs,n.verbose,D,T,v,n.shuffle,N,n.initialEpoch,null,null)}finally{this.isTraining=!1,Xs(a,e),Xs(r,t),Xs(i,e),Xs(s,t),Xs(d,o),Xs(c,u),h!=null&&Wt(h)}}async fitLoop(e,t,n,a,r,i,s,o,u,d,c,h,m,g){a==null&&(a=32),r==null&&(r=1),d==null&&(d=!0),h==null&&(h=0);let x=!1;if(o!=null&&u!=null&&(x=!0),g!=null&&(x=!0,m==null))throw new we("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let v=this.checkNumSamples(t,a,m,"steps_per_epoch"),S;v!=null&&(S=oo(0,v)),i==null&&(i=1);let{callbackList:E,history:C}=gO(s,i,r,h,v,m,a,x,c);E.setModel(this),this.history=C,await E.onTrainBegin(),this.stopTraining_=!1;for(let T=h;T<r;++T){await E.onEpochBegin(T);let N={};if(m!=null)throw new rn("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new rn("batch shuffling is not implemneted yet");d&&O.shuffle(S);let D=Dn(S),q=rk(v,a);for(let H=0;H<q.length;++H){let K={};if(await E.onBatchBegin(H,K),be(()=>{let j=q[H][0],te=q[H][1],Q=$d(D,j,te-j);K.batch=H,K.size=te-j;let z=Pk(t,Q),ae=e(z);for(let ue=0;ue<n.length;++ue){let he=n[ue],Z=ae[ue];K[he]=Z,Ga(Z)}if(H===q.length-1&&x){let ue=this.testLoop(o,u,a);for(let he=0;he<n.length;++he){let Z=n[he],se=ue[he];Ga(se),N["val_"+Z]=se}}}),await E.onBatchEnd(H,K),dO(K),this.stopTraining_)break}D.dispose()}if(await E.onEpochEnd(T,N),this.stopTraining_)break}return await E.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return uj(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),a=n[0],r=n[1],i=this.makeTrainFunction()(a.concat(r)),s=[];for(let o of i){let u=await o.data();s.push(u[0])}return Wt(i),Xs(n[0],e),Xs(n[1],t),si(s)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let i=0;i<a.length;++i)n&&!a[i].trainable||t.push({name:a[i].originalName,tensor:r[i]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=Ek().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Ek().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=$l(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>$l(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let a of t)if(typeof n[a]=="string")e[a]=$l(n[a]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[$l(Jx(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>$l(Jx(e)));{let e={};for(let t in this.metrics)e[t]=$l(Jx(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=t0(e.optimizer_config),n=io(t),a;if(typeof e.loss=="string")a=Vd(e.loss);else if(Array.isArray(e.loss))a=e.loss.map(i=>Vd(i));else if(e.loss!=null){a={};for(let i in e.loss)a[i]=Vd(e.loss[i])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(i=>Vd(i));else if(e.metrics!=null){r={};for(let i in e.metrics)r[i]=Vd(e.metrics[i])}this.compile({loss:a,metrics:r,optimizer:n})}async save(e,t){if(typeof e=="string"){let r=xr.getSaveHandlers(e);if(r.length===0)throw new we(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new we(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new we("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await xr.encodeWeights(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:bj,generatedBy:`TensorFlow.js tfjs-layers v${EC}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let r="optimizer",{data:i,specs:s}=await xr.encodeWeights(await this.optimizer.getWeights(),r);n.specs.push(...s),n.data=xr.concatenateArrayBuffers([n.data,i])}return this.userDefinedMetadata!=null&&(YN(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){YN(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};eu.className="Model";We.registerClass(eu);var IO=class extends eu{};IO.className="Functional";We.registerClass(IO);async function yj(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let a=t0(n),r=io(a,t);if(e.weightsManifest!=null){let i=await xr.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map(o=>o.originalName)),s={};for(let o of r.weights)s[o.originalName]=i[o.originalName];r.loadWeights(s),Wt(i)}return r}async function wj(e,t){if(t==null&&(t={}),typeof e=="string"){let n=xr.getLoadHandlers(e,t);if(n.length===0)n.push(xr.browserHTTPRequest(e,t));else if(n.length>1)throw new we(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return xj(e,void 0,t)}async function xj(e,t,n){if(n==null&&(n={}),e.load==null)throw new we("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let a=await e.load(),r=a.modelTopology;r.model_config!=null&&(r=r.model_config);let i=n.strict==null?!0:n.strict,s=a.weightData!=null&&a.weightSpecs!=null&&i,o=io(t0(r),t,s),u=a.trainingConfig;if(u!=null&&o.loadTrainingConfig(u),a.userDefinedMetadata!=null&&o.setUserDefinedMetadata(a.userDefinedMetadata),a.weightData!=null){if(a.weightSpecs==null)throw new we("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:d,optimizerWeights:c}=vj(a.weightData,a.weightSpecs);o.loadWeights(d,i),o.optimizer!=null&&c.length>0&&await o.optimizer.setWeights(c),Wt(d),Wt(c.map(h=>h.tensor))}return o}function vj(e,t){let n=xr.decodeWeights(e,t),a={},r=[];return t.forEach(i=>{i.group==="optimizer"?r.push({name:i.name,tensor:n[i.name]}):a[i.name]=n[i.name]}),{modelWeights:a,optimizerWeights:r}}var cS=class Gk extends eu{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:Zv("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new we(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof Gk||t instanceof eu,a;if(n){if(a=t,a.outputs.length!==1)throw new we("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(a.inputs.length!==1)throw new we("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new we("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let r=sO({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(n)this.outputs=a.outputs,this.inputs=a.inputs;else{if(t.inboundNodes.length!==1)throw new we(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new we("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=iO(this.outputs[0])}this.inboundNodes=[],new oS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:lp(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(vn(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new eu({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,a=console.log){this.built||this.build(),super.summary(t,n,a)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,a={}){if(!this.built)throw new Xo("The model needs to be compiled before being used.");return this.model.evaluate(t,n,a)}async evaluateDataset(t,n){if(!this.built)throw new Xo("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,a={}){if(!this.built)throw new Xo("The model needs to be compiled before being used.");return this.model.fit(t,n,a)}async fitDataset(t,n){if(!this.built)throw new Xo("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,a={},r=!1){let i,s={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new we("Legacy serialization format not supported yet.");i=n}else O.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=n.layers,delete n.layers,s=n;let o=new t(s);if(!(o instanceof Gk))throw new rn(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let u of i){let d=io(u,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),o.add(d)}return o}set stopTraining(t){if(this.model==null)throw new we("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new we("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let a={};a.className=n.getClassName(),a.config=n.getConfig(),t.push(a)}return{name:this.name,layers:t}}};cS.className="Sequential";We.registerClass(cS);function Sj(e){return new eu(e)}function kj(e){return new cS(e)}function _O(e){return sO(e)}function Aj(e,t){xC.registerCallbackConstructor(e,t)}var Dr=class extends We.Serializable{getConfig(){return{}}},TO=class extends Dr{apply(e,t=1){return PY(e,t)}};TO.className="elu";We.registerClass(TO);var NO=class extends Dr{apply(e){return Mv(e)}};NO.className="selu";We.registerClass(NO);var RO=class extends Dr{apply(e){return zn(e)}};RO.className="relu";We.registerClass(RO);var FO=class extends Dr{apply(e){return be(()=>Ac(6,zn(e)))}};FO.className="relu6";We.registerClass(FO);var DO=class extends Dr{apply(e){return e}};DO.className="linear";We.registerClass(DO);var OO=class extends Dr{apply(e){return Ns(e)}};OO.className="sigmoid";We.registerClass(OO);var MO=class extends Dr{apply(e){return GY(e)}};MO.className="hardSigmoid";We.registerClass(MO);var BO=class extends Dr{apply(e){return Lh(e)}};BO.className="softplus";We.registerClass(BO);var LO=class extends Dr{apply(e){return HY(e)}};LO.className="softsign";We.registerClass(LO);var zO=class extends Dr{apply(e){return kc(e)}};zO.className="tanh";We.registerClass(zO);var CC=class extends Dr{apply(e,t=-1){return qc(e,t)}};CC.className="softmax";We.registerClass(CC);var UO=class extends Dr{apply(e,t=-1){return _v(e,t)}};UO.className="logSoftmax";We.registerClass(UO);var VO=class extends Dr{apply(e){return be(()=>be(()=>{let t=Math.sqrt(2),n=pe(.5,Oe(1,Ev(it(e,t))));return pe(e,n)}))}};VO.className="gelu";We.registerClass(VO);var WO=class extends Dr{apply(e){return be(()=>pe(.5,pe(e,Oe(1,kc(pe(ur(it(2,Math.PI)),Oe(e,pe(.044715,il(e,3)))))))))}};WO.className="gelu_new";We.registerClass(WO);var qO=class extends Dr{apply(e){return be(()=>pe(e,kc(Lh(e))))}};qO.className="mish";We.registerClass(qO);var PO=class extends Dr{apply(e,t=1){return be(()=>pe(Ns(pe(e,t)),e))}};PO.className="swish";We.registerClass(PO);function Ic(e){return e.getClassName()}function ik(e,t={}){return Z0(e,We.SerializationMap.getMap().classNameMap,t,"activation")}function _c(e){if(e==null){let t={};return t.className="linear",t.config={},ik(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},ik(t)}else return e instanceof Dr?e:ik(e)}function IC(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var HO=class extends We.Serializable{},aw=class extends HO{constructor(e){super(),IC(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return be(()=>{let t=wa([1]);return this.hasL1&&(t=Oe(t,lt(pe(this.l1,Da(e))))),this.hasL2&&(t=Oe(t,lt(pe(this.l2,ew(e))))),ge(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};aw.className="L1L2";We.registerClass(aw);function Ej(e){return IC(e),new aw({l1:e!=null?e.l1:null,l2:0})}function Cj(e){return IC(e),new aw({l2:e!=null?e.l2:null,l1:0})}var tR={l1l2:"L1L2"};function Zn(e){return rC(e)}function nR(e,t={}){return Z0(e,We.SerializationMap.getMap().classNameMap,t,"regularizer")}function da(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in tR?tR[e]:e,config:{}};return nR(t)}else return e instanceof HO?e:nR(e)}var _C=class extends sn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Ot(e);let n=zn(e);return this.maxValue!=null&&(n=Rr(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};_C.className="ReLU";We.registerClass(_C);var TC=class extends sn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ot(e);return W0(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};TC.className="LeakyReLU";We.registerClass(TC);var NC=class extends sn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ca(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=da(e.alphaRegularizer),this.alphaConstraint=Ya(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new we(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=vn(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new Oa({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Ot(e),$0(e,this.alpha.read())}getConfig(){let e={alphaInitializer:xa(this.alphaInitializer),alphaRegularizer:Zn(this.alphaRegularizer),alphaConstraint:Ja(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};NC.className="PReLU";We.registerClass(NC);var RC=class extends sn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new rn(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ot(e);return Bg(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};RC.className="ELU";We.registerClass(RC);var FC=class extends sn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Ot(e);return pe(n,je(Yr(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};FC.className="ThresholdedReLU";We.registerClass(FC);var DC=class extends sn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new CC().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return be(()=>{let n=Ot(e),a=t.mask;if(a!=null){let r=pe(at(oi(n.shape),je(a,n.dtype)),gt(-1e9));n=Oe(n,r)}return this.axis instanceof Array?this.axis.length>1?Fr(at(n,P0(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};DC.className="Softmax";We.registerClass(DC);function dm(e,t,n){if(typeof e=="number")return lp(e,t);if(e.length!==t)throw new we(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let a=0;a<t;++a){let r=e[a];if(!UY(r))throw new we(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${r}`)}return e}function so(e,t,n,a,r=1){if(e==null)return e;let i=t+(t-1)*(r-1),s;return n==="same"?s=e:s=e-i+1,Math.floor((s+a-1)/a)}function Zo(e,t,n,a){if(e==null)return null;if(a==="valid")e=e*t+Cc([n-t,0]);else if(a==="same")e=e*t;else throw new we(`Unsupport padding mode: ${a}.`);return e}function OC(e,t){return be(()=>(_a(t),t==="channelsFirst"?Qt(e,[0,2,3,1]):e))}function GO(e,t){return be(()=>(_a(t),t==="channelsFirst"?Qt(e,[0,2,3,4,1]):e))}function Ij(e,t,n,a=1,r="valid",i,s=1){return be(()=>{if(i==null&&(i=lo()),_a(i),e.shape.length!==3)throw new we(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new we(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new we(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(i==="channelsFirst"&&(e=Qt(e,[0,2,1])),r==="causal")throw new rn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=vv(e,t,a,r==="same"?"same":"valid","NWC",s);return n!=null&&(o=fo(o,n)),o})}function aR(e,t,n,a=[1,1],r="valid",i,s,o=null){return be(()=>{if(i==null&&(i=lo()),_a(i),e.rank!==3&&e.rank!==4)throw new we(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new we(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=OC(e,i);if(r==="causal")throw new rn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Am.conv2d({x:u,filter:t,strides:a,pad:r==="same"?"same":"valid",dilations:s,dataFormat:"NHWC",bias:n,activation:o}),i==="channelsFirst"&&(u=Qt(u,[0,3,1,2])),u})}function _j(e,t,n,a=[1,1,1],r="valid",i,s){return be(()=>{if(i==null&&(i=lo()),_a(i),e.rank!==4&&e.rank!==5)throw new we(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new we(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=GO(e,i);if(r==="causal")throw new rn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=lE(o,t,a,r==="same"?"same":"valid","NDHWC",s),n!=null&&(o=fo(o,n)),i==="channelsFirst"&&(o=Qt(o,[0,4,1,2,3])),o})}var KO=class $O extends sn{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",$O.verifyArgs(n),this.rank=t,or(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new rn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=dm(n.kernelSize,t,"kernelSize"),this.strides=dm(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,ss(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,_a(this.dataFormat),this.activation=_c(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=ca(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ya(n.biasConstraint),this.biasRegularizer=da(n.biasRegularizer),this.activityRegularizer=da(n.activityRegularizer),this.dilationRate=dm(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new we(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new we(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new we(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Qo("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!iC(t.kernelSize,"number",1,3))throw new we(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ic(this.activation),useBias:this.useBias,biasInitializer:xa(this.biasInitializer),biasRegularizer:Zn(this.biasRegularizer),activityRegularizer:Zn(this.activityRegularizer),biasConstraint:Ja(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},dS=class JO extends KO{constructor(t,n){super(t,n),this.kernel=null,JO.verifyArgs(n),this.filters=n.filters,or(this.filters,"filters"),this.kernelInitializer=ca(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ya(n.kernelConstraint),this.kernelRegularizer=da(n.kernelRegularizer)}build(t){t=vn(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new we(`The channel dimension of the input should be defined. Found ${t[n]}`);let a=t[n],r=this.kernelSize.concat([a,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:a}}],this.built=!0}call(t,n){return be(()=>{t=Ot(t);let a,r=this.bias==null?null:this.bias.read(),i=jD(this.activation.getClassName());if(i!=null&&this.rank===2)a=aR(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)a=Ij(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)a=aR(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)a=_j(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new rn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(a=this.activation.apply(a))}return a})}computeOutputShape(t){t=vn(t);let n=[],a=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<a.length;++i){let s=so(a[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);n.push(s)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){let t={filters:this.filters,kernelInitializer:xa(this.kernelInitializer),kernelRegularizer:Zn(this.kernelRegularizer),kernelConstraint:Ja(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new we(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},pS=class YO extends dS{constructor(t){super(2,t),YO.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!iC(t.kernelSize,"number",1,2))throw new we(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};pS.className="Conv2D";We.registerClass(pS);var hS=class jO extends dS{constructor(t){super(3,t),jO.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new we(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};hS.className="Conv3D";We.registerClass(hS);var MC=class extends pS{constructor(e){if(super(e),this.inputSpec=[new Oa({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new we(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=vn(e),e.length!==4)throw new we("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new we("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Oa({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return be(()=>{let n=Ot(e);if(n.shape.length!==4)throw new we(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],i,s;this.dataFormat==="channelsFirst"?(i=2,s=3):(i=1,s=2);let o=a[i],u=a[s],d=this.kernelSize[0],c=this.kernelSize[1],h=this.strides[0],m=this.strides[1],g=Zo(o,h,d,this.padding),x=Zo(u,m,c,this.padding),v=[r,g,x,this.filters];this.dataFormat!=="channelsLast"&&(n=Qt(n,[0,2,3,1]));let S=Sv(n,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=Qt(S,[0,3,1,2])),this.bias!=null&&(S=fo(S,this.bias.read(),this.dataFormat)),this.activation!=null&&(S=this.activation.apply(S)),S})}computeOutputShape(e){e=vn(e);let t=e.slice(),n,a,r;this.dataFormat==="channelsFirst"?(n=1,a=2,r=3):(n=3,a=1,r=2);let i=this.kernelSize[0],s=this.kernelSize[1],o=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[a]=Zo(t[a],o,i,this.padding),t[r]=Zo(t[r],u,s,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};MC.className="Conv2DTranspose";We.registerClass(MC);var BC=class extends hS{constructor(e){if(super(e),this.inputSpec=[new Oa({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new we(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=vn(e),e.length!==5)throw new we("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new we("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Oa({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return be(()=>{let n=Ot(e);if(n.shape.length!==5)throw new we(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],i,s,o;this.dataFormat==="channelsFirst"?(o=2,i=3,s=4):(o=1,i=2,s=3);let u=a[o],d=a[i],c=a[s],h=this.kernelSize[0],m=this.kernelSize[1],g=this.kernelSize[2],x=this.strides[0],v=this.strides[1],S=this.strides[2],E=Zo(u,x,h,this.padding),C=Zo(d,v,m,this.padding),T=Zo(c,S,g,this.padding),N=[r,E,C,T,this.filters];this.dataFormat!=="channelsLast"&&(n=Qt(n,[0,2,3,4,1]));let D=uE(n,this.kernel.read(),N,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(D=Qt(D,[0,4,1,2,3])),this.bias!==null&&(D=fo(D,this.bias.read(),this.dataFormat)),this.activation!==null&&(D=this.activation.apply(D)),D})}computeOutputShape(e){e=vn(e);let t=e.slice(),n,a,r,i;this.dataFormat==="channelsFirst"?(n=1,a=2,r=3,i=4):(n=4,a=1,r=2,i=3);let s=this.kernelSize[0],o=this.kernelSize[1],u=this.kernelSize[2],d=this.strides[0],c=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[a]=Zo(t[a],d,s,this.padding),t[r]=Zo(t[r],c,o,this.padding),t[i]=Zo(t[i],h,u,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};BC.className="Conv3DTranspose";We.registerClass(BC);var QO=class extends dS{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new we("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new we("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new we(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=ca(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=da(t.depthwiseRegularizer),this.depthwiseConstraint=Ya(t.depthwiseConstraint),this.pointwiseInitializer=ca(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=da(t.pointwiseRegularizer),this.pointwiseConstraint=Ya(t.pointwiseConstraint)}build(e){if(e=vn(e),e.length<this.rank+2)throw new we(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new we(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let s=0;s<this.rank;++s)r.push(1);r.push(n*this.depthMultiplier,this.filters);let i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new Oa({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return be(()=>{e=Ot(e);let n;if(this.rank===1)throw new rn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Qt(e,[0,2,3,1])),n=Vg(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=fo(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Qt(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=xa(this.depthwiseInitializer),e.pointwiseInitializer=xa(this.pointwiseInitializer),e.depthwiseRegularizer=Zn(this.depthwiseRegularizer),e.pointwiseRegularizer=Zn(this.pointwiseRegularizer),e.depthwiseConstraint=Ja(this.depthwiseConstraint),e.pointwiseConstraint=Ja(this.pointwiseConstraint),e}};QO.className="SeparableConv";var LC=class extends QO{constructor(e){super(2,e)}};LC.className="SeparableConv2D";We.registerClass(LC);var zC=class ZO extends dS{constructor(t){super(1,t),ZO.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!iC(t.kernelSize,"number",1,1))throw new we(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};zC.className="Conv1D";We.registerClass(zC);var UC=class extends sn{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return be(()=>{if(e=Ot(e),this.dataFormat==="channelsLast"){let n=$x(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return $x(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=$x(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return $x(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};UC.className="Cropping2D";We.registerClass(UC);var VC=class extends sn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,_a(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,BY(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return be(()=>{let n=Ot(e),a=n.shape;if(this.dataFormat==="channelsFirst"){n=Qt(n,[0,2,3,1]);let r=this.size[0]*a[2],i=this.size[1]*a[3],s=this.interpolation==="nearest"?Zi.resizeNearestNeighbor(n,[r,i]):Zi.resizeBilinear(n,[r,i]);return Qt(s,[0,3,1,2])}else{let r=this.size[0]*a[1],i=this.size[1]*a[2];return this.interpolation==="nearest"?Zi.resizeNearestNeighbor(n,[r,i]):Zi.resizeBilinear(n,[r,i])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};VC.className="UpSampling2D";We.registerClass(VC);function Tj(e,t,n=[1,1],a="valid",r,i){return be(()=>{r==null&&(r=lo()),_a(r);let s=OC(e,r);if(e.rank!==4)throw new we(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new we(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return s=Bh(s,t,n,a==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(s=Qt(s,[0,3,1,2])),s})}var WC=class extends KO{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=ca(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ya(e.depthwiseConstraint),this.depthwiseRegularizer=da(e.depthwiseRegularizer)}build(e){if(e=vn(e),e.length<4)throw new we(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new we(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return be(()=>{e=Ot(e);let n=Tj(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=fo(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=vn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],a=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=so(t,this.kernelSize[0],this.padding,this.strides[0]),i=so(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],a,r,i]:[e[0],r,i,a]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=xa(this.depthwiseInitializer),e.depthwiseRegularizer=Zn(this.depthwiseRegularizer),e.depthwiseConstraint=Ja(this.depthwiseRegularizer),e}};WC.className="DepthwiseConv2D";We.registerClass(WC);function XO(e,t,n,a){if(Array.isArray(e)){if(t!=null||n!=null)throw new we("When inputs is an array, neither initialState or constants should be provided");a!=null&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return t=r(t),n=r(n),{inputs:e,initialState:t,constants:n}}function eM(e,t,n,a=!1,r,i,s=!1,o=!1){return be(()=>{let u=t.shape.length;if(u<3)throw new we(`Input should be at least 3D, but is ${u}D.`);let d=[1,0].concat(oo(2,u));t=Qt(t,d),i!=null,s&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=je(je(r,"bool"),"float32"),r.rank===u-1&&(r=sr(r,-1)),r=Qt(r,d)),a&&(t=is(t,0),r!=null&&(r=is(r,0)));let c=[],h,m=n,g=t.shape[0],x=Aa(t),v;r!=null&&(v=Aa(r));for(let E=0;E<g;++E){let C=x[E],T=be(()=>e(C,m));if(r==null)h=T[0],m=T[1];else{let N=be(()=>{let D=v[E],q=at(Oi(D),D),H=Oe(pe(T[0],D),pe(m[0],q)),K=m.map((j,te)=>Oe(pe(T[1][te],D),pe(j,q)));return{output:H,newStates:K}});h=N.output,m=N.newStates}o&&c.push(h)}let S;return o&&(S=Ba(c,1)),[h,S,m]})}var cu=class tM extends sn{constructor(t){super(t);let n;if(t.cell==null)throw new we("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new gS({cells:t.cell}):n=t.cell,n.stateSize==null)throw new we("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Oa({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return oo(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Uk(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let a=n[0],r;if(this.returnSequences?r=[t[0],t[1],a]:r=[t[0],a],this.returnState){let i=[];for(let s of n)i.push([t[0],s]);return[r].concat(i)}else return r}computeMask(t,n){return be(()=>{Array.isArray(n)&&(n=n[0]);let a=this.returnSequences?n:null;if(this.returnState){let r=this.states.map(i=>null);return[a].concat(r)}else return a})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let a=0;a<t;++a)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new rn("Constants support is not implemented in RNN yet.");Uk(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,a=t.slice(2);this.inputSpec[0]=new Oa({shape:[n,null,...a]});let r=[t[0]].concat(t.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!O.arraysEqual(this.stateSpec.map(s=>s.shape[s.shape.length-1]),i))throw new we(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(s=>new Oa({shape:[null,s]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){be(()=>{if(!this.stateful)throw new lc("Cannot call resetStates() on an RNN Layer that is not stateful.");let a=this.inputSpec[0].shape[0];if(a==null)throw new we("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>wa([a,r])):this.states_=[wa([a,this.cell.stateSize])];else if(t==null)Wt(this.states_),this.keptStates!=null&&(Wt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>wa([a,r])):this.states_[0]=wa([a,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new we(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):Wt(this.states_);for(let r=0;r<this.states_.length;++r){let i=t[r],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[a,s];if(!O.arraysEqual(i.shape,o))throw new we(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>Ga(r.clone()))})}apply(t,n){let a=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});let i=XO(t,a,r,this.numConstants);t=i.inputs,a=i.initialState,r=i.constants;let s=[],o=[];if(a!=null){n.initialState=a,s=s.concat(a),this.stateSpec=[];for(let u of a)this.stateSpec.push(new Oa({shape:u.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(n.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof uo){let u=[t].concat(s),d=this.inputSpec.concat(o),c=this.inputSpec;this.inputSpec=d;let h=super.apply(u,n);return this.inputSpec=c,h}else return super.apply(t,n)}call(t,n){return be(()=>{let a=n==null?null:n.mask,r=n==null?null:n.training,i=n==null?null:n.initialState;t=Ot(t),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(t));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==s)throw new we(`RNN Layer has ${s} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:r},u=eM((g,x)=>{let v=this.cell.call([g].concat(x),o);return[v[0],v.slice(1)]},t,i,this.goBackwards,a,null,this.unroll,this.returnSequences),d=u[0],c=u[1],h=u[2];this.stateful&&this.resetStates(h,r);let m=this.returnSequences?c:d;return this.returnState?[m].concat(h):m})}getInitialState(t){return be(()=>{let n=wa(t.shape);return n=lt(n,[1,2]),n=X0(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(a=>a>1?Lk(n,[1,a]):n):this.cell.stateSize>1?[Lk(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let a=this.cell.getConfig();return this.getClassName()===tM.className&&(n.cell={className:this.cell.getClassName(),config:a}),Object.assign(Object.assign(Object.assign({},a),t),n)}static fromConfig(t,n,a={}){let r=n.cell,i=io(r,a);return new t(Object.assign(n,{cell:i}))}};cu.className="RNN";We.registerClass(cu);var rw=class extends sn{},fS=class extends rw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,or(this.units,"units"),this.activation=_c(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ca(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ca(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ca(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=da(e.kernelRegularizer),this.recurrentRegularizer=da(e.recurrentRegularizer),this.biasRegularizer=da(e.biasRegularizer),this.kernelConstraint=Ya(e.kernelConstraint),this.recurrentConstraint=Ya(e.recurrentConstraint),this.biasConstraint=Ya(e.biasConstraint),this.dropout=Em([1,Cc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Em([1,Cc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=vn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return be(()=>{if(e=e,e.length!==2)throw new we(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let a=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Tc({ones:()=>Oi(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Tc({ones:()=>Oi(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));let r,i=this.dropoutMask,s=this.recurrentDropoutMask;i!=null?r=al(pe(e,i),this.kernel.read()):r=al(e,this.kernel.read()),this.bias!=null&&(r=fo(r,this.bias.read())),s!=null&&(n=pe(n,s));let o=Oe(r,al(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ic(this.activation),useBias:this.useBias,kernelInitializer:xa(this.kernelInitializer),recurrentInitializer:xa(this.recurrentInitializer),biasInitializer:xa(this.biasInitializer),kernelRegularizer:Zn(this.kernelRegularizer),recurrentRegularizer:Zn(this.recurrentRegularizer),biasRegularizer:Zn(this.biasRegularizer),activityRegularizer:Zn(this.activityRegularizer),kernelConstraint:Ja(this.kernelConstraint),recurrentConstraint:Ja(this.recurrentConstraint),biasConstraint:Ja(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};fS.className="SimpleRNNCell";We.registerClass(fS);var qC=class extends cu{constructor(e){e.cell=new fS(e),super(e)}call(e,t){return be(()=>{this.cell.dropoutMask!=null&&(Wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return new e(t)}};qC.className="SimpleRNN";We.registerClass(qC);var mS=class extends rw{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new we("GRUCell does not support reset_after parameter set to true.");this.units=e.units,or(this.units,"units"),this.activation=_c(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=_c(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ca(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ca(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ca(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=da(e.kernelRegularizer),this.recurrentRegularizer=da(e.recurrentRegularizer),this.biasRegularizer=da(e.biasRegularizer),this.kernelConstraint=Ya(e.kernelConstraint),this.recurrentConstraint=Ya(e.recurrentConstraint),this.biasConstraint=Ya(e.biasConstraint),this.dropout=Em([1,Cc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Em([1,Cc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=vn(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return be(()=>{if(e=e,e.length!==2)throw new we(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Tc({ones:()=>Oi(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Tc({ones:()=>Oi(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let r=this.dropoutMask,i=this.recurrentDropoutMask,s,o,u;0<this.dropout&&this.dropout<1&&(e=pe(e,r[0]));let d=al(e,this.kernel.read());this.useBias&&(d=fo(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=pe(a,i[0]));let c=this.recurrentKernel.read(),[h,m]=li(c,[2*this.units,this.units],c.rank-1),g=al(a,h),[x,v,S]=li(d,3,d.rank-1),[E,C]=li(g,2,g.rank-1);s=this.recurrentActivation.apply(Oe(x,E)),o=this.recurrentActivation.apply(Oe(v,C));let T=al(pe(o,a),m);u=this.activation.apply(Oe(S,T));let N=Oe(pe(s,a),pe(Oe(1,ia(s)),u));return[N,N]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ic(this.activation),recurrentActivation:Ic(this.recurrentActivation),useBias:this.useBias,kernelInitializer:xa(this.kernelInitializer),recurrentInitializer:xa(this.recurrentInitializer),biasInitializer:xa(this.biasInitializer),kernelRegularizer:Zn(this.kernelRegularizer),recurrentRegularizer:Zn(this.recurrentRegularizer),biasRegularizer:Zn(this.biasRegularizer),activityRegularizer:Zn(this.activityRegularizer),kernelConstraint:Ja(this.kernelConstraint),recurrentConstraint:Ja(this.recurrentConstraint),biasConstraint:Ja(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};mS.className="GRUCell";We.registerClass(mS);var PC=class extends cu{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new mS(e),super(e)}call(e,t){return be(()=>{this.cell.dropoutMask!=null&&(Wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};PC.className="GRU";We.registerClass(PC);var iw=class extends rw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,or(this.units,"units"),this.activation=_c(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=_c(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ca(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ca(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ca(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=da(e.kernelRegularizer),this.recurrentRegularizer=da(e.recurrentRegularizer),this.biasRegularizer=da(e.biasRegularizer),this.kernelConstraint=Ya(e.kernelConstraint),this.recurrentConstraint=Ya(e.recurrentConstraint),this.biasConstraint=Ya(e.biasConstraint),this.dropout=Em([1,Cc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Em([1,Cc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=vn(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let a;if(this.useBias){if(this.unitForgetBias){let r=this.biasInitializer,i=this.units;a=new(t=class extends Ds{apply(s,o){let u=r.apply([i]),d=new eS().apply([i]),c=r.apply([i*2]);return WN(WN(u,d),c)}},t.className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return be(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new we(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let a=e[1],r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Tc({ones:()=>Oi(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Tc({ones:()=>Oi(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,s=this.recurrentDropoutMask,o,u,d,c;0<this.dropout&&this.dropout<1&&(e=pe(e,i[0]));let h=al(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=pe(a,s[0])),h=Oe(h,al(a,this.recurrentKernel.read())),this.useBias&&(h=fo(h,this.bias.read()));let[m,g,x,v]=li(h,4,h.rank-1);o=this.recurrentActivation.apply(m),u=this.recurrentActivation.apply(g),d=Oe(pe(u,r),pe(o,this.activation.apply(x))),c=this.recurrentActivation.apply(v);let S=pe(c,this.activation.apply(d));return[S,S,d]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ic(this.activation),recurrentActivation:Ic(this.recurrentActivation),useBias:this.useBias,kernelInitializer:xa(this.kernelInitializer),recurrentInitializer:xa(this.recurrentInitializer),biasInitializer:xa(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Zn(this.kernelRegularizer),recurrentRegularizer:Zn(this.recurrentRegularizer),biasRegularizer:Zn(this.biasRegularizer),activityRegularizer:Zn(this.activityRegularizer),kernelConstraint:Ja(this.kernelConstraint),recurrentConstraint:Ja(this.recurrentConstraint),biasConstraint:Ja(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};iw.className="LSTMCell";We.registerClass(iw);var HC=class extends cu{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new iw(e),super(e)}call(e,t){return be(()=>{this.cell.dropoutMask!=null&&(Wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};HC.className="LSTM";We.registerClass(HC);var gS=class extends rw{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return be(()=>{e=e;let n=e.slice(1),a=[];for(let s of this.cells.slice().reverse())Array.isArray(s.stateSize)?a.push(n.splice(0,s.stateSize.length)):a.push(n.splice(0,1));a.reverse();let r=[],i;for(let s=0;s<this.cells.length;++s){let o=this.cells[s];n=a[s],s===0?i=[e[0]].concat(n):i=[i[0]].concat(n),i=o.call(i,t),r.push(i.slice(1))}n=[];for(let s of r.slice().reverse())n.push(...s);return[i[0]].concat(n)})}build(e){Uk(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,a)=>{Kd(`RNNCell_${a}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=a=>({className:a.getClassName(),config:a.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let a=[];for(let r of t.cells)a.push(io(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Vk(e)}setWeights(e){let t=[];for(let n of this.cells){let a=n.weights.length,r=e.splice(a);for(let i=0;i<n.weights.length;++i)t.push([n.weights[i],r[i]])}fC(t)}};gS.className="StackedRNNCells";We.registerClass(gS);function Tc(e){let{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:i}=e,s=()=>i!=null?i(t(),n):aO(t(),n),o=()=>tw(s,t,a);return!r||r<=1?Ga(o().clone()):Array(r).fill(void 0).map(o).map(u=>Ga(u.clone()))}var Nj=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]]);return n},nM=class extends cu{constructor(e){if(e.unroll)throw new rn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new rn("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Oa({ndim:5})]}call(e,t){return be(()=>{if(this.cell.dropoutMask!=null&&(Wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new we("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return be(()=>{let{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)],i=wa(r);return Array.isArray(t)?Array(t.length).fill(i):[i]})}resetStates(e,t=!1){be(()=>{if(!this.stateful)throw new lc("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(n[0]==null)throw new we("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>wa(r)):this.states_=[wa(r)];else if(e==null)Wt(this.states_),this.keptStates!=null&&(Wt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>wa(r)):this.states_[0]=wa(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new we(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Wt(this.states_);for(let i=0;i<this.states_.length;++i){let s=e[i],o=r;if(!O.arraysEqual(s.shape,o))throw new we(`State ${i} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[i]=s}}this.states_=this.states_.map(i=>Ga(i.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:i,dilationRate:s}=this.cell,o=t==="channelsFirst",u=e[o?3:2],d=e[o?4:3],c=so(u,a[0],r,i[0],s[0]),h=so(d,a[1],r,i[1],s[1]);return[...e.slice(0,2),...o?[n,c,h]:[c,h,n]]}};nM.className="ConvRNN2D";var bS=class extends iw{constructor(e){let{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:i,dilationRate:s}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,or(this.filters,"filters"),this.kernelSize=dm(n,2,"kernelSize"),this.kernelSize.forEach(o=>or(o,"kernelSize")),this.strides=dm(a||1,2,"strides"),this.strides.forEach(o=>or(o,"strides")),this.padding=r||"valid",ss(this.padding),this.dataFormat=i||"channelsLast",_a(this.dataFormat),this.dilationRate=dm(s||1,2,"dilationRate"),this.dilationRate.forEach(o=>or(o,"dilationRate"))}build(e){var t;e=vn(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new we(`The channel dimension of the input should be defined. Found ${e[n]}`);let a=e[n],r=4,i=this.kernelSize.concat([a,this.filters*r]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let s=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let u=this.biasInitializer,d=this.filters;o=new(t=class extends Ds{apply(c,h){let m=u.apply([d]),g=oi([d]),x=u.apply([d*2]);return sC([m,g,x])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return be(()=>{if(e.length!==3)throw new we(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,a=e[0],r=e[1],i=e[2],s=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Tc({ones:()=>Oi(a),rate:this.dropout,training:n,count:s,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,u=(Ce,Y,ie)=>!Y||!Y[ie]?Ce:pe(Y[ie],Ce),d=u(a,o,0),c=u(a,o,1),h=u(a,o,2),m=u(a,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Tc({ones:()=>Oi(r),rate:this.recurrentDropout,training:n,count:s,dropoutFunc:this.dropoutFunc}));let g=this.recurrentDropoutMask,x=u(r,g,0),v=u(r,g,1),S=u(r,g,2),E=u(r,g,3),C=3,[T,N,D,q]=li(this.kernel.read(),s,C),[H,K,j,te]=this.useBias?li(this.bias.read(),s):[null,null,null,null];d=this.inputConv(d,T,H,this.padding),c=this.inputConv(c,N,K,this.padding),h=this.inputConv(h,D,j,this.padding),m=this.inputConv(m,q,te,this.padding);let[Q,z,ae,ue]=li(this.recurrentKernel.read(),s,C);x=this.recurrentConv(x,Q),v=this.recurrentConv(v,z),S=this.recurrentConv(S,ae),E=this.recurrentConv(E,ue);let he=this.recurrentActivation.apply(Oe(d,x)),Z=this.recurrentActivation.apply(Oe(c,v)),se=Oe(pe(Z,i),pe(he,this.activation.apply(Oe(h,S)))),de=pe(this.recurrentActivation.apply(Oe(m,E)),this.activation.apply(se));return[de,de,se]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=Nj(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){let r=Hr(e,t,this.strides,a||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?fo(r,n,this.dataFormat):r}recurrentConv(e,t){return Hr(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};bS.className="ConvLSTM2DCell";We.registerClass(bS);var GC=class extends nM{constructor(e){let t=new bS(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};GC.className="ConvLSTM2D";We.registerClass(GC);var yS=class extends sn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(this.noiseShape[a]==null?t[a]:this.noiseShape[a]);return n}call(e,t){return be(()=>{this.invokeCallHook(e,t);let n=Ot(e);if(0<this.rate&&this.rate<1){let a=t.training==null?!1:t.training,r=this.getNoiseShape(n);return tw(()=>aO(n,this.rate,r,this.seed),()=>n,a)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};yS.className="Dropout";We.registerClass(yS);var KC=class extends yS{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};KC.className="SpatialDropout1D";We.registerClass(KC);var $C=class extends sn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,or(this.units,"units"),this.activation=_c(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=ca(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ca(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ya(e.kernelConstraint),this.biasConstraint=Ya(e.biasConstraint),this.kernelRegularizer=da(e.kernelRegularizer),this.biasRegularizer=da(e.biasRegularizer),this.activityRegularizer=da(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=vn(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=vn(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return be(()=>{this.invokeCallHook(e,t);let n=Ot(e),a=jD(this.activation.getClassName()),r;return a!=null?r=al(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=al(n,this.kernel.read()),this.bias!=null&&(r=fo(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){let e={units:this.units,activation:Ic(this.activation),useBias:this.useBias,kernelInitializer:xa(this.kernelInitializer),biasInitializer:xa(this.biasInitializer),kernelRegularizer:Zn(this.kernelRegularizer),biasRegularizer:Zn(this.biasRegularizer),activityRegularizer:Zn(this.activityRegularizer),kernelConstraint:Ja(this.kernelConstraint),biasConstraint:Ja(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};$C.className="Dense";We.registerClass($C);var JC=class extends sn{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=vn(e);for(let t of e.slice(1))if(t==null)throw new we(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],bc(e,1)]}call(e,t){return be(()=>{this.invokeCallHook(e,t);let n=Ot(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let a=[0];for(let r=2;r<n.rank;++r)a.push(r);a.push(1),n=Qt(n,a)}return qY(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};JC.className="Flatten";We.registerClass(JC);var YC=class extends sn{constructor(e){super(e),this.supportsMasking=!0,this.activation=_c(e.activation)}call(e,t){return be(()=>{this.invokeCallHook(e,t);let n=Ot(e);return this.activation.apply(n)})}getConfig(){let e={activation:Ic(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};YC.className="Activation";We.registerClass(YC);var jC=class extends sn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return be(()=>(e=Ot(e),VY(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};jC.className="RepeatVector";We.registerClass(jC);var QC=class extends sn{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",a=t.slice(),r=1,i=null;for(let o=0;o<a.length;++o){let u=a[o];if(this.isUnknown(u))if(i===null)i=o;else throw new we("Can only specifiy one unknown dimension.");else r*=u}let s=bc(e);if(i!==null){if(r===0||s%r!==0)throw new we(n);a[i]=s/r}else if(s!==r)throw new we(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return be(()=>{this.invokeCallHook(e,t);let n=Ot(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return ge(n,r)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};QC.className="Reshape";We.registerClass(QC);var ZC=class extends sn{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=oo(1,e.dims.length+1);if(!O.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Oa({ndim:this.dims.length+1})]}computeOutputShape(e){e=vn(e);let t=e.slice();return this.dims.forEach((n,a)=>{t[a+1]=e[n]}),t}call(e,t){return Qt(Ot(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};ZC.className="Permute";We.registerClass(ZC);var XC=class extends sn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Ot(e);return jy(sp(n,this.maskValue),-1)}call(e,t){return be(()=>{this.invokeCallHook(e,t);let n=Ot(e),a=jy(sp(n,this.maskValue),-1,!0);return pe(n,je(a,n.dtype))})}};XC.className="Masking";We.registerClass(XC);var eI=class extends sn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Ln(e.inputLength))}this.inputDim=e.inputDim,or(this.inputDim,"inputDim"),this.outputDim=e.outputDim,or(this.outputDim,"outputDim"),this.embeddingsInitializer=ca(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=da(e.embeddingsRegularizer),this.activityRegularizer=da(e.activityRegularizer),this.embeddingsConstraint=Ya(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return be(()=>this.maskZero?(e=Ot(e),sp(e,gn(e))):null)}computeOutputShape(e){if(e=vn(e),this.inputLength==null)return[...e,this.outputDim];let t=Ln(this.inputLength);if(t.length!==e.length-1)throw new we(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let a=0;a<t.length;++a){let r=t[a],i=e[a+1];if(r!=null&&i!=null&&r!==i)throw new we(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[n]=i),n++}}return[e[0],...t,this.outputDim]}call(e,t){return be(()=>{this.invokeCallHook(e,t);let n=Ot(e);n.dtype!=="int32"&&(n=au(n,"int32"));let a=nO(this.embeddings.read(),ge(n,[n.size]));return ge(a,vn(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:xa(this.embeddingsInitializer),embeddingsRegularizer:Zn(this.embeddingsRegularizer),activityRegularizer:Zn(this.activityRegularizer),embeddingsConstraint:Ja(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};eI.className="Embedding";We.registerClass(eI);var Wh=class extends sn{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new rn}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){let r=e[e.length-t.length+a],i=t[a];if(r==null||i==null||r<0||i<0)n.push(null);else if(r===1)n.push(i);else if(i===1)n.push(r);else{if(r!==i)throw new we("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[vn(e)]),e=e,e.length<2)throw new we(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=gc(t),t.length>1)throw new we(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){let i=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let a=e.map(r=>r.length);e.indexOf(null)===-1&&gc(a).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return be(()=>{if(e=e,this.reshapeRequired){let n=[],a=e.map(r=>r.rank);if(a.indexOf(null)===-1){let r=Cc(a);for(let i of e){let s=i.rank;for(let o=0;o<r-s;++o)i=X0(i,1);n.push(i)}return this.mergeFunction(n)}else{let r=!1;for(let o of e){let u=o.rank;if(u==null){let d=o.shape,c=d[0],h=d.slice(1).concat([c]),m=ge(o,[c].concat(bc(d.slice(1))));m=Qt(m,[1,0]),m=ge(m,h),n.push(m),r=!0}else if(u>1){let d=oo(1,u).concat([0]);n.push(Qt(o,d)),r=!0}else n.push(o)}let i=this.mergeFunction(n),s=i.rank;if(r){if(s==null){let o=i.shape,u=o.length,d=o[u-1],c=[d].concat(o.slice(0,o.length-1));i=ge(Qt(ge(i,[-1,d]),[1,0]),c)}else if(s>1){let o=[s-1].concat(oo(0,s-1));i=Qt(i,o)}}return i}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let a=1;a<e.length;++a){let r=e[a]==null?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(let a of e)a!=null&&a[0]!==null&&n.push(a[0]);return n=gc(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return be(()=>{if(t==null)return null;if(!Array.isArray(t))throw new we("`mask` should be an Array");if(!Array.isArray(e))throw new we("`inputs` should be an Array");if(t.length!==e.length)throw new we(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(a=>a==null))return null;t=t.map(a=>a==null?a:sr(a,0));let n=t[0];for(let a=1;a<t.length-1;++a)n=Rs(n,t[a]);return n})}},tI=class extends Wh{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Oe(t,e[n]);return t})}};tI.className="Add";We.registerClass(tI);var nI=class extends Wh{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=pe(t,e[n]);return t})}};nI.className="Multiply";We.registerClass(nI);var aI=class extends Wh{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Oe(t,e[n]);return pe(1/e.length,t)})}};aI.className="Average";We.registerClass(aI);var rI=class extends Wh{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ul(t,e[n]);return t})}};rI.className="Maximum";We.registerClass(rI);var iI=class extends Wh{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ac(t,e[n]);return t})}};iI.className="Minimum";We.registerClass(iI);var sI=class extends Wh{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new we("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let a of e)if(a!=null){t=!1;break}if(t)return;let n=[];for(let a=0;a<e.length;++a){let r=e[a].slice();r.splice(this.axis,1);let i=!1;for(let s of n)if(O.arraysEqual(s,r)){i=!0;break}i||n.push(r)}if(n.length>1)throw new we("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return be(()=>sC(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new we("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(let r of t.slice(1)){if(n[a]==null||r[a]==null){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new we("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new we("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new we(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return be(()=>{let n=!0;if(t.forEach(i=>{if(i!=null){n=!1;return}}),n)return null;let a=[];for(let i=0;i<e.length;++i)t[i]==null?a.push(je(Oi(e[i]),"bool")):t[i].rank<e[i].rank?a.push(sr(t[i],-1)):a.push(t[i]);let r=Gn(a,this.axis);return xv(r,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};sI.className="Concatenate";We.registerClass(sI);function gy(e,t){for(;e<0;)e+=t;return e}function Rj(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new rn("batchDot is not implemented for tensors of 4D or higher rank yet");if(O.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),O.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new rn("batchDot is not implemented for complex64-type Tensors yet.");let a=e.shape.length,r=t.shape.length;n==null&&(n=[a-1,r-2]);let i=n;return be(()=>{let s;if(a>r){s=a-r;let u=[];for(let d=0;d<s;++d)u.push(1);t=ge(t,t.shape.concat(u))}else if(r>a){s=r-a;let u=[];for(let d=0;d<s;++d)u.push(1);e=ge(e,e.shape.concat(u))}else s=0;let o;if(e.shape.length===2&&t.shape.length===2)i[0]===i[1]?o=lt(pe(e,t),i[0]):o=lt(pe(Qt(e,[1,0]),t),i[1]);else{let u=i[0]!==e.shape.length-1,d=i[1]===t.shape.length-1;o=jt(e,t,u,d)}if(s>0){let u;a>r?u=a+r-3:u=a-1;let d=[];for(let c=u;c<u+s;++c)d.push(c);o=Pc(o,d)}return o.shape.length===1&&(o=sr(o,1)),o})}var oI=class extends Wh{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){O.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new rn("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new we(`Dimension incompatibility: ${t[a[0]]} !== ${n[a[1]]}`)}mergeFunction(e){if(e.length!==2)throw new we(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],a;return Array.isArray(this.axes)?a=this.axes.map((r,i)=>gy(r,e[i].shape.length)):a=[gy(this.axes,t.shape.length),gy(this.axes,n.shape.length)],this.normalize&&(t=F1(t,a[0]),n=F1(n,a[1])),Rj(t,n,a)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[gy(this.axes,e.length),gy(this.axes,t.length)],n}computeOutputShape(e){O.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new rn("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);let r=t.concat(n);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};oI.className="Dot";We.registerClass(oI);var lI=class extends sn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return be(()=>{this.invokeCallHook(e,t);let n=Ot(e);return tw(()=>Oe(Xv(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};lI.className="GaussianNoise";We.registerClass(lI);var uI=class extends sn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return be(()=>{this.invokeCallHook(e,t);let n=Ot(e);return this.rate>0&&this.rate<1?tw(()=>{let a=Math.sqrt(this.rate/(1-this.rate));return pe(n,Xv(n.shape,1,a))},()=>n,t.training||!1):n})}};uI.className="GaussianDropout";We.registerClass(uI);var cI=class extends sn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ot(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return be(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return tw(()=>{let a=Ot(e),r=-1.6732632423543772*1.0507009873554805,i=ou(Wc(n),this.rate);i=au(i,"float32");let s=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-s*r*this.rate,u=Oe(pe(a,i),pe(Oe(i,-1),r));return Oe(pe(u,s),o)},()=>Ot(e),t.training||!1)}return e})}};cI.className="AlphaDropout";We.registerClass(cI);function n0(e,t,n,a,r,i=.001){let s;if(e.rank===2)s=ZA(e,t,n,a,r,i);else if(e.rank===3)s=XA(e,t,n,a,r,i);else if(e.rank===4)s=eE(e,t,n,a,r,i);else throw new rn(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return s}function Fj(e,t,n,a,r=.001){return be(()=>{let i=G0(e,a),s=i.mean,o=i.variance;return[n0(e,s,o,n,t,r),s,o]})}function Dj(e,t,n,a,r=.001){return be(()=>{let i=G0(e,a),s=i.mean,o=i.variance,u=[];for(let g of oo(0,e.rank))a.indexOf(g)!==-1?u.push(1):u.push(e.shape[g]);let d=ge(s,u),c=ge(o,u),h=t==null?null:ge(t,u),m=n==null?null:ge(n,u);return[n0(e,d,c,m,h,r),s,o]})}function Oj(e,t,n,a,r=.001){return O.arraysEqual(a.slice().sort(),oo(0,e.rank-1))?Fj(e,t,n,a,r):Dj(e,t,n,a,r)}var dI=class extends sn{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ca(e.betaInitializer||"zeros"),this.gammaInitializer=ca(e.gammaInitializer||"ones"),this.movingMeanInitializer=ca(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ca(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ya(e.betaConstraint),this.gammaConstraint=Ya(e.gammaConstraint),this.betaRegularizer=da(e.betaRegularizer),this.gammaRegularizer=da(e.gammaRegularizer)}build(e){e=vn(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new we(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Oa({ndim:e.length,axes:{[t]:n}})];let a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return be(()=>{let n=t.training==null?!1:t.training,a=Ot(e),r=a.shape,i=r.length,s=oo(0,i),o=this.axis>=0?this.axis:this.axis+i;s.splice(o,1);let u=lp(1,i);u[o]=r[o];let d=s.slice();d.sort();let c=!O.arraysEqual(d,oo(0,i).slice(0,i-1)),h=()=>{if(c){let S=ge(this.movingMean.read(),u),E=ge(this.movingVariance.read(),u),C=this.center?ge(this.beta.read(),u):null,T=this.scale?ge(this.gamma.read(),u):null;return n0(a,S,E,C,T,this.epsilon)}else return n0(a,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return h();let[m,g,x]=Oj(a,this.gamma.read(),this.beta.read(),s,this.epsilon),v=(S,E,C)=>{be(()=>{let T=1-C,N=S.read(),D=pe(at(N,E),T);S.write(at(N,D))})};return v(this.movingMean,g,this.momentum),v(this.movingVariance,x,this.momentum),m})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:xa(this.betaInitializer),gammaInitializer:xa(this.gammaInitializer),movingMeanInitializer:xa(this.movingMeanInitializer),movingVarianceInitializer:xa(this.movingVarianceInitializer),betaRegularizer:Zn(this.betaRegularizer),gammaRegularizer:Zn(this.gammaRegularizer),betaConstraint:Ja(this.betaConstraint),gammaConstraint:Ja(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};dI.className="BatchNormalization";We.registerClass(dI);var pI=class extends sn{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ca(e.betaInitializer||"zeros"),this.gammaInitializer=ca(e.gammaInitializer||"ones"),this.betaRegularizer=da(e.betaRegularizer),this.gammaRegularizer=da(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=vn(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(let r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==gc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(r=>e[r]),a=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){let n=Ot(e),a=n.shape,r=a.length;return be(()=>{let{mean:i,variance:s}=G0(n,this.axis,!0),o=lp(1,r);for(let g of this.axis)o[g]=a[g];let u=g=>g!=null&&g.shape.length!==r?ge(g,o):g,d=this.scale?u(this.gamma.read()):null,c=this.center?u(this.beta.read()):null,h=[],m=[];for(let g=0;g<r;++g)this.axis.indexOf(g)!==-1?(h.push(a[g]),m.push(1)):(h.push(1),m.push(a[g]));return i=Ti(i,h),s=Ti(s,h),d!=null&&(d=Ti(d,m)),c!=null&&(c=Ti(c,m)),n0(n,i,s,c,d,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:xa(this.betaInitializer),gammaInitializer:xa(this.gammaInitializer),betaRegularizer:Zn(this.betaRegularizer),gammaRegularizer:Zn(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};pI.className="LayerNormalization";We.registerClass(pI);function Mj(e,t,n){return be(()=>{if(e.rank!==4)throw new we(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new we("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=lo()),n!=="channelsLast"&&n!=="channelsFirst")throw new we(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let a;return n==="channelsFirst"?a=[[0,0],[0,0],t[0],t[1]]:a=[[0,0],t[0],t[1],[0,0]],ho(e,a)})}var hI=class extends sn{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?lo():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new we(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new we(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new we(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Oa({ndim:4})]}computeOutputShape(e){e=vn(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return be(()=>Mj(Ot(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};hI.className="ZeroPadding2D";We.registerClass(hI);function wS(e,t,n,a,r,i){return be(()=>{_a(r),ZD(i),ss(a),n==null&&(n=[1,1]),a==null&&(a="valid"),r==null&&(r=lo()),i==null&&(i="max"),e=OC(e,r);let s,o=a==="same"?"same":"valid";return i==="max"?s=ar(e,t,n,o):s=su(e,t,n,o),r==="channelsFirst"&&(s=Qt(s,[0,3,1,2])),s})}function aM(e,t,n,a,r,i){return be(()=>{_a(r),ZD(i),ss(a),n==null&&(n=[1,1,1]),a==null&&(a="valid"),r==null&&(r=lo()),i==null&&(i="max"),e=GO(e,r);let s,o=a==="same"?"same":"valid";return i==="max"?s=AE(e,t,n,o):s=QA(e,t,n,o),r==="channelsFirst"&&(s=Qt(s,[0,4,1,2,3])),s})}var rM=class extends sn{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new we(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(or(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new we(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);or(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,ss(this.padding),this.inputSpec=[new Oa({ndim:3})]}computeOutputShape(e){e=vn(e);let t=so(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return be(()=>{this.invokeCallHook(e,t),e=X0(Ot(e),2);let n=this.poolingFunction(Ot(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Pc(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},fI=class extends rM{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return _a(r),ss(a),wS(e,t,n,a,r,"max")}};fI.className="MaxPooling1D";We.registerClass(fI);var mI=class extends rM{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return _a(r),ss(a),wS(e,t,n,a,r,"avg")}};mI.className="AveragePooling1D";We.registerClass(mI);var iM=class extends sn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new we(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];or(this.poolSize,"poolSize"),or(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,_a(this.dataFormat),ss(this.padding),this.inputSpec=[new Oa({ndim:4})]}computeOutputShape(e){e=vn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=so(t,this.poolSize[0],this.padding,this.strides[0]),n=so(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return be(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ot(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},gI=class extends iM{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return _a(r),ss(a),wS(e,t,n,a,r,"max")}};gI.className="MaxPooling2D";We.registerClass(gI);var bI=class extends iM{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return _a(r),ss(a),wS(e,t,n,a,r,"avg")}};bI.className="AveragePooling2D";We.registerClass(bI);var sM=class extends sn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new we(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];or(this.poolSize,"poolSize"),or(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,_a(this.dataFormat),ss(this.padding),this.inputSpec=[new Oa({ndim:5})]}computeOutputShape(e){e=vn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],a=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=so(t,this.poolSize[0],this.padding,this.strides[0]),n=so(n,this.poolSize[1],this.padding,this.strides[1]),a=so(a,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return be(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ot(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},yI=class extends sM{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return _a(r),ss(a),aM(e,t,n,a,r,"max")}};yI.className="MaxPooling3D";We.registerClass(yI);var wI=class extends sM{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return _a(r),ss(a),aM(e,t,n,a,r,"avg")}};wI.className="AveragePooling3D";We.registerClass(wI);var oM=class extends sn{constructor(e){super(e),this.inputSpec=[new Oa({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new rn}},xI=class extends oM{constructor(e){super(e||{})}call(e,t){return be(()=>{let n=Ot(e);return ya(n,1)})}};xI.className="GlobalAveragePooling1D";We.registerClass(xI);var vI=class extends oM{constructor(e){super(e||{})}call(e,t){return be(()=>{let n=Ot(e);return ns(n,1)})}};vI.className="GlobalMaxPooling1D";We.registerClass(vI);var lM=class extends sn{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,_a(this.dataFormat),this.inputSpec=[new Oa({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new rn}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},SI=class extends lM{call(e,t){return be(()=>{let n=Ot(e);return this.dataFormat==="channelsLast"?ya(n,[1,2]):ya(n,[2,3])})}};SI.className="GlobalAveragePooling2D";We.registerClass(SI);var kI=class extends lM{call(e,t){return be(()=>{let n=Ot(e);return this.dataFormat==="channelsLast"?ns(n,[1,2]):ns(n,[2,3])})}};kI.className="GlobalMaxPooling2D";We.registerClass(kI);var uM=class extends sn{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let a=t.layer,r=io(a,n);delete t.layer;let i={layer:r};return Object.assign(i,t),new e(i)}},AI=class extends uM{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=vn(e),e.length<3)throw new we(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=vn(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return be(()=>(e=Ot(e),eM((n,a)=>[Ot(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};AI.className="TimeDistributed";We.registerClass(AI);function Bj(e){Uh(MY,"BidirectionalMergeMode",e)}var Lj="concat",EI=class extends uM{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=io(n),t.goBackwards=t.goBackwards!==!0;let a={};if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=io(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Lj:e.mergeMode,Bj(this.mergeMode),e.weights)throw new rn("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,a,r;return this.returnState&&(r=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,a=[n]):this.mergeMode==null?a=[n,n.slice()]:a=[n],this.returnState?this.mergeMode==null?a.concat(r).concat(r.slice()):[n].concat(r).concat(r.slice()):si(a)}apply(e,t){let n=t==null?null:t.initialState,a=t==null?null:t.constants;t==null&&(t={});let r=XO(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&a==null)return super.apply(e,t);let i=[],s=[];if(n!=null){let u=n.length;if(u%2>0)throw new we("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,i.push(...n);let d=n.map(c=>new Oa({shape:c.shape}));this.forwardLayer.stateSpec=d.slice(0,u/2),this.backwardLayer.stateSpec=d.slice(u/2),s.push(...d)}if(a!=null)throw new rn("Support for constants in Bidirectional layers is not implemented yet.");let o=i[0]instanceof uo;for(let u of i)if(u instanceof uo!==o)throw new we("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let u=[e].concat(i),d=this.inputSpec.concat(s),c=this.inputSpec;this.inputSpec=d;let h=super.apply(u,t);return this.inputSpec=c,h}else return super.apply(e,t)}call(e,t){return be(()=>{let n=t.initialState,a,r;if(n==null)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),u=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let i;this.returnState&&(Array.isArray(a)&&(i=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=is(r,1));let s;return this.mergeMode==="concat"?s=sC([a,r]):this.mergeMode==="sum"?s=Oe(a,r):this.mergeMode==="ave"?s=pe(.5,Oe(a,r)):this.mergeMode==="mul"?s=pe(a,r):this.mergeMode==null&&(s=[a,r]),this.returnState?this.mergeMode==null?s.concat(i):[s].concat(i):s})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Kd(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Kd(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let a=this.forwardLayer.states.map(r=>null);return Array.isArray(n)?n.concat(a).concat(a):[n].concat(a).concat(a)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=io(t.layer);if(delete t.layer,t.numConstants!=null)throw new rn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let a=t;return a.layer=n,new e(a)}};EI.className="Bidirectional";We.registerClass(EI);var CI=class extends sn{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return be(()=>(e=Ot(e),e.dtype!=="float32"&&(e=au(e,"float32")),Oe(pe(e,this.scale),this.offset)))}};CI.className="Rescaling";We.registerClass(CI);var{resizeBilinear:zj,cropAndResize:Uj}=Zi,II=class extends sn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,r,i,s,o){return be(()=>{let u,d=!1,c=t/i,h=n/s,m=(a+t)/i,g=(r+n)/s,x=[c,h,m,g],v=[];e.rank===3?(d=!0,u=Ba([e])):u=e;for(let T=0;T<u.shape[0];T++)v.push(x);let S=Pr(v,[v.length,4]),E=op(0,v.length,1,"int32"),C=Uj(u,S,E,[a,r],"nearest");return au(d?Ot(Aa(C)):C,o)})}upsize(e,t,n,a){return be(()=>{let r=zj(e,[t,n]);return au(r,a)})}call(e,t){return be(()=>{let n=Ot(e),a=n.dtype,r=n.shape,i=r[r.length-3],s=r[r.length-2],o=0;i!==this.height&&(o=Math.floor((i-this.height)/2));let u=0;return s!==this.width&&(u=Math.floor((s-this.width)/2),u===0&&(u=1)),o>=0&&u>=0?this.centerCrop(n,o,u,this.height,this.width,i,s,a):this.upsize(e,this.height,this.width,a)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=vn(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};II.className="CenterCrop";We.registerClass(II);function Vj(e,t,n,a){let r=Ot(e);if(r.dtype!=="int32"&&(r=au(r,"int32")),t==="int")return r;let i=r.shape;if(r.rank===0&&(r=sr(r,-1)),t==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=sr(r,-1)),r.rank>2)throw new we(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${r.rank}.`);let s=["multiHot","oneHot"].includes(t),o=r,u;if(typeof a<"u"&&t==="count"?u=C1(o,a,n,s):u=C1(o,[],n,s),t!=="tfIdf")return u;if(a)return pe(u,a);throw new we("When outputMode is 'tfIdf', weights must be provided.")}var _I=class extends sn{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=vn(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return be(()=>{e=Ot(e),e.dtype!=="int32"&&(e=au(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new we(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Ot(t.countWeights)}let a=ns(e),r=ym(e),i=Yr(this.numTokens,a).bufferSync().get(0),s=ou(r,0).bufferSync().get(0);if(!(i&&s))throw new we(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Vj(e,this.outputMode,this.numTokens,n)})}};_I.className="CategoryEncoding";We.registerClass(_I);var Wj=["bilinear","nearest"],rR=new Set(Wj),TI=class extends sn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(rR.has(e.interpolation))this.interpolation=e.interpolation;else throw new we(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=vn(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return be(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return Zi.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Zi.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...rR]} are supported`)})}};TI.className="Resizing";We.registerClass(TI);var cM=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};cM.className="RandomSeed";var dM=class extends sn{constructor(e){super(e),this.randomGenerator=new cM(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};dM.className="BaseRandomLayer";var qj=["bilinear","nearest"],iR=new Set(qj),NI=class extends dM{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new we(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new we(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new we(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(iR.has(n))this.interpolation=n;else throw new we(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=vn(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return be(()=>{let n=Ot(e);this.imgHeight=n.shape[n.shape.length-3];let a=n.shape[n.shape.length-2];this.widthFactor=Wc([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*a;r=Math.round(r);let i=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return Zi.resizeBilinear(e,i);case"nearest":return Zi.resizeNearestNeighbor(e,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...iR]} are supported`)}})}};NI.className="RandomWidth";We.registerClass(NI);function Pj(e){return new Pg(e)}function Hj(e){return new RC(e)}function Gj(e){return new _C(e)}function Kj(e){return new TC(e)}function $j(e){return new NC(e)}function Jj(e){return new DC(e)}function Yj(e){return new FC(e)}function jj(e){return new zC(e)}function Qj(e){return new pS(e)}function Zj(e){return new MC(e)}function Xj(e){return new hS(e)}function eQ(e){return new BC(e)}function tQ(e){return new LC(e)}function nQ(e){return new UC(e)}function aQ(e){return new VC(e)}function rQ(e){return new WC(e)}function iQ(e){return new YC(e)}function sQ(e){return new $C(e)}function oQ(e){return new yS(e)}function lQ(e){return new KC(e)}function uQ(e){return new JC(e)}function cQ(e){return new jC(e)}function dQ(e){return new QC(e)}function pQ(e){return new ZC(e)}function hQ(e){return new eI(e)}function fQ(e){return new tI(e)}function mQ(e){return new aI(e)}function gQ(e){return new sI(e)}function bQ(e){return new rI(e)}function yQ(e){return new iI(e)}function wQ(e){return new nI(e)}function xQ(e){return new oI(e)}function vQ(e){return new dI(e)}function SQ(e){return new pI(e)}function kQ(e){return new hI(e)}function RI(e){return new mI(e)}function AQ(e){return RI(e)}function EQ(e){return RI(e)}function FI(e){return new bI(e)}function CQ(e){return FI(e)}function IQ(e){return FI(e)}function DI(e){return new wI(e)}function _Q(e){return DI(e)}function TQ(e){return DI(e)}function NQ(e){return new xI(e)}function RQ(e){return new SI(e)}function pM(e){return new vI(e)}function hM(e){return new kI(e)}function fM(e){return new fI(e)}function mM(e){return new gI(e)}function FQ(e){return new yI(e)}function DQ(e){return new PC(e)}function OQ(e){return new mS(e)}function MQ(e){return new HC(e)}function BQ(e){return new iw(e)}function LQ(e){return new qC(e)}function zQ(e){return new fS(e)}function UQ(e){return new GC(e)}function VQ(e){return new bS(e)}function WQ(e){return new cu(e)}function qQ(e){return new gS(e)}function PQ(e){return new EI(e)}function HQ(e){return new AI(e)}var GQ=pM,KQ=hM,$Q=fM,JQ=mM;function YQ(e){return new lI(e)}function jQ(e){return new uI(e)}function QQ(e){return new cI(e)}function ZQ(e){return new XC(e)}function XQ(e){return new CI(e)}function eZ(e){return new II(e)}function tZ(e){return new TI(e)}function nZ(e){return new _I(e)}function aZ(e){return new NI(e)}var gM={};qt(gM,{MAPE:()=>fZ,MSE:()=>bZ,binaryAccuracy:()=>rZ,binaryCrossentropy:()=>iZ,categoricalAccuracy:()=>oZ,categoricalCrossentropy:()=>lZ,cosineProximity:()=>dZ,mape:()=>mZ,meanAbsoluteError:()=>pZ,meanAbsolutePercentageError:()=>hZ,meanSquaredError:()=>gZ,mse:()=>yZ,precision:()=>uZ,r2Score:()=>wZ,recall:()=>cZ,sparseCategoricalAccuracy:()=>sZ});function rZ(e,t){return SC(e,t)}function iZ(e,t){return wO(e,t)}function sZ(e,t){return xO(e,t)}function oZ(e,t){return kC(e,t)}function lZ(e,t){return AC(e,t)}function uZ(e,t){return yO(e,t)}function cZ(e,t){return W9(e,t)}function dZ(e,t){return vC(e,t)}function pZ(e,t){return lS(e,t)}function hZ(e,t){return Hg(e,t)}function fZ(e,t){return Hg(e,t)}function mZ(e,t){return Hg(e,t)}function gZ(e,t){return Vh(e,t)}function bZ(e,t){return Vh(e,t)}function yZ(e,t){return Vh(e,t)}function wZ(e,t){return q9(e,t)}var bM={};qt(bM,{modelFromJSON:()=>yj});var yM={};qt(yM,{l1:()=>vZ,l1l2:()=>xZ,l2:()=>SZ});function xZ(e){return new aw(e)}function vZ(e){return Ej(e)}function SZ(e){return Cj(e)}var wM=class extends Cm{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof eu))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function Yx(e,t){return e<t}function sR(e,t){return e>t}var xM=class extends wM{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new rn("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Yx:this.mode==="max"?this.monitorFunc=sR:this.monitor.indexOf("acc")!==-1?this.monitorFunc=sR:this.monitorFunc=Yx,this.monitorFunc===Yx&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Yx?1/0:-1/0}async onEpochEnd(e,t){await sc(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function kZ(e){return new xM(e)}var AZ={earlyStopping:kZ},EZ=Ae();EZ.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Ai;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(Ai||(Ai={}));var oR;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(oR||(oR={}));var OI={};function CZ(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};OI[e]=n}function vM(e){return OI[e]}function IZ(e){delete OI[e]}function B(e,t,n,a,r){let i=t.inputParams[e];if(i&&i.inputIndexStart!==void 0){let o=i.inputIndexStart,u=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?o+1:i.inputIndexEnd,d=o<0?t.inputNames.length+o:o;if(i.type==="tensor")return yr(t.inputNames[d],n,a,r);if(i.type==="tensors"){let m=t.inputs.slice(o,u);return t.inputNames.slice(o,u).filter((g,x)=>{var v;return((v=m[x])===null||v===void 0?void 0:v.op)!=="NoOp"}).map(g=>yr(g,n,a,r))}let c=yr(t.inputNames[d],n,a,r),h=c.dataSync();return i.type==="number"?h[0]:O.toNestedArray(c.shape,h)}let s=t.attrParams[e];return s&&s.value}function yr(e,t,n,a){let[r,i]=Ci(e,n);if(a!=null){let o=a.getHashTableHandleByName(r);if(o!=null)return o}let s=n.currentContextIds.find(o=>!!t[L1(r,o)]);return s!==void 0?t[L1(r,s)][i]:void 0}function lR(e,t,n){return t[L1(e,n.currentContextId)]}function Jl(e,t){let[n,a,r]=Ci(e,t);return[L1(n,t&&t.currentContextId),a,r]}function L1(e,t){return t?`${e}-${t}`:e}function Ci(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let i=t.parseNodeNameCache.get(e);if(i!=null)return i}let a=e.split(":"),r;if(a.length===1)r=[e,0,void 0];else{let i=a[0],s=a.length===3?a[1]:void 0,o=Number(a[a.length-1]);r=[i,o,s]}return n&&t.parseNodeNameCache.set(e,r),r}function u1(e,t,n){let a=B("pad",e,t,n);if(a==="explicit"){a=B("explicitPaddings",e,t,n);let r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=a[i*2],r[i][1]=a[i*2+1];return r}return a}function Yl(e){return e.kept?e:tl(e)}var SM={};qt(SM,{json:()=>_Z});var _Z=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],kM={};qt(kM,{json:()=>TZ});var TZ=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],AM={};qt(AM,{json:()=>NZ});var NZ=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],EM={};qt(EM,{json:()=>RZ});var RZ=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],CM={};qt(CM,{json:()=>FZ});var FZ=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],IM={};qt(IM,{json:()=>DZ});var DZ=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],_M={};qt(_M,{json:()=>OZ});var OZ=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],TM={};qt(TM,{json:()=>MZ});var MZ=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],NM={};qt(NM,{json:()=>BZ});var BZ=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],RM={};qt(RM,{json:()=>LZ});var LZ=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],FM={};qt(FM,{json:()=>zZ});var zZ=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],DM={};qt(DM,{json:()=>UZ});var UZ=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],OM={};qt(OM,{json:()=>VZ});var VZ=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],MM={};qt(MM,{json:()=>WZ});var WZ=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],BM={};qt(BM,{json:()=>qZ});var qZ=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],LM={};qt(LM,{json:()=>PZ});var PZ=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],zM={};qt(zM,{json:()=>HZ});var HZ=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],UM={};qt(UM,{json:()=>GZ});var GZ=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],VM={};qt(VM,{json:()=>KZ});var KZ=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],uR=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[SM,kM,AM,EM,CM,IM,_M,TM,NM,RM,FM,DM,OM,MM,BM,LM,zM,UM,VM],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,a)=>(n[a.tfOpName]=a,n),{})}transformGraph(e,t={}){let n=e.node,a=[],r=[],i=[],s=n.reduce((x,v)=>(x[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?a.push(x[v.name]):v.op==="Const"?r.push(x[v.name]):(v.input==null||v.input.length===0)&&i.push(x[v.name]),x),{}),o=[],u=[],d={},c={};t!=null&&(d=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let h=Object.keys(s);h.forEach(x=>{let v=s[x];v.inputNames.forEach((S,E)=>{let[C,,T]=Jl(S),N=s[C];if(N.outputs!=null){let D=N.outputs.indexOf(T);if(D!==-1){let q=`${C}:${D}`;v.inputNames[E]=q}}v.inputs.push(N),N.children.push(v)})}),Object.keys(c).length===0?h.forEach(x=>{let v=s[x];v.children.length===0&&u.push(v)}):Object.keys(c).forEach(x=>{let[v]=Jl(x),S=s[v];S!=null&&(S.signatureKey=c[x],u.push(S))}),Object.keys(d).length>0?Object.keys(d).forEach(x=>{let[v]=Jl(x),S=s[v];S&&(S.signatureKey=d[x],o.push(S))}):o=a;let m={};e.library!=null&&e.library.function!=null&&(m=e.library.function.reduce((x,v)=>(x[v.signature.name]=this.mapFunction(v),x),{}));let g={nodes:s,inputs:o,outputs:u,weights:r,placeholders:a,signature:t,functions:m};return i.length>0&&(g.initNodes=i),g}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=vM(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(a=>a.startsWith("^")?a.slice(1):a),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((a,r)=>(a[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},a),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((a,r)=>{let i=r.type,s;switch(r.type){case"string":s=Kk(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=Kk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":s=Xk(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=Xk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":s=Jk(e.attr,r.tfName,r.defaultValue||0),s===void 0&&r.tfDeprecatedName&&(s=Jk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":s=Zk(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=Zk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":s=$k(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=$k(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":s=tA(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=tA(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":s=Qk(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=Qk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":s=eA(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=eA(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":s=Yk(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=Yk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":s=jk(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=jk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":s=cR(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=cR(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return a[r.name]={value:s,type:i},a},{})),n}mapFunction(e){let t=e.nodeDef,n=[],a=[],r={};t!=null&&(r=t.reduce((d,c)=>(d[c.name]=this.mapNode(c),c.op==="Const"&&a.push(d[c.name]),d),{}));let i=[],s=[];e.signature.inputArg.forEach(d=>{let[c]=Jl(d.name),h={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:MI(d.type),type:"dtype"}},children:[]};h.signatureKey=d.name,i.push(h),r[c]=h}),Object.keys(r).forEach(d=>{let c=r[d];c.inputNames.forEach((h,m)=>{let[g,,x]=Jl(h),v=r[g];if(v.outputs!=null){let S=v.outputs.indexOf(x);if(S!==-1){let E=`${g}:${S}`;c.inputNames[m]=E}}c.inputs.push(v),v.children.push(c)})});let o=e.ret;e.signature.outputArg.forEach(d=>{let[c,h]=Jl(o[d.name]),m=r[c];m!=null&&(m.defaultOutput=h,s.push(m))});let u=this.mapArgsToSignature(e);return{nodes:r,inputs:i,outputs:s,weights:a,placeholders:n,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function $Z(e){let t=Ae().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function WM(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):$Z(e);return t?n:n.toLowerCase()}function Kk(e,t,n,a=!1){let r=e[t];return r!=null?WM(r.s,a):n}function $k(e,t,n){let a=e[t];return a?a.b:n}function Jk(e,t,n){let a=e[t]||{},r=a.i!=null?a.i:a.f!=null?a.f:n;return typeof r=="number"?r:parseInt(r,10)}function MI(e){switch(typeof e=="string"&&(e=Ai[e]),e){case Ai.DT_FLOAT:case Ai.DT_HALF:return"float32";case Ai.DT_INT32:case Ai.DT_INT64:case Ai.DT_INT8:case Ai.DT_UINT8:return"int32";case Ai.DT_BOOL:return"bool";case Ai.DT_DOUBLE:return"float32";case Ai.DT_STRING:return"string";case Ai.DT_COMPLEX64:case Ai.DT_COMPLEX128:return"complex64";default:return null}}function cR(e,t,n){let a=e[t];return a&&a.func?a.func.name:n}function Yk(e,t,n){let a=e[t];return a&&a.type?MI(a.type):n}function jk(e,t,n){let a=e[t];return a&&a.list&&a.list.type?a.list.type.map(r=>MI(r)):n}function qM(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function Qk(e,t,n){let a=e[t];return a&&a.shape?qM(a.shape):n}function Zk(e,t,n){let a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function Xk(e,t,n,a=!1){let r=e[t];return r&&r.list&&r.list.s?r.list.s.map(i=>WM(i,a)):n}function eA(e,t,n){let a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(r=>qM(r)):n}function tA(e,t,n){let a=e[t];return a&&a.list&&a.list.b?a.list.b:n}var JZ=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(a=>this.getInput(a)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((a,r)=>(a[r]=this.getAttr(r),a),{}))}getInput(e){return yr(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return yr(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return Jk(this.node.rawAttrs,e,t);if(n.s!=null)return Kk(this.node.rawAttrs,e,t);if(n.b!=null)return $k(this.node.rawAttrs,e,t);if(n.shape!=null)return Qk(this.node.rawAttrs,e,t);if(n.type!=null)return Yk(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return Zk(this.node.rawAttrs,e,t);if(n.list.s!=null)return Xk(this.node.rawAttrs,e,t);if(n.list.shape!=null)return eA(this.node.rawAttrs,e,t);if(n.list.b!=null)return tA(this.node.rawAttrs,e,t);if(n.list.type!=null)return jk(this.node.rawAttrs,e,t)}return t}},dr={};qt(dr,{OP_SCOPE_SUFFIX:()=>LA,abs:()=>Da,acos:()=>qA,acosh:()=>PA,add:()=>Oe,addN:()=>nF,all:()=>xv,any:()=>jy,argMax:()=>ap,argMin:()=>HA,asin:()=>GA,asinh:()=>KA,atan:()=>$A,atan2:()=>JA,atanh:()=>YA,avgPool:()=>su,avgPool3d:()=>QA,basicLSTMCell:()=>sF,batchNorm:()=>Mh,batchNorm2d:()=>ZA,batchNorm3d:()=>XA,batchNorm4d:()=>eE,batchToSpaceND:()=>z0,bincount:()=>tE,bitwiseAnd:()=>oF,booleanMaskAsync:()=>jF,broadcastArgs:()=>lF,broadcastTo:()=>Gd,buffer:()=>Zt,cast:()=>je,ceil:()=>nE,clipByValue:()=>Rr,clone:()=>tl,complex:()=>nu,concat:()=>Gn,concat1d:()=>aE,concat2d:()=>rE,concat3d:()=>iE,concat4d:()=>sE,conv1d:()=>vv,conv2d:()=>Hr,conv2dTranspose:()=>Sv,conv3d:()=>lE,conv3dTranspose:()=>uE,cos:()=>U0,cosh:()=>kv,cosineWindow:()=>Kv,cumprod:()=>Xy,cumsum:()=>Av,denseBincount:()=>C1,depthToSpace:()=>cE,depthwiseConv2d:()=>Bh,diag:()=>cF,dilation2d:()=>dE,div:()=>it,divNoNan:()=>pE,dot:()=>hE,dropout:()=>qE,einsum:()=>Ud,elu:()=>Bg,enclosingPowerOfTwo:()=>PE,ensureShape:()=>pF,equal:()=>Fi,erf:()=>Ev,euclideanNorm:()=>gE,exp:()=>Fr,expandDims:()=>sr,expm1:()=>bE,eye:()=>Cv,fft:()=>Y0,fill:()=>Ni,floor:()=>zg,floorDiv:()=>wv,fused:()=>Am,gather:()=>Ug,gatherND:()=>eD,greater:()=>Yr,greaterEqual:()=>ou,ifft:()=>km,imag:()=>V0,image:()=>Zi,inTopKAsync:()=>tD,irfft:()=>Uv,isFinite:()=>yE,isInf:()=>wE,isNaN:()=>xE,leakyRelu:()=>W0,less:()=>wm,lessEqual:()=>Vc,linalg:()=>KE,linspace:()=>bF,localResponseNormalization:()=>vE,log:()=>Di,log1p:()=>q0,logSigmoid:()=>SE,logSoftmax:()=>_v,logSumExp:()=>P0,logicalAnd:()=>Rs,logicalNot:()=>H0,logicalOr:()=>Tv,logicalXor:()=>kE,losses:()=>hD,lowerBound:()=>wF,matMul:()=>jt,max:()=>ns,maxPool:()=>ar,maxPool3d:()=>AE,maxPoolWithArgmax:()=>xF,maximum:()=>ul,mean:()=>ya,meshgrid:()=>vF,min:()=>ym,minimum:()=>Ac,mirrorPad:()=>EE,mod:()=>CE,moments:()=>G0,movingAverage:()=>QF,mul:()=>pe,multiRNNCell:()=>SF,multinomial:()=>kF,neg:()=>ia,norm:()=>Lg,notEqual:()=>sp,oneHot:()=>xm,ones:()=>oi,onesLike:()=>Oi,op:()=>le,outerProduct:()=>AF,pad:()=>ho,pad1d:()=>EF,pad2d:()=>CF,pad3d:()=>IF,pad4d:()=>_F,pool:()=>IE,pow:()=>il,prelu:()=>$0,print:()=>WA,prod:()=>_E,raggedGather:()=>TF,raggedRange:()=>NF,raggedTensorToTensor:()=>RF,rand:()=>FF,randomGamma:()=>BF,randomNormal:()=>Rv,randomStandardNormal:()=>LF,randomUniform:()=>Wc,randomUniformInt:()=>zF,range:()=>op,real:()=>vm,reciprocal:()=>DE,relu:()=>zn,relu6:()=>Fv,reshape:()=>ge,reverse:()=>is,reverse1d:()=>UF,reverse2d:()=>VF,reverse3d:()=>WF,reverse4d:()=>qF,rfft:()=>j0,round:()=>Dv,rsqrt:()=>Ov,scalar:()=>gt,scatterND:()=>ZF,searchSorted:()=>Nv,selu:()=>Mv,separableConv2d:()=>Vg,setdiff1dAsync:()=>PF,sigmoid:()=>Ns,sign:()=>OE,signal:()=>pD,sin:()=>Bv,sinh:()=>Lv,slice:()=>un,slice1d:()=>J0,slice2d:()=>zv,slice3d:()=>Wg,slice4d:()=>Sm,softmax:()=>qc,softplus:()=>Lh,spaceToBatchND:()=>K0,sparse:()=>fD,sparseToDense:()=>XF,spectral:()=>dD,split:()=>li,sqrt:()=>ur,square:()=>Hn,squaredDifference:()=>Vv,squeeze:()=>Pc,stack:()=>Ba,step:()=>zh,stridedSlice:()=>ME,string:()=>mD,sub:()=>at,sum:()=>lt,tan:()=>BE,tanh:()=>kc,tensor:()=>Pr,tensor1d:()=>Dn,tensor2d:()=>nl,tensor3d:()=>Wv,tensor4d:()=>Ec,tensor5d:()=>HF,tensor6d:()=>GF,tensorScatterUpdate:()=>$F,tile:()=>Ti,topk:()=>zE,transpose:()=>Qt,truncatedNormal:()=>Hv,unique:()=>UE,unsortedSegmentSum:()=>Gv,unstack:()=>Aa,upperBound:()=>JF,variable:()=>VE,where:()=>lr,whereAsync:()=>WE,zeros:()=>wa,zerosLike:()=>gn});var YZ=(e,t,n,a=dr)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(B("a",e,t,n),B("b",e,t,n))];case"AddN":return[a.addN(B("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(B("a",e,t,n),B("b",e,t,n))];case"Mul":return[a.mul(B("a",e,t,n),B("b",e,t,n))];case"RealDiv":case"Div":return[a.div(B("a",e,t,n),B("b",e,t,n))];case"DivNoNan":return[a.divNoNan(B("a",e,t,n),B("b",e,t,n))];case"FloorDiv":return[a.floorDiv(B("a",e,t,n),B("b",e,t,n))];case"Sub":return[a.sub(B("a",e,t,n),B("b",e,t,n))];case"Minimum":return[a.minimum(B("a",e,t,n),B("b",e,t,n))];case"Maximum":return[a.maximum(B("a",e,t,n),B("b",e,t,n))];case"Pow":return[a.pow(B("a",e,t,n),B("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(B("a",e,t,n),B("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},jZ=(e,t,n,a=dr)=>{switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(B("x",e,t,n))];case"Acos":return[a.acos(B("x",e,t,n))];case"Acosh":return[a.acosh(B("x",e,t,n))];case"Asin":return[a.asin(B("x",e,t,n))];case"Asinh":return[a.asinh(B("x",e,t,n))];case"Atan":return[a.atan(B("x",e,t,n))];case"Atan2":return[a.atan2(B("x",e,t,n),B("y",e,t,n))];case"Atanh":return[a.atanh(B("x",e,t,n))];case"Ceil":return[a.ceil(B("x",e,t,n))];case"Complex":return[a.complex(B("real",e,t,n),B("imag",e,t,n))];case"Cos":return[a.cos(B("x",e,t,n))];case"Cosh":return[a.cosh(B("x",e,t,n))];case"Elu":return[a.elu(B("x",e,t,n))];case"Erf":return[a.erf(B("x",e,t,n))];case"Exp":return[a.exp(B("x",e,t,n))];case"Expm1":return[a.expm1(B("x",e,t,n))];case"Floor":return[a.floor(B("x",e,t,n))];case"Log":return[a.log(B("x",e,t,n))];case"Log1p":return[a.log1p(B("x",e,t,n))];case"Imag":return[a.imag(B("x",e,t,n))];case"Neg":return[a.neg(B("x",e,t,n))];case"Reciprocal":return[a.reciprocal(B("x",e,t,n))];case"Real":return[a.real(B("x",e,t,n))];case"Relu":return[a.relu(B("x",e,t,n))];case"Round":return[a.round(B("x",e,t,n))];case"Selu":return[a.selu(B("x",e,t,n))];case"Sigmoid":return[a.sigmoid(B("x",e,t,n))];case"Sin":return[a.sin(B("x",e,t,n))];case"Sign":return[a.sign(B("x",e,t,n))];case"Sinh":return[a.sinh(B("x",e,t,n))];case"Softplus":return[a.softplus(B("x",e,t,n))];case"Sqrt":return[a.sqrt(B("x",e,t,n))];case"Square":return[a.square(B("x",e,t,n))];case"Tanh":return[a.tanh(B("x",e,t,n))];case"Tan":return[a.tan(B("x",e,t,n))];case"ClipByValue":return[a.clipByValue(B("x",e,t,n),B("clipValueMin",e,t,n),B("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(B("x",e,t,n))];case"Rsqrt":return[a.rsqrt(yr(e.inputNames[0],t,n))];case"LeakyRelu":return[a.leakyRelu(B("x",e,t,n),B("alpha",e,t,n))];case"Prelu":return[a.prelu(B("x",e,t,n),B("alpha",e,t,n))];case"IsNan":return[a.isNaN(yr(e.inputNames[0],t,n))];case"IsInf":return[a.isInf(yr(e.inputNames[0],t,n))];case"IsFinite":return[a.isFinite(yr(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Ts(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){O.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let a=0;a<e.length;a++){let r=e[a],i=t[a];O.assert(r<0||i<0||r===i,()=>n+` Shapes ${e} and ${t} must match`)}}}function dR(e){return!(typeof e=="number"||e.some(t=>t<0))}function by(e,t,n){let a=nA(e,n),r=!dR(a);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);if(r&&t.forEach(i=>{a=nA(i.shape,a)}),!dR(a))throw new Error(`Non-fully-defined elementShape: ${a}`);return a}function nA(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let a=0;a<e.length;++a){let r=e[a],i=t[a];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[a]=r>=0?r:i}return n}var QZ=class{constructor(e,t,n,a,r,i,s){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=i,this.clearAfterRead=s,this.tensors=[],this.closed_=!1,this.idTensor=gt(0),Ga(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ts(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Ga(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,a)=>this.write(n,t[a]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let a=0;a<this.size();a++)e.push(a)}if(e.length===0)return Pr([],[0].concat(this.elementShape));let n=this.readMany(e);return Ts(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Ba(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Pr([],[0].concat(this.elementShape));let t=[];for(let a=0;a<this.size();a++)t.push(a);let n=this.readMany(t);return Ts(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Gn(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Aa(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,a=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let r=n===0?0:t.size/n,i=[];be(()=>{t=ge(t,[1,n,r]);for(let o=0;o<e.length;++o){let u=[0,o===0?0:a[o-1],0],d=[1,e[o],r];i[o]=ge(un(t,u,d),this.elementShape)}return i});let s=[];for(let o=0;o<e.length;o++)s[o]=o;this.writeMany(s,i)}},xS=class aA{get id(){return this.idTensor.id}constructor(t,n,a,r=-1){this.tensors=t,this.elementShape=n,this.elementDtype=a,t!=null&&t.forEach(i=>{if(a!==i.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${i.dtype}`);Ts(n,i.shape,"TensorList shape mismatch: "),Ga(i)}),this.idTensor=gt(0),this.maxNumElements=r,Ga(this.idTensor)}copy(){return new aA([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,a=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(a!==-1&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);Ts(t,this.elementShape,"TensorList shape mismatch: ");let r=by(this.elementShape,this.tensors,t);return be(()=>{let i=this.tensors.map(s=>ge(s,r));return Ba(i,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let a=by(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,Ts(r.shape,t,"TensorList shape mismatch: "),ge(r,a)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Ts(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ga(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new aA([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let a=0;a<Math.min(this.tensors.length,t);++a)n.tensors[a]=this.tensors[a];return n}getItem(t,n,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Ts(this.tensors[t].shape,n,"TensorList shape mismatch: ");let r=by(this.elementShape,this.tensors,n);return ge(this.tensors[t],r)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Ts(this.elementShape,n.shape,"TensorList shape mismatch: "),Ga(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,a){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Ts(this.elementShape,a,"TensorList shape mismatch: "),t=t.slice(0,this.size());let r=by(this.elementShape,this.tensors,a);return t.length===0?Pr([],[0].concat(r)):be(()=>{let i=t.map(s=>ge(this.tensors[s],r));return Ba(i,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Ts(this.elementShape,n,"TensorList shape mismatch: ");let a=by(this.elementShape,this.tensors,n);return this.size()===0?Pr([],[0].concat(a)):be(()=>{let r=this.tensors.map(i=>ge(i,a));return Gn(r,0)})}};function ZZ(e,t,n){let a=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let r=e.shape.slice(1);Ts(r,t,"TensorList shape mismatch: ");let i=Aa(e);return new xS(i,t,a)}function XZ(e,t,n,a){return new xS([],e,t,a)}function eX(e,t,n,a){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let r=Math.max(...t);if(a!=null&&a!==-1&&r>=a)throw new Error(`Max index must be < array size (${r}  vs. ${a})`);let i=new xS([],n,e.dtype,a),s=Aa(e,0);return t.forEach((o,u)=>{i.setItem(o,s[u])}),i}function tX(e,t,n){let a=0,r=t.map(c=>(a+=c,a));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${a}, and tensor's shape is: ${e.shape}`);let i=e.shape.slice(1),s=nA(i,n),o=a===0?0:e.size/a,u=be(()=>{let c=[];e=ge(e,[1,a,o]);for(let h=0;h<t.length;++h){let m=[0,h===0?0:r[h-1],0],g=[1,t[h],o];c[h]=ge(un(e,m,g),s)}return e.dispose(),c}),d=new xS([],n,e.dtype,t.length);for(let c=0;c<u.length;c++)d.setItem(c,u[c]);return d}var nX=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let a=B("thenBranch",e,t,n),r=B("elseBranch",e,t,n),i=B("cond",e,t,n),s=B("args",e,t,n);return(await i.data())[0]?n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let a=B("body",e,t,n),r=B("cond",e,t,n),i=B("args",e,t,n),s=await n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap),o=i.map(c=>c.id),u=await s[0].data();s.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let d=i;for(;u[0];){let c=d;d=await n.functionMap[a].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap);let h=d.map(g=>g.id);c.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&h.indexOf(g.id)===-1&&g.dispose()});let m=await n.functionMap[r].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap);u=await m[0].data(),m.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&h.indexOf(g.id)===-1&&g.dispose()})}return d}case"LoopCond":{let a=B("pred",e,t,n);return[Yl(a)]}case"Switch":{let a=B("pred",e,t,n),r=B("data",e,t,n);return r.kept||(r=Yl(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{let a=e.inputNames.find(r=>yr(r,t,n)!==void 0);if(a){let r=yr(a,t,n);return[Yl(r)]}return}case"Enter":{let a=B("frameName",e,t,n),r=B("tensor",e,t,n);return n.enterFrame(a),[Yl(r)]}case"Exit":{let a=B("tensor",e,t,n);return n.exitFrame(),[Yl(a)]}case"NextIteration":{let a=B("tensor",e,t,n);return n.nextIteration(),[Yl(a)]}case"TensorArrayV3":{let a=B("size",e,t,n),r=B("dtype",e,t,n),i=B("elementShape",e,t,n),s=B("dynamicSize",e,t,n),o=B("clearAfterRead",e,t,n),u=B("identicalElementShapes",e,t,n),d=B("name",e,t,n),c=new QZ(d,r,a,i,u,s,o);return n.addTensorArray(c),[c.idTensor,gt(1)]}case"TensorArrayWriteV3":{let a=B("tensorArrayId",e,t,n),r=B("index",e,t,n),i=B("tensor",e,t,n),s=n.getTensorArray(a.id);return s.write(r,i),[s.idTensor]}case"TensorArrayReadV3":{let a=B("tensorArrayId",e,t,n),r=B("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{let a=B("tensorArrayId",e,t,n),r=B("indices",e,t,n),i=B("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,i)]}case"TensorArrayScatterV3":{let a=B("tensorArrayId",e,t,n),r=B("indices",e,t,n),i=B("tensor",e,t,n),s=n.getTensorArray(a.id);return s.scatter(r,i),[s.idTensor]}case"TensorArrayConcatV3":{let a=B("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),i=B("dtype",e,t,n);return[r.concat(i)]}case"TensorArraySplitV3":{let a=B("tensorArrayId",e,t,n),r=B("tensor",e,t,n),i=B("lengths",e,t,n),s=n.getTensorArray(a.id);return s.split(i,r),[s.idTensor]}case"TensorArraySizeV3":{let a=B("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return[gt(r.size(),"int32")]}case"TensorArrayCloseV3":{let a=B("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{let a=B("tensorListId",e,t,n),r=B("index",e,t,n),i=B("tensor",e,t,n),s=n.getTensorList(a.id);return s.setItem(r,i),[s.idTensor]}case"TensorListGetItem":{let a=B("tensorListId",e,t,n),r=B("index",e,t,n),i=B("elementShape",e,t,n),s=B("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,i,s)]}case"TensorListScatterV2":case"TensorListScatter":{let a=B("indices",e,t,n),r=B("tensor",e,t,n),i=B("elementShape",e,t,n),s=B("numElements",e,t,n),o=eX(r,a,i,s);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let a=B("elementShape",e,t,n),r=B("elementDType",e,t,n),i;e.op==="TensorListReserve"?i="numElements":i="maxNumElements";let s=B(i,e,t,n),o=e.op==="TensorListReserve"?-1:s,u=XZ(a,r,s,o);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{let a=B("tensorListId",e,t,n),r=B("indices",e,t,n),i=B("elementShape",e,t,n),s=B("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,s,i)]}case"TensorListStack":{let a=B("tensorListId",e,t,n),r=B("elementShape",e,t,n),i=B("elementDType",e,t,n),s=B("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,i,s)]}case"TensorListFromTensor":{let a=B("tensor",e,t,n),r=B("elementShape",e,t,n),i=B("elementDType",e,t,n),s=ZZ(a,r,i);return n.addTensorList(s),[s.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let a=B("tensorListId",e,t,n),r=n.getTensorList(a.id),i=B("dtype",e,t,n),s=B("elementShape",e,t,n);return[r.concat(i,s)]}case"TensorListPushBack":{let a=B("tensorListId",e,t,n),r=B("tensor",e,t,n),i=n.getTensorList(a.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{let a=B("tensorListId",e,t,n),r=B("elementShape",e,t,n),i=B("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,i)]}case"TensorListSplit":{let a=B("tensor",e,t,n),r=B("elementShape",e,t,n),i=B("lengths",e,t,n),s=tX(a,i,r);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{let a=B("tensorListId",e,t,n),r=n.getTensorList(a.id);return[gt(r.size(),"int32")]}case"TensorListResize":{let a=B("tensorListId",e,t,n),r=B("size",e,t,n),i=n.getTensorList(a.id).resize(r);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function pR(e,t,n){let[a,r]=B("fusedOps",e,t,n),i=a==="biasadd",s=!i,o=r==="prelu",u=a==="fusedbatchnorm",d=B("numArgs",e,t,n);if(i){if(o&&d!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i&&d!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=B("strides",e,t,n),h=u1(e,t,n),m=B("dataFormat",e,t,n).toUpperCase(),g=B("dilations",e,t,n),[x,v]=B("args",e,t,n);s&&(v=x,x=void 0);let S=B("leakyreluAlpha",e,t,n);return{stride:c,pad:h,dataFormat:m,dilations:g,biasArg:x,preluArg:v,activationFunc:r,leakyreluAlpha:S}}var aX=(e,t,n,a=dr)=>{switch(e.op){case"Conv1D":{let r=B("stride",e,t,n),i=B("pad",e,t,n),s=B("dataFormat",e,t,n).toUpperCase(),o=B("dilation",e,t,n);return[a.conv1d(B("x",e,t,n),B("filter",e,t,n),r,i,s,o)]}case"Conv2D":{let r=B("strides",e,t,n),i=u1(e,t,n),s=B("dataFormat",e,t,n).toUpperCase(),o=B("dilations",e,t,n);return[a.conv2d(B("x",e,t,n),B("filter",e,t,n),[r[1],r[2]],i,s,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:r,pad:i,dataFormat:s,dilations:o,biasArg:u,preluArg:d,activationFunc:c,leakyreluAlpha:h}=pR(e,t,n);return[a.fused.conv2d({x:B("x",e,t,n),filter:B("filter",e,t,n),strides:[r[1],r[2]],pad:i,dataFormat:s,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:d,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:i,dataFormat:s,dilations:o,biasArg:u,preluArg:d,activationFunc:c,leakyreluAlpha:h}=pR(e,t,n);return[a.fused.depthwiseConv2d({x:B("x",e,t,n),filter:B("filter",e,t,n),strides:[r[1],r[2]],pad:i,dataFormat:s,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:d,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=B("outputShape",e,t,n),i=B("strides",e,t,n),s=u1(e,t,n);return[a.conv2dTranspose(B("x",e,t,n),B("filter",e,t,n),r,[i[1],i[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=B("strides",e,t,n),i=u1(e,t,n),s=B("dilations",e,t,n),o=B("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(B("input",e,t,n),B("filter",e,t,n),[r[1],r[2]],i,o,[s[1],s[2]])]}case"Conv3D":{let r=B("strides",e,t,n),i=B("pad",e,t,n),s=B("dataFormat",e,t,n).toUpperCase(),o=B("dilations",e,t,n);return[a.conv3d(B("x",e,t,n),B("filter",e,t,n),[r[1],r[2],r[3]],i,s,[o[1],o[2],o[3]])]}case"AvgPool":{let r=B("strides",e,t,n),i=B("pad",e,t,n),s=B("kernelSize",e,t,n);return[a.avgPool(B("x",e,t,n),[s[1],s[2]],[r[1],r[2]],i)]}case"MaxPool":{let r=B("strides",e,t,n),i=B("pad",e,t,n),s=B("kernelSize",e,t,n);return[a.maxPool(B("x",e,t,n),[s[1],s[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{let r=B("strides",e,t,n),i=B("pad",e,t,n),s=B("kernelSize",e,t,n),o=B("includeBatchInIndex",e,t,n),{result:u,indexes:d}=a.maxPoolWithArgmax(B("x",e,t,n),[s[1],s[2]],[r[1],r[2]],i,o);return[u,d]}case"AvgPool3D":{let r=B("strides",e,t,n),i=B("pad",e,t,n),s=B("kernelSize",e,t,n);return[a.avgPool3d(B("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{let r=B("strides",e,t,n),i=B("pad",e,t,n),s=B("kernelSize",e,t,n);return[a.maxPool3d(B("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{let r=B("strides",e,t,n),i=B("pad",e,t,n),s=B("dilations",e,t,n),o=r[1],u=r[2],d=s[1],c=s[2];return[a.dilation2d(B("x",e,t,n),B("filter",e,t,n),[o,u],i,[d,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},rX=(e,t,n,a=dr)=>{switch(e.op){case"Fill":{let r=B("shape",e,t,n),i=B("dtype",e,t,n),s=B("value",e,t,n);return[a.fill(r,s,i)]}case"LinSpace":{let r=B("start",e,t,n),i=B("stop",e,t,n),s=B("num",e,t,n);return[a.linspace(r,i,s)]}case"Multinomial":{let r=B("logits",e,t,n),i=B("numSamples",e,t,n),s=B("seed",e,t,n);return[a.multinomial(r,i,s)]}case"OneHot":{let r=B("indices",e,t,n),i=B("depth",e,t,n),s=B("onValue",e,t,n),o=B("offValue",e,t,n),u=B("dtype",e,t,n);return[a.oneHot(r,i,s,o,u)]}case"Ones":return[a.ones(B("shape",e,t,n),B("dtype",e,t,n))];case"OnesLike":return[a.onesLike(B("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(B("shape",e,t,n),B("dtype",e,t,n),B("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(B("shape",e,t,n),B("minval",e,t,n),B("maxval",e,t,n),B("dtype",e,t,n))];case"RandomUniformInt":return[a.randomUniformInt(B("shape",e,t,n),B("minval",e,t,n),B("maxval",e,t,n),B("seed",e,t,n))];case"Range":{let r=B("start",e,t,n),i=B("stop",e,t,n),s=B("step",e,t,n);return[a.range(r,i,s,B("dtype",e,t,n))]}case"TruncatedNormal":{let r=B("shape",e,t,n),i=B("mean",e,t,n),s=B("stdDev",e,t,n),o=B("seed",e,t,n);return[a.truncatedNormal(r,i,s,B("dtype",e,t,n),o)]}case"Zeros":return[a.zeros(B("shape",e,t,n),B("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(B("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function sk(e,t,n){let a=B("boxes",e,t,n),r=B("scores",e,t,n),i=B("maxOutputSize",e,t,n),s=B("iouThreshold",e,t,n),o=B("scoreThreshold",e,t,n),u=B("softNmsSigma",e,t,n);return{boxes:a,scores:r,maxOutputSize:i,iouThreshold:s,scoreThreshold:o,softNmsSigma:u}}var iX=async(e,t,n,a,r=dr)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:i,scores:s,maxOutputSize:o,iouThreshold:u,scoreThreshold:d,softNmsSigma:c}=sk(e,t,n),h=await r.image.nonMaxSuppressionWithScoreAsync(i,s,o,u,d,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:i,scores:s,maxOutputSize:o,iouThreshold:u,scoreThreshold:d}=sk(e,t,n),c=B("padToMaxOutputSize",e,t,n),h=await r.image.nonMaxSuppressionPaddedAsync(i,s,o,u,d,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:i,scores:s,maxOutputSize:o,iouThreshold:u,scoreThreshold:d}=sk(e,t,n);return[await r.image.nonMaxSuppressionAsync(i,s,o,u,d)]}case"Where":{let i=r.cast(B("condition",e,t,n),"bool"),s=[await r.whereAsync(i)];return i.dispose(),s}case"ListDiff":return r.setdiff1dAsync(B("x",e,t,n),B("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},sX=(e,t,n,a=dr)=>{switch(e.op){case"LowerBound":{let r=B("sortedSequence",e,t,n),i=B("values",e,t,n);return[a.lowerBound(r,i)]}case"TopKV2":{let r=B("x",e,t,n),i=B("k",e,t,n),s=B("sorted",e,t,n),o=a.topk(r,i,s);return[o.values,o.indices]}case"UpperBound":{let r=B("sortedSequence",e,t,n),i=B("values",e,t,n);return[a.upperBound(r,i)]}case"Unique":{let r=B("x",e,t,n),i=a.unique(r);return[i.values,i.indices]}case"UniqueV2":{let r=B("x",e,t,n),i=B("axis",e,t,n),s=a.unique(r,i);return[s.values,s.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},oX=(e,t,n,a=dr)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=B("default",e,t,n);return[yr(e.name,t,n)||r];case"Placeholder":return[yr(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=B("x",e,t,n);return[Yl(c)]}case"IdentityN":return B("x",e,t,n).map(c=>Yl(c));case"Snapshot":let i=B("x",e,t,n);return[Yl(i)];case"Shape":return[a.tensor1d(B("x",e,t,n).shape,"int32")];case"ShapeN":return B("x",e,t,n).map(c=>a.tensor1d(c.shape));case"Size":return[a.scalar(B("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(B("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":let s=B("x",e,t,n),o=B("data",e,t,n),u=B("message",e,t,n),d=B("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,d));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}},lX=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=gt(0),this.tensorMap=new Map,Ga(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return gt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(a=>a.dispose()),this.tensorMap.clear(),be(()=>{let a=Aa(t),r=n.length,i=a.length;O.assert(r===i,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${i} elements.`);for(let s=0;s<r;s++){let o=n[s],u=a[s];Ga(u),this.tensorMap.set(o,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return be(()=>{let a=[];for(let r=0;r<n.length;r++){let i=n[r],s=this.findWithDefault(i,t);a.push(s)}return Ba(a)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},uX=async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{let r=a.getHashTableHandleByName(e.name);if(r!=null)return[r];{let i=B("keyDType",e,t,n),s=B("valueDType",e,t,n),o=new lX(i,s);return a.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let r=B("tableHandle",e,t,n,a),i=B("keys",e,t,n),s=B("values",e,t,n);return[await a.getHashTableById(r.id).import(i,s)]}case"LookupTableFind":case"LookupTableFindV2":{let r=B("tableHandle",e,t,n,a),i=B("keys",e,t,n),s=B("defaultValue",e,t,n);return[await a.getHashTableById(r.id).find(i,s)]}case"LookupTableSize":case"LookupTableSizeV2":{let r=B("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},cX=(e,t,n,a=dr)=>{switch(e.op){case"ResizeBilinear":{let r=B("images",e,t,n),i=B("size",e,t,n),s=B("alignCorners",e,t,n),o=B("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(r,[i[0],i[1]],s,o)]}case"ResizeNearestNeighbor":{let r=B("images",e,t,n),i=B("size",e,t,n),s=B("alignCorners",e,t,n),o=B("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(r,[i[0],i[1]],s,o)]}case"CropAndResize":{let r=B("image",e,t,n),i=B("boxes",e,t,n),s=B("boxInd",e,t,n),o=B("cropSize",e,t,n),u=B("method",e,t,n),d=B("extrapolationValue",e,t,n);return[a.image.cropAndResize(r,i,s,o,u,d)]}case"ImageProjectiveTransformV3":{let r=B("images",e,t,n),i=B("transforms",e,t,n),s=B("outputShape",e,t,n),o=B("fillValue",e,t,n),u=B("interpolation",e,t,n),d=B("fillMode",e,t,n);return[a.image.transform(r,i,u.toLowerCase(),d.toLowerCase(),o,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},dX=(e,t,n,a=dr)=>{switch(e.op){case"Equal":return[a.equal(B("a",e,t,n),B("b",e,t,n))];case"NotEqual":return[a.notEqual(B("a",e,t,n),B("b",e,t,n))];case"Greater":return[a.greater(B("a",e,t,n),B("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(B("a",e,t,n),B("b",e,t,n))];case"Less":return[a.less(B("a",e,t,n),B("b",e,t,n))];case"LessEqual":return[a.lessEqual(B("a",e,t,n),B("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(B("a",e,t,n),B("b",e,t,n))];case"LogicalNot":return[a.logicalNot(B("a",e,t,n))];case"LogicalOr":return[a.logicalOr(B("a",e,t,n),B("b",e,t,n))];case"Select":case"SelectV2":return[a.where(B("condition",e,t,n),B("a",e,t,n),B("b",e,t,n))];case"BitwiseAnd":return[a.bitwiseAnd(B("a",e,t,n),B("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},pX=(e,t,n,a=dr)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(B("a",e,t,n),B("b",e,t,n),B("transposeA",e,t,n),B("transposeB",e,t,n))];case"Einsum":return[a.einsum(B("equation",e,t,n),...B("tensors",e,t,n))];case"Transpose":return[a.transpose(B("x",e,t,n),B("perm",e,t,n))];case"_FusedMatMul":let[r,i]=B("fusedOps",e,t,n),s=r==="biasadd",o=i==="prelu",u=B("numArgs",e,t,n),d=B("leakyreluAlpha",e,t,n);if(s){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,h]=B("args",e,t,n);return[a.fused.matMul({a:B("a",e,t,n),b:B("b",e,t,n),transposeA:B("transposeA",e,t,n),transposeB:B("transposeB",e,t,n),bias:c,activation:i,preluActivationWeights:h,leakyreluAlpha:d})];case"MatrixBandPart":return[a.linalg.bandPart(B("a",e,t,n),B("numLower",e,t,n),B("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},hX=(e,t,n,a=dr)=>{switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(B("x",e,t,n),B("axis",e,t,n),B("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[a.batchNorm(B("x",e,t,n),B("mean",e,t,n),B("variance",e,t,n),B("offset",e,t,n),B("scale",e,t,n),B("epsilon",e,t,n))];case"FusedBatchNormV3":return[a.batchNorm(B("x",e,t,n),B("mean",e,t,n),B("variance",e,t,n),B("offset",e,t,n),B("scale",e,t,n),B("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(B("x",e,t,n),B("radius",e,t,n),B("bias",e,t,n),B("alpha",e,t,n),B("beta",e,t,n))];case"Softmax":return[a.softmax(B("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(B("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},fX=(e,t,n,a=dr)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:r,outputDenseValues:i}=a.raggedGather(B("paramsNestedSplits",e,t,n),B("paramsDenseValues",e,t,n),B("indices",e,t,n),B("outputRaggedRank",e,t,n));return r.concat(i)}case"RaggedRange":{let{rtNestedSplits:r,rtDenseValues:i}=a.raggedRange(B("starts",e,t,n),B("limits",e,t,n),B("splits",e,t,n));return[r,i]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor(B("shape",e,t,n),B("values",e,t,n),B("defaultValue",e,t,n),B("rowPartitionTensors",e,t,n),B("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},mX=(e,t,n,a=dr)=>{switch(e.op){case"Max":{let o=B("axis",e,t,n),u=B("keepDims",e,t,n);return[a.max(B("x",e,t,n),o,u)]}case"Mean":{let o=B("axis",e,t,n),u=B("keepDims",e,t,n);return[a.mean(B("x",e,t,n),o,u)]}case"Min":{let o=B("axis",e,t,n),u=B("keepDims",e,t,n);return[a.min(B("x",e,t,n),o,u)]}case"Sum":{let o=B("axis",e,t,n),u=B("keepDims",e,t,n);return[a.sum(B("x",e,t,n),o,u)]}case"All":{let o=B("axis",e,t,n),u=B("keepDims",e,t,n);return[a.all(B("x",e,t,n),o,u)]}case"Any":{let o=B("axis",e,t,n),u=B("keepDims",e,t,n);return[a.any(B("x",e,t,n),o,u)]}case"ArgMax":{let o=B("axis",e,t,n);return[a.argMax(B("x",e,t,n),o)]}case"ArgMin":{let o=B("axis",e,t,n);return[a.argMin(B("x",e,t,n),o)]}case"Prod":{let o=B("axis",e,t,n),u=B("keepDims",e,t,n);return[a.prod(B("x",e,t,n),o,u)]}case"Cumprod":{let o=B("axis",e,t,n),u=B("exclusive",e,t,n),d=B("reverse",e,t,n);return[a.cumprod(B("x",e,t,n),o,u,d)]}case"Cumsum":{let o=B("axis",e,t,n),u=B("exclusive",e,t,n),d=B("reverse",e,t,n);return[a.cumsum(B("x",e,t,n),o,u,d)]}case"Bincount":let r=B("x",e,t,n),i=B("weights",e,t,n),s=B("size",e,t,n);return[a.bincount(r,i,s)];case"DenseBincount":{let o=B("x",e,t,n),u=B("weights",e,t,n),d=B("size",e,t,n),c=B("binaryOutput",e,t,n);return[a.denseBincount(o,u,d,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},gX=(e,t,n,a=dr)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=B("n",e,t,n),i=B("axis",e,t,n),s=B("tensors",e,t,n);return s=s.slice(0,r),[a.concat(s,i)]}case"Gather":{let r=B("x",e,t,n),i=B("indices",e,t,n);return[a.gather(r,a.cast(i,"int32"),0)]}case"GatherV2":{let r=B("axis",e,t,n),i=B("batchDims",e,t,n),s=B("x",e,t,n),o=B("indices",e,t,n);return[a.gather(s,a.cast(o,"int32"),r,i)]}case"Reverse":{let r=B("dims",e,t,n),i=[];for(let o=0;o<r.length;o++)r[o]&&i.push(o);let s=B("x",e,t,n);return[a.reverse(s,i)]}case"ReverseV2":{let r=B("axis",e,t,n),i=B("x",e,t,n);return[a.reverse(i,r)]}case"Slice":{let r=B("begin",e,t,n),i=B("size",e,t,n);return[a.slice(B("x",e,t,n),r,i)]}case"StridedSlice":{let r=B("begin",e,t,n),i=B("end",e,t,n),s=B("strides",e,t,n),o=B("beginMask",e,t,n),u=B("endMask",e,t,n),d=B("ellipsisMask",e,t,n),c=B("newAxisMask",e,t,n),h=B("shrinkAxisMask",e,t,n),m=B("x",e,t,n);return[a.stridedSlice(m,r,i,s,o,u,d,c,h)]}case"Pack":return be(()=>{let r=B("axis",e,t,n),i=B("tensors",e,t,n),s=i[0].shape,o=a.squeeze(i[0]).shape,u=i.map(d=>{let c=O.arraysEqual(d.shape,s);if(!c&&!O.arraysEqual(a.squeeze(d).shape,o))throw new Error("the input tensors shape does not match");return c?d:a.reshape(d,s)});return[a.stack(u,r)]});case"Unpack":{let r=B("axis",e,t,n),i=B("tensor",e,t,n);return a.unstack(i,r)}case"Tile":{let r=B("reps",e,t,n);return[a.tile(B("x",e,t,n),r)]}case"Split":case"SplitV":{let r=B("axis",e,t,n),i=B("numOrSizeSplits",e,t,n),s=B("x",e,t,n);return a.split(s,i,r)}case"ScatterNd":{let r=B("indices",e,t,n),i=B("values",e,t,n),s=B("shape",e,t,n);return[a.scatterND(r,i,s)]}case"GatherNd":{let r=B("x",e,t,n),i=B("indices",e,t,n);return[a.gatherND(r,i)]}case"SparseToDense":{let r=B("sparseIndices",e,t,n),i=B("outputShape",e,t,n),s=B("sparseValues",e,t,n),o=B("defaultValue",e,t,n);return[a.sparseToDense(r,s,i,s.dtype===o.dtype?o:a.cast(o,s.dtype))]}case"TensorScatterUpdate":{let r=B("indices",e,t,n),i=B("values",e,t,n),s=B("tensor",e,t,n);return[a.tensorScatterUpdate(s,r,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},bX=(e,t,n,a=dr)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:i,emptyRowIndicator:s,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows(B("indices",e,t,n),B("values",e,t,n),B("denseShape",e,t,n),B("defaultValue",e,t,n));return[r,i,s,o]}case"SparseReshape":{let{outputIndices:r,outputShape:i}=a.sparse.sparseReshape(B("inputIndices",e,t,n),B("inputShape",e,t,n),B("newShape",e,t,n));return[r,i]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(B("data",e,t,n),B("indices",e,t,n),B("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(B("data",e,t,n),B("indices",e,t,n),B("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},yX=(e,t,n,a=dr)=>{switch(e.op){case"FFT":return[a.fft(B("x",e,t,n))];case"IFFT":return[a.ifft(B("x",e,t,n))];case"RFFT":return[a.rfft(B("x",e,t,n))];case"IRFFT":return[a.irfft(B("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},wX=(e,t,n,a=dr)=>{switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace(B("input",e,t,n),B("pattern",e,t,n),B("rewrite",e,t,n),B("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:r,nGramsSplits:i}=a.string.stringNGrams(B("data",e,t,n),B("dataSplits",e,t,n),B("separator",e,t,n),B("nGramWidths",e,t,n),B("leftPad",e,t,n),B("rightPad",e,t,n),B("padWidth",e,t,n),B("preserveShortSequences",e,t,n));return[r,i]}case"StringSplit":{let{indices:r,values:i,shape:s}=a.string.stringSplit(B("input",e,t,n),B("delimiter",e,t,n),B("skipEmpty",e,t,n));return[r,i,s]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(B("input",e,t,n),B("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},xX=(e,t,n,a=dr)=>{switch(e.op){case"Cast":return[a.cast(B("x",e,t,n),B("dtype",e,t,n))];case"ExpandDims":{let r=B("axis",e,t,n);return[a.expandDims(B("x",e,t,n),r)]}case"Squeeze":{let r=B("axis",e,t,n);return[a.squeeze(B("x",e,t,n),r)]}case"Reshape":return[a.reshape(B("x",e,t,n),B("shape",e,t,n))];case"EnsureShape":return[a.ensureShape(B("x",e,t,n),B("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(B("x",e,t,n),B("padding",e,t,n),B("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(B("x",e,t,n),B("padding",e,t,n),B("constantValue",e,t,n))];case"SpaceToBatchND":{let r=B("blockShape",e,t,n),i=B("paddings",e,t,n);return[a.spaceToBatchND(B("x",e,t,n),r,i)]}case"BatchToSpaceND":{let r=B("blockShape",e,t,n),i=B("crops",e,t,n);return[a.batchToSpaceND(B("x",e,t,n),r,i)]}case"DepthToSpace":{let r=B("blockSize",e,t,n),i=B("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(B("x",e,t,n),r,i)]}case"BroadcastTo":return[a.broadcastTo(B("x",e,t,n),B("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(B("s0",e,t,n),B("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function hR(e,t,n,a,r=be){let i=((s,o,u)=>{switch(s.category){case"arithmetic":return r(()=>YZ(s,o,u));case"basic_math":return r(()=>jZ(s,o,u));case"control":return nX(s,o,u);case"convolution":return r(()=>aX(s,o,u));case"creation":return r(()=>rX(s,o,u));case"dynamic":return iX(s,o,u);case"evaluation":return r(()=>sX(s,o,u));case"image":return r(()=>cX(s,o,u));case"graph":return r(()=>oX(s,o,u));case"logical":return r(()=>dX(s,o,u));case"matrices":return r(()=>pX(s,o,u));case"normalization":return r(()=>hX(s,o,u));case"ragged":return r(()=>fX(s,o,u));case"reduction":return r(()=>mX(s,o,u));case"slice_join":return r(()=>gX(s,o,u));case"sparse":return r(()=>bX(s,o,u));case"spectral":return r(()=>yX(s,o,u));case"string":return r(()=>wX(s,o,u));case"transformation":return r(()=>xX(s,o,u));case"hash_table":return uX(s,o,u,a);case"custom":let d=vM(s.op);if(d&&d.customExecutor)return d.customExecutor(new JZ(s,o,u));throw TypeError(`Custom op ${s.op} is not registered.`);default:throw TypeError(`Unknown op '${s.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return O.isPromise(i)?i.then(s=>[].concat(s)):[].concat(i)}var fR=class{constructor(e={},t={},n={},a={},r){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function mR(e,t,n,a){let r=new Set,i=[],s=null,o=null,u=new Set,d=new Set(Object.keys(e).map(m=>Ci(m)[0]));a=a||[];let c=new Set(a.map(m=>Ci(m.name)[0])),h=[...t];for(;h.length>0;){let m=h.pop();if((Wd(m)||_X(m)||TX(m))&&s==null&&(s=m,o=s.children.map(g=>g.name).filter(g=>r.has(g))),r.add(m.name),n[m.name]==null&&!d.has(m.name)&&!c.has(m.name)){if(m.inputs.length===0){i.push(m.name);continue}m.inputs.forEach(g=>{u.has(g.name)||(u.add(g.name),h.push(g))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:i,dynamicNode:s,syncInputs:o}}function vX(e,t){let{usedNodes:n,inputs:a}=t,r=Object.keys(a).map(S=>Ci(S)[0]).map(S=>e.nodes[S]),i=e.initNodes||[],s=S=>n.has(typeof S=="string"?S:S.name);function o(S){return[...new Map(S.map(E=>[E.name,E])).values()]}let u=o([...r,...e.weights,...i]).filter(s),d=o([...u,...Object.values(e.nodes)]).filter(s),c=new Map(d.map(S=>[S.name,S])),h={};for(let S of d){h[S.name]=h[S.name]||0;for(let E of S.children)s(E)||(h[E.name]=Number.POSITIVE_INFINITY),h[E.name]=(h[E.name]||0)+1}let m=Object.entries(h).filter(([,S])=>S===0).map(([S])=>S),g=[...m];for(;m.length>0;){let S=m.pop(),E=c.get(S);for(let C of E.children.filter(s))--h[C.name]===0&&(g.push(C.name),m.push(C.name))}let x=g.map(S=>c.get(S)),v=SX(x,u);return kX(v,u),v}function SX(e,t){let n=new Map(e.map(i=>[i.name,i])),a=t.map(i=>i.name),r=new Set(a);for(;a.length>0;){let i=a.pop(),s=n.get(i);for(let o of s.children)!n.has(o.name)||r.has(o.name)||(r.add(o.name),a.push(o.name))}return e.filter(i=>r.has(i.name))}var jx=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function kX(e,t){let n=new Map(e.map((o,u)=>[o.name,u])),a=new Set(t.map(o=>o.name)),r=o=>a.has(typeof o=="string"?o:o.name),i=new Set(e.map(o=>o.name)),s=o=>i.has(typeof o=="string"?o:o.name);for(let o of e){for(let u of o.children.filter(s)){if(!n.has(u.name))throw new jx(`Child ${u.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(u.name))throw new jx(`Node ${o.name} is scheduled to run after its child ${u.name}.`)}if(!r(o))for(let u of o.inputs){if(!n.has(u.name))throw new jx(`Input ${u.name} of node ${o.name} is unreachable.`);if(n.get(u.name)>n.get(o.name))throw new jx(`Node ${o.name} is scheduled to run before its input ${u.name}.`)}}}function AX(e){let t=new Map(e.map((o,u)=>[o.name,u])),n=Number.MAX_SAFE_INTEGER,a=e.map((o,u)=>Wd(o)?n:u),r=o=>{let u=a[t.get(o.name)];return u??-1},i=e.map((o,u)=>o.children.map(r).reduce((d,c)=>Math.max(d,c),a[u])),s=new Map;for(let o=0;o<e.length;++o){let u=i[o];if(u===n)continue;let d=e[o],c=e[u];s.has(c.name)||s.set(c.name,[]),s.get(c.name).push(d)}return s}var EX=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),CX=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),IX=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Wd(e){return EX.has(e.op)}function _X(e){return CX.has(e.op)}function TX(e){return IX.has(e.op)}var gR=class PM{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(a=>t[a].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(a=>{this._functionExecutorMap[a]=new PM(t.functions[a],this)})}getCompilationKey(t,n){let a=t.map(i=>i.name).sort(),r=n.map(i=>i.name).sort();return a.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,n){let a=mR(t,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:s}=a;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){let d=n.map(h=>h.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${d}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}let o=vX(this.graph,a),u=AX(o);return{orderedNodes:o,nodeLiveUntilMap:u}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return Ga(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,a])=>[n,this.cloneTensorList(a)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let a=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let r=a.map(m=>this.graph.nodes[Ci(m)[0]]),i=n.map(m=>Ci(m)[0]),s=new Set(i),o=i.map(m=>this.graph.nodes[m]);o.length===0&&(o=this._outputs);let u=this.getCompilationKey(r,o),d=this.compiledMap.get(u);d==null&&(d=this.compile(t,o),this.compiledMap.set(u,d));try{this.keepIntermediateTensors=Ae().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}let c={},h={};return be(()=>{let m=new fR(this.weightMap,c,h,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(E=>{let[C,T]=Ci(E,m),N=[];N[T]=t[E],g[C]=N,this.keepIntermediateTensors&&(this.clonedTensorsMap[C]=this.cloneTensorList(N))});let x=this.getFrozenTensorIds(g),{orderedNodes:v,nodeLiveUntilMap:S}=d;for(let E of v){if(g[E.name])continue;let C=hR(E,g,m,this._resourceManager);if(O.isPromise(C))throw new Error(`The execution of the op '${E.op}' returned a promise. Please use model.executeAsync() instead.`);g[E.name]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[E.name]=this.cloneTensorList(C)),this.checkTensorForDisposalWithNodeLiveUntilInfo(E,g,m,x,s,S.get(E.name))}return this.parent==null&&m.dispose(x),n.map(E=>yr(E,g,m))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(a=>t[a]).map(a=>a.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(t,n,a,r,i,s,o){if(!(Wd(n)||s.has(t))){for(let u of a[t])u!=null&&(o[u.id]=(o[u.id]||0)+n.children.length);for(let u of n.inputs){if(Wd(u))continue;let d=lR(u.name,a,r);if(d!=null)for(let c of d){if(!c||c.kept||i.has(c.id))continue;let h=o[c.id];h===1?(c.dispose(),delete o[c.id]):h!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,a,r,i,s){function o(u){return Wd(u)||i.has(u.name)}if(!(Wd(t)||s==null))for(let u of s){if(o(u))continue;let d=lR(u.name,n,a);for(let c of d)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,a=!1,r={},i={}){this.disposeIntermediateTensors(),a||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=Ae().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}let s=new fR(this.weightMap,r,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,s,n,a),u=n.map(m=>yr(m,o,s)),d=u.map(m=>m.id),c=Object.keys(t).map(m=>t[m].id),h=new Set([...d,...c,...this.weightIds]);return Object.values(o).forEach(m=>{m.forEach(g=>{g&&!g.isDisposed&&!h.has(g.id)&&g.dispose()})}),this.parent==null&&s.dispose(h),u}async executeFunctionAsync(t,n,a){let r=t.reduce((i,s,o)=>(i[this.inputs[o].name]=s,i),{});return this._executeAsync(r,this.outputNodes,!0,n,a)}async executeWithControlFlow(t,n,a,r){let i=Object.keys(t),s=i.map(N=>this.graph.nodes[Ci(N)[0]]),o=a.map(N=>Ci(N)[0]),u=new Set(o),d=o.map(N=>this.graph.nodes[N]);d.length===0&&(d=this._outputs);let{usedNodes:c,missingInputs:h,dynamicNode:m,syncInputs:g}=mR(t,d,this.weightMap,this._initNodes),x=[...s,...this.graph.weights,...this._initNodes||[]].map(N=>({node:N,contexts:n.currentContext})),v=Object.assign({},this.weightMap);Object.keys(t).forEach(N=>{let[D,q]=Ci(N),H=[];H[q]=t[N],v[D]=H});let S={},E=this.getFrozenTensorIds(v),C={};for(;x.length>0;){let N=this.processStack(s,x,n,v,C,E,u,S,c);await Promise.all(N)}m==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let T=d.filter(N=>!Wd(N)&&!yr(N.name,v,n)).map(N=>N.name);if(T.length>0){let N="";throw m!=null&&(N=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${T}] from the provided inputs [${i}]. Consider providing the following inputs: [${h}]. ${N}`)}return v}processStack(t,n,a,r,i,s,o,u,d){let c=[];for(;n.length>0;){let h=n.pop();a.currentContext=h.contexts;let m="";if(h.node.op==="Enter"&&B("isConstant",h.node,r,a)&&([m]=Jl(h.node.name,a)),r[h.node.name]==null){let g=hR(h.node,r,a,this._resourceManager);m||([m]=Jl(h.node.name,a));let x=a.currentContext;O.isPromise(g)?c.push(g.then(v=>(r[m]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(v)),a.currentContext=x,this.checkTensorForDisposal(m,h.node,r,a,s,o,u),this.processChildNodes(h.node,n,a,r,i,d),v))):(r[m]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(g)),this.checkTensorForDisposal(m,h.node,r,a,s,o,u),this.processChildNodes(h.node,n,a,r,i,d))}else this.processChildNodes(h.node,n,a,r,i,d)}return c}processChildNodes(t,n,a,r,i,s){t.children.forEach(o=>{let[u]=Jl(o.name,a);i[u]||!s.has(o.name)||(o.op==="Merge"?o.inputNames.some(d=>!!yr(d,r,a))&&(i[u]=!0,n.push({contexts:a.currentContext,node:o})):o.inputNames.every(d=>!!yr(d,r,a))&&(i[u]=!0,n.push({contexts:a.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let a=t[n],[r]=Ci(n),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){let s=i.attrParams.shape.value,o=s.length===a.shape.length&&a.shape.every((u,d)=>s[d]===-1||s[d]===u);O.assert(o,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${s}], but was [${a.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&O.assert(a.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${a.dtype}`)})}mapInputs(t){var n,a;let r={};for(let i in t){let s=(a=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||a===void 0?void 0:a[i];s!=null?r[s.name]=t[i]:r[i]=t[i]}return r}checkInputs(t){let n=Object.keys(t).filter(a=>{let[r]=Ci(a);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var a,r;let i=(r=(a=this._signature)===null||a===void 0?void 0:a.outputs)===null||r===void 0?void 0:r[n];return i!=null?i.name:n},{})}checkOutputs(t){t.forEach(n=>{let[a]=Ci(n);if(!this.graph.nodes[a])throw new Error(`The output '${n}' is not found in the graph`)})}},NX=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},RX="?tfjs-format=file",FX="model.json",BI=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=xr){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new NX}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return O.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await K3(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,a=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let r=this.artifacts.userDefinedMetadata;r.signature!=null&&(a=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}if(this.signature=a,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new gR(uR.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let r=uR.Instance.transformGraph(e.modelInitializer);this.initializer=new gR(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof $t?[e]:e,n={};return t.forEach((a,r)=>n[this.structuredOutputKeys[r]]=a),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof $t)&&!Array.isArray(e)){let r=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(r!=null)for(let i in r){let s=r[i];s.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[s.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let a=0;return this.inputNodes.reduce((r,i)=>{var s,o,u;let d=(u=(o=(s=this.signature)===null||s===void 0?void 0:s.inputs)===null||o===void 0?void 0:o[i])===null||u===void 0?void 0:u.resourceId;return d!=null?r[i]=this.resourceIdToCapturedInput[d]:r[i]=e[a++],r},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let a=0;a<n.length;a++){let r=n[a],i=t[r];this.resourceIdToCapturedInput[i.resourceId]=e[a]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Wt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function DX(e,t={},n=xr){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=MX(e));let a=new BI(e,t,n);return await a.load(),a}function OX(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[a,r]=e;if(!a)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in a))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in a))throw new Error("Model JSON is missing 'weightsManifest'");let i=xr.getWeightSpecs(a.weightsManifest),s=xr.getModelArtifactsForJSONSync(a,i,r);t=xr.fromMemorySync(s)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=xr.fromMemorySync(e);else throw new Error("Unknown model format");let n=new BI(t);return n.load(),n}function MX(e){return e.endsWith("/")||(e=e+"/"),`${e}${FX}${RX}`}var BX="4.22.0",HM={};qt(HM,{CSVDataset:()=>tB,Dataset:()=>Gg,FileDataSource:()=>lB,TextLineDataset:()=>eB,URLDataSource:()=>uB,array:()=>iee,csv:()=>yee,func:()=>wee,generator:()=>xee,microphone:()=>See,version_data:()=>kee,webcam:()=>vee,zip:()=>see});var LX=Oc(X1()),zX=Oc(X1());function UX(e,t){return z1(e,t)}function z1(e,t,n=new Map,a=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let r=t(e);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(Im(e)){let i=Array.isArray(e)?[]:{};a.add(e);for(let s in e){let o=e[s],u=z1(o,t,n,a);i[s]=u}return a.delete(e),e.__proto__&&(i.__proto__=e.__proto__),i}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,r.value),r.value}function VX(e,t=KM){return GM(e,t)}function GM(e,t,n=new Set){let a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");let r=t(e);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(Im(a)){let i=Array.isArray(a)?[]:{};n.add(a);for(let s in a){let o=e.map(d=>d[s]),u=GM(o,t,n);i[s]=u}return n.delete(a),i}else throw new Error(`Can't recurse into non-iterable type: ${a}`);else return r.value}function KM(e){return e===null?null:Im(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function $M(e,t){let n=new Map;z1(e,t,n);for(let a of Array.from(n.keys())){let r=n.get(a);if(O.isPromise(r)){let i=await r;n.set(a,i)}}return z1(e,t,n)}function Im(e){let t=!1;if(Ae().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=p3();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof $t)&&!(e instanceof Promise)&&!t)}function WX(e){return e==null||qX(e)||Array.isArray(e)||typeof e=="object"&&e instanceof $t||O.isTypedArray(e)}function qX(e){return e===null||typeof e!="object"&&typeof e!="function"}function PX(e){return UX(e,HX)}function HX(e){return e instanceof $t?{value:e.clone(),recurse:!1}:Im(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var JM=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},YM=class jM extends JM{constructor(){super(jM.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),a=this.length();for(let r=0;r<a;r++)n[r]=this.get(this.wrap(this.begin+r));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=a}};YM.INITIAL_CAPACITY=32;function QM(e){return new $X(e)}function LI(e){return new JX(e)}function GX(e,t){return new ZM(e,t)}function KX(e,t=hc.FAIL){return new aee(e,t)}var cr=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new tee(this,e)}filter(e){return new XX(this,e)}map(e){return new eee(this,e)}mapAsync(e){return new bR(this,e)}serialMapAsync(e){return new bR(this,e).serial()}flatmap(e){return new nee(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new ZX(this,e,t)}columnMajorBatch(e,t=!0,n=KM){return this.rowMajorBatch(e,t).map(a=>VX(a,n))}concatenate(e,t){return new ZM(QM([this,e]),t)}take(e){return e<0||e==null?this:new QX(this,e)}skip(e){return e<0||e==null?this:new jX(this,e)}prefetch(e){return new XM(this,e)}shuffle(e,t){return new ree(this,e,t)}serial(){return new YX(this)}},$X=class extends cr{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:PX(e),done:!1}}},JX=class extends cr{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},YX=class extends cr{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},jX=class extends cr{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Wt(e.value)}return this.upstream.next()}},QX=class extends cr{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},ZX=class extends cr{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},XX=class extends cr{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Wt(e.value)}}},eee=class extends cr{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=ro.getTensorsInContainer(e.value),n=this.transform(e.value),a=ro.getTensorsInContainer(n);for(let r of t)ro.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},tee=class extends cr{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},bR=class extends cr{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=ro.getTensorsInContainer(e.value),n=await this.transform(e.value),a=ro.getTensorsInContainer(n);for(let r of t)ro.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},zI=class extends cr{constructor(){super(),this.outputQueue=new YM,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},nee=class extends zI{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=ro.getTensorsInContainer(e.value),n=this.transform(e.value),a=ro.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let r of t)ro.isTensorInList(r,a)||r.dispose();return!0}},ZM=class extends cr{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},hc;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(hc||(hc={}));var aee=class extends cr{constructor(e,t=hc.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function a(i){return i instanceof cr?{value:i.next().then(s=>(t++,s.done&&n++,s.value)),recurse:!1}:{value:null,recurse:!0}}let r=await $M(this.iterators,a);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case hc.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case hc.SHORTEST:return{value:null,done:!0};case hc.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},XM=class extends cr{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new JM(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},ree=class extends XM{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=zX.alea(n||O.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},Gg=class{constructor(){this.size=null}batch(e,t=!0){let n=this;O.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let a;return this.size===1/0||this.size==null?a=this.size:t?a=Math.ceil(this.size/e):a=Math.floor(this.size/e),Ei(async()=>(await n.iterator()).columnMajorBatch(e,t,oee),a)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Ei(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Ei(async()=>(await t.iterator()).filter(a=>be(()=>e(a))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Ei(async()=>(await t.iterator()).map(n=>be(()=>e(n))),this.size)}mapAsync(e){let t=this;return Ei(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Ei(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Ei(async()=>{let a=LI(async()=>({value:await t.iterator(),done:!1}));return GX(a.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Ei(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let a=this,r=LX.alea(t||O.now().toString());return Ei(async()=>{let i=r.int32();return n&&(i+=r.int32()),(await a.iterator()).shuffle(e,i.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Ei(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Gg.MAX_BUFFER_SIZE=1e4;function Ei(e,t=null){return new class extends Gg{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function iee(e){return Ei(async()=>QM(e),e.length)}function see(e){if(!Im(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return Ei(async()=>{let n=await $M(e,a=>{if(a instanceof Gg)return{value:a.iterator(),recurse:!1};if(Im(a))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return KX(n,hc.SHORTEST)},t)}function oee(e){if(e===null)return null;let t=e[0];return WX(t)?{value:lee(e),recurse:!1}:{value:null,recurse:!0}}function lee(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof $t?Ba(e):Pr(e)}var eB=class extends Gg{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},Qx='"',yy=Symbol("out"),yR=Symbol("field"),Zx=Symbol("quote"),ok=Symbol("quoteafterquote"),wR=Symbol("quoteinquote"),tB=class extends Gg{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&O.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((a,r)=>(a[r]=a[r]+1||1,a),{}),n=Object.keys(t).filter(a=>t[a]>1);if(O.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let a of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(a)===-1)throw new Error('The key "'+a+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new eB(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(O.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},a={};for(let r=0;r<this.fullColumnNames.length;r++){let i=this.fullColumnNames[r],s=this.columnConfigs?this.columnConfigs[i]:null;if(!(this.configuredColumnsOnly&&!s)){let o=t[r],u=null;if(o==="")if(s&&s.default!==void 0)u=s.default;else{if(s&&(s.required||s.isLabel))throw new Error(`Required column ${i} is empty in this line: ${e}`);u=void 0}else{let d=Number(o);if(isNaN(d))s&&s.dtype==="bool"?u=this.getBoolean(o):u=o;else if(!s||!s.dtype)u=d;else switch(s.dtype){case"float32":u=d;break;case"int32":u=Math.floor(d);break;case"bool":u=this.getBoolean(o);break;default:u=d}}s&&s.isLabel?a[i]=u:n[i]=u}}return Object.keys(a).length===0?n:{xs:n,ys:a}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],a=0,r=e.length,i=yy;for(let s=0;s<r;s++)switch(i){case yy:switch(e.charAt(s)){case Qx:a=s+1,i=Zx;break;case this.delimiter:if(a=s+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),i=yy;break;default:i=yR,a=s;break}break;case yR:switch(e.charAt(s)){case this.delimiter:n.push(e.substring(a,s)),i=yy,a=s+1;break}break;case Zx:switch(e.charAt(s)){case Qx:i=ok;break}break;case ok:switch(e.charAt(s)){case this.delimiter:n.push(e.substring(a,s-1)),i=yy,a=s+1;break;case Qx:i=Zx;break;default:i=wR;break}break;case wR:switch(e.charAt(s)){case Qx:i=Zx;break}break}if(i===ok?n.push(e.substring(a,r-1)):n.push(e.substring(a)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},uee=class nB extends cr{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!Ae().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new nB(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(a){throw new Error(`Error thrown while initializing video stream: ${a.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,a=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(a.freqDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(a.timeDataQueue);n=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],a=0;return new Promise(r=>{let i=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++a===this.numFrames&&(clearInterval(i),r({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,a=new Float32Array(t.length*n);return t.forEach((r,i)=>a.set(r,i*n)),a}getTensorFromAudioDataArray(t,n){let a=new Float32Array(O.sizeFromShape(n));return a.set(t,a.length-t.length),Pr(a,n)}},cee=class aB extends cr{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Dn([0],"int32"),this.webcamConfig.centerCrop){let a=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,i=(1-a)/2,s=(1-r)/2,o=i+a,u=r+s;this.cropBox=nl([s,i,u,o],[1,4])}else this.cropBox=nl([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!Ae().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let a=new aB(t,n);return await a.start(),a}async start(){this.webcamConfig.facingMode&&O.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Q0.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return be(()=>{let n=sr(je(t,"float32"),0),a;a=Zi.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=a.shape;return ge(a,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},rB=class{},iB=class extends cr{split(e){return new dee(this,e)}},dee=class extends iB{constructor(e,t){super(),this.upstream=e,this.impl=new pee(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},pee=class extends zI{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},hee=class extends cr{decodeUTF8(){return new fee(this)}},fee=class extends iB{constructor(e){super(),this.upstream=e,this.impl=new mee(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},mee=class extends zI{constructor(e){if(super(),this.upstream=e,Ae().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=p3();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return Ae().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},sB=class extends hee{constructor(e,t={}){super(),this.file=e,this.options=t,O.assert(e instanceof Uint8Array||(Ae().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let a=new FileReader;a.onload=i=>{let s=a.result;if(s instanceof ArrayBuffer&&(s=new Uint8Array(s)),!(s instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(s)},a.onabort=i=>t(new Error("Aborted")),a.onerror=i=>t(new Error(i.type));let r=this.file.slice(this.offset,n);a.readAsArrayBuffer(r)}this.offset=n}),done:!1}}};async function gee(e,t={},n){let a,r;typeof e=="string"?a=e:(a=e.url,r=bee(e));let i=await(0,O.fetch)(a,r);if(i.ok){let s=new Uint8Array(await i.arrayBuffer());return new sB(s,t)}else throw new Error(i.statusText)}var bee=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function oB(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var lB=class extends rB{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(oB(this.input)&&Ae().get("IS_NODE")){let e=TA();this.input=e.readFileSync(this.input.slice(7))}return new sB(this.input,this.options)}},uB=class extends rB{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return oB(this.url)?new lB(this.url,this.fileOptions).iterator():gee(this.url,this.fileOptions)}};function yee(e,t={}){return new tB(new uB(e),t)}function wee(e){let t=LI(e);return Ei(async()=>t)}function xee(e){return Ei(async()=>{let t=await e();return LI(()=>t.next())})}async function vee(e,t){return cee.create(e,t)}async function See(e){return uee.create(e)}var kee="4.22.0";function ct(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&O.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var Aee=cl.whereImpl,UI=class cB extends u0{nextDataId(){return cB.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new ev(this,_s())}write(t,n,a){this.firstUse&&(this.firstUse=!1,Ae().get("IS_NODE")&&P.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:a,refCount:1}),r}makeTensorInfo(t,n,a){let r;if(n==="string"&&a!=null&&a.length>0&&O.isString(a[0])){let i=a.map(s=>O.encodeString(s));r=this.write(i,t,n)}else r=this.write(a,t,n);return{dataId:r,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,a,r,i){this.data.set(t,{values:n,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:a}=this.data.get(t);if(n==="complex64"){let r=this.readSync(a.real.dataId),i=this.readSync(a.imag.dataId);return P.mergeRealAndImagArrays(r,i)}return O.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let a=n.map(r=>O.decodeString(r));return Zt(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Zt(t.shape,t.dtype,n)}makeOutput(t,n,a){return _s().makeTensorFromTensorInfo(this.makeTensorInfo(n,a,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:a}=this.data.get(t);a!=null&&(this.disposeData(a.real.dataId,!0),this.disposeData(a.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=O.now();return t(),{kernelMs:O.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){ct([t],"where");let n=this.readSync(t.dataId);return Aee(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};UI.nextDataId=0;var VI={};qt(VI,{addImpl:()=>hB,bincountImpl:()=>qI,bincountReduceImpl:()=>fB,bitwiseAndImpl:()=>mB,castImpl:()=>pB,ceilImpl:()=>gB,concatImpl:()=>PI,equalImpl:()=>bB,expImpl:()=>wB,expm1Impl:()=>vB,floorDivImpl:()=>kB,floorImpl:()=>SB,gatherNdImpl:()=>AB,gatherV2Impl:()=>EB,greaterEqualImpl:()=>IB,greaterImpl:()=>CB,lessEqualImpl:()=>TB,lessImpl:()=>_B,linSpaceImpl:()=>NB,logImpl:()=>RB,maxImpl:()=>FB,maximumImpl:()=>DB,minimumImpl:()=>OB,multiplyImpl:()=>HI,negImpl:()=>MB,notEqualImpl:()=>BB,prodImpl:()=>LB,raggedGatherImpl:()=>zB,raggedRangeImpl:()=>UB,raggedTensorToTensorImpl:()=>VB,rangeImpl:()=>KI,rsqrtImpl:()=>WB,scatterImpl:()=>Hd,sigmoidImpl:()=>kte,simpleAbsImpl:()=>dB,sliceImpl:()=>V1,sparseFillEmptyRowsImpl:()=>PB,sparseReshapeImpl:()=>HB,sparseSegmentReductionImpl:()=>$I,sqrtImpl:()=>Cte,squaredDifferenceImpl:()=>GB,staticRegexReplaceImpl:()=>KB,stridedSliceImpl:()=>$B,stringNGramsImpl:()=>JI,stringSplitImpl:()=>YI,stringToHashBucketFastImpl:()=>jI,subImpl:()=>JB,tileImpl:()=>YB,topKImpl:()=>QB,transposeImpl:()=>GI,uniqueImpl:()=>ZI});function dB(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var Eee=e=>{let{x:t}=e.inputs,n=e.backend;ct(t,"abs");let a=new Float32Array(O.sizeFromShape(t.shape)),r=n.data.get(t.dataId).values;return a=dB(r),n.makeOutput(a,t.shape,t.dtype)},Cee={kernelName:Dm,backendName:"cpu",kernelFunc:Eee};function Ta(e){return(t,n,a,r,i)=>{let s=P.assertAndGetBroadcastShape(t,n),o=s.length,u=O.computeStrides(s),d=O.sizeFromShape(s),c=O.getTypedArrayFromDType(i,d),h=t.length,m=n.length,g=O.computeStrides(t),x=O.computeStrides(n),v=P.getBroadcastDims(t,s),S=P.getBroadcastDims(n,s);if(v.length+S.length===0)for(let E=0;E<c.length;++E)c[E]=e(a[E%a.length],r[E%r.length]);else for(let E=0;E<c.length;++E){let C=O.indexToLoc(E,o,u),T=C.slice(-h);v.forEach(H=>T[H]=0);let N=O.locToIndex(T,h,g),D=C.slice(-m);S.forEach(H=>D[H]=0);let q=O.locToIndex(D,m,x);c[E]=e(a[N],r[q])}return[c,s]}}function Ii(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,i=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,o=n.makeTensorInfo(a.shape,"complex64"),u=n.data.get(o.dataId);return u.complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",i),imag:n.makeTensorInfo(r.shape,"float32",s)},o}var Iee={kernelName:av,backendName:"cpu",kernelFunc:Ii};function U1(e,t,n="float32"){if(n==="complex64"){let r=U1(e,t,"float32"),i=U1(e,t,"float32");return Ii({inputs:{real:r,imag:i},backend:e})}let a=O.makeZerosTypedArray(O.sizeFromShape(t),n);return e.makeTensorInfo(t,n,a)}function ol(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var _ee={kernelName:Kp,backendName:"cpu",kernelFunc:ol};function up(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}var Tee={kernelName:mv,backendName:"cpu",kernelFunc:up};function pB(e,t,n,a){if(a==="int32"){let r=Int32Array.from(e);return[t,"int32",r]}if(a==="bool"){let r=O.toTypedArray([0],n),[i,s]=Ta((o,u)=>o!==u?1:0)(t,[],e,r,"bool");return[s,"bool",i]}throw new Error(`Error in Cast: failed to cast ${n} to ${a}`)}function Nc(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:i}=a;if(i==="complex64"){if(r.dtype==="complex64")return ol({inputs:{x:r},backend:n});let c=U1(n,r.shape,r.dtype),h=Nc({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),m=Ii({inputs:{real:h,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),m}if(r.dtype==="complex64"){let c=up({inputs:{input:r},backend:n}),h=Nc({inputs:{x:c},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(c),h}if(!O.hasEncodingLoss(r.dtype,i)){let c=ol({inputs:{x:r},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:i}}let s=n.data.get(r.dataId).values,[o,u,d]=pB(s,r.shape,r.dtype,i);return n.makeTensorInfo(o,u,d)}var Nee={kernelName:Ip,backendName:"cpu",kernelFunc:Nc};function ja(e,t,n,a){return n==null?({inputs:r,backend:i})=>{let{a:s,b:o}=r,u=i;ct([s,o],e);let d=u.data.get(s.dataId).values,c=u.data.get(o.dataId).values,h=s.dtype==="string"?P.fromUint8ToStringArray(d):d,m=s.dtype==="string"?P.fromUint8ToStringArray(c):c,g=a||s.dtype,[x,v]=t(s.shape,o.shape,h,m,g);return u.makeTensorInfo(v,g,x)}:({inputs:r,backend:i})=>{let{a:s,b:o}=r,u=i;if(s.dtype==="complex64"||o.dtype==="complex64"){let d=Nc({inputs:{x:s},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(d.dataId),h=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,g=u.data.get(h.dataId).values,x=u.data.get(m.dataId).values,v=Nc({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),S=u.data.get(v.dataId),E=S.complexTensorInfos.real,C=S.complexTensorInfos.imag,T=u.data.get(E.dataId).values,N=u.data.get(C.dataId).values,[D,q,H]=n(s.shape,o.shape,g,x,T,N),K=u.makeTensorInfo(H,"float32",D),j=u.makeTensorInfo(H,"float32",q),te=Ii({inputs:{real:K,imag:j},backend:u});return u.disposeIntermediateTensorInfo(d),u.disposeIntermediateTensorInfo(v),u.disposeIntermediateTensorInfo(K),u.disposeIntermediateTensorInfo(j),te}else{let d=u.data.get(s.dataId).values,c=u.data.get(o.dataId).values,h=a||s.dtype,[m,g]=t(s.shape,o.shape,d,c,h);return u.makeTensorInfo(g,h,m)}}}function WI(e){return(t,n,a,r,i,s)=>{let o=P.assertAndGetBroadcastShape(t,n),u=O.sizeFromShape(o),d=o.length,c=O.computeStrides(o),h=O.getTypedArrayFromDType("float32",u),m=O.getTypedArrayFromDType("float32",u),g=P.getBroadcastDims(t,o),x=P.getBroadcastDims(n,o),v=P.mergeRealAndImagArrays(a,r),S=P.mergeRealAndImagArrays(i,s),E=t.length,C=O.computeStrides(t),T=n.length,N=O.computeStrides(n);if(g.length+x.length===0)for(let D=0;D<h.length;D++){let q=D%v.length,H=D%S.length,K=e(v[q*2],v[q*2+1],S[H*2],S[H*2+1]);h[D]=K.real,m[D]=K.imag}else for(let D=0;D<h.length;D++){let q=O.indexToLoc(D,d,c),H=q.slice(-E);g.forEach(z=>H[z]=0);let K=O.locToIndex(H,E,C),j=q.slice(-T);x.forEach(z=>j[z]=0);let te=O.locToIndex(j,T,N),Q=e(v[K*2],v[K*2+1],S[te*2],S[te*2+1]);h[D]=Q.real,m[D]=Q.imag}return[h,m,o]}}var hB=Ta((e,t)=>e+t),Ree=WI((e,t,n,a)=>({real:e+n,imag:t+a})),_m=ja(Mc,hB,Ree),Fee={kernelName:Mc,backendName:"cpu",kernelFunc:_m};function qI(e,t,n,a,r){let i=O.sizeFromShape(a),s=O.makeZerosTypedArray(r,n);for(let o=0;o<e.length;o++){let u=e[o];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(i>0?s[u]+=t[o]:s[u]+=1)}return s}function fB(e,t,n,a=!1){let r=e.shape[0],i=e.shape[1],s=Zt([r,n],t.dtype);for(let o=0;o<r;o++)for(let u=0;u<i;u++){let d=e.get(o,u);if(d<0)throw new Error("Input x must be non-negative!");d>=n||(a?s.set(1,o,d):t.size>0?s.set(s.get(o,d)+t.get(o,u),o,d):s.set(s.get(o,d)+1,o,d))}return s}var mB=Ta((e,t)=>e&t),Dee=ja(Wm,mB),Oee={kernelName:Wm,backendName:"cpu",kernelFunc:Dee};function dl(e){return(t,n,a)=>{let r=O.getArrayFromDType(n,t.length);for(let i=0;i<t.length;++i)r[i]=e(t[i],a);return r}}function Vn(e,t,n){let a=dl(t);return Hc(e,a,n)}function Hc(e,t,n){return({inputs:a,attrs:r,backend:i})=>{let{x:s}=a;ct(s,e);let o=i,u=o.data.get(s.dataId).values,d;if(s.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");d=P.fromUint8ToStringArray(u)}else d=u;let c=n||s.dtype,h=t(d,c,r);return o.makeTensorInfo(s.shape,c,h)}}var gB=dl(e=>Math.ceil(e)),Mee=Hc(_p,gB),Bee={kernelName:_p,backendName:"cpu",kernelFunc:Mee};function PI(e,t,n,a){let r=O.getArrayFromDType(n,O.sizeFromShape(t));if(a&&n!=="string"){let i=0;e.forEach(s=>{let o=O.sizeFromShape(s.shape);r.set(s.vals,i),i+=o})}else{let i=0;e.forEach(s=>{let o=n==="string"?P.fromUint8ToStringArray(s.vals):s.vals,u=0;for(let d=0;d<s.shape[0];++d){let c=d*t[1]+i;for(let h=0;h<s.shape[1];++h)r[c+h]=o[u++]}i+=s.shape[1]})}return r}var bB=Ta((e,t)=>e===t?1:0),yB=ja(Ym,bB,null,"bool"),Lee={kernelName:Ym,backendName:"cpu",kernelFunc:yB},wB=dl(e=>Math.exp(e)),xB=Hc(Vp,wB,"float32"),zee={kernelName:Vp,backendName:"cpu",kernelFunc:xB},vB=dl(e=>Math.expm1(e)),Uee=Hc(Wp,vB),Vee={kernelName:Wp,backendName:"cpu",kernelFunc:Uee},SB=dl(e=>Math.floor(e)),Wee=Hc(qp,SB),qee={kernelName:qp,backendName:"cpu",kernelFunc:Wee},kB=Ta((e,t)=>Math.floor(e/t)),Pee=ja(Pp,kB,null,"int32"),Hee={kernelName:Pp,backendName:"cpu",kernelFunc:Pee};function AB(e,t,n,a,r,i,s,o,u){let d=Zt([a,i],n);for(let c=0;c<a;c++){let h=[],m=0;for(let g=0;g<r;g++){let x=e[c*r+g];m+=x*s[g],h.push(x)}if(m<0||m>=u/i)throw new Error(`Invalid indices: ${h} does not index into ${o}`);for(let g=0;g<i;g++)d.values[c*i+g]=t.get(...t.indexToLoc(m*i+g))}return d}function EB(e,t,n){let a=Zt(n,e.dtype);for(let r=0;r<a.size;++r){let i=a.indexToLoc(r).slice(),s=i[0],o=i[2],u=t.locToIndex([s,o]);i[2]=t.values[u];let d=e.locToIndex(i);0<=d&&d<e.values.length&&(a.values[r]=e.values[d])}return a}var CB=Ta((e,t)=>e>t?1:0),Gee=ja(eg,CB,null,"bool"),Kee={kernelName:eg,backendName:"cpu",kernelFunc:Gee},IB=Ta((e,t)=>e>=t?1:0),$ee=ja(Gp,IB,null,"bool"),Jee={kernelName:Gp,backendName:"cpu",kernelFunc:$ee},_B=Ta((e,t)=>e<t?1:0),Yee=ja(tg,_B,null,"bool"),jee={kernelName:tg,backendName:"cpu",kernelFunc:Yee},TB=Ta((e,t)=>e<=t?1:0),Qee=ja(ng,TB,null,"bool"),Zee={kernelName:ng,backendName:"cpu",kernelFunc:Qee};function NB(e,t,n){let a=(t-e)/(n-1),r=O.makeZerosTypedArray(n,"float32");r[0]=e;for(let i=1;i<r.length;i++)r[i]=r[i-1]+a;return r}var RB=dl(e=>Math.log(e)),Xee=Hc(Qp,RB),ete={kernelName:Qp,backendName:"cpu",kernelFunc:Xee};function FB(e,t,n,a){let r=O.getTypedArrayFromDType(a,O.sizeFromShape(n));for(let i=0;i<r.length;++i){let s=i*t,o=e[s];for(let u=0;u<t;++u){let d=e[s+u];(Number.isNaN(d)||d>o)&&(o=d)}r[i]=o}return r}var DB=Ta((e,t)=>Math.max(e,t)),tte=ja(th,DB),nte={kernelName:th,backendName:"cpu",kernelFunc:tte},OB=Ta((e,t)=>Math.min(e,t)),ate=ja(ih,OB),rte={kernelName:ih,backendName:"cpu",kernelFunc:ate},HI=Ta((e,t)=>e*t),ite=WI((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n})),vS=ja(lh,HI,ite),ste={kernelName:lh,backendName:"cpu",kernelFunc:vS};function MB(e,t,n){let a=O.createScalarValue(-1,n);return HI([],t,a,e,n)}function ote(e){let{inputs:t,backend:n}=e,{x:a}=t;ct(a,"neg");let r=n.data.get(a.dataId).values,[i,s]=MB(r,a.shape,a.dtype);return n.makeTensorInfo(s,a.dtype,i)}var lte={kernelName:cg,backendName:"cpu",kernelFunc:ote},BB=Ta((e,t)=>e!==t?1:0),ute=ja(dg,BB,null,"bool"),cte={kernelName:dg,backendName:"cpu",kernelFunc:ute};function GI(e,t,n,a,r){let i=t.length,s=O.sizeFromShape(t),o=O.computeStrides(t),u=O.computeStrides(r),d=O.getTypedArrayFromDType(n,O.sizeFromShape(r));for(let c=0;c<s;++c){let h=O.indexToLoc(c,i,o),m=new Array(h.length);for(let x=0;x<m.length;x++)m[x]=h[a[x]];let g=O.locToIndex(m,i,u);d[g]=e[c]}return d}function pi(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:i}=n;ct(r,"transpose");let s=r.shape.length,o=new Array(s);for(let c=0;c<o.length;c++)o[c]=r.shape[i[c]];let u=a.data.get(r.dataId).values,d=GI(u,r.shape,r.dtype,i,o);return{dataId:a.write(d,o,r.dtype),shape:o,dtype:r.dtype}}var dte={kernelName:Xl,backendName:"cpu",kernelFunc:pi};function LB(e,t,n,a){let[r,i]=P.computeOutAndReduceShapes(e,a),s=as(t,"int32"),o=O.makeZerosTypedArray(O.sizeFromShape(r),s),u=O.sizeFromShape(i);for(let d=0;d<o.length;++d){let c=d*u,h=1;for(let m=0;m<u;++m)h*=n[c+m];o[d]=h}return{outVals:o,outShape:r,outDtype:s}}function pte(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:s}=a;ct(r,"prod");let o=r.shape.length,u=O.parseAxisParam(i,r.shape),d=P.getAxesPermutation(u,o),c=u,h=r,m=[];d!=null&&(h=pi({inputs:{x:r},backend:n,attrs:{perm:d}}),m.push(h),c=P.getInnerMostAxes(c.length,o));let g=n.data.get(h.dataId).values,{outVals:x,outShape:v,outDtype:S}=LB(h.shape,h.dtype,g,c),E=v;return s&&(E=P.expandShapeToKeepDim(v,u)),m.forEach(C=>n.disposeIntermediateTensorInfo(C)),n.makeTensorInfo(E,S,x)}var hte={kernelName:hh,backendName:"cpu",kernelFunc:pte};function fte(e,t,n){e.forEach((a,r)=>{if(a<0||a>=n){let i=O.indexToLoc(r,t.length,O.computeStrides(t)).join(",");throw new Error(`indices[${i}] = ${a} is not in [0, ${n})`)}})}function mte(e,t){for(let n=0;n<e.length;++n){let a=e[n],r=n===e.length-1?t:e[n+1].length;if(a.length===0)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<a.length;++i)if(a[i-1]>a[i])throw new Error("Ragged splits must be sorted in ascending order")}}function gte(e,t,n,a){let r=[],i=0,s=t.length-1+n.length,o=new Array(s).fill(null).map(()=>[0]);mte(n,a);let u=1;for(let d=0;d<t.length-1;++d){u*=t[d];let c=t[d+1];for(let h=1;h<u+1;++h)o[d].push(h*c)}for(let d=0;d<e.length;++d){let c=e[d],h=e[d]+1;for(let m=0;m<n.length;++m){let g=n[m],x=m+t.length-1;if(x>=0){let v=o[x],S=v[v.length-1]-g[c];for(let E=c;E<h;++E)o[x].push(g[E+1]+S)}c=g[c],h=g[h]}h!==c&&(r.push([c,h]),i+=h-c)}return{outSplits:o,valueSlices:r,numValues:i}}function bte(e){let t=[];for(let n=0;n<e.length;++n){let a=e[n].length,r=O.getArrayFromDType("int32",a);t.push(r),e[n].forEach((i,s)=>r[s]=i)}return t}function xR(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function yte(e,t,n,a,r,i){let s=xR(t,2)[1],o=xR(i,2)[1],u=0;for(let d of n)for(let c=d[0];c<d[1];++c){for(let h=0;h<a;++h)r[u*o+h]=e[c*s+h];++u}}function wte(e,t,n,a,r){let i=t.slice();i[0]=r;let s=O.getArrayFromDType(n,O.sizeFromShape(i)),o=e.length,u=o===0?0:o/t[0];return yte(e,t,a,u,s,i),[s,i]}function zB(e,t,n,a,r,i,s,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let u=t[0][0]-1;if(fte(i,s,u),a.length===0)throw new Error("params.rank must be nonzero");let d=a[0],{outSplits:c,valueSlices:h,numValues:m}=gte(i,s,e,d),g=bte(c),x=wte(n,a,r,h,m);return[g,x[0],x[1]]}var vR=2147483647;function UB(e,t,n,a,r,i,s){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(s.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,u=r.length===0,d=s.length===0,c=[];o||c.push(t[0]),u||c.push(r[0]),d||c.push(s[0]);for(let S=1;S<c.length;++S)if(c[S]!==c[S-1])throw new Error("starts, limits, and deltas must have the same shape");let h=c.length===0?1:c[0],m=O.getArrayFromDType("int32",h+1);m[0]=0;for(let S=0;S<h;++S){let E=o?e[0]:e[S],C=u?a[0]:a[S],T=d?i[0]:i[S];if(T===0)throw new Error("Requires delta != 0");let N;if(T>0&&C<E||T<0&&C>E)N=0;else if(N=Math.ceil(Math.abs((C-E)/T)),N>vR)throw new Error(`Requires ((limit - start) / delta) <= ${vR}`);m[S+1]=m[S]+N}let g=m[h],x=O.getArrayFromDType(n,g),v=0;for(let S=0;S<h;++S){let E=m[S+1]-m[S],C=o?e[0]:e[S],T=d?i[0]:i[S];for(let N=0;N<E;++N)x[v++]=C,C+=T}return[m,x]}var Is=P.RowPartitionType,xte=class rA{constructor(t,n,a,r,i,s,o,u,d,c){this.shape=t,this.shapeShape=n,this.values=a,this.valuesShape=r,this.valuesDType=i,this.defaultValue=s,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=d,this.rowPartitionTypes=P.getRowPartitionTypesHelper(c),this.raggedRank=P.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Is.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Is.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Is.VALUE_ROWIDS:return rA.getMaxWidthValueRowID(n);case Is.ROW_SPLITS:return rA.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Is[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let a=0;for(let r=0;r<n-1;++r){let i=t[r+1]-t[r];i>a&&(a=i)}return a}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let a=0,r=t[0],i=0;for(let s=1;s<n;++s){let o=t[s];o!==r&&(r=o,i=Math.max(s-a,i),a=s)}return Math.max(n-a,i)}tensorShapeFromTensor(t,n,a=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return kR(t,a)}calculateOutputSize(t){let n=this.valuesShape,a=this.defaultValueShape;P.validateDefaultValueShape(a,n);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=P.combineRaggedTensorToTensorShapes(this.raggedRank,r,n);i[0]<0&&(i[0]=t);for(let s=1;s<=this.raggedRank;++s)i[s]<0&&(i[s]=this.getMaxWidth(s));return i}calculateFirstParentOutputIndex(t,n,a){let r=Math.min(t,a),i=[],s=0;for(let o=0;o<r;++o,s+=n)i.push(s);for(let o=r;o<t;++o)i.push(-1);return O.assert(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,n,a,r){let i=t.length,s=[];for(let o=0;o<i-1;++o){let u=t[o+1]-t[o],d=Math.min(r,u),c=n[o];c===-1&&(d=0);for(let h=0;h<d;++h)s.push(c),c+=a;for(let h=0;h<u-d;++h)s.push(-1)}if(i>0&&s.length!==t[i-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(t,n,a,r){let i=t.length,s=[];if(i===0)return[];let o=0,u=t[0];if(u>=n.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${n.length}`);let d=n[u];s.push(d);for(let c=1;c<i;++c){let h=t[c];if(h===u)d>=0&&(++o,o<r?d+=a:d=-1);else{if(o=0,u=h,h>=n.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);d=n[h]}s.push(d)}if(s.length!==t.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(t,n,a,r){let i=this.getRowPartitionTensor(t),s=this.getRowPartitionTypeByDimension(t);switch(s){case Is.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,n,a,r);case Is.ROW_SPLITS:if(i.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(i,n,a,r);default:throw new Error(`Unsupported partition type: ${Is[s]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case Is.FIRST_DIM_SIZE:return t[0];case Is.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Is.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Is[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),a=new Array(this.raggedRank+1);a[a.length-1]=1;for(let s=a.length-2;s>=0;--s)a[s]=a[s+1]*n[s+1];let r=kR(n,!1),i=O.getArrayFromDType(this.valuesDType,O.sizeFromShape(r));if(a[0]*n[0]>0){let s=this.calculateFirstParentOutputIndex(t,a[0],n[0]);for(let o=1;o<=this.raggedRank;++o)s=this.calculateOutputIndex(o-1,s,a[o],n[o]);this.setOutput(this.raggedRank,s,i,r)}return[r,i]}setOutput(t,n,a,r){if(a.length===0)return;let i=this.values,s=a,o=r.slice();o=o.slice(t+1);let u=O.sizeFromShape(o),d=n.length,c=this.defaultValue;if(c.length!==u&&c.length!==1){let x=this.defaultValueShape;be(()=>{let v=ge(c,x);c=Gd(v,o).dataSync()})}let h=0,m=0,g=0;for(let x=0;x<=d;++x){let v=x<d?n[x]:-1;if(v===g){++g;continue}if(m<g){let S=i.subarray(h*u),E=s.subarray(m*u),C=(g-m)*u;SR(E,S,C)}if(x>=d){let S=a.length;v=Math.floor(S/u)}if(v>g)if(this.defaultValue.length===1)s.subarray(g*u,v*u).fill(this.defaultValue[0]),g=v;else for(;v>g;){let S=s.slice(g*u);SR(S,c,u),++g}v<0?(h=x+1,m=g):(h=x,m=g,g=m+1)}}};function SR(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function kR(e,t){let n=[];for(let a of e){if(a<0){if(!t)throw new Error(`Dimension ${a} must be >= 0`);if(a<-1)throw new Error(`Dimension ${a} must be >= -1`);a=-1}n.push(a)}return n}function VB(e,t,n,a,r,i,s,o,u,d){return new xte(e,t,n,a,r,i,s,o,u,d).compute()}function KI(e,t,n,a){let r=e===t,i=e<t&&n<0,s=t<e&&n>1;if(r||i||s)return O.makeZerosTypedArray(0,a);let o=Math.abs(Math.ceil((t-e)/n)),u=O.makeZerosTypedArray(o,a);t<e&&n===1&&(n=-1),u[0]=e;for(let d=1;d<u.length;d++)u[d]=u[d-1]+n;return u}var WB=dl(e=>1/Math.sqrt(e)),vte=Hc(vh,WB),Ste={kernelName:vh,backendName:"cpu",kernelFunc:vte};function Hd(e,t,n,a,r,i,s,o,u,d){let c=[a/r,r],h=e.values,m=t.values;if(a===0)return Zt(n,t.dtype);let g=u instanceof Ma?u:Zt(c,t.dtype);typeof u=="string"||typeof u=="number"?g.values.fill(u):typeof u=="boolean"&&g.values.fill(+u);for(let x=0;x<i;x++){let v=[],S=0;for(let E=0;E<s;E++){let C=h[x*s+E];v.push(C),S+=C*o[E]}if(S<0||S>=a/r)throw new Error(`Invalid indices: ${v} does not index into ${n}`);for(let E=0;E<r;E++)d?g.values[S*r+E]+=m[x*r+E]:g.values[S*r+E]=t.rank===0?m[0]:m[x*r+E]}return g}var kte=dl(e=>1/(1+Math.exp(-e))),qB=Vn(Ch,e=>1/(1+Math.exp(-e))),Ate={kernelName:Ch,backendName:"cpu",kernelFunc:qB};function V1(e,t,n,a,r){let i=$a.isSliceContinous(a,t,n),s=O.sizeFromShape(n),o=O.computeStrides(a);if(i){let h=$a.computeFlatOffset(t,o);return r==="string"?e.slice(h,h+s):e.subarray(h,h+s)}let u=r==="string"?P.fromUint8ToStringArray(e):e,d=Zt(a,r,u),c=Zt(n,r);for(let h=0;h<c.size;++h){let m=c.indexToLoc(h),g=m.map((x,v)=>x+t[v]);c.set(d.get(...g),...m)}return r==="string"?P.fromStringArrayToUint8(c.values):c.values}function cp(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:i,size:s}=a;ct(r,"slice");let[o,u]=$a.parseSliceParams(r,i,s);$a.assertParamsValid(r,o,u);let d=n.data.get(r.dataId).values,c=V1(d,o,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,c)}var Ete={kernelName:Ag,backendName:"cpu",kernelFunc:cp};function PB(e,t,n,a,r,i,s){let o=t[0],u=i[0],d=new Array(u),c=new Array(o),h=t[1];if(u===0){if(o!==0)throw new Error(P.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let S=O.getArrayFromDType(n,0),E=O.getArrayFromDType(r,0);return[S,[0,h],E,d,c]}let m=!0,g=0,x=new Array(u).fill(0);for(let S=0;S<o;++S){let E=e[S*h];if(E<0)throw new Error(P.getSparseFillEmptyRowsNegativeIndexErrorMessage(S,E));if(E>=u)throw new Error(P.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(S,E,u));++x[E],m=m&&E>=g,g=E}let v=!0;for(let S=0;S<u;++S){let E=x[S]===0;d[S]=E,v=v&&!E,x[S]=Math.max(x[S],1),S>0&&(x[S]+=x[S-1])}if(v&&m){let S=e,E=a;for(let C=0;C<o;++C)c[C]=C;return[S,[o,h],E,d,c]}else{let S=x[u-1],E=O.getArrayFromDType(n,S*h),C=O.getArrayFromDType(r,S),T=new Array(u).fill(0);for(let N=0;N<o;++N){let D=e[N*h],q=T[D],H=(D===0?0:x[D-1])+q;T[D]++;for(let K=0;K<h;++K)E[H*h+K]=e[N*h+K];C[H]=a[N],c[N]=H}for(let N=0;N<u;++N)if(T[N]===0){let D=N===0?0:x[N-1];E[D*h+0]=N;for(let q=1;q<h;++q)E[D*h+q]=0;C[D]=s}return[E,[S,h],C,d,c]}}function HB(e,t,n,a,r){let i=O.sizeFromShape(a),s=t[0],o=r.length,u=[],d=1,c=-1;for(let v=0;v<o;++v){let S=r[v];if(S===-1){if(c!==-1)throw new Error(P.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,v));c=v,u.push(1)}else{if(S<0)throw new Error(P.getSparseReshapeNegativeOutputDimErrorMessage(v,S));d*=S,u.push(S)}}if(c!==-1){if(d<=0)throw new Error(P.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let v=Math.trunc(i/d);if(d*v!==i)throw new Error(P.getSparseReshapeInputOutputMultipleErrorMessage(a,u));u[c]=v}if(O.sizeFromShape(u)!==i)throw new Error(P.getSparseReshapeInputOutputMismatchErrorMessage(a,u));let h=a.length,m=[];if(h>0){m[h-1]=1;for(let v=h-2;v>=0;--v)m[v]=m[v+1]*a[v+1]}let g=[];if(o>0){g[o-1]=1;for(let v=o-2;v>=0;--v)g[v]=g[v+1]*u[v+1]}let x=O.getArrayFromDType(n,s*o);for(let v=0;v<s;++v){let S=0;for(let E=0;E<h;++E)S+=e[v*h+E]*m[E];for(let E=0;E<o;++E)x[v*o+E]=Math.trunc(S/g[E]),S%=g[E]}return[x,[s,o],u]}function $I(e,t,n,a,r,i=!1,s=0){let o=a.length,u=[t[0],e.length/t[0]],d=u[1],c=o>0?r[o-1]+1:0;if(c<0)throw new Error(P.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=t.slice();h[0]=c;let m=h.reduce((C,T)=>C*T,1),g=O.getArrayFromDType(n,m);if(o===0)return c>0&&g.fill(s),[g,h];if(c<=0)throw new Error(P.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let x=0,v=1,S=0,E=r[x];for(;;){let C=0;if(v<o){if(C=r[v],E===C){++v;continue}if(E>=C)throw new Error(P.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(E<0||E>=c)throw new Error(P.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(E,c));E>S&&g.fill(s,S*d,E*d);for(let T=x;T<v;++T){let N=a[T];if(N<0||N>=u[0])throw new Error(P.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(T,a[T],u[0]));for(let D=0;D<d;D++)g[E*d+D]+=e[N*d+D]}if(i)for(let T=0;T<d;T++)g[E*d+T]/=v-x;if(x=v,++v,S=E+1,E=C,v>o)break}return S<c&&g.fill(s,S*d,c*d),[g,h]}var Cte=dl(e=>Math.sqrt(e)),Ite=Vn(_h,e=>Math.sqrt(e)),_te={kernelName:_h,backendName:"cpu",kernelFunc:Ite},GB=Ta((e,t)=>{let n=e-t;return n*n}),Tte=ja(Rh,GB),Nte={kernelName:Rh,backendName:"cpu",kernelFunc:Tte},KB=dl((e,t)=>{let{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)}),Rte=Hc(C0,KB),Fte={kernelName:C0,backendName:"cpu",kernelFunc:Rte};function $B(e,t,n,a){let r=Zt(e,t.dtype);for(let i=0;i<r.size;i++){let s=r.indexToLoc(i),o=new Array(s.length);for(let u=0;u<o.length;u++)o[u]=s[u]*n[u]+a[u];r.set(t.get(...o),...s)}return r}var Dte=class{constructor(e,t,n,a,r,i){this.separator=O.encodeString(e),this.nGramWidths=t,this.leftPad=O.encodeString(n),this.rightPad=O.encodeString(a),this.padWidth=r,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,i){for(let s=0;s<r;++s){let o=this.getPadWidth(i),u=Math.max(0,o-s),d=Math.max(0,o-(r-(s+1))),c=i-(u+d),h=t+(u>0?0:s-o),m=0;m+=u*this.leftPad.length;for(let E=0;E<c;++E)m+=e[h+E].length;m+=d*this.rightPad.length;let g=u+d+c-1;m+=g*this.separator.length,n[a+s]=new Uint8Array(m);let x=n[a+s],v=0,S=E=>E.forEach(C=>x[v++]=C);for(let E=0;E<u;++E)S(this.leftPad),S(this.separator);for(let E=0;E<c-1;++E)S(e[h+E]),S(this.separator);if(c>0){S(e[h+c-1]);for(let E=0;E<d;++E)S(this.separator),S(this.rightPad)}else{for(let E=0;E<d-1;++E)S(this.rightPad),S(this.separator);S(this.rightPad)}}}compute(e,t){let n=e.length,a=t.length;if(a>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let u=1;u<a;++u){let d=t[u]>=o;if(d=d&&t[u]<=n,!d)throw new Error(`Invalid split value ${t[u]}, must be in [${o}, ${n}]`);o=t[u]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let r=a-1,i=O.getArrayFromDType("int32",a);if(n===0||a===0){let o=new Array(n);for(let u=0;u<=r;++u)i[u]=0;return[o,i]}i[0]=0;for(let o=1;o<=r;++o){let u=t[o]-t[o-1],d=0;this.nGramWidths.forEach(c=>{d+=this.getNumNGrams(u,c)}),this.preserveShort&&u>0&&d===0&&(d=1),i[o]=i[o-1]+d}let s=new Array(i[r]);for(let o=0;o<r;++o){let u=t[o],d=i[o];if(this.nGramWidths.forEach(c=>{let h=t[o+1]-t[o],m=this.getNumNGrams(h,c);this.createNGrams(e,u,s,d,m,c),d+=m}),this.preserveShort&&d===i[o]){let c=t[o+1]-t[o];if(c===0)continue;let h=c+2*this.padWidth;this.createNGrams(e,u,s,d,1,h)}}return[s,i]}};function JI(e,t,n,a,r,i,s,o){return new Dte(n,a,r,i,s,o).compute(e,t)}function Ote(e,t,n,a){if(!e.length)return;if(t.length===0){for(let i=0;i<e.length;++i)a.push(e.subarray(i,i+1));return}if(t.length===1){let i=t[0],s=e.indexOf(i);for(;s!==-1;){let o=e.subarray(0,s);(!n||o.length!==0)&&a.push(o),e=e.subarray(s+1),s=e.indexOf(i)}(!n||e.length!==0)&&a.push(e);return}let r=0;for(let i=0;i<e.length+1;i++)if(i===e.length||t.indexOf(e[i])!==-1){let s=e.subarray(r,i);(!n||s.length!==0)&&a.push(s),r=i+1}}function YI(e,t,n){let a=e.length,r=[],i=0,s=0,o=new Array(a);for(let m=0;m<a;++m){let g=r.length;Ote(e[m],t,n,r);let x=r.length-g;o[m]=x,i+=x,s=Math.max(s,x)}let u=O.getArrayFromDType("int32",i*2),d=new Array(i),c=[a,s],h=0;for(let m=0;m<a;++m)for(let g=0;g<o[m];++g)u[h*2]=m,u[h*2+1]=g,d[h]=r[h],++h;return[u,d,c]}function jI(e,t){let n=O.getArrayFromDType("int32",e.length);for(let a=0;a<e.length;++a)n[a]=O.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();return n}var JB=Ta((e,t)=>e-t),Mte=WI((e,t,n,a)=>({real:e-n,imag:t-a})),QI=ja(Fh,JB,Mte),Bte={kernelName:Fh,backendName:"cpu",kernelFunc:QI};function YB(e,t){let n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];let a=Zt(n,e.dtype);for(let r=0;r<a.values.length;++r){let i=a.indexToLoc(r),s=new Array(e.rank);for(let u=0;u<s.length;u++)s[u]=i[u]%e.shape[u];let o=e.locToIndex(s);a.values[r]=e.values[o]}return a}var Ay=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function jB(e,t,n=0,a=e.length-1){for(;a>n;){if(a-n>600){let o=a-n+1,u=t-n+1,d=Math.log(o),c=.5*Math.exp(2*d/3),h=.5*Math.sqrt(d*c*(o-c)/o)*Math.sign(u-o/2),m=Math.max(n,Math.floor(t-u*c/o+h)),g=Math.min(a,Math.floor(t+(o-u)*c/o+h));jB(e,t,m,g)}let r=e[t],i=n,s=a;for(O.swap(e,n,t),Ay(e[a],r)>0&&O.swap(e,n,a);i<s;){for(O.swap(e,i,s),i++,s--;Ay(e[i],r)<0;)i=i+1;for(;Ay(e[s],r)>0;)s=s-1}Ay(e[n],r)===0?O.swap(e,n,s):(s=s+1,O.swap(e,s,a)),s<=t&&(n=s+1),t<=s&&(a=s-1)}}function QB(e,t,n,a,r){let i=t[t.length-1],[s,o]=[e.length/i,i],u=O.getTypedArrayFromDType(n,s*a),d=O.getTypedArrayFromDType("int32",s*a);for(let h=0;h<s;h++){let m=h*o,g=e.subarray(m,m+o),x=new Array(g.length);g.forEach((C,T)=>x[T]={value:C,index:T}),a<x.length&&(jB(x,a),x=x.slice(0,a)),r&&x.sort(Ay);let v=h*a,S=u.subarray(v,v+a),E=d.subarray(v,v+a);for(let C=0;C<a;C++)S[C]=x[C].value,E[C]=x[C].index}let c=t.slice();return c[c.length-1]=a,[Zt(c,n,u),Zt(c,"int32",d)]}function ZI(e,t,n,a){let r=O.parseAxisParam(t,n)[0],i=[1,n[0],1];for(let x=0;x<r;x++)i[0]*=n[x];i[1]=n[r];for(let x=r+1;x<n.length;x++)i[2]*=n[x];let s=new Map,o=new Int32Array(n[r]),u=new Ma(i,a,e),d=[],c=i[0]===1&&i[2]===1;for(let x=0;x<n[r];x++){let v;if(c)v=e[x].toString();else{let E=[];for(let C=0;C<i[0];C++)for(let T=0;T<i[2];T++)E.push(u.get(C,x,T));v=E.join(",")}let S=s.get(v);if(S!=null)o[x]=S;else{let E=s.size;s.set(v,E),o[x]=E,d.push(x)}}let h=i.slice();h[1]=s.size;let m=new Ma(h,a);d.forEach((x,v)=>{for(let S=0;S<i[0];S++)for(let E=0;E<i[2];E++)m.set(u.get(S,x,E),S,v,E)});let g=n.slice();return g[r]=h[1],{outputValues:m.values,outputShape:g,indices:o}}var Lte="4.22.0";yv("cpu",()=>new UI,1);var ZB=Vn(zp,e=>e>=0?e:Math.exp(e)-1),zte={kernelName:zp,backendName:"cpu",kernelFunc:ZB};function XB(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:i}=a;ct([r],"leakyRelu");let s=O.sizeFromShape(r.shape),o=n.data.get(r.dataId).values,u=O.getTypedArrayFromDType("float32",s);for(let d=0;d<o.length;d++)u[d]=o[d]<0?i*o[d]:o[d];return n.makeTensorInfo(r.shape,"float32",u)}var Ute={kernelName:jp,backendName:"cpu",kernelFunc:XB},Vte=Ta((e,t)=>e<0?t*e:e);function e4(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t;ct([a,r],"prelu");let i=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,[o,u]=Vte(a.shape,r.shape,i,s,"float32");return n.makeTensorInfo(u,"float32",o)}var Wte={kernelName:ph,backendName:"cpu",kernelFunc:e4},t4=Vn(mh,e=>Math.max(0,e)),qte={kernelName:mh,backendName:"cpu",kernelFunc:t4},n4=Vn(yh,e=>Math.min(Math.max(0,e),6)),Pte={kernelName:yh,backendName:"cpu",kernelFunc:n4};function W1(e,t,n,a,r){if(n==="linear")return ol({inputs:{x:t},backend:e});if(n==="relu")return t4({inputs:{x:t},backend:e});if(n==="elu")return ZB({inputs:{x:t},backend:e});if(n==="relu6")return n4({inputs:{x:t},backend:e});if(n==="prelu")return e4({inputs:{x:t,alpha:a},backend:e});if(n==="leakyrelu")return XB({inputs:{x:t},backend:e,attrs:{alpha:r}});if(n==="sigmoid")return qB({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function sa(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:i}=a,s=O.sizeFromShape(r.shape),o=O.inferFromImplicitShape(i,s),u=O.sizeFromShape(o);O.assert(s===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${r.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);let d=n.data.get(r.dataId);if(d.complexTensorInfos!=null){let c=d.complexTensorInfos.real,h=d.complexTensorInfos.imag;c.shape=o,h.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}var Hte={kernelName:bg,backendName:"cpu",kernelFunc:sa};function a4(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:i}=t,{transposeA:s,transposeB:o}=a;ct([r,i],"matMul");let u=r.shape.length,d=i.shape.length,c=s?r.shape[u-2]:r.shape[u-1],h=o?i.shape[d-1]:i.shape[d-2],m=s?r.shape[u-1]:r.shape[u-2],g=o?i.shape[d-2]:i.shape[d-1],x=r.shape.slice(0,-2),v=i.shape.slice(0,-2),S=O.sizeFromShape(x),E=O.sizeFromShape(v),C=Mg.assertAndGetBroadcastShape(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,g]);O.assert(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${s} and transposeB=${o} must match.`);let T=s?[S,c,m]:[S,m,c],N=o?[E,g,h]:[E,h,g],D=sa({inputs:{x:r},backend:n,attrs:{shape:T}}),q=sa({inputs:{x:i},backend:n,attrs:{shape:N}}),H=s?D.shape[1]:D.shape[2],K=s?D.shape[2]:D.shape[1],j=o?q.shape[1]:q.shape[2],te=Math.max(S,E),Q=n.data.get(D.dataId).values,z=n.data.get(q.dataId).values,ae=O.computeStrides(D.shape),ue=O.computeStrides(q.shape),[he,Z,se]=s?[ae[0],1,ae[1]]:[ae[0],ae[1],1],[de,Ce,Y]=o?[1,ue[1],ue[0]]:[ue[1],1,ue[0]],ie=K*j,xe=Zt([te,K,j],D.dtype),me=xe.values,_e=n.blockSize;for(let Le=0;Le<te;Le++){let qe=Le%S,$e=Le%E;for(let Ke=0;Ke<K;Ke+=_e){let rt=Math.min(Ke+_e,K);for(let ht=0;ht<j;ht+=_e){let kt=Math.min(ht+_e,j);for(let _t=0;_t<H;_t+=_e){let ln=Math.min(_t+_e,H);for(let Nt=Ke;Nt<rt;Nt++)for(let Pt=ht;Pt<kt;Pt++){let Re=0;for(let ft=_t;ft<ln;ft++){let wt=Q[qe*he+Nt*Z+ft*se],oa=z[ft*de+Pt*Ce+$e*Y];Re+=wt*oa}me[Le*ie+(Nt*j+Pt)]+=Re}}}}}return n.disposeIntermediateTensorInfo(D),n.disposeIntermediateTensorInfo(q),n.makeTensorInfo(C,xe.dtype,xe.values)}var Gte={kernelName:Cp,backendName:"cpu",kernelFunc:a4};function Kte(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:i,bias:s,preluActivationWeights:o}=t,{transposeA:u,transposeB:d,activation:c,leakyreluAlpha:h}=a,m,g,x,v=[];m=a4({inputs:{a:r,b:i},attrs:{transposeA:u,transposeB:d},backend:n}),s&&(g=_m({inputs:{a:m,b:s},backend:n}),v.push(m),m=g),c&&(x=W1(n,m,c,o,h),v.push(m),m=x);for(let S of v)n.disposeIntermediateTensorInfo(S);return m}var $te={kernelName:jd,backendName:"cpu",kernelFunc:Kte},Jte=Vn(bp,e=>Math.acos(e)),Yte={kernelName:bp,backendName:"cpu",kernelFunc:Jte},jte=Vn(yp,e=>Math.acosh(e)),Qte={kernelName:yp,backendName:"cpu",kernelFunc:jte};function Zte(e){let{inputs:t,backend:n}=e,a=t;ct(t,"addN");let r=a.map(o=>n.data.get(o.dataId).values),i=Zt(a[0].shape,a[0].dtype),s=i.values;for(let o=0;o<a.length;o++){let u=r[o];for(let d=0;d<s.length;d++)s[d]+=u[d]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}var Xte={kernelName:wp,backendName:"cpu",kernelFunc:Zte};function ene(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:s}=a;ct(r,"all");let o=O.parseAxisParam(i,r.shape),u=o,d=P.getAxesPermutation(u,r.shape.length),c=r;d!=null&&(c=pi({inputs:{x:r},backend:n,attrs:{perm:d}}),u=P.getInnerMostAxes(u.length,r.shape.length)),P.assertAxesAreInnerMostDims("all",u,c.shape.length);let[h,m]=P.computeOutAndReduceShapes(c.shape,u),g=O.sizeFromShape(m),x=O.makeZerosTypedArray(O.sizeFromShape(h),c.dtype),v=n.data.get(c.dataId).values;for(let E=0;E<x.length;++E){let C=E*g,T=v[C];for(let N=0;N<g;++N){let D=v[C+N];T=T&&D}x[E]=T}d!=null&&n.disposeIntermediateTensorInfo(c);let S=n.makeTensorInfo(h,c.dtype,x);if(s){let E=P.expandShapeToKeepDim(h,o),C=sa({inputs:{x:S},backend:n,attrs:{shape:E}});return n.disposeIntermediateTensorInfo(S),C}return S}var tne={kernelName:Om,backendName:"cpu",kernelFunc:ene};function nne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:s}=a;ct(r,"any");let o=O.parseAxisParam(i,r.shape),u=o,d=P.getAxesPermutation(u,r.shape.length),c=r;d!=null&&(c=pi({inputs:{x:r},backend:n,attrs:{perm:d}}),u=P.getInnerMostAxes(u.length,r.shape.length)),P.assertAxesAreInnerMostDims("any",u,c.shape.length);let[h,m]=P.computeOutAndReduceShapes(c.shape,u),g=O.sizeFromShape(m),x=O.makeZerosTypedArray(O.sizeFromShape(h),c.dtype),v=n.data.get(c.dataId).values;for(let E=0;E<x.length;++E){let C=E*g,T=v[C];for(let N=0;N<g;++N){let D=v[C+N];T=T||D}x[E]=T}d!=null&&n.disposeIntermediateTensorInfo(c);let S=n.makeTensorInfo(h,c.dtype,x);if(s){let E=P.expandShapeToKeepDim(h,o),C=sa({inputs:{x:S},backend:n,attrs:{shape:E}});return n.disposeIntermediateTensorInfo(S),C}return S}var ane={kernelName:Mm,backendName:"cpu",kernelFunc:nne};function rne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i}=a;ct(r,"argMax");let s=O.parseAxisParam(i,r.shape),o=P.getAxesPermutation(s,r.shape.length),u=r,d=[];o!=null&&(u=pi({inputs:{x:r},backend:n,attrs:{perm:o}}),d.push(u),s=P.getInnerMostAxes(s.length,u.shape.length)),s=[s[0]],P.assertAxesAreInnerMostDims("argMax",s,u.shape.length);let[c,h]=P.computeOutAndReduceShapes(u.shape,s),m=O.sizeFromShape(c),g=O.makeZerosTypedArray(m,"int32"),x=O.sizeFromShape(h),v=n.data.get(u.dataId).values;for(let S=0;S<g.length;++S){let E=S*x,C=v[E],T=0;for(let N=0;N<x;++N){let D=v[E+N];D>C&&(C=D,T=N)}g[S]=T}return d.forEach(S=>n.disposeIntermediateTensorInfo(S)),n.makeTensorInfo(c,"int32",g)}var ine={kernelName:Bm,backendName:"cpu",kernelFunc:rne};function sne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i}=a;ct(r,"argMin");let s=O.parseAxisParam(i,r.shape),o=P.getAxesPermutation(s,r.shape.length),u=r,d=[];o!=null&&(u=pi({inputs:{x:r},backend:n,attrs:{perm:o}}),d.push(u),s=P.getInnerMostAxes(s.length,u.shape.length)),s=[s[0]],P.assertAxesAreInnerMostDims("argMin",s,u.shape.length);let[c,h]=P.computeOutAndReduceShapes(u.shape,s),m=O.sizeFromShape(c),g=O.makeZerosTypedArray(m,"int32"),x=O.sizeFromShape(h),v=n.data.get(u.dataId).values;for(let S=0;S<g.length;++S){let E=S*x,C=v[E],T=0;for(let N=0;N<x;++N){let D=v[E+N];D<C&&(C=D,T=N)}g[S]=T}return d.forEach(S=>n.disposeIntermediateTensorInfo(S)),n.makeTensorInfo(c,"int32",g)}var one={kernelName:Lm,backendName:"cpu",kernelFunc:sne},lne=Vn(xp,e=>Math.asin(e)),une={kernelName:xp,backendName:"cpu",kernelFunc:lne},cne=Vn(vp,e=>Math.asinh(e)),dne={kernelName:vp,backendName:"cpu",kernelFunc:cne},pne=Vn(Sp,e=>Math.atan(e)),hne={kernelName:Sp,backendName:"cpu",kernelFunc:pne},fne=Ta((e,t)=>Math.atan2(e,t)),mne=ja(Ap,fne),gne={kernelName:Ap,backendName:"cpu",kernelFunc:mne},bne=Vn(kp,e=>Math.atanh(e)),yne={kernelName:kp,backendName:"cpu",kernelFunc:bne};function XI(e,t,n,a,r,i){let s=r.strideHeight,o=r.strideWidth,u=r.dilationHeight,d=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,m=r.padInfo.top,g=r.padInfo.left,x=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Zt(r.outShape,n),S=v.values,E=r.outShape[1]*r.outShape[2]*r.outShape[3],C=r.outShape[2]*r.outShape[3],T=r.outShape[3];for(let N=0;N<r.batchSize;++N){let D=N*E,q=N*a[0];for(let H=0;H<r.inChannels;++H)for(let K=0;K<r.outHeight;++K){let j=K*s-m,te=Math.max(0,j),Q=Math.min(r.inHeight,c+j),z=D+K*C;for(let ae=0;ae<r.outWidth;++ae){let ue=ae*o-g,he=Math.max(0,ue),Z=Math.min(r.inWidth,h+ue),se=x,de=0,Ce=0;for(let ie=te;ie<Q;ie+=u){let xe=q+ie*a[1];for(let me=he;me<Z;me+=d){let _e=xe+me*a[2],Le=e[_e+H];i==="max"&&Le>se?se=Le:i==="avg"&&(de+=Le,Ce++)}if(isNaN(se))break}let Y=z+ae*T+H;S[Y]=i==="avg"?de/Ce:se}}}return v}function r4(e,t,n,a,r=!1,i=!1){let s=Zt(a.outShape,"int32"),o=a.strideHeight,u=a.strideWidth,d=a.dilationHeight,c=a.dilationWidth,h=a.effectiveFilterHeight,m=a.effectiveFilterWidth,g=a.padInfo.top,x=a.padInfo.left,v=Zt(t,n,e);for(let S=0;S<a.batchSize;++S)for(let E=0;E<a.inChannels;++E)for(let C=0;C<a.outHeight;++C){let T=C*o-g,N=T;for(;N<0;)N+=d;let D=Math.min(a.inHeight,h+T);for(let q=0;q<a.outWidth;++q){let H=q*u-x,K=H;for(;K<0;)K+=c;let j=Math.min(a.inWidth,m+H),te=Number.NEGATIVE_INFINITY,Q=-1;for(let z=N;z<D;z+=d){let ae=z-T;for(let ue=K;ue<j;ue+=c){let he=ue-H,Z=v.get(S,z,ue,E);Z>te&&(te=Z,r?Q=i?((S*a.inHeight+z)*a.inWidth+ue)*a.inChannels+E:(z*a.inWidth+ue)*a.inChannels+E:Q=ae*m+he)}}s.set(Q,S,C,q,E)}}return s}function i4(e,t,n,a,r,i){let s=r.strideDepth,o=r.strideHeight,u=r.strideWidth,d=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,m=r.effectiveFilterDepth,g=r.effectiveFilterHeight,x=r.effectiveFilterWidth,v=r.padInfo.front,S=r.padInfo.top,E=r.padInfo.left,C=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,T=Zt(r.outShape,n),N=T.values,D=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],q=r.outShape[2]*r.outShape[3]*r.outShape[4],H=r.outShape[3]*r.outShape[4],K=r.outShape[4];for(let j=0;j<r.batchSize;++j){let te=j*D,Q=j*a[0];for(let z=0;z<r.inChannels;++z)for(let ae=0;ae<r.outDepth;++ae){let ue=ae*s-v,he=ue;for(;he<0;)he+=d;let Z=Math.min(r.inDepth,m+ue),se=te+ae*q;for(let de=0;de<r.outHeight;++de){let Ce=de*o-S,Y=Ce;for(;Y<0;)Y+=c;let ie=Math.min(r.inHeight,g+Ce),xe=se+de*H;for(let me=0;me<r.outWidth;++me){let _e=me*u-E,Le=_e;for(;Le<0;)Le+=h;let qe=Math.min(r.inWidth,x+_e),$e=xe+me*K,Ke=C,rt=0,ht=0;for(let _t=he;_t<Z;_t+=d){let ln=Q+_t*a[1];for(let Nt=Y;Nt<ie;Nt+=c){let Pt=ln+Nt*a[2];for(let Re=Le;Re<qe;Re+=h){let ft=Pt+Re*a[3],wt=e[ft+z];if(i==="max"&&wt>Ke?Ke=wt:i==="avg"&&(rt+=wt,ht++),isNaN(Ke))break}if(isNaN(Ke))break}if(isNaN(Ke))break}let kt=$e+z;N[kt]=i==="avg"?rt/Math.max(ht,1):Ke}}}}return T}function wne(e,t){let n=Zt(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,d=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,x=t.padInfo.left;for(let v=0;v<t.batchSize;++v)for(let S=0;S<t.inChannels;++S)for(let E=0;E<t.outDepth;++E){let C=E*a-m,T=C;for(;T<0;)T+=s;let N=Math.min(t.inDepth,d+C);for(let D=0;D<t.outHeight;++D){let q=D*r-g,H=q;for(;H<0;)H+=o;let K=Math.min(t.inHeight,c+q);for(let j=0;j<t.outWidth;++j){let te=j*i-x,Q=te;for(;Q<0;)Q+=u;let z=Math.min(t.inWidth,h+te),ae=Number.NEGATIVE_INFINITY,ue=-1;for(let he=T;he<N;he+=s){let Z=he-C;for(let se=H;se<K;se+=o){let de=se-q;for(let Ce=Q;Ce<z;Ce+=u){let Y=Ce-te,ie=e.get(v,he,se,Ce,S);ie>=ae&&(ae=ie,ue=Z*c*h+de*c+Y)}}}n.set(ue,v,E,D,j,S)}}}return n}function xne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;ct(r,"avgPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:u}=a,d=1;O.assert(P.eitherStridesOrDilationsAreOne(s,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`);let c=P.computePool2DInfo(r.shape,i,s,d,o,u),h;if(c.filterWidth===1&&c.filterHeight===1&&O.arraysEqual(c.inShape,c.outShape))h=ol({inputs:{x:r},backend:n});else{let m=n.data.get(r.dataId).values,g=O.computeStrides(r.shape),x=XI(m,r.shape,r.dtype,g,c,"avg");h=n.makeTensorInfo(c.outShape,r.dtype,x.values)}return h}var vne={kernelName:Ep,backendName:"cpu",kernelFunc:xne};function Sne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:u,dataFormat:d}=a;ct(r,"avgPool3d");let c=P.computePool3DInfo(r.shape,i,s,1,o,u,d),h=n.data.get(r.dataId).values,m=i4(h,r.shape,r.dtype,O.computeStrides(r.shape),c,"avg");return n.makeTensorInfo(m.shape,"float32",m.values)}var kne={kernelName:zm,backendName:"cpu",kernelFunc:Sne};function Ane(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,{filterSize:s,strides:o,pad:u,dimRoundingMode:d}=a;ct([r,i],"avgPool3DGrad");let c=P.computePool3DInfo(i.shape,s,o,1,u,d),h=c.strideDepth,m=c.strideHeight,g=c.strideWidth,x=c.filterDepth,v=c.filterHeight,S=c.filterWidth,E=c.dilationDepth,C=c.dilationHeight,T=c.dilationWidth,N=c.effectiveFilterDepth,D=c.effectiveFilterHeight,q=c.effectiveFilterWidth,H=N-1-c.padInfo.front,K=q-1-c.padInfo.left,j=D-1-c.padInfo.top,te=Zt(i.shape,"float32"),Q=1/(x*v*S),z=n.bufferSync(r);for(let ae=0;ae<c.batchSize;++ae)for(let ue=0;ue<c.inChannels;++ue)for(let he=0;he<c.inDepth;++he)for(let Z=0;Z<c.inHeight;++Z)for(let se=0;se<c.inWidth;++se){let de=he-H,Ce=Z-j,Y=se-K,ie=0;for(let xe=0;xe<N;xe+=E){let me=(de+xe)/h;if(!(me<0||me>=c.outDepth||Math.floor(me)!==me))for(let _e=0;_e<D;_e+=C){let Le=(Ce+_e)/m;if(!(Le<0||Le>=c.outHeight||Math.floor(Le)!==Le))for(let qe=0;qe<q;qe+=T){let $e=(Y+qe)/g;if($e<0||$e>=c.outWidth||Math.floor($e)!==$e)continue;let Ke=z.get(ae,me,Le,$e,ue);ie+=Ke}}}te.set(ie*Q,ae,he,Z,se,ue)}return n.makeTensorInfo(te.shape,te.dtype,te.values)}var Ene={kernelName:p0,backendName:"cpu",kernelFunc:Ane};function Cne(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,s=i;ct([r,i],"avgPoolGrad");let{filterSize:o,strides:u,pad:d}=a,c=P.computePool2DInfo(s.shape,o,u,1,d),h=c.strideHeight,m=c.strideWidth,g=c.filterHeight,x=c.filterWidth,v=c.dilationHeight,S=c.dilationWidth,E=c.effectiveFilterHeight,C=c.effectiveFilterWidth,T=C-1-c.padInfo.left,N=E-1-c.padInfo.top,D=Zt(s.shape,"float32"),q=1/(g*x),H=n.data.get(r.dataId).values,K=Zt(r.shape,"float32",H);for(let j=0;j<c.batchSize;++j)for(let te=0;te<c.inChannels;++te)for(let Q=0;Q<c.inHeight;++Q)for(let z=0;z<c.inWidth;++z){let ae=Q-N,ue=z-T,he=0;for(let Z=0;Z<E;Z+=v){let se=(ae+Z)/h;if(!(se<0||se>=c.outHeight||Math.floor(se)!==se))for(let de=0;de<C;de+=S){let Ce=(ue+de)/m;if(Ce<0||Ce>=c.outWidth||Math.floor(Ce)!==Ce)continue;let Y=K.get(j,se,Ce,te);he+=Y}}D.set(he*q,j,Q,z,te)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}var Ine={kernelName:d0,backendName:"cpu",kernelFunc:Cne};function _ne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,scale:i,offset:s,mean:o,variance:u}=t;O.assert(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O.assert(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ct([r,o,u,i,s],"batchNorm");let{varianceEpsilon:d}=a;d==null&&(d=.001);let c=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,m=n.data.get(u.dataId).values,g=i?n.data.get(i.dataId).values:new Float32Array([1]),x=s?n.data.get(s.dataId).values:new Float32Array([0]),v=new Float32Array(c.length),S=x.length,E=g.length,C=m.length,T=h.length,N=0,D=0,q=0,H=0;for(let K=0;K<c.length;++K)v[K]=x[N++]+(c[K]-h[D++])*g[q++]/Math.sqrt(m[H++]+d),N>=S&&(N=0),D>=T&&(D=0),q>=E&&(q=0),H>=C&&(H=0);return n.makeTensorInfo(r.shape,r.dtype,v)}var Tne={kernelName:Hp,backendName:"cpu",kernelFunc:_ne};function Nne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:i,crops:s}=a;ct([r],"batchToSpaceND");let o=i.reduce((E,C)=>E*C),u=P.getReshaped(r.shape,i,o),d=P.getPermuted(u.length,i.length),c=P.getReshapedPermuted(r.shape,i,o),h=P.getSliceBeginCoords(s,i.length),m=P.getSliceSize(c,s,i.length),g=sa({inputs:{x:r},backend:n,attrs:{shape:u}}),x=pi({inputs:{x:g},backend:n,attrs:{perm:d}}),v=sa({inputs:{x},backend:n,attrs:{shape:c}}),S=cp({inputs:{x:v},backend:n,attrs:{begin:h,size:m}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),S}var Rne={kernelName:Um,backendName:"cpu",kernelFunc:Nne};function Fne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:i}=t,{size:s}=a,o=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,d=qI(o,u,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,d)}var Dne={kernelName:Vm,backendName:"cpu",kernelFunc:Fne};function One(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,i=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values,o=P.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Mne={kernelName:h0,backendName:"cpu",kernelFunc:One},Bne=Vn(Bc,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),Lne={kernelName:Bc,backendName:"cpu",kernelFunc:Bne},zne=e=>{let{x:t}=e.inputs,n=e.backend,a=new Float32Array(O.sizeFromShape(t.shape)),r=n.data.get(t.dataId),i=r.complexTensorInfos.real,s=r.complexTensorInfos.imag,o=n.data.get(i.dataId).values,u=n.data.get(s.dataId).values;for(let d=0;d<o.length;d++){let c=o[d],h=u[d];a[d]=Math.hypot(c,h)}return n.makeOutput(a,t.shape,"float32")},Une={kernelName:f0,backendName:"cpu",kernelFunc:zne};function Tm(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}var Vne={kernelName:dv,backendName:"cpu",kernelFunc:Tm};function Nm(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,i=O.parseAxisParam(r,t[0].shape)[0],s=t.map(v=>v.shape);P.assertParamsConsistent(s,i);let o=P.computeOutShape(t.map(v=>v.shape),i);if(O.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let u=t.filter(v=>O.sizeFromShape(v.shape)>0);if(u.length===1)return ol({inputs:{x:u[0]},backend:n});if(u[0].dtype==="complex64"){let v=u.map(N=>up({inputs:{input:N},backend:n})),S=u.map(N=>Tm({inputs:{input:N},backend:n})),E=Nm({inputs:v,backend:n,attrs:{axis:i}}),C=Nm({inputs:S,backend:n,attrs:{axis:i}}),T=Ii({inputs:{real:E,imag:C},backend:n});return v.forEach(N=>n.disposeIntermediateTensorInfo(N)),S.forEach(N=>n.disposeIntermediateTensorInfo(N)),n.disposeIntermediateTensorInfo(E),n.disposeIntermediateTensorInfo(C),T}let d=u.map(v=>{let S=[-1,O.sizeFromShape(v.shape.slice(i))];return sa({inputs:{x:v},backend:n,attrs:{shape:S}})}),c=d.map(v=>({vals:n.data.get(v.dataId).values,shape:v.shape}));o=P.computeOutShape(d.map(v=>v.shape),1);let h=d[0].shape[0]===1,m=PI(c,o,t[0].dtype,h),g=P.computeOutShape(u.map(v=>v.shape),i),x=n.makeTensorInfo(g,t[0].dtype,m);return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}var Wne={kernelName:qm,backendName:"cpu",kernelFunc:Nm};function s4(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:s,pad:o,dataFormat:u,dilations:d,dimRoundingMode:c}=a;ct([r,i],"conv2d");let h=P.convertConv2DDataFormat(u),m=P.computeConv2DInfo(r.shape,i.shape,s,d,o,c,!1,h),g=m.filterHeight,x=m.filterWidth,v=m.dilationHeight,S=m.dilationWidth,E=m.padInfo.left,C=m.padInfo.top,T=m.dataFormat==="channelsLast",N=new Ma(m.outShape,r.dtype),D=O.computeStrides(r.shape),q=O.computeStrides(i.shape),H=D[0],K=T?D[1]:D[2],j=T?D[2]:1,te=T?1:D[1],Q=N.strides[0],z=T?N.strides[1]:N.strides[2],ae=T?N.strides[2]:1,ue=T?1:N.strides[1],he=n.data.get(r.dataId).values,Z=n.data.get(i.dataId).values,se=N.values;for(let de=0;de<m.batchSize;++de){let Ce=de*H,Y=de*Q;for(let ie=0;ie<m.outHeight;++ie){let xe=Y+ie*z,me=ie*m.strideHeight-C;for(let _e=0;_e<g;++_e){let Le=me+_e*v;if(Le<0||Le>=m.inHeight)continue;let qe=_e*q[0],$e=Ce+Le*K;for(let Ke=0;Ke<m.outWidth;++Ke){let rt=xe+Ke*ae,ht=Ke*m.strideWidth-E;for(let kt=0;kt<x;++kt){let _t=ht+kt*S;if(_t<0||_t>=m.inWidth)continue;let ln=qe+kt*q[1],Nt=$e+_t*j,Pt=ln;for(let Re=0;Re<m.inChannels;++Re){let ft=he[Nt+Re*te];for(let wt=0;wt<m.outChannels;++wt)se[rt+wt*ue]+=ft*Z[Pt+wt];Pt+=m.outChannels}}}}}}return n.makeTensorInfo(N.shape,N.dtype,se)}var qne={kernelName:Tp,backendName:"cpu",kernelFunc:s4};function Pne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:s,pad:o,dataFormat:u,dimRoundingMode:d,filterShape:c}=a;ct([r,i],"conv2dBackpropFilter");let h=P.convertConv2DDataFormat(u),m=P.computeConv2DInfo(r.shape,c,s,1,o,d,!1,h),{strideHeight:g,strideWidth:x,filterHeight:v,filterWidth:S}=m,E=m.dataFormat==="channelsLast",C=new Ma(m.filterShape,"float32"),T=m.padInfo.left,N=m.padInfo.top,D=n.data.get(r.dataId).values,q=n.data.get(i.dataId).values,H=new Ma(r.shape,r.dtype,D),K=new Ma(i.shape,i.dtype,q);for(let j=0;j<v;++j){let te=Math.max(0,Math.ceil((N-j)/g)),Q=Math.min(m.outHeight,(m.inHeight+N-j)/g);for(let z=0;z<S;++z){let ae=Math.max(0,Math.ceil((T-z)/x)),ue=Math.min(m.outWidth,(m.inWidth+T-z)/x);for(let he=0;he<m.inChannels;++he)for(let Z=0;Z<m.outChannels;++Z){let se=0;for(let de=0;de<m.batchSize;++de)for(let Ce=te;Ce<Q;++Ce){let Y=j+Ce*g-N;for(let ie=ae;ie<ue;++ie){let xe=z+ie*x-T;E?se+=H.get(de,Y,xe,he)*K.get(de,Ce,ie,Z):se+=H.get(de,he,Y,xe)*K.get(de,Z,Ce,ie)}}C.set(se,j,z,he,Z)}}}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var Hne={kernelName:rv,backendName:"cpu",kernelFunc:Pne};function Gne(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{inputShape:s,strides:o,pad:u,dataFormat:d,dimRoundingMode:c}=a;ct([r,i],"conv2dBackpropInput");let h=O.computeStrides(i.shape),m=O.computeStrides(r.shape),g=P.convertConv2DDataFormat(d),x=P.computeConv2DInfo(s,i.shape,o,1,u,c,!1,g),v=new Ma(x.inShape,"float32"),S=v.values,E=n.data.get(r.dataId).values,C=n.data.get(i.dataId).values,[T,N,D]=h,{batchSize:q,filterHeight:H,filterWidth:K,inChannels:j,inHeight:te,inWidth:Q,outChannels:z,outHeight:ae,outWidth:ue,strideHeight:he,strideWidth:Z}=x;g=x.dataFormat;let se=H-1-x.padInfo.top,de=K-1-x.padInfo.left,Ce=g==="channelsLast",Y=v.strides[0],ie=Ce?v.strides[1]:v.strides[2],xe=Ce?v.strides[2]:1,me=Ce?1:v.strides[1],_e=m[0],Le=Ce?m[1]:m[2],qe=Ce?m[2]:1,$e=Ce?1:m[1];for(let Ke=0;Ke<q;++Ke)for(let rt=0;rt<j;++rt)for(let ht=0;ht<te;++ht){let kt=ht-se,_t=Math.max(0,Math.ceil(kt/he)),ln=Math.min(ae,(H+kt)/he);for(let Nt=0;Nt<Q;++Nt){let Pt=Nt-de,Re=Math.max(0,Math.ceil(Pt/Z)),ft=Math.min(ue,(K+Pt)/Z),wt=0;for(let en=_t;en<ln;++en){let Ht=en*he-kt;for(let Jn=Re;Jn<ft;++Jn){let kn=Jn*Z-Pt,pa=_e*Ke+Le*en+qe*Jn,Na=T*(H-1-Ht)+N*(K-1-kn)+D*rt;for(let An=0;An<z;++An){let tn=E[pa+$e*An],G=C[Na+An];wt+=tn*G}}}let oa=Y*Ke+ie*ht+xe*Nt+me*rt;S[oa]=wt}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var Kne={kernelName:Np,backendName:"cpu",kernelFunc:Gne};function $ne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:s,pad:o,dilations:u}=a;ct([r,i],"conv3d");let d=P.computeConv3DInfo(r.shape,i.shape,s,u,o),{filterDepth:c,filterHeight:h,filterWidth:m,dilationDepth:g,dilationHeight:x,dilationWidth:v,padInfo:S}=d,E=S.front,C=S.left,T=S.top,N=new Ma(d.outShape,r.dtype),D=n.data.get(r.dataId).values,q=n.data.get(i.dataId).values,H=N.values,K=O.computeStrides(r.shape),j=O.computeStrides(i.shape);for(let te=0;te<d.batchSize;++te){let Q=te*K[0],z=te*N.strides[0];for(let ae=0;ae<d.outDepth;++ae){let ue=z+ae*N.strides[1],he=ae*d.strideDepth-E;for(let Z=0;Z<c;++Z){let se=he+Z*g;if(se<0||se>=d.inDepth)continue;let de=Z*j[0],Ce=Q+se*K[1];for(let Y=0;Y<d.outHeight;++Y){let ie=ue+Y*N.strides[2],xe=Y*d.strideHeight-T;for(let me=0;me<h;++me){let _e=xe+me*x;if(_e<0||_e>=d.inHeight)continue;let Le=de+me*j[1],qe=Ce+_e*K[2];for(let $e=0;$e<d.outWidth;++$e){let Ke=ie+$e*d.outChannels,rt=$e*d.strideWidth-C;for(let ht=0;ht<m;++ht){let kt=rt+ht*v;if(kt<0||kt>=d.inWidth)continue;let _t=Le+ht*j[2],ln=qe+kt*d.inChannels,Nt=_t;for(let Pt=0;Pt<d.inChannels;++Pt){let Re=D[ln+Pt];for(let ft=0;ft<d.outChannels;++ft)H[Ke+ft]+=Re*q[Nt+ft];Nt+=d.outChannels}}}}}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var Jne={kernelName:Rp,backendName:"cpu",kernelFunc:$ne};function Yne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:s,pad:o,filterShape:u}=a;ct([r,i],"conv3dBackpropFilterV2");let d=O.computeStrides(r.shape),c=O.computeStrides(i.shape),h=P.computeConv3DInfo(r.shape,u,s,1,o),m=h.strideDepth,g=h.strideHeight,x=h.strideWidth,v=h.filterDepth,S=h.filterHeight,E=h.filterWidth,C=new Ma(h.filterShape,"float32"),T=C.values,[N,D,q,H]=C.strides,K=n.data.get(i.dataId).values,[j,te,Q,z]=c,ae=n.data.get(r.dataId).values,[ue,he,Z,se]=d,de=h.padInfo.front,Ce=h.padInfo.left,Y=h.padInfo.top;for(let ie=0;ie<v;++ie){let xe=Math.max(0,Math.ceil((de-ie)/m)),me=Math.min(h.outDepth,(h.inDepth+de-ie)/m),_e=ie*N;for(let Le=0;Le<S;++Le){let qe=Math.max(0,Math.ceil((Y-Le)/g)),$e=Math.min(h.outHeight,(h.inHeight+Y-Le)/g),Ke=Le*D+_e;for(let rt=0;rt<E;++rt){let ht=Math.max(0,Math.ceil((Ce-rt)/x)),kt=Math.min(h.outWidth,(h.inWidth+Ce-rt)/x),_t=rt*q+Ke;for(let ln=0;ln<h.inChannels;++ln){let Nt=ln*H+_t;for(let Pt=0;Pt<h.outChannels;++Pt){let Re=0;for(let ft=0;ft<h.batchSize;++ft){let wt=ft*ue,oa=ft*j;for(let en=xe;en<me;++en){let Ht=(ie+en*m-de)*he+wt,Jn=en*te+oa;for(let kn=qe;kn<$e;++kn){let pa=(Le+kn*g-Y)*Z+Ht,Na=kn*Q+Jn;for(let An=ht;An<kt;++An){let tn=(rt+An*x-Ce)*se+pa,G=An*z+Na;Re+=ae[tn+ln]*K[G+Pt]}}}}T[Nt+Pt]=Re}}}}}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var jne={kernelName:Pm,backendName:"cpu",kernelFunc:Yne};function Qne(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{pad:s,strides:o,inputShape:u}=a;ct([r],"conv3dBackpropInputV2");let d=O.computeStrides(r.shape),c=O.computeStrides(i.shape),h=P.computeConv3DInfo(u,i.shape,o,1,s),m=new Ma(h.inShape,"float32"),g=m.values,[x,v,S,E]=m.strides,C=n.data.get(r.dataId).values,[T,N,D,q]=d,H=n.data.get(i.dataId).values,[K,j,te,Q]=c,{batchSize:z,filterDepth:ae,filterHeight:ue,filterWidth:he,inChannels:Z,inDepth:se,inHeight:de,inWidth:Ce,outChannels:Y,outDepth:ie,outHeight:xe,outWidth:me,strideDepth:_e,strideHeight:Le,strideWidth:qe}=h,$e=ae-1-h.padInfo.front,Ke=ue-1-h.padInfo.top,rt=he-1-h.padInfo.left;for(let ht=0;ht<z;++ht)for(let kt=0;kt<Z;++kt)for(let _t=0;_t<se;++_t){let ln=_t-$e,Nt=Math.max(0,Math.ceil(ln/_e)),Pt=Math.min(ie,(ae+ln)/_e);for(let Re=0;Re<de;++Re){let ft=Re-Ke,wt=Math.max(0,Math.ceil(ft/Le)),oa=Math.min(xe,(ue+ft)/Le);for(let en=0;en<Ce;++en){let Ht=en-rt,Jn=Math.max(0,Math.ceil(Ht/qe)),kn=Math.min(me,(he+Ht)/qe),pa=0;for(let Na=Nt;Na<Pt;++Na){let An=Na*_e-ln;for(let tn=wt;tn<oa;++tn){let G=tn*Le-ft;for(let F=Jn;F<kn;++F){let L=F*qe-Ht,ne=T*ht+N*Na+D*tn+q*F,ke=K*(ae-1-An)+j*(ue-1-G)+te*(he-1-L)+Q*kt;for(let ve=0;ve<Y;++ve){let ze=C[ne+ve],ot=H[ke+ve];pa+=ze*ot}}}}g[x*ht+v*_t+S*Re+E*en+kt]=pa}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var Zne={kernelName:Hm,backendName:"cpu",kernelFunc:Qne},Xne=Vn(Fp,e=>Math.cos(e)),eae={kernelName:Fp,backendName:"cpu",kernelFunc:Xne},tae=Vn(Dp,e=>Math.cosh(e)),nae={kernelName:Dp,backendName:"cpu",kernelFunc:tae};function aae(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:i,boxInd:s}=t,{cropSize:o,method:u,extrapolationValue:d}=a,[c,h,m,g]=r.shape,x=i.shape[0],[v,S]=o,E=Zt([x,v,S,g],"float32"),C=n.data.get(i.dataId).values,T=n.data.get(s.dataId).values,N=n.data.get(r.dataId).values,D=O.computeStrides(r.shape),q=O.computeStrides(E.shape);for(let H=0;H<x;H++){let K=H*4,j=C[K],te=C[K+1],Q=C[K+2],z=C[K+3],ae=T[H];if(ae>=c)continue;let ue=v>1?(Q-j)*(h-1)/(v-1):0,he=S>1?(z-te)*(m-1)/(S-1):0;for(let Z=0;Z<v;Z++){let se=v>1?j*(h-1)+Z*ue:.5*(j+Q)*(h-1);if(se<0||se>h-1){for(let de=0;de<S;de++)for(let Ce=0;Ce<g;Ce++){let Y=Ce+de*q[2]+Z*q[1]+H*q[0];E.values[Y]=d}continue}if(u==="bilinear"){let de=Math.floor(se),Ce=Math.ceil(se),Y=se-de;for(let ie=0;ie<S;ie++){let xe=S>1?te*(m-1)+ie*he:.5*(te+z)*(m-1);if(xe<0||xe>m-1){for(let qe=0;qe<g;qe++){let $e=qe+ie*q[2]+Z*q[1]+H*q[0];E.values[$e]=d}continue}let me=Math.floor(xe),_e=Math.ceil(xe),Le=xe-me;for(let qe=0;qe<g;qe++){let $e=qe+me*D[2]+de*D[1]+ae*D[0],Ke=N[$e];$e=qe+_e*D[2]+de*D[1]+ae*D[0];let rt=N[$e];$e=qe+me*D[2]+Ce*D[1]+ae*D[0];let ht=N[$e];$e=qe+_e*D[2]+Ce*D[1]+ae*D[0];let kt=N[$e],_t=Ke+(rt-Ke)*Le,ln=ht+(kt-ht)*Le;$e=qe+ie*q[2]+Z*q[1]+H*q[0],E.values[$e]=_t+(ln-_t)*Y}}}else for(let de=0;de<S;++de){let Ce=S>1?te*(m-1)+de*he:.5*(te+z)*(m-1);if(Ce<0||Ce>m-1){for(let xe=0;xe<g;xe++){let me=xe+de*q[2]+Z*q[1]+H*q[0];E.values[me]=d}continue}let Y=Math.round(Ce),ie=Math.round(se);for(let xe=0;xe<g;xe++){let me=xe+Y*D[2]+ie*D[1]+ae*D[0],_e=xe+de*q[2]+Z*q[1]+H*q[0];E.values[_e]=N[me]}}}}return n.makeTensorInfo(E.shape,E.dtype,E.values)}var rae={kernelName:Km,backendName:"cpu",kernelFunc:aae};function iae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,exclusive:s,reverse:o}=a;ct(r,"cumprod");let u=P.getAxesPermutation([i],r.shape.length),d=r;u!=null&&(d=pi({inputs:{x:r},backend:n,attrs:{perm:u}}));let c=P.getInnerMostAxes(1,r.shape.length)[0];if(c!==d.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${c}`);let h=as(d.dtype,"int32"),m=O.makeOnesTypedArray(O.sizeFromShape(d.shape),h),g=n.data.get(d.dataId).values,x=d.shape[d.shape.length-1],v=o?(E,C)=>E+x-C-1:(E,C)=>E+C;for(let E=0;E<g.length;E+=x)for(let C=0;C<x;C++){let T=v(E,C);if(C===0)m[T]=s?1:g[T];else{let N=v(E,C-1);m[T]=s?g[N]*m[N]:g[T]*m[N]}}let S=n.makeTensorInfo(d.shape,h,m);if(u!=null){let E=P.getUndoAxesPermutation(u),C=pi({inputs:{x:S},backend:n,attrs:{perm:E}});return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(d),C}return S}var sae={kernelName:Gm,backendName:"cpu",kernelFunc:iae};function oae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,exclusive:s,reverse:o}=a;ct(r,"cumsum");let u=P.getAxesPermutation([i],r.shape.length),d=r;u!=null&&(d=pi({inputs:{x:r},backend:n,attrs:{perm:u}}));let c=P.getInnerMostAxes(1,r.shape.length)[0];if(c!==d.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${c}`);let h=as(d.dtype,"int32"),m=O.makeZerosTypedArray(O.sizeFromShape(d.shape),h),g=n.data.get(d.dataId).values,x=d.shape[d.shape.length-1],v=o?(E,C)=>E+x-C-1:(E,C)=>E+C;for(let E=0;E<g.length;E+=x)for(let C=0;C<x;C++){let T=v(E,C);if(C===0)m[T]=s?0:g[T];else{let N=v(E,C-1);m[T]=s?g[N]+m[N]:g[T]+m[N]}}let S=n.makeTensorInfo(d.shape,h,m);if(u!=null){let E=P.getUndoAxesPermutation(u),C=pi({inputs:{x:S},backend:n,attrs:{perm:E}});return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(d),C}return S}var lae={kernelName:Op,backendName:"cpu",kernelFunc:oae};function uae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:i}=t,{size:s,binaryOutput:o}=a;if(r.shape.length===1){let u=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,c=qI(u,d,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,c)}else if(r.shape.length===2){let u=n.bufferSync(r),d=n.bufferSync(i),c=fB(u,d,s,o);return n.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var cae={kernelName:m0,backendName:"cpu",kernelFunc:uae};function dae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:i,dataFormat:s}=a;O.assert(s==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${s}`);let o=r.shape[0],u=r.shape[1],d=r.shape[2],c=r.shape[3],h=u*i,m=d*i,g=c/(i*i),x=n.data.get(r.dataId).values,v=new Float32Array(o*h*m*g),S=0;for(let E=0;E<o;++E)for(let C=0;C<h;++C){let T=Math.floor(C/i),N=C%i;for(let D=0;D<m;++D){let q=Math.floor(D/i),H=D%i,K=(N*i+H)*g;for(let j=0;j<g;++j){let te=j+K+c*(q+d*(T+u*E));v[S++]=x[te]}}}return n.makeTensorInfo([o,h,m,g],r.dtype,v)}var pae={kernelName:$m,backendName:"cpu",kernelFunc:dae};function o4(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:s,pad:o,dilations:u,dimRoundingMode:d}=a;ct([r,i],"depthwiseConv2DNative");let c=O.computeStrides(r.shape),h=O.computeStrides(i.shape),m=u;m==null&&(m=[1,1]),O.assert(P.eitherStridesOrDilationsAreOne(s,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${m}'`);let g=P.computeConv2DInfo(r.shape,i.shape,s,m,o,d,!0),{filterHeight:x,filterWidth:v,dilationHeight:S,dilationWidth:E,padInfo:C}=g,T=C.left,N=C.top,D=g.outChannels/g.inChannels,q=new Ma(g.outShape,r.dtype),H=n.data.get(r.dataId).values,K=n.data.get(i.dataId).values,j=q.values;for(let te=0;te<g.batchSize;++te){let Q=te*c[0],z=te*q.strides[0];for(let ae=0;ae<g.outHeight;++ae){let ue=z+ae*q.strides[1],he=ae*g.strideHeight-N;for(let Z=0;Z<x;++Z){let se=he+Z*S;if(se<0||se>=g.inHeight)continue;let de=Z*h[0],Ce=Q+se*c[1];for(let Y=0;Y<g.outWidth;++Y){let ie=ue+Y*q.strides[2],xe=Y*g.strideWidth-T;for(let me=0;me<v;++me){let _e=xe+me*E;if(_e<0||_e>=g.inWidth)continue;let Le=de+me*h[1],qe=Ce+_e*g.inChannels,$e=ie,Ke=Le;for(let rt=0;rt<g.inChannels;++rt){let ht=H[qe+rt];for(let kt=0;kt<D;++kt)j[$e+kt]+=ht*K[Ke+kt];$e+=D,Ke+=D}}}}}}return n.makeTensorInfo(q.shape,q.dtype,q.values)}var hae={kernelName:Mp,backendName:"cpu",kernelFunc:o4};function fae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:s,dilations:o,pad:u,dimRoundingMode:d,filterShape:c}=a;ct([r,i],"depthwiseConv2dNativeBackpropFilter");let h=P.computeConv2DInfo(r.shape,c,s,o,u,d,!0),{strideHeight:m,strideWidth:g,filterHeight:x,filterWidth:v}=h,S=new Ma(h.filterShape,"float32"),E=h.padInfo.left,C=h.padInfo.top,T=h.outChannels/h.inChannels,N=n.data.get(r.dataId).values,D=new Ma(r.shape,r.dtype,N),q=n.data.get(i.dataId).values,H=new Ma(i.shape,i.dtype,q);for(let K=0;K<x;++K){let j=Math.max(0,Math.ceil((C-K)/m)),te=Math.min(h.outHeight,(h.inHeight+C-K)/m);for(let Q=0;Q<v;++Q){let z=Math.max(0,Math.ceil((E-Q)/g)),ae=Math.min(h.outWidth,(h.inWidth+E-Q)/g);for(let ue=0;ue<h.outChannels;++ue){let he=Math.trunc(ue/T),Z=ue%T,se=0;for(let de=0;de<h.batchSize;++de)for(let Ce=j;Ce<te;++Ce){let Y=K+Ce*m-C;for(let ie=z;ie<ae;++ie){let xe=Q+ie*g-E;se+=D.get(de,Y,xe,he)*H.get(de,Ce,ie,ue)}}S.set(se,K,Q,he,Z)}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}var mae={kernelName:iv,backendName:"cpu",kernelFunc:fae};function gae(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{strides:s,dilations:o,pad:u,dimRoundingMode:d,inputShape:c}=a;ct([r,i],"depthwiseConv2DNativeBackpropInput");let h=O.computeStrides(r.shape),m=O.computeStrides(i.shape),g=P.computeConv2DInfo(c,i.shape,s,o,u,d,!0),x=new Ma(g.inShape,"float32"),v=x.values,[S,E,C]=x.strides,T=n.data.get(r.dataId).values,[N,D,q]=h,H=n.data.get(i.dataId).values,[K,j,te]=m,{batchSize:Q,filterHeight:z,filterWidth:ae,inChannels:ue,inHeight:he,inWidth:Z,outChannels:se,outHeight:de,outWidth:Ce,strideHeight:Y,strideWidth:ie}=g,xe=z-1-g.padInfo.top,me=ae-1-g.padInfo.left,_e=se/ue;for(let Le=0;Le<Q;++Le)for(let qe=0;qe<ue;++qe)for(let $e=0;$e<he;++$e){let Ke=$e-xe,rt=Math.max(0,Math.ceil(Ke/Y)),ht=Math.min(de,(z+Ke)/Y);for(let kt=0;kt<Z;++kt){let _t=kt-me,ln=Math.max(0,Math.ceil(_t/ie)),Nt=Math.min(Ce,(ae+_t)/ie),Pt=0;for(let Re=rt;Re<ht;++Re){let ft=Re*Y-Ke;for(let wt=ln;wt<Nt;++wt){let oa=wt*ie-_t,en=N*Le+D*Re+q*wt,Ht=K*(z-1-ft)+j*(ae-1-oa)+te*qe;for(let Jn=0;Jn<_e;++Jn){let kn=qe*_e+Jn,pa=T[en+kn],Na=H[Ht+Jn];Pt+=pa*Na}}}v[S*Le+E*$e+C*kt+qe]=Pt}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var bae={kernelName:sv,backendName:"cpu",kernelFunc:gae};function yae(e){let{inputs:t,backend:n}=e,{x:a}=t,r=O.sizeFromShape(a.shape),i=n.data.get(a.dataId).values,s=Zt([r,r],a.dtype),o=s.values;for(let d=0;d<i.length;d++)o[d*r+d]=i[d];let u=[...a.shape,...a.shape];return n.makeTensorInfo(u,s.dtype,s.values)}var wae={kernelName:g0,backendName:"cpu",kernelFunc:yae},xae={kernelName:Bp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r}=e,{strides:i,pad:s,dilations:o}=n,u=t,d=u.data.get(a.dataId).values,c=a.shape.length,h=u.data.get(r.dataId).values,m=r.shape.length,{batchSize:g,inHeight:x,inWidth:v,inChannels:S,outHeight:E,outWidth:C,padInfo:T,strideHeight:N,strideWidth:D,filterHeight:q,filterWidth:H,dilationHeight:K,dilationWidth:j,outShape:te}=P.computeDilation2DInfo(a.shape,r.shape,i,s,"NHWC",o),Q=O.sizeFromShape(te),z=te.length,ae=O.getArrayFromDType(a.dtype,Q);for(let ue=0;ue<g;++ue)for(let he=0;he<E;++he){let Z=he*N-T.top;for(let se=0;se<C;++se){let de=se*D-T.left;for(let Ce=0;Ce<S;++Ce){let Y=Number.MIN_SAFE_INTEGER;for(let xe=0;xe<q;++xe){let me=Z+xe*K;if(me>=0&&me<x)for(let _e=0;_e<H;++_e){let Le=de+_e*j;if(Le>=0&&Le<v){let qe=O.locToIndex([ue,me,Le,Ce],c,O.computeStrides(a.shape)),$e=O.locToIndex([xe,_e,Ce],m,O.computeStrides(r.shape)),Ke=d[qe]+h[$e];Ke>Y&&(Y=Ke)}}}let ie=O.locToIndex([ue,he,se,Ce],z,O.computeStrides(te));ae[ie]=Y}}}return{dataId:u.write(O.toTypedArray(ae,a.dtype),te,a.dtype),shape:te,dtype:a.dtype}}},vae={kernelName:gm,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:i}=e,{strides:s,pad:o,dilations:u}=n,d=t,c=O.toNestedArray(a.shape,d.data.get(a.dataId).values),h=O.toNestedArray(r.shape,d.data.get(r.dataId).values),{batchSize:m,inHeight:g,inWidth:x,inChannels:v,outHeight:S,outWidth:E,padInfo:C,strideHeight:T,strideWidth:N,filterHeight:D,filterWidth:q,dilationHeight:H,dilationWidth:K,outShape:j}=P.computeDilation2DInfo(a.shape,r.shape,s,o,"NHWC",u);O.assert(i.rank===j.length,()=>`Error in ${gm}, dy must have the same rank as output ${j.length}, but got ${i.rank}`);let te=O.toNestedArray(j,d.data.get(i.dataId).values),Q=O.makeZerosNestedTypedArray(r.shape,r.dtype);for(let z=0;z<m;++z)for(let ae=0;ae<S;++ae){let ue=ae*T-C.top;for(let he=0;he<E;++he){let Z=he*N-C.left;for(let se=0;se<v;++se){let de=Number.MIN_SAFE_INTEGER,Ce=0,Y=0;for(let ie=0;ie<D;++ie){let xe=ue+ie*H;if(xe>=0&&xe<g)for(let me=0;me<q;++me){let _e=Z+me*K;if(_e>=0&&_e<x){let Le=c[z][xe][_e][se]+h[ie][me][se];Le>de&&(de=Le,Ce=ie,Y=me)}}}Q[Ce][Y][se]+=te[z][ae][he][se]}}}return{dataId:d.write(O.toTypedArray(Q,a.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Sae={kernelName:mm,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:i}=e,{strides:s,pad:o,dilations:u}=n,d=t,c=O.toNestedArray(a.shape,d.data.get(a.dataId).values),h=O.toNestedArray(r.shape,d.data.get(r.dataId).values),{batchSize:m,inHeight:g,inWidth:x,inChannels:v,outHeight:S,outWidth:E,padInfo:C,strideHeight:T,strideWidth:N,filterHeight:D,filterWidth:q,dilationHeight:H,dilationWidth:K,outShape:j}=P.computeDilation2DInfo(a.shape,r.shape,s,o,"NHWC",u);O.assert(i.rank===j.length,()=>`Error in ${mm}, dy must have the same rank as output ${j.length}, but got ${i.rank}`);let te=O.toNestedArray(j,d.data.get(i.dataId).values),Q=O.makeZerosNestedTypedArray(a.shape,a.dtype);for(let z=0;z<m;++z)for(let ae=0;ae<S;++ae){let ue=ae*T-C.top;for(let he=0;he<E;++he){let Z=he*N-C.left;for(let se=0;se<v;++se){let de=Number.MIN_SAFE_INTEGER,Ce=ue<0?0:ue,Y=Z<0?0:Z;for(let ie=0;ie<D;++ie){let xe=ue+ie*H;if(xe>=0&&xe<g)for(let me=0;me<q;++me){let _e=Z+me*K;if(_e>=0&&_e<x){let Le=c[z][xe][_e][se]+h[ie][me][se];Le>de&&(de=Le,Ce=xe,Y=_e)}}}Q[z][Ce][Y][se]+=te[z][ae][he][se]}}}return{dataId:d.write(O.toTypedArray(Q,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function kae(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:i,options:s}=a,{contextOptions:o,imageOptions:u}=s||{},d=(u==null?void 0:u.alpha)||1,c=(o==null?void 0:o.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let h=i.getContext(c,(o==null?void 0:o.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);let[m,g]=r.shape.slice(0,2),x=r.shape.length===2?1:r.shape[2],v=n.data.get(r.dataId).values,S=r.dtype==="float32"?255:1,E=new Uint8ClampedArray(g*m*4);for(let T=0;T<m*g;++T){let N=[0,0,0,255*d];for(let q=0;q<x;q++){let H=v[T*x+q];if(r.dtype==="float32"){if(H<0||H>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${H}.`)}else if(r.dtype==="int32"&&(H<0||H>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${H}.`);x===1?(N[0]=H*S,N[1]=H*S,N[2]=H*S):N[q]=H*S}let D=T*4;E[D+0]=Math.round(N[0]),E[D+1]=Math.round(N[1]),E[D+2]=Math.round(N[2]),E[D+3]=Math.round(N[3])}i.width=g,i.height=m;let C=new ImageData(E,g,m);return h.putImageData(C,0,0),r}var Aae={kernelName:ov,backendName:"cpu",kernelFunc:kae};function sw(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:s}=a;ct(r,"sum");let o;r.dtype==="bool"?o=Nc({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):o=ol({inputs:{x:r},backend:n});let u=o.shape.length,d=O.parseAxisParam(i,o.shape),c=P.getAxesPermutation(d,u),h=d,m=o;c!=null&&(m=pi({inputs:{x:o},backend:n,attrs:{perm:c}}),h=P.getInnerMostAxes(h.length,u)),P.assertAxesAreInnerMostDims("sum",h,m.shape.length);let[g,x]=P.computeOutAndReduceShapes(m.shape,h),v=P.upcastType(m.dtype,"int32"),S=U1(n,g,v),E=O.sizeFromShape(x),C=n.data.get(S.dataId).values,T=n.data.get(m.dataId).values;for(let N=0;N<C.length;++N){let D=N*E,q=0;for(let H=0;H<E;++H)q+=T[D+H];C[N]=q}if(s){let N=P.expandShapeToKeepDim(S.shape,d),D=S;S=sa({inputs:{x:S},backend:n,attrs:{shape:N}}),n.disposeIntermediateTensorInfo(D)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(m),S}var Eae={kernelName:Th,backendName:"cpu",kernelFunc:sw};function Cae(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,i=t,{allDims:s,summedDims:o,idDims:u}=P.decodeEinsumEquation(r,i.length);P.checkEinsumDimSizes(s.length,u,i);let{path:d,steps:c}=P.getEinsumComputePath(o,u),h=c.length,m=null,g=s.length,x=[];for(let v=0;v<h;++v){for(let S of c[v]){let{permutationIndices:E,expandDims:C}=P.getEinsumPermutation(g,u[S]),T;P.isIdentityPermutation(E)?T=i[S]:(T=pi({inputs:{x:i[S]},backend:n,attrs:{perm:E}}),x.push(T));let N=T.shape.slice();for(let D=0;D<C.length;++D)N.splice(C[D],0,1);O.arraysEqual(T.shape,N)||(T=sa({inputs:{x:T},backend:n,attrs:{shape:N}}),x.push(T)),m===null?m=T:(m=vS({inputs:{a:T,b:m},backend:n}),x.push(m))}v<h-1&&(d[v]>=0&&(m=sw({inputs:{x:m},backend:n,attrs:{axis:d[v]-(s.length-g),keepDims:!1}}),x.push(m)),g--)}for(let v of x)v!==m&&n.disposeIntermediateTensorInfo(v);return m}var Iae={kernelName:lv,backendName:"cpu",kernelFunc:Cae};function _ae(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t;ct([a,r],"eluGrad");let i=new Float32Array(O.sizeFromShape(r.shape)),s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values;for(let u=0;u<s.length;++u){let d=s[u];d>=0?i[u]=o[u]:i[u]=o[u]*(d+1)}return n.makeTensorInfo(r.shape,"float32",i)}var Tae={kernelName:Jm,backendName:"cpu",kernelFunc:_ae},Nae=P.ERF_P,Rae=P.ERF_A1,Fae=P.ERF_A2,Dae=P.ERF_A3,Oae=P.ERF_A4,Mae=P.ERF_A5,Bae=Vn(Up,e=>{let t=Math.sign(e),n=Math.abs(e),a=1/(1+Nae*n);return t*(1-((((Mae*a+Oae)*a+Dae)*a+Fae)*a+Rae)*a*Math.exp(-n*n))}),Lae={kernelName:Up,backendName:"cpu",kernelFunc:Bae};function q1(e){let{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:i}=a,s=r.shape.length,o=r.shape.slice(),u=i;return i<0&&(O.assert(-(s+1)<=i,()=>`Axis must be in the interval [${-(s+1)}, ${s}]`),u=s+i+1),o.splice(u,0,1),sa({inputs:{x:r},backend:n,attrs:{shape:o}})}var zae={kernelName:jm,backendName:"cpu",kernelFunc:q1},Uae=Ta((e,t)=>e/t),e_=ja(Lp,Uae),iA={kernelName:Lp,backendName:"cpu",kernelFunc:e_};function l4(e,t,n){let a=e.shape,r=a[0],i=a[1],s=n.data.get(e.dataId),o=s.complexTensorInfos.real,u=s.complexTensorInfos.imag,d=[r,i],c=O.sizeFromShape(d),h=O.getTypedArrayFromDType("float32",c),m=O.getTypedArrayFromDType("float32",c);for(let S=0;S<r;S++){let E=cp({inputs:{x:o},backend:n,attrs:{begin:[S,0],size:[1,i]}}),C=cp({inputs:{x:u},backend:n,attrs:{begin:[S,0],size:[1,i]}}),T=Ii({inputs:{real:E,imag:C},backend:n}),{real:N,imag:D}=Vae(T,t,n),q=P.mergeRealAndImagArrays(N,D);for(let H=0;H<i;H++){let K=P.getComplexWithIndex(q,H);h[S*i+H]=K.real,m[S*i+H]=K.imag}n.disposeIntermediateTensorInfo(E),n.disposeIntermediateTensorInfo(C),n.disposeIntermediateTensorInfo(T)}let g=n.makeTensorInfo(d,"float32",h),x=n.makeTensorInfo(d,"float32",m),v=Ii({inputs:{real:g,imag:x},backend:n});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),v}function Vae(e,t,n){let a=O.sizeFromShape(e.shape),r=n.data.get(e.dataId),i=n.data.get(r.complexTensorInfos.real.dataId).values,s=n.data.get(r.complexTensorInfos.imag.dataId).values;if(Wae(a)){let o=sA(i,s,a,t,n),u=[e.shape[0],e.shape[1]];if(t){let d=n.makeTensorInfo(u,"float32",o.real),c=n.makeTensorInfo(u,"float32",o.imag),h=n.makeTensorInfo([],"float32",O.createScalarValue(a,"float32")),m=ol({inputs:{x:h},backend:n}),g=iA.kernelFunc({inputs:{a:d,b:h},backend:n}),x=iA.kernelFunc({inputs:{a:c,b:m},backend:n}),v=n.data.get(g.dataId).values,S=n.data.get(x.dataId).values;return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),{real:v,imag:S}}return o}else{let o=P.mergeRealAndImagArrays(i,s),u=qae(o,a,t);return P.splitRealAndImagArrays(u)}}function Wae(e){return(e&e-1)===0}function sA(e,t,n,a,r){if(n===1)return{real:e,imag:t};let i=P.mergeRealAndImagArrays(e,t),s=n/2,o=P.complexWithEvenIndex(i),u=o.real,d=o.imag,c=[u.length],h=r.makeTensorInfo(c,"float32",u),m=r.makeTensorInfo(c,"float32",d),g=Ii({inputs:{real:h,imag:m},backend:r}),x=P.complexWithOddIndex(i),v=x.real,S=x.imag,E=[v.length],C=r.makeTensorInfo(E,"float32",v),T=r.makeTensorInfo(E,"float32",S),N=Ii({inputs:{real:C,imag:T},backend:r}),D=sA(u,d,s,a,r),q=D.real,H=D.imag,K=[q.length],j=r.makeTensorInfo(K,"float32",q),te=r.makeTensorInfo(K,"float32",H),Q=Ii({inputs:{real:j,imag:te},backend:r}),z=sA(v,S,s,a,r),ae=z.real,ue=z.imag,he=[ae.length],Z=r.makeTensorInfo(he,"float32",ae),se=r.makeTensorInfo(he,"float32",ue),de=Ii({inputs:{real:Z,imag:se},backend:r}),Ce=P.exponents(n,a),Y=[Ce.real.length],ie=r.makeTensorInfo(Y,"float32",Ce.real),xe=r.makeTensorInfo(Y,"float32",Ce.imag),me=Ii({inputs:{real:ie,imag:xe},backend:r}),_e=vS({inputs:{a:me,b:de},backend:r}),Le=_m({inputs:{a:Q,b:_e},backend:r}),qe=QI({inputs:{a:Q,b:_e},backend:r}),$e=up({inputs:{input:Le},backend:r}),Ke=up({inputs:{input:qe},backend:r}),rt=Tm({inputs:{input:Le},backend:r}),ht=Tm({inputs:{input:qe},backend:r}),kt=Nm({inputs:[$e,Ke],backend:r,attrs:{axis:0}}),_t=Nm({inputs:[rt,ht],backend:r,attrs:{axis:0}}),ln=r.data.get(kt.dataId).values,Nt=r.data.get(_t.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(se),r.disposeIntermediateTensorInfo(de),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(xe),r.disposeIntermediateTensorInfo(me),r.disposeIntermediateTensorInfo(_e),r.disposeIntermediateTensorInfo(Le),r.disposeIntermediateTensorInfo(qe),r.disposeIntermediateTensorInfo($e),r.disposeIntermediateTensorInfo(rt),r.disposeIntermediateTensorInfo(Ke),r.disposeIntermediateTensorInfo(ht),r.disposeIntermediateTensorInfo(kt),r.disposeIntermediateTensorInfo(_t),{real:ln,imag:Nt}}function qae(e,t,n){let a=new Float32Array(t*2);for(let r=0;r<t;r++){let i=0,s=0;for(let o=0;o<t;o++){let u=P.exponent(r*o,t,n),d=P.getComplexWithIndex(e,o);i+=d.real*u.real-d.imag*u.imag,s+=d.real*u.imag+d.imag*u.real}n&&(i/=t,s/=t),P.assignToTypedArray(a,i,s,r)}return a}function Pae(e){let{inputs:t,backend:n}=e,{input:a}=t,r=O.sizeFromShape(a.shape),i=a.shape[a.shape.length-1],s=r/i,o=sa({inputs:{x:a},backend:n,attrs:{shape:[s,i]}}),u=l4(o,!1,n),d=sa({inputs:{x:u},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),d}var Hae={kernelName:uv,backendName:"cpu",kernelFunc:Pae};function t_(e){let{backend:t,attrs:n}=e,{shape:a,value:r,dtype:i}=n,s=i||O.inferDtype(r),o=O.getArrayFromDType(s,O.sizeFromShape(a));return Kae(o,r),t.makeTensorInfo(a,s,o)}var Gae={kernelName:b0,backendName:"cpu",kernelFunc:t_};function Kae(e,t,n){e.fill(t)}var $ae={kernelName:Qm,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,r=n,i=O.getTypedArrayFromDType(a.dtype,O.sizeFromShape(a.shape)),[s,o,u,d]=a.shape,c=r.data.get(a.dataId).values;for(let h=0;h<s;h++){let m=h*u*o*d;for(let g=0;g<o;g++){let x=g*(u*d);for(let v=0;v<u;v++){let S=v*d;for(let E=0;E<d;E++){let C=Math.round(u-v-1),T=m+x+S+E,N=c[T];if(C>=0&&C<u){let D=C*d,q=m+x+D+E;N=c[q]}i[T]=N}}}}return{dataId:r.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function Jae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i,bias:s,preluActivationWeights:o}=t,{strides:u,pad:d,dataFormat:c,dilations:h,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=a,v=s4({inputs:{x:r,filter:i},backend:n,attrs:{strides:u,pad:d,dataFormat:c,dilations:h,dimRoundingMode:m}});if(s){let S=v;if(c==="NCHW"&&s.shape.length===1&&s.shape[0]!==1){let E=sa({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});v=_m({inputs:{a:v,b:E},backend:n}),n.disposeIntermediateTensorInfo(E)}else v=_m({inputs:{a:v,b:s},backend:n});n.disposeIntermediateTensorInfo(S)}if(g){let S=v;if(c==="NCHW"&&g==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let E=sa({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});v=W1(n,v,g,E,x),n.disposeIntermediateTensorInfo(E)}else v=W1(n,v,g,o,x);n.disposeIntermediateTensorInfo(S)}return v}var Yae={kernelName:Qd,backendName:"cpu",kernelFunc:Jae};function jae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i,bias:s,preluActivationWeights:o}=t,{strides:u,pad:d,dataFormat:c,dilations:h,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=a,v=o4({inputs:{x:r,filter:i},backend:n,attrs:{strides:u,pad:d,dataFormat:c,dilations:h,dimRoundingMode:m}});if(s){let S=v;v=_m({inputs:{a:v,b:s},backend:n}),n.disposeIntermediateTensorInfo(S)}if(g){let S=v;v=W1(n,v,g,o,x),n.disposeIntermediateTensorInfo(S)}return v}var Qae={kernelName:Zd,backendName:"cpu",kernelFunc:jae};function Zae(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,i=O.sizeFromShape(a.shape),s=r.shape,o=s[s.length-1],[u,d,c,h]=P.prepareAndValidate(a,r);if(d===0)return n.makeTensorInfo(u,a.dtype,[]);let m=n.data.get(r.dataId).values,g=n.bufferSync(a),x=AB(m,g,a.dtype,d,o,c,h,a.shape,i);return n.makeTensorInfo(u,a.dtype,x.values)}var Xae={kernelName:Xm,backendName:"cpu",kernelFunc:Zae};function ere(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:i}=t,{axis:s,batchDims:o}=a;ct([r,i],"gatherV2");let u=O.parseAxisParam(s,r.shape)[0],d=n.data.get(i.dataId).values,c=r.shape[u];for(let N=0;N<d.length;++N){let D=d[N];O.assert(D<=c-1&&D>=0,()=>`GatherV2: the index value ${D} is not in [0, ${c-1}]`)}let h=o;o==null&&(h=0);let m=O.sizeFromShape(i.shape),g=P.segment_util.collectGatherOpShapeInfo(r,i,u,h),x=sa({inputs:{x:r},backend:n,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),v=sa({inputs:{x:i},backend:n,attrs:{shape:[g.batchSize,m/g.batchSize]}}),S=[g.batchSize,g.outerSize,m/g.batchSize,g.sliceSize],E=n.bufferSync(v),C=n.bufferSync(x),T=EB(C,E,S);return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),n.makeTensorInfo(g.outputShape,T.dtype,T.values)}var tre={kernelName:Zm,backendName:"cpu",kernelFunc:ere};function nre(e){let{inputs:t,backend:n}=e,{input:a}=t,r=O.sizeFromShape(a.shape),i=a.shape[a.shape.length-1],s=r/i,o=sa({inputs:{x:a},backend:n,attrs:{shape:[s,i]}}),u=l4(o,!0,n),d=sa({inputs:{x:u},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),d}var are={kernelName:cv,backendName:"cpu",kernelFunc:nre},rre=Vn($p,e=>Number.isFinite(e)?1:0,"bool"),ire={kernelName:$p,backendName:"cpu",kernelFunc:rre},sre=Vn(Jp,e=>Math.abs(e)===1/0?1:0,"bool"),ore={kernelName:Jp,backendName:"cpu",kernelFunc:sre},lre=Vn(Yp,e=>Number.isNaN(e)?1:0,"bool"),ure={kernelName:Yp,backendName:"cpu",kernelFunc:lre};function cre(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:i}=n,s=NB(a,r,i);return t.makeTensorInfo([s.length],"float32",s)}var dre={kernelName:ag,backendName:"cpu",kernelFunc:cre},pre=Vn(Zp,e=>Math.log1p(e)),hre={kernelName:Zp,backendName:"cpu",kernelFunc:pre},fre=Ta((e,t)=>e&&t),mre=ja(rg,fre,null,"bool"),gre={kernelName:rg,backendName:"cpu",kernelFunc:mre},bre=Vn(ig,e=>e?0:1,"bool"),yre={kernelName:ig,backendName:"cpu",kernelFunc:bre},wre=Ta((e,t)=>e||t),xre=ja(sg,wre,null,"bool"),vre={kernelName:sg,backendName:"cpu",kernelFunc:xre};function Sre(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:i,bias:s,alpha:o,beta:u}=a;ct(r,"LRN");let d=r.shape[3],c=d-1,h=n.data.get(r.dataId).values,m=O.sizeFromShape(r.shape),g=new Float32Array(m);function x(v){let S=v%d,E=v-S+Math.max(0,S-i),C=v-S+Math.min(S+i,c),T=0;for(;E<=C;E++){let N=h[E];T+=N*N}return T}for(let v=0;v<m;v++){let S=x(v),E=h[v]*Math.pow(s+o*S,-u);g[v]=E}return n.makeTensorInfo(r.shape,r.dtype,g)}var kre={kernelName:Xp,backendName:"cpu",kernelFunc:Sre};function Are(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:i,dy:s}=t,{depthRadius:o,bias:u,alpha:d,beta:c}=a;ct(s,"LRNGrad");let h=O.sizeFromShape(s.shape),m=s.shape[3],g=n.data.get(s.dataId).values,x=n.data.get(r.dataId).values,v=n.data.get(i.dataId).values,S=new Float32Array(h),E=h;for(let C=0;C<E;C++){let T=C%m,N=C-T+Math.max(0,T-o),D=C-T+Math.min(m,T+o+1),q=0;for(let H=N;H<D;H++)q+=Math.pow(x[H],2);q=d*q+u;for(let H=N;H<D;H++){let K=-2*d*c*x[H]*v[C]/q;C===H&&(K+=Math.pow(q,-c)),K*=g[C],S[H]+=K}}return n.makeTensorInfo(s.shape,r.dtype,S)}var Ere={kernelName:og,backendName:"cpu",kernelFunc:Are};function u4(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:i,keepDims:s}=a,o=n,u=r.shape,d=u.length,c=O.parseAxisParam(i,u),h=c,m=P.getAxesPermutation(h,d),g=o.data.get(r.dataId).values;if(m!=null){let N=new Array(d);for(let D=0;D<N.length;D++)N[D]=u[m[D]];g=GI(g,u,r.dtype,m,N),h=P.getInnerMostAxes(h.length,d),u=N}ct(r,"max"),P.assertAxesAreInnerMostDims("max",h,d);let[x,v]=P.computeOutAndReduceShapes(u,h),S=O.sizeFromShape(v),E=FB(g,S,x,r.dtype),C=o.write(E,x,r.dtype),T=x;return s&&(T=P.expandShapeToKeepDim(x,c)),{dataId:C,shape:T,dtype:r.dtype}}var Cre={kernelName:eh,backendName:"cpu",kernelFunc:u4};function Ire(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;ct(r,"maxPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:u}=a,d=1;O.assert(P.eitherStridesOrDilationsAreOne(s,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`);let c=P.computePool2DInfo(r.shape,i,s,d,o,u),h;if(c.filterWidth===1&&c.filterHeight===1&&O.arraysEqual(c.inShape,c.outShape))h=ol({inputs:{x:r},backend:n});else{let m=n.data.get(r.dataId).values,g=O.computeStrides(r.shape),x=XI(m,r.shape,r.dtype,g,c,"max");h=n.makeTensorInfo(c.outShape,r.dtype,x.values)}return h}var _re={kernelName:nh,backendName:"cpu",kernelFunc:Ire};function Tre(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:u,dataFormat:d}=a;ct(r,"maxPool3d");let c=P.computePool3DInfo(r.shape,i,s,1,o,u,d),h=n.data.get(r.dataId).values,m=i4(h,r.shape,r.dtype,O.computeStrides(r.shape),c,"max");return n.makeTensorInfo(m.shape,"float32",m.values)}var Nre={kernelName:lg,backendName:"cpu",kernelFunc:Tre};function Rre(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,{filterSize:s,strides:o,pad:u,dimRoundingMode:d}=a;ct([r,i],"maxPool3DGrad");let c=P.computePool3DInfo(i.shape,s,o,1,u,d),h=n.bufferSync(i),m=wne(h,c),g=c.strideDepth,x=c.strideHeight,v=c.strideWidth,S=c.dilationDepth,E=c.dilationHeight,C=c.dilationWidth,T=c.effectiveFilterDepth,N=c.effectiveFilterHeight,D=c.effectiveFilterWidth,q=T-1-c.padInfo.front,H=D-1-c.padInfo.left,K=N-1-c.padInfo.top,j=Zt(i.shape,"float32"),te=n.bufferSync(r);for(let Q=0;Q<c.batchSize;++Q)for(let z=0;z<c.inChannels;++z)for(let ae=0;ae<c.inDepth;++ae)for(let ue=0;ue<c.inHeight;++ue)for(let he=0;he<c.inWidth;++he){let Z=ae-q,se=ue-K,de=he-H,Ce=0;for(let Y=0;Y<T;Y+=S){let ie=(Z+Y)/g;if(!(ie<0||ie>=c.outDepth||Math.floor(ie)!==ie))for(let xe=0;xe<N;xe+=E){let me=(se+xe)/x;if(!(me<0||me>=c.outHeight||Math.floor(me)!==me))for(let _e=0;_e<D;_e+=C){let Le=(de+_e)/v;if(Le<0||Le>=c.outWidth||Math.floor(Le)!==Le)continue;let qe=T*N*D-1-m.get(Q,ie,me,Le,z),$e=Y*N*D+xe*D+_e,Ke=qe===$e?1:0;if(Ke===0)continue;let rt=te.get(Q,ie,me,Le,z);Ce+=rt*Ke}}}j.set(Ce,Q,ae,ue,he,z)}return n.makeTensorInfo(j.shape,j.dtype,j.values)}var Fre={kernelName:w0,backendName:"cpu",kernelFunc:Rre};function Dre(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i,output:s}=t,o=i;ct([i,s],"maxPoolGrad");let{filterSize:u,strides:d,pad:c,dimRoundingMode:h}=a,m=P.computePool2DInfo(o.shape,u,d,1,c,h),g=n.data.get(o.dataId).values,x=Zt(m.outShape,o.dtype,r4(g,o.shape,o.dtype,m).values),v=m.strideHeight,S=m.strideWidth,E=m.dilationHeight,C=m.dilationWidth,T=m.effectiveFilterHeight,N=m.effectiveFilterWidth,D=N-1-m.padInfo.left,q=T-1-m.padInfo.top,H=Zt(o.shape,"float32"),K=n.data.get(r.dataId).values,j=Zt(r.shape,"float32",K);for(let te=0;te<m.batchSize;++te)for(let Q=0;Q<m.inChannels;++Q)for(let z=0;z<m.inHeight;++z)for(let ae=0;ae<m.inWidth;++ae){let ue=z-q,he=ae-D,Z=0;for(let se=0;se<T;se+=E){let de=(ue+se)/v;if(!(de<0||de>=m.outHeight||Math.floor(de)!==de))for(let Ce=0;Ce<N;Ce+=C){let Y=(he+Ce)/S;if(Y<0||Y>=m.outWidth||Math.floor(Y)!==Y)continue;let ie=T*N-1-x.get(te,de,Y,Q),xe=se*N+Ce,me=ie===xe?1:0;if(me===0)continue;let _e=j.get(te,de,Y,Q);Z+=_e*me}}H.set(Z,te,z,ae,Q)}return n.makeTensorInfo(H.shape,H.dtype,H.values)}var Ore={kernelName:y0,backendName:"cpu",kernelFunc:Dre};function Mre(e,t,n,a,r){let i=O.computeStrides(t),s=XI(e,t,n,i,r,"max"),o=r4(e,t,n,r,!0,a);return[s.values,o.values]}var Bre={kernelName:x0,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:i,pad:s,includeBatchInIndex:o}=t,u=n;ct(a,"MaxPoolWithArgmax");let d=u.data.get(a.dataId).values,c=P.computePool2DInfo(a.shape,r,i,[1,1],s),[h,m]=Mre(d,a.shape,a.dtype,o,c),g=u.write(h,c.outShape,a.dtype),x=u.write(m,c.outShape,a.dtype);return[{dataId:g,shape:c.outShape,dtype:a.dtype},{dataId:x,shape:c.outShape,dtype:"int32"}]}};function Lre(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:s}=a,o=O.parseAxisParam(i,r.shape),u=P.computeOutAndReduceShapes(r.shape,o)[1],d=O.sizeFromShape(u),c=[],h=n.makeTensorInfo([],"float32",new Float32Array([d]));c.push(h);let m=Nc({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});c.push(m);let g=e_({inputs:{a:m,b:h},backend:n});c.push(g);let x=sw({inputs:{x:g},backend:n,attrs:{axis:i,keepDims:s}});return c.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}var zre={kernelName:ah,backendName:"cpu",kernelFunc:Lre};function Ure(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:s}=a;ct(r,"min");let o=O.parseAxisParam(i,r.shape),u=o,d=P.getAxesPermutation(u,r.shape.length),c=r;d!=null&&(c=pi({inputs:{x:r},backend:n,attrs:{perm:d}}),u=P.getInnerMostAxes(u.length,r.shape.length)),P.assertAxesAreInnerMostDims("min",u,c.shape.length);let[h,m]=P.computeOutAndReduceShapes(c.shape,u),g=O.sizeFromShape(m),x=O.makeZerosTypedArray(O.sizeFromShape(h),c.dtype),v=n.data.get(c.dataId).values;for(let E=0;E<x.length;++E){let C=E*g,T=v[C];for(let N=0;N<g;++N){let D=v[C+N];(Number.isNaN(D)||D<T)&&(T=D)}x[E]=T}d!=null&&n.disposeIntermediateTensorInfo(c);let S=n.makeTensorInfo(h,c.dtype,x);if(s){let E=P.expandShapeToKeepDim(h,o),C=sa({inputs:{x:S},backend:n,attrs:{shape:E}});return n.disposeIntermediateTensorInfo(S),C}return S}var Vre={kernelName:rh,backendName:"cpu",kernelFunc:Ure};function Wre(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:i,mode:s}=a;ct(r,"mirrorPad");let o=i.map((C,T)=>C[0]+r.shape[T]+C[1]),u=i.map(C=>C[0]),d=i.map((C,T)=>C[0]+r.shape[T]),c=s==="reflect"?0:1,h=n.data.get(r.dataId).values,m=r.shape.length,g=O.computeStrides(r.shape),x=O.sizeFromShape(o),v=o.length,S=O.computeStrides(o),E=O.getTypedArrayFromDType(r.dtype,x);for(let C=0;C<x;C++){let T=O.indexToLoc(C,v,S);for(let D=0;D<v;D++)T[D]<u[D]?T[D]=u[D]*2-T[D]-c:T[D]>=d[D]&&(T[D]=(d[D]-1)*2-T[D]+c);T=T.map((D,q)=>D-u[q]);let N=O.locToIndex(T,m,g);E[C]=h[N]}return{dataId:n.write(E,o,r.dtype),shape:o,dtype:r.dtype}}var qre={kernelName:sh,backendName:"cpu",kernelFunc:Wre},Pre=Ta((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),Hre=ja(oh,Pre),Gre={kernelName:oh,backendName:"cpu",kernelFunc:Hre},Kre=Oc(X1());function c4(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:i}=a,s=r.shape.length,o=i;if(o===-1&&(o=s-1),o!==s-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${s} and dim was ${o}`);let u=O.parseAxisParam([o],r.shape),d=u4({inputs:{x:r},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=P.expandShapeToKeepDim(d.shape,u),h=sa({inputs:{x:d},backend:n,attrs:{shape:c}}),m=QI({inputs:{a:r,b:h},backend:n}),g=xB({inputs:{x:m},backend:n}),x=sw({inputs:{x:g},backend:n,attrs:{axis:u,keepDims:!1}}),v=sa({inputs:{x},backend:n,attrs:{shape:c}}),S=e_({inputs:{a:g,b:v},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),S}var $re={kernelName:Nh,backendName:"cpu",kernelFunc:c4};function Jre(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:i,seed:s,normalized:o}=a;ct(r,"multinomial");let u=o?r:c4({inputs:{logits:r},backend:n,attrs:{dim:-1}}),d=u.shape[0],c=u.shape[1],h=n.data.get(u.dataId).values,m=[d,i],g=O.makeZerosTypedArray(O.sizeFromShape(m),"int32");for(let x=0;x<d;++x){let v=x*c,S=new Float32Array(c-1);S[0]=h[v];for(let T=1;T<S.length;++T)S[T]=S[T-1]+h[v+T];let E=Kre.alea(s.toString()),C=x*i;for(let T=0;T<i;++T){let N=E();g[C+T]=S.length;for(let D=0;D<S.length;D++)if(N<S[D]){g[C+T]=D;break}}}return o||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(m,"int32",g)}var Yre={kernelName:ug,backendName:"cpu",kernelFunc:Jre},jre=cl.nonMaxSuppressionV3Impl;function Qre(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:u}=a;ct(r,"NonMaxSuppression");let d=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:h}=jre(d,c,s,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var Zre={kernelName:pg,backendName:"cpu",kernelFunc:Qre},Xre=cl.nonMaxSuppressionV4Impl;function eie(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:d}=a;ct(r,"NonMaxSuppressionPadded");let c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:m,validOutputs:g}=Xre(c,h,s,o,u,d);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}var tie={kernelName:hg,backendName:"cpu",kernelFunc:eie},nie=cl.nonMaxSuppressionV5Impl;function aie(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:u,softNmsSigma:d}=a;ct(r,"NonMaxSuppressionWithScore");let c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,m=s,g=o,x=u,v=d,{selectedIndices:S,selectedScores:E}=nie(c,h,m,g,x,v);return[n.makeTensorInfo([S.length],"int32",new Int32Array(S)),n.makeTensorInfo([E.length],"float32",new Float32Array(E))]}var rie={kernelName:fg,backendName:"cpu",kernelFunc:aie};function iie(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:i,depth:s,onValue:o,offValue:u}=a;ct(r,"oneHot");let d=O.sizeFromShape(r.shape),c=new Float32Array(d*s);c.fill(u);let h=n.data.get(r.dataId).values;for(let m=0;m<d;++m)h[m]>=0&&h[m]<s&&(c[m*s+h[m]]=o);return n.makeTensorInfo([...r.shape,s],i,c)}var sie={kernelName:uh,backendName:"cpu",kernelFunc:iie};function P1(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(a.dtype==="complex64"){let r=up({inputs:{input:a},backend:n}),i=P1({inputs:{x:r},backend:n}),s=Tm({inputs:{input:a},backend:n}),o=P1({inputs:{x:s},backend:n}),u=Ii({inputs:{real:i,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),u}else return t_({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}var oie={kernelName:Dg,backendName:"cpu",kernelFunc:P1};function d4(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(a.dtype==="complex64"){let r=up({inputs:{input:a},backend:n}),i=d4({inputs:{x:r},backend:n}),s=Tm({inputs:{input:a},backend:n}),o=P1({inputs:{x:s},backend:n}),u=Ii({inputs:{real:i,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),u}else return t_({backend:n,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}var lie={kernelName:mg,backendName:"cpu",kernelFunc:d4};function p4(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return q1({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let i=t[0].shape,s=t[0].dtype;t.forEach(c=>{O.assertShapesMatch(i,c.shape,"All tensors passed to stack must have matching shapes"),O.assert(s===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(c=>{let h=q1({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(h),h}),d=Nm({inputs:u,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),d}var uie={kernelName:gg,backendName:"cpu",kernelFunc:p4};function cie(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:i,constantValue:s}=a;ct(r,"pad");let o=i.map((E,C)=>E[0]+r.shape[C]+E[1]),u=i.map(E=>E[0]),d=n.data.get(r.dataId).values,c=O.sizeFromShape(r.shape),h=r.shape.length,m=O.computeStrides(r.shape),g=O.sizeFromShape(o),x=o.length,v=O.computeStrides(o),S=O.getTypedArrayFromDType(r.dtype,g);s!==0&&S.fill(s);for(let E=0;E<c;E++){let C=O.indexToLoc(E,h,m).map((N,D)=>N+u[D]),T=O.locToIndex(C,x,v);S[T]=d[E]}return{dataId:n.write(S,o,r.dtype),shape:o,dtype:r.dtype}}var h4={kernelName:ch,backendName:"cpu",kernelFunc:cie},die=Ta((e,t)=>Math.pow(e,t)),pie=ja(dh,die),hie={kernelName:dh,backendName:"cpu",kernelFunc:pie};function fie(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:i,indices:s}=t,{outputRaggedRank:o}=a,u=r.map(E=>n.data.get(E.dataId).values),d=r.map(E=>E.shape),c=n.data.get(i.dataId).values,h=n.data.get(s.dataId).values,[m,g,x]=zB(u,d,c,i.shape,i.dtype,h,s.shape),v=m.map(E=>n.makeTensorInfo([E.length],"int32",E)),S=n.makeTensorInfo(x,i.dtype,g);return v.concat([S])}var mie={kernelName:pv,backendName:"cpu",kernelFunc:fie};function gie(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:i}=t,s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,[d,c]=UB(s,a.shape,a.dtype,o,r.shape,u,i.shape),h=n.makeTensorInfo([d.length],"int32",d),m=n.makeTensorInfo([c.length],a.dtype,c);return[h,m]}var bie={kernelName:hv,backendName:"cpu",kernelFunc:gie};function yie(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:i,defaultValue:s,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=a,d=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,h=n.data.get(s.dataId).values,m=o.map(S=>n.data.get(S.dataId).values),g=o.map(S=>S.shape),[x,v]=VB(d,r.shape,c,i.shape,i.dtype,h,s.shape,m,g,u);return n.makeTensorInfo(x,i.dtype,v)}var wie={kernelName:fv,backendName:"cpu",kernelFunc:yie};function xie(e){let{backend:t,attrs:n}=e,{start:a,stop:r,dtype:i,step:s}=n,o=KI(a,r,s,i);return t.makeTensorInfo([o.length],i,o)}var vie={kernelName:v0,backendName:"cpu",kernelFunc:xie},Sie=Vn(fh,e=>1/e),kie={kernelName:fh,backendName:"cpu",kernelFunc:Sie};function Aie(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:s,size:o}=a;ct(r,"resizeBilinear");let u=O.computeStrides(r.shape),[d,c]=o,[h,m,g,x]=r.shape,v=n.data.get(r.dataId).values,S=new Float32Array(O.sizeFromShape([h,d,c,x])),E=[i&&d>1?m-1:m,i&&c>1?g-1:g],C=[i&&d>1?d-1:d,i&&c>1?c-1:c],T=0,N=E[0]/C[0],D=E[1]/C[1];for(let q=0;q<h;q++)for(let H=0;H<d;H++){let K;s?K=N*(H+.5)-.5:K=N*H;let j=Math.max(0,Math.floor(K)),te=K-j,Q=Math.min(m-1,Math.ceil(K)),z=q*u[0]+j*u[1],ae=q*u[0]+Q*u[1];for(let ue=0;ue<c;ue++){let he;s?he=D*(ue+.5)-.5:he=D*ue;let Z=Math.max(0,Math.floor(he)),se=he-Z,de=Math.min(g-1,Math.ceil(he)),Ce=z+Z*u[2],Y=ae+Z*u[2],ie=z+de*u[2],xe=ae+de*u[2];for(let me=0;me<x;me++){let _e=v[Ce+me],Le=v[Y+me],qe=v[ie+me],$e=v[xe+me],Ke=_e+(qe-_e)*se,rt=Le+($e-Le)*se,ht=Ke+(rt-Ke)*te;S[T++]=ht}}}return n.makeTensorInfo([h,d,c,x],"float32",S)}var Eie={kernelName:bh,backendName:"cpu",kernelFunc:Aie};function Cie(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:i}=t,{alignCorners:s}=a;ct([i,r],"resizeBilinearGrad");let o=O.computeStrides(r.shape),[u,d,c,h]=r.shape,[,m,g]=i.shape,x=new Float32Array(u*d*c*h),v=[s&&m>1?d-1:d,s&&g>1?c-1:c],S=[s&&m>1?m-1:m,s&&g>1?g-1:g],E=v[0]/S[0],C=v[1]/S[1],T=n.data.get(i.dataId).values,N=0;for(let D=0;D<u;D++){let q=D*o[0];for(let H=0;H<m;H++){let K=H*E,j=Math.floor(K),te=Math.min(Math.ceil(K),d-1),Q=q+j*o[1],z=q+te*o[1],ae=K-j,ue=1-ae;for(let he=0;he<g;he++){let Z=he*C,se=Math.floor(Z),de=Math.min(Math.ceil(Z),c-1),Ce=Z-se,Y=1-Ce,ie=Q+se*o[2],xe=Q+de*o[2],me=z+se*o[2],_e=z+de*o[2],Le=ue*Y,qe=ue*Ce,$e=ae*Y,Ke=ae*Ce;for(let rt=0;rt<h;rt++){let ht=T[N++];x[ie+rt]+=ht*Le,x[xe+rt]+=ht*qe,x[me+rt]+=ht*$e,x[_e+rt]+=ht*Ke}}}}return n.makeTensorInfo([u,c,d,h],"float32",x)}var Iie={kernelName:wg,backendName:"cpu",kernelFunc:Cie};function _ie(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:s,size:o}=a;ct(r,"resizeNearestNeighbor");let u=O.computeStrides(r.shape),[d,c]=o,[h,m,g,x]=r.shape,v=n.data.get(r.dataId).values,S=new Float32Array(h*d*c*x),E=[i&&d>1?m-1:m,i&&c>1?g-1:g],C=[i&&d>1?d-1:d,i&&c>1?c-1:c],T=E[0]/C[0],N=E[1]/C[1],D=0;for(let q=0;q<h;q++){let H=q*u[0];for(let K=0;K<d;K++){let j=s?T*(K+.5):T*K,te=Math.min(m-1,i?Math.round(j):Math.floor(j));s&&(te=Math.max(0,te));let Q=H+te*u[1];for(let z=0;z<c;z++){let ae=s?N*(z+.5):N*z,ue=Math.min(g-1,i?Math.round(ae):Math.floor(ae));s&&(ue=Math.max(0,ue));let he=Q+ue*u[2];for(let Z=0;Z<x;Z++){let se=v[he+Z];S[D++]=se}}}}return n.makeTensorInfo([h,d,c,x],r.dtype,S)}var Tie={kernelName:gh,backendName:"cpu",kernelFunc:_ie};function Nie(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:i}=t,{alignCorners:s}=a;ct([i,r],"resizeNearestNeighborGrad");let o=O.computeStrides(r.shape),u=O.computeStrides(i.shape),[d,c,h,m]=r.shape,[,g,x]=i.shape,v=new Float32Array(d*c*h*m),S=n.data.get(i.dataId).values,E=[s&&g>1?c-1:c,s&&x>1?h-1:h],C=[s&&g>1?g-1:g,s&&x>1?x-1:x],T=E[0]/C[0],N=E[1]/C[1],D=1/T,q=1/N,H=Math.ceil(D)*2+2,K=Math.ceil(q)*2+2;for(let j=0;j<d;j++){let te=j*o[0];for(let Q=0;Q<c;Q++){let z=te+Q*o[1],ae=Math.floor(Q*D),ue=Math.floor(ae-H/2);for(let he=0;he<h;he++){let Z=z+he*o[2],se=Math.floor(he*q),de=Math.floor(se-K/2);for(let Ce=0;Ce<m;Ce++){let Y=0;for(let ie=0;ie<H;ie++){let xe=ie+ue;if(xe<0||xe>=g)continue;let me=te+xe*u[1],_e=xe*T,Le=Math.min(c-1,s?Math.round(_e):Math.floor(_e));if(Q===Le)for(let qe=0;qe<K;qe++){let $e=qe+de;if($e<0||$e>=x)continue;let Ke=me+$e*u[2],rt=$e*N,ht=Math.min(h-1,s?Math.round(rt):Math.floor(rt));he===ht&&(Y+=S[Ke+Ce])}}v[Z+Ce]=Y}}}}return n.makeTensorInfo(r.shape,r.dtype,v)}var Rie={kernelName:yg,backendName:"cpu",kernelFunc:Nie};function Fie(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:i}=a;ct(r,"reverse");let s=r.shape.length,o=O.parseAxisParam(i,r.shape);if(s===0)return ol({inputs:{x:r},backend:n});let u=new Ma(r.shape,r.dtype),d=n.bufferSync(r);for(let c=0;c<u.size;c++){let h=u.indexToLoc(c),m=h.slice();o.forEach(g=>m[g]=r.shape[g]-1-m[g]),u.set(d.get(...m),...h)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}var Die={kernelName:wh,backendName:"cpu",kernelFunc:Fie},Oie={kernelName:Og,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:i,center:s}=t,o=n,u=O.getTypedArrayFromDType(a.dtype,O.sizeFromShape(a.shape)),[d,c,h,m]=a.shape,[g,x]=P.getImageCenter(s,c,h),v=255,S=Math.sin(r),E=Math.cos(r),C=o.data.get(a.dataId).values;for(let T=0;T<d;T++){let N=T*h*c*m;for(let D=0;D<c;D++){let q=D*(h*m);for(let H=0;H<h;H++){let K=H*m;for(let j=0;j<m;j++){let te=[d,D,H,j],Q=te[2],z=te[1],ae=(Q-g)*E-(z-x)*S,ue=(Q-g)*S+(z-x)*E;ae=Math.round(ae+g),ue=Math.round(ue+x);let he=i;if(typeof i!="number"&&(j===3?he=v:he=i[j]),ae>=0&&ae<h&&ue>=0&&ue<c){let se=ue*(h*m),de=ae*m,Ce=N+se+de+j;he=C[Ce]}let Z=N+q+K+j;u[Z]=he}}}}return{dataId:o.write(u,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},Mie=Vn(xh,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),Bie={kernelName:xh,backendName:"cpu",kernelFunc:Mie};function Lie(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:i}=t,{shape:s}=a,{sliceRank:o,numUpdates:u,sliceSize:d,strides:c,outputSize:h}=P.calculateShapes(i,r,s),m=!0,g=n.bufferSync(r),x=n.bufferSync(i),v=Hd(g,x,s,h,d,u,o,c,0,m);return n.makeTensorInfo(s,v.dtype,v.values)}var zie={kernelName:xg,backendName:"cpu",kernelFunc:Lie};function Uie(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function Vie(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}function Wie(e,t,n,a,r,i){let s=O.getArrayFromDType("int32",n*r);for(let o=0;o<n;++o){let u=e.slice(o*a,(o+1)*a),d=o*r;for(let c=0;c<r;++c)s[d+c]=i==="left"?Uie(u,t[c+d]):Vie(u,t[c+d])}return s}function qie(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:i}=t,{side:s}=a,o=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,d=Wie(o,u,r.shape[0],r.shape[1],i.shape[1],s);return n.makeTensorInfo(i.shape,"int32",d)}var Pie={kernelName:Sg,backendName:"cpu",kernelFunc:qie};function Hie(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:i}=t;ct([a,r,i],"select");let s=a.shape.length,o=n.data.get(a.dataId).values,u=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,c=as(r.dtype,i.dtype),h=O.makeZerosTypedArray(O.sizeFromShape(r.shape),c),m=0,g=s===0||s>1||r.shape.length===1?1:O.sizeFromShape(r.shape.slice(1));for(let x=0;x<o.length;x++)for(let v=0;v<g;v++)o[x]===1?h[m++]=u[x]:h[m++]=d[x];return n.makeTensorInfo(r.shape,c,h)}var Gie={kernelName:kg,backendName:"cpu",kernelFunc:Hie},Kie=P.SELU_SCALEALPHA,$ie=P.SELU_SCALE,Jie=Vn(Sh,e=>e>=0?$ie*e:Kie*(Math.exp(e)-1)),Yie={kernelName:Sh,backendName:"cpu",kernelFunc:Jie},jie=Vn(Eh,e=>e<0?-1:e>0?1:0),Qie={kernelName:Eh,backendName:"cpu",kernelFunc:jie},Zie=Vn(kh,e=>Math.sin(e)),Xie={kernelName:kh,backendName:"cpu",kernelFunc:Zie},ese=Vn(Ah,e=>Math.sinh(e)),tse={kernelName:Ah,backendName:"cpu",kernelFunc:ese},nse=11920928955078125e-23,AR=Math.log(nse)+2,ase=Vn(Ih,e=>{let t=e>-AR,n=e<AR,a=Math.exp(e),r;return n?r=a:t?r=e:r=Math.log(1+a),r}),rse={kernelName:Ih,backendName:"cpu",kernelFunc:ase};function ise(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:i,paddings:s}=a;ct([r],"spaceToBatchND");let o=O.sizeFromShape(i),u=[[0,0]];u.push(...s);for(let S=1+i.length;S<r.shape.length;++S)u.push([0,0]);let d=h4.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),c=P.getReshaped(d.shape,i,o,!1),h=P.getPermuted(c.length,i.length,!1),m=P.getReshapedPermuted(d.shape,i,o,!1),g=sa({inputs:{x:d},backend:n,attrs:{shape:c}}),x=pi({inputs:{x:g},backend:n,attrs:{perm:h}}),v=sa({inputs:{x},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),v}var sse={kernelName:Eg,backendName:"cpu",kernelFunc:ise};function ose(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:i,defaultValue:s}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(s.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${s.shape}`);let o=n.data.get(a.dataId).values,u=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,c=n.data.get(s.dataId).values[0],[h,m,g,x,v]=PB(o,a.shape,a.dtype,u,r.dtype,d,c);return[n.makeTensorInfo(m,a.dtype,h),n.makeTensorInfo([m[0]],r.dtype,g),n.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(S=>Number(S)))),n.makeTensorInfo([v.length],a.dtype,new Int32Array(v))]}var lse={kernelName:S0,backendName:"cpu",kernelFunc:ose};function use(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:i}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let s=Array.from(n.data.get(r.dataId).values),o=n.data.get(a.dataId).values,u=Array.from(n.data.get(i.dataId).values),[d,c,h]=HB(o,a.shape,a.dtype,s,u);return[n.makeTensorInfo(c,a.dtype,d),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}var cse={kernelName:Ig,backendName:"cpu",kernelFunc:use};function dse(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:i}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");let s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,[d,c]=$I(s,a.shape,a.dtype,o,u,!0);return n.makeTensorInfo(c,a.dtype,d)}var pse={kernelName:k0,backendName:"cpu",kernelFunc:dse};function hse(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:i}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");let s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,[d,c]=$I(s,a.shape,a.dtype,o,u);return n.makeTensorInfo(c,a.dtype,d)}var fse={kernelName:A0,backendName:"cpu",kernelFunc:hse};function mse(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:i,defaultValue:s}=t,{outputShape:o}=a,{sliceRank:u,numUpdates:d,sliceSize:c,strides:h,outputSize:m}=P.calculateShapes(i,r,o),g=!1,x=n.bufferSync(r),v;switch(i.dtype){case"bool":{let S=n.bufferSync(i),E=!!n.data.get(s.dataId).values[0];v=Hd(x,S,o,m,c,d,u,h,E,g);break}case"float32":{let S=n.bufferSync(i),E=n.data.get(s.dataId).values[0];v=Hd(x,S,o,m,c,d,u,h,E,g);break}case"int32":{let S=n.bufferSync(i),E=n.data.get(s.dataId).values[0];v=Hd(x,S,o,m,c,d,u,h,E,g);break}case"string":{let S=n.bufferSync(i),E=O.decodeString(n.data.get(s.dataId).values[0]);v=Hd(x,S,o,m,c,d,u,h,E,g);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return n.makeTensorInfo(o,v.dtype,v.values)}var gse={kernelName:_g,backendName:"cpu",kernelFunc:mse};function bse(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:i,axis:s}=a,o=O.parseAxisParam(s,r.shape)[0],u=P.prepareSplitSize(r,i,o),d=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(h=>{let m=[...c];m[o]=h;let g=cp({inputs:{x:r},backend:n,attrs:{begin:d,size:m}});return d[o]+=h,g})}var yse={kernelName:Cg,backendName:"cpu",kernelFunc:bse},wse={kernelName:E0,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,a=t;ct(n,"square");let r=a.data.get(n.dataId).values,i=new Float32Array(r.length);for(let s=0;s<r.length;++s){let o=r[s];i[s]=o*o}return{dataId:a.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},xse=Vn(zc,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),vse={kernelName:zc,backendName:"cpu",kernelFunc:xse};function Sse(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:i,end:s,strides:o,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:m}=a;ct(r,"stridedSlice");let{finalShapeSparse:g,finalShape:x,isIdentity:v,sliceDim0:S,isSimpleSlice:E,begin:C,end:T,strides:N}=$a.sliceInfo(r.shape,i,s,o,u,d,c,h,m),D;if(v)D=sa({inputs:{x:r},backend:n,attrs:{shape:x}});else if(S||E){O.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let q=$a.computeOutShape(C,T,N),H=cp({inputs:{x:r},backend:n,attrs:{begin:C,size:q}});D=sa({inputs:{x:H},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(H)}else{let q=n.bufferSync(r),H=$B(g,q,N,C);D=n.makeTensorInfo(x,H.dtype,H.values)}return D}var kse={kernelName:Tg,backendName:"cpu",kernelFunc:Sse};function Ase(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:i,leftPad:s,rightPad:o,padWidth:u,preserveShortSequences:d}=a,{data:c,dataSplits:h}=t,m=n.data.get(c.dataId).values,g=n.data.get(h.dataId).values,[x,v]=JI(m,g,r,i,s,o,u,d);return[n.makeTensorInfo([x.length],"string",x),n.makeTensorInfo(h.shape,"int32",v)]}var Ese={kernelName:I0,backendName:"cpu",kernelFunc:Ase};function Cse(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:i,delimiter:s}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(s.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);let o=n.data.get(i.dataId).values,u=n.data.get(s.dataId).values[0],[d,c,h]=YI(o,u,r),m=c.length;return[n.makeTensorInfo([m,2],"int32",d),n.makeTensorInfo([m],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var Ise={kernelName:_0,backendName:"cpu",kernelFunc:Cse};function _se(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let s=n.data.get(i.dataId).values,o=jI(s,r);return n.makeTensorInfo(i.shape,"int32",o)}var Tse={kernelName:T0,backendName:"cpu",kernelFunc:_se},Nse=Vn(Dh,e=>Math.tan(e)),Rse={kernelName:Dh,backendName:"cpu",kernelFunc:Nse},Fse=Vn(Oh,e=>Math.tanh(e)),Dse={kernelName:Oh,backendName:"cpu",kernelFunc:Fse};function Ose(e){let{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:i}=t,{sliceRank:s,numUpdates:o,sliceSize:u,strides:d,outputSize:c}=P.calculateShapes(i,r,a.shape),h=!1,m=n.bufferSync(r),g=n.bufferSync(i),x=n.bufferSync(a),v=Hd(m,g,a.shape,c,u,o,s,d,x,h);return n.makeTensorInfo(a.shape,v.dtype,v.values)}var Mse={kernelName:vg,backendName:"cpu",kernelFunc:Ose};function Bse(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:i}=a;ct(r,"tile");let s=YB(n.bufferSync(r),i);return n.makeTensorInfo(s.shape,s.dtype,s.values)}var Lse={kernelName:Lc,backendName:"cpu",kernelFunc:Bse};function zse(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:i,sorted:s}=a;ct(r,"topk");let o=n.data.get(r.dataId).values,[u,d]=QB(o,r.shape,r.dtype,i,s);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(d.shape,d.dtype,d.values)]}var Use={kernelName:Ng,backendName:"cpu",kernelFunc:zse};function Vse(e){let{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:i}=t,{interpolation:s,fillMode:o,fillValue:u,outputShape:d}=n,[c,h,m,g]=r.shape,[x,v]=d??[h,m],S=[c,x,v,g],E=O.computeStrides(r.shape),C=E[0],T=E[1],N=E[2],D=O.computeStrides(S),q=D[0],H=D[1],K=D[2],j=O.getTypedArrayFromDType(r.dtype,O.sizeFromShape(S));j.fill(u);let te=a.data.get(r.dataId).values,Q=a.data.get(i.dataId).values;for(let z=0;z<c;++z){let ae=i.shape[0]===1?Q:Q.subarray(z*8,z*8+8);for(let ue=0;ue<x;++ue)for(let he=0;he<v;++he)for(let Z=0;Z<g;++Z){let se,de=ae[6]*he+ae[7]*ue+1;if(de===0)continue;let Ce=(ae[0]*he+ae[1]*ue+ae[2])/de,Y=(ae[3]*he+ae[4]*ue+ae[5])/de,ie=ER(Ce,m,o),xe=ER(Y,h,o);switch(s){case"nearest":se=Kse(te,h,m,C,T,N,z,xe,ie,Z,u);break;case"bilinear":se=$se(te,h,m,C,T,N,z,xe,ie,Z,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${s}`)}let me=z*q+ue*H+he*K+Z;j[me]=se}return a.makeTensorInfo(S,r.dtype,j)}return{dataId:a.write(j,S,r.dtype),shape:r.shape,dtype:r.dtype}}var Wse={kernelName:Rg,backendName:"cpu",kernelFunc:Vse};function ER(e,t,n){switch(n){case"reflect":return qse(e,t);case"wrap":return Pse(e,t);case"nearest":return Gse(e,t);case"constant":default:return Hse(e)}}function qse(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=2*t;n<a&&(n=a*Math.trunc(-n/a)+n),n=n<-t?n+a:-n-1}else if(n>t-1)if(t<=1)n=0;else{let a=2*t;n-=a*Math.trunc(n/a),n>=t&&(n=a-n-1)}return O.clamp(0,n,t-1)}function Pse(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=t-1;n+=t*(Math.trunc(-n/a)+1)}else if(n>t-1)if(t<=1)n=0;else{let a=t-1;n-=t*Math.trunc(n/a)}return O.clamp(0,n,t-1)}function Hse(e,t){return e}function Gse(e,t){return O.clamp(0,e,t-1)}function Ey(e,t,n,a,r,i,s,o,u,d,c){let h=s*a+o*r+u*i+d;return 0<=o&&o<t&&0<=u&&u<n?e[h]:c}function Kse(e,t,n,a,r,i,s,o,u,d,c){let h=Math.round(o),m=Math.round(u);return Ey(e,t,n,a,r,i,s,h,m,d,c)}function $se(e,t,n,a,r,i,s,o,u,d,c){let h=Math.floor(o),m=Math.floor(u),g=h+1,x=m+1,v=(x-u)*Ey(e,t,n,a,r,i,s,h,m,d,c)+(u-m)*Ey(e,t,n,a,r,i,s,h,x,d,c),S=(x-u)*Ey(e,t,n,a,r,i,s,g,m,d,c)+(u-m)*Ey(e,t,n,a,r,i,s,g,x,d,c);return(g-o)*v+(o-h)*S}function Jse(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:i}=t;ct(i,"unique");let s=a.data.get(i.dataId).values,{outputValues:o,outputShape:u,indices:d}=ZI(s,r,i.shape,i.dtype);return[a.makeTensorInfo(u,i.dtype,o),a.makeTensorInfo([d.length],"int32",d)]}var Yse={kernelName:N0,backendName:"cpu",kernelFunc:Jse};function jse(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:i}=a;i<0&&(i+=r.shape.length);let s=r.shape.length,o=r.shape[i],u=new Array(s-1),d=0;for(let g=0;g<s;g++)g!==i&&(u[d++]=r.shape[g]);let c=new Array(s).fill(0),h=r.shape.slice();h[i]=1;let m=new Array(o);for(let g=0;g<m.length;g++){c[i]=g;let x=cp({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});m[g]=sa({inputs:{x},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(x)}return m}var Qse={kernelName:Fg,backendName:"cpu",kernelFunc:jse};function Zse(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:i}=t,{numSegments:s}=a;ct(r,"unsortedSegmentSum");let o=r.shape.length,u=i.shape.length,d=[],c=[],h=o-u,m=i;for(let x=0;x<h;++x){let v=q1({inputs:{input:m},backend:n,attrs:{dim:x+1}});m=v,c.push(v)}for(let x=0;x<s;++x){let v=O.createScalarValue(x,"int32"),S=n.makeTensorInfo([],"int32",v),E=yB({inputs:{a:S,b:m},backend:n}),C=Nc({inputs:{x:E},backend:n,attrs:{dtype:"float32"}}),T=vS({inputs:{a:C,b:r},backend:n}),N=sw({inputs:{x:T},backend:n,attrs:{axis:0,keepDims:!1}});d.push(N),c.push(S),c.push(E),c.push(C),c.push(T),c.push(N)}let g=p4({inputs:d,backend:n,attrs:{axis:0}});return c.forEach(x=>n.disposeIntermediateTensorInfo(x)),g}var Xse={kernelName:R0,backendName:"cpu",kernelFunc:Zse},eoe=[$te,Cee,Yte,Qte,Fee,Xte,tne,ane,ine,one,une,dne,hne,gne,yne,vne,kne,Ene,Ine,Gte,Tne,Rne,Dne,Oee,Mne,Nee,Bee,Lne,Iee,Une,Wne,qne,Hne,Kne,Jne,jne,Zne,eae,nae,rae,sae,lae,cae,pae,hae,mae,bae,wae,xae,vae,Sae,Aae,Iae,zte,Tae,Lee,Lae,zee,zae,Vee,Hae,Gae,$ae,qee,Hee,Yae,Qae,Xae,tre,Kee,Jee,_ee,are,Vne,ire,ore,ure,Ute,jee,Zee,dre,ete,hre,gre,yre,vre,kre,Ere,Cre,nte,_re,Nre,Fre,Ore,Bre,zre,Vre,rte,qre,Gre,Yre,ste,lte,Zre,tie,rie,cte,sie,lie,uie,h4,hie,Wte,hte,mie,bie,wie,vie,Tee,iA,kie,qte,Pte,Hte,Eie,Iie,Tie,Rie,Die,Oie,Bie,Ste,zie,Pie,Gie,Yie,Ate,Qie,Xie,tse,Ete,$re,rse,sse,lse,cse,pse,fse,gse,yse,_te,wse,Nte,Fte,vse,kse,Ese,Ise,Tse,Bte,Eae,Rse,Dse,Mse,Lse,Use,Wse,dte,Yse,Qse,Xse,oie];for(let e of eoe)F0(e);var f4={};qt(f4,{assertNotComplex:()=>$g,bindCanvasToFramebuffer:()=>doe,bindColorTextureToFramebuffer:()=>d1,bindTextureToProgramUniformSampler:()=>N4,bindTextureUnit:()=>I4,bindVertexBufferToProgramAttribute:()=>oA,callAndCheck:()=>nt,canBeRepresented:()=>g4,createFragmentShader:()=>w4,createFramebuffer:()=>C4,createProgram:()=>x4,createStaticIndexBuffer:()=>k4,createStaticVertexBuffer:()=>S4,createTexture:()=>A4,createVertexShader:()=>y4,getBatchDim:()=>dp,getExtensionOrThrow:()=>Cy,getFramebufferErrorMessage:()=>R4,getMaxTexturesInShader:()=>M4,getNumChannels:()=>uoe,getProgramUniformLocation:()=>T4,getProgramUniformLocationOrThrow:()=>_4,getRowsCols:()=>pp,getShapeAs3D:()=>_y,getTextureShapeFromLogicalShape:()=>D4,getWebGLDisjointQueryTimerVersion:()=>B4,getWebGLErrorMessage:()=>b4,getWebGLMaxTextureSize:()=>O4,hasExtension:()=>es,isCapableOfRenderingToFloatTexture:()=>L4,isDownloadFloatTextureEnabled:()=>z4,isReshapeFree:()=>r0,isWebGLFenceEnabled:()=>U4,isWebGLVersionEnabled:()=>uA,linkProgram:()=>v4,logShaderSourceAndInfoLog:()=>a_,resetMaxTextureSize:()=>poe,resetMaxTexturesInShader:()=>hoe,unbindColorTextureFromFramebuffer:()=>lA,unbindTextureUnit:()=>coe,validateFramebuffer:()=>Iy,validateProgram:()=>c1,validateTextureSize:()=>E4});var qd={},Xx={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function m4(e,t){qd[e]=t}function co(e,t){if(!(e in qd)||t!=null){let a=noe(e,t);if(a!==null)qd[e]=a;else return console.log("Could not get context for WebGL version",e),null}let n=qd[e];return n==null||n.isContextLost()?(delete qd[e],co(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),qd[e])}function toe(e){if(!Ae().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function noe(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??toe(e);return n.addEventListener("webglcontextlost",a=>{a.preventDefault(),delete qd[e]},!1),Ae().getBool("SOFTWARE_WEBGL_ENABLED")&&(Xx.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",Xx)||n.getContext("experimental-webgl",Xx):n.getContext("webgl2",Xx)}var a0;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(a0||(a0={}));var Xi;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Xi||(Xi={}));var wr;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(wr||(wr={}));function ow(e,t){return[t,e]}function aoe(e,t){return e*t}function e1(e){let t=O.sizeFromShape(e),n=Math.ceil(t/4);return O.sizeToSquarishShape(n)}function Kg(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function roe(e,t){let[n,a]=Kg(e,t);return n*a*4}function n_(e,t){let n=e,a,r,i,s,o,u,d,c,h,m;return Ae().getNumber("WEBGL_VERSION")===2?(a=n.R32F,r=n.R16F,i=n.RGBA16F,s=n.RGBA32F,o=n.RED,d=4,c=1,h=n.HALF_FLOAT,m=n.FLOAT,u=n.RGBA8):(a=e.RGBA,r=e.RGBA,i=e.RGBA,s=n.RGBA,o=e.RGBA,d=4,c=4,h=t!=null?t.HALF_FLOAT_OES:null,m=e.FLOAT,u=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:s,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:d,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:m}}function nt(e,t){let n=t();return Ae().getBool("DEBUG")&&ioe(e),n}function ioe(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+b4(e,t))}var soe=596e-10,ooe=65504;function g4(e){return!!(Ae().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||soe<Math.abs(e)&&Math.abs(e)<ooe)}function b4(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Cy(e,t){return du(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function y4(e,t){let n=du(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(nt(e,()=>e.shaderSource(n,t)),nt(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function w4(e,t){let n=du(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(nt(e,()=>e.shaderSource(n,t)),nt(e,()=>e.compileShader(n)),Ae().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw a_(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var loe=/ERROR: [0-9]+:([0-9]+):/g;function a_(e,t){let n=loe.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let a=+n[1],r=e.split(`
`),i=r.length.toString().length+2,s=r.map((h,m)=>O.rightPad((m+1).toString(),i)+h),o=0;for(let h=0;h<s.length;h++)o=Math.max(s[h].length,o);let u=s.slice(0,a-1),d=s.slice(a-1,a),c=s.slice(a);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${O.rightPad(d[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function x4(e){return du(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function v4(e,t){if(nt(e,()=>e.linkProgram(t)),!Ae().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function c1(e,t){if(nt(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function S4(e,t){let n=du(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return nt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),nt(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function k4(e,t){let n=du(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return nt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),nt(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function uoe(){return Ae().getNumber("WEBGL_VERSION")===2?1:4}function A4(e){return du(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function E4(e,t){let n=Ae().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let a=`[${e}x${t}]`;throw new Error("Requested texture size "+a+" is invalid.")}if(e>n||t>n){let a=`[${e}x${t}]`,r=`[${n}x${n}]`;throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}function C4(e){return du(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function oA(e,t,n,a,r,i,s){let o=e.getAttribLocation(t,n);return o===-1?!1:(nt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),nt(e,()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,i,s)),nt(e,()=>e.enableVertexAttribArray(o)),!0)}function I4(e,t,n){F4(e,n),nt(e,()=>e.activeTexture(e.TEXTURE0+n)),nt(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function coe(e,t){F4(e,t),nt(e,()=>e.activeTexture(e.TEXTURE0+t)),nt(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function _4(e,t,n){return du(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function T4(e,t,n){return e.getUniformLocation(t,n)}function N4(e,t,n,a){nt(e,()=>I4(e,t,a)),nt(e,()=>e.uniform1i(n,a))}function doe(e){nt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),nt(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),nt(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function d1(e,t,n){nt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),nt(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function lA(e,t){nt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),nt(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Iy(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+R4(e,t))}function R4(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function du(e,t,n){let a=nt(e,()=>t());if(a==null)throw new Error(n);return a}function F4(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){let r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function dp(e,t=2){return O.sizeFromShape(e.slice(0,e.length-t))}function pp(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function _y(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[dp(e),...pp(e)]),t}function D4(e,t=!1){let n=Ae().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=Ae().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");a===1/0&&Ae().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n=n*2,a=a*2,e=e.map((o,u)=>u>=e.length-2?O.nearestLargerEven(e[u]):e[u]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=O.squeezeShape(e).newShape);let r=O.sizeFromShape(e),i=null;e.length<=1&&r<=n?i=[1,r]:e.length===2&&e[0]<=n&&e[1]<=n?i=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?i=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?i=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?i=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(i=[e[0],e[1]*e[2]*e[3]]);let s=i!=null&&Math.max(...i)>a&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(i==null||s)if(t){let o=dp(e),u=2,d=2;e.length&&([u,d]=pp(e)),r=o*(u/2)*(d/2),i=O.sizeToSquarishShape(r).map(c=>c*2)}else i=O.sizeToSquarishShape(r);return i}function t1(e){return e%2===0}function r0(e,t){if(e=e.slice(-2),t=t.slice(-2),O.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],a=t[t.length-1];if(n===a||t1(n)&&t1(a)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&t1(e[0])&&t1(t[0])}var p1,h1;function O4(e){if(p1==null){let t=co(e);p1=t.getParameter(t.MAX_TEXTURE_SIZE)}return p1}function poe(){p1=null}function hoe(){h1=null}function M4(e){if(h1==null){let t=co(e);h1=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,h1)}function B4(e){if(e===0)return 0;let t,n=co(e);return es(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:es(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function es(e,t){return e.getExtension(t)!=null}function uA(e){try{if(co(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function L4(e){if(e===0)return!1;let t=co(e);if(e===1){if(!es(t,"OES_texture_float"))return!1}else if(!es(t,"EXT_color_buffer_float"))return!1;return cA(t)}function z4(e){if(e===0)return!1;let t=co(e);if(e===1){if(!es(t,"OES_texture_float")||!es(t,"WEBGL_color_buffer_float"))return!1}else{if(es(t,"EXT_color_buffer_float"))return cA(t);let n="EXT_color_buffer_half_float";if(es(t,n)){let a=t.getExtension(n);return foe(t,a)}return!1}return cA(t)}function cA(e){let t=n_(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function foe(e,t){let n=n_(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(r),i}function U4(e){return e!==2?!1:co(e).fenceSync!=null}function $g(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&O.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var pt=Ae();pt.registerFlag("HAS_WEBGL",()=>pt.getNumber("WEBGL_VERSION")>0);pt.registerFlag("WEBGL_VERSION",()=>uA(2)?2:uA(1)?1:0);pt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);pt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>pt.get("WEBGL_VERSION")===2);pt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);pt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);pt.registerFlag("WEBGL_PACK",()=>pt.getBool("HAS_WEBGL"));pt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>pt.getBool("WEBGL_PACK"));pt.registerFlag("WEBGL_PACK_CLIP",()=>pt.getBool("WEBGL_PACK"));pt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>pt.getBool("WEBGL_PACK"));pt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>pt.getBool("WEBGL_PACK"));pt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>pt.getBool("WEBGL_PACK"));pt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>pt.getBool("WEBGL_PACK"));pt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>pt.getBool("WEBGL_PACK"));pt.registerFlag("WEBGL_PACK_REDUCE",()=>pt.getBool("WEBGL_PACK"));pt.registerFlag("WEBGL_LAZILY_UNPACK",()=>pt.getBool("WEBGL_PACK"));pt.registerFlag("WEBGL_CONV_IM2COL",()=>pt.getBool("WEBGL_PACK"));pt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>pt.getBool("WEBGL_PACK"));pt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>O4(pt.getNumber("WEBGL_VERSION")));pt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>M4(pt.getNumber("WEBGL_VERSION")));pt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=pt.getNumber("WEBGL_VERSION");return e===0?0:B4(e)});pt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>pt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!M0.isMobile());pt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>L4(pt.getNumber("WEBGL_VERSION")));pt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>pt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:pt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));pt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>z4(pt.getNumber("WEBGL_VERSION")));pt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>U4(pt.getNumber("WEBGL_VERSION")));pt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>pt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);pt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});pt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>M0.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});pt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);pt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);pt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);pt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);pt.registerFlag("WEBGL_EXP_CONV",()=>!1);pt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>pt.getBool("IS_TEST"));pt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);pt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);pt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);pt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function jr(){let e,t,n,a,r,i,s,o,u,d;return Ae().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",a="in",r="texture",i="outputColor",s="out vec4 outputColor;",o=Ae().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",d=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",a="varying",r="texture2D",i="gl_FragColor",s="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,d=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:i,defineOutput:s,defineSpecialNaN:o,defineSpecialInf:u,defineRound:d}}function qh(e,t,n="index"){let a=O.computeStrides(t);return a.map((r,i)=>{let s=`int ${e[i]} = ${n} / ${r}`,o=i===a.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r}`:`index -= ${e[i]} * ${r}`;return`${s}; ${o};`}).join("")}function SS(e,t,n="index"){let a=O.computeStrides(t);return a.map((r,i)=>{let s=`int ${e[i]} = ${n} / outShapeStrides[${i}]`,o=i===a.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * outShapeStrides[${i}]`:`index -= ${e[i]} * outShapeStrides[${i}]`;return`${s}; ${o};`}).join("")}function moe(e,t){let n=e.length,a=e.map(i=>`${t}[${i}]`),r=new Array(n-1);r[n-2]=a[n-1];for(let i=n-3;i>=0;--i)r[i]=`(${r[i+1]} * ${a[i+1]})`;return r}function goe(e,t,n="index"){let a=e.map((i,s)=>s),r=moe(a,t);return r.map((i,s)=>{let o=`int ${e[s]} = ${n} / ${r[s]}`,u=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r[s]}`:`index -= ${e[s]} * ${r[s]}`;return`${o}; ${u};`}).join("")}function r_(e){let t=O.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function i_(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var V4=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:W4}=P;function boe(e,t,n){let a=[];if(e.forEach(m=>{let g=O.sizeFromShape(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?a.push(`uniform float ${m.name}${g>1?`[${g}]`:""};`):(a.push(`uniform sampler2D ${m.name};`),a.push(`uniform int offset${m.name};`)),n.enableShapeUniforms){let{uniformShape:x}=s_(n.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(x.length){case 1:a.push(`uniform int ${m.name}Shape;`);break;case 2:a.push(`uniform ivec2 ${m.name}Shape;`);break;case 3:a.push(`uniform ivec3 ${m.name}Shape;`);break;case 4:a.push(`uniform ivec4 ${m.name}Shape;`);break}a.push(`uniform ivec2 ${m.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;");break}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(m=>{a.push(`uniform ${m.type} ${m.name}${m.arrayIndex?`[${m.arrayIndex}]`:""};`)});let r=a.join(`
`),i=e.map(m=>yoe(m,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),s=t.texShape,o=jr(),u=voe(o),d,c,h=Aoe(o);return t.isPacked?(d=woe(t.logicalShape,s,n.enableShapeUniforms),c=koe(o)):(d=xoe(t.logicalShape,s,n.enableShapeUniforms),c=Soe(o)),n.packedInputs&&(h+=_oe),[h,u,c,r,d,i,n.userCode].join(`
`)}function Jg(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return Voe(e,t);case 1:return qoe(e,t);case 2:return Hoe(e,t);case 3:return Koe(e,t);case 4:return Joe(e,t);case 5:return Yoe(e);case 6:return joe(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function q4(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return Uoe(e);case 1:return Woe(e,t);case 2:return Poe(e,t);case 3:return Goe(e,t);default:return $oe(e,t)}}function yoe(e,t,n=!1,a){let r="";n?r+=q4(e,a):r+=Jg(e,a);let i=e.shapeInfo.logicalShape,s=t.logicalShape;return i.length<=s.length&&(n?r+=Qoe(e,t):r+=Zoe(e,t)),r}function woe(e,t,n){switch(e.length){case 0:return P4();case 1:return Toe(e,t,n);case 2:return Loe(e,t,n);case 3:return Roe(e,t,n);default:return Doe(e,t,n)}}function xoe(e,t,n){switch(e.length){case 0:return P4();case 1:return Noe(e,t,n);case 2:return zoe(e,t,n);case 3:return Foe(e,t,n);case 4:return Ooe(e,t,n);case 5:return Moe(e,t);case 6:return Boe(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function voe(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function Soe(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function koe(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function Aoe(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Eoe}
    ${Coe}
    ${Ioe}
  `}var Eoe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Coe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Ioe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,_oe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function P4(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Toe(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return a[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${a[1]}.0);
      }
    `:a[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${a[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      return 2 * (resTexRC.x * ${a[1]} + resTexRC.y);
    }
  `}function Noe(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function Roe(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),i=r*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function Foe(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${SS(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let a=qh(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec3(r, c, d);
    }
  `}function Doe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),i=r*Math.ceil(e[e.length-2]/2),s=i,o="",u="b, r, c";for(let d=2;d<e.length-1;d++)s*=e[e.length-d-1],o=`
      int b${d} = index / ${s};
      index -= b${d} * ${s};
    `+o,u=`b${d}, `+u;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      ${o}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${e.length}(${u});
    }
  `}function Ooe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${SS(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let a=qh(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec4(r, c, d, d2);
    }
  `}function Moe(e,t){let n=qh(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Boe(e,t){let n=qh(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Loe(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(O.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${a[0]}, ${a[1]}));
      }
    `;let r=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));

      int index = resTexRC.x * ${a[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function zoe(e,t,n){return O.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Ph(e){return`offset${e}`}function Uoe(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=jr();return`
    vec4 ${n}() {
      return ${a.texture2D}(${t}, halfCR);
    }
  `}function Voe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${a}() {return ${n};}`;let[r,i]=e.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${a}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let s=Ph(n);if(t)return`
    float ${a}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${s});
      return sampleTexture(${n}, uv);
    }
  `;let[o,u]=e.shapeInfo.texShape;return`
    float ${a}() {
      vec2 uv = uvFromFlat(${o}, ${u}, ${s});
      return sampleTexture(${n}, uv);
    }
  `}function Woe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,i=jr();if(t)return`
    vec4 ${a}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${n}, uv);
    }
  `;let s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${a}(int index) {
      vec2 uv = packedUVfrom1D(
        ${s[0]}, ${s[1]}, index);
      return ${i.texture2D}(${n}, uv);
    }
  `}function qoe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${a}(int index) {
        ${Yg(e)}
      }
    `;let r=e.shapeInfo.texShape,i=r[0],s=r[1];if(s===1&&i===1)return`
      float ${a}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=Ph(n);return s===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${i}.0);
        return sampleTexture(${n}, uv);
      }
    `:i===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${s}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${i}, ${s}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function Poe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=e.shapeInfo.texShape,s=i[0],o=i[1],u=jr();if(i!=null&&O.arraysEqual(n,i))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);

        return ${u.texture2D}(${a}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${s}.0);

        return ${u.texture2D}(${a}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${a}, uv);
    }
  `;let d=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${d[0]}, ${d[1]}, row, col);
      return ${u.texture2D}(${a}, uv);
    }
  `}function Hoe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=e.shapeInfo.texShape;if(i!=null&&O.arraysEqual(n,i)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `;let m=i[0],g=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${m}.0);
      return sampleTexture(${a}, uv);
    }
  `}let{newShape:s,keptDims:o}=O.squeezeShape(n),u=s;if(u.length<n.length){let m=jg(e,u),g=["row","col"];return`
      ${Jg(m,t)}
      float ${r}(int row, int col) {
        return ${r}(${Qg(g,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Yg(e)}
      }
    `;let d=i[0],c=i[1],h=Ph(a);return c===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${a}TexShape[0]));
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
      return sampleTexture(${a}, uv);
    }
  `:d===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${a}TexShape[1]), 0.5);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${a}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
        return sampleTexture(${a}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${d}, ${c}, index);
    return sampleTexture(${a}, uv);
  }
`}function Goe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=e.shapeInfo.texShape,s=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(n[0]===1){let m=n.slice(1),g=[1,2],x=jg(e,m),v=["b","row","col"];return`
        ${q4(x,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Qg(v,g)});
        }
      `}let o=jr();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${a}, uv);
    }
  `;let u=s[0],d=s[1],c=Math.ceil(n[2]/2),h=c*Math.ceil(n[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${d}, ${h}, ${c}, b, row, col);
      return ${o.texture2D}(${a}, uv);
    }
  `}function Koe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=n[1]*n[2],s=n[2],{newShape:o,keptDims:u}=O.squeezeShape(n),d=o;if(d.length<n.length){let v=jg(e,d),S=["row","col","depth"];return`
        ${Jg(v,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Qg(S,u)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${s}, 1)));
        ${Yg(e)}
      }
    `;let c=e.shapeInfo.texShape,h=c[0],m=c[1],g=e.shapeInfo.flatOffset;if(m===i&&g==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${a}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${s}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${h}.0);
          return sampleTexture(${a}, uv);
        }
      `;if(m===s&&g==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${a}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${h}.0);
      return sampleTexture(${a}, uv);
    }
  `;let x=Ph(a);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${a}Shape[1] * ${a}Shape[2];
      int stride1 = ${a}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${x};
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
      return sampleTexture(${a}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${s} + depth + ${x};
        vec2 uv = uvFromFlat(${h}, ${m}, index);
        return sampleTexture(${a}, uv);
      }
  `}function $oe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=jr();if(t)return`
    vec4 ${a}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);
    }
  `;let i=e.shapeInfo.logicalShape,s=i.length,o=e.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],d=u[0],c=u[1],h=Math.ceil(i[s-1]/2),m=h*Math.ceil(i[s-2]/2),g="int b, int row, int col",x=`b * ${m} + (row / 2) * ${h} + (col / 2)`;for(let v=2;v<s-1;v++)g=`int b${v}, `+g,m*=i[s-v-1],x=`b${v} * ${m} + `+x;return`
    vec4 ${a}(${g}) {
      int index = ${x};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${d});
      return ${r.texture2D}(${n}, uv);
    }
  `}function Joe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=n[3],s=n[2]*i,o=n[1]*s,{newShape:u,keptDims:d}=O.squeezeShape(n);if(u.length<n.length){let C=jg(e,u),T=["row","col","depth","depth2"];return`
      ${Jg(C,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Qg(T,d)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${s}, ${i}, 1)));
        ${Yg(e)}
      }
    `;let c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,m=h[0],g=h[1],x=`int stride2 = ${a}Shape[3];`,v=`int stride1 = ${a}Shape[2] * stride2;`,S=`int stride0 = ${a}Shape[1] * stride1;`;if(g===o&&c==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${x}
        ${v}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${s}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${a}, uv);
      }
    `;if(g===i&&c==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${a}Shape[1] * ${a}Shape[2], ${a}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${a}, uv);
      }
    `;let E=Ph(a);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${x}
      ${v}
      ${S}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${E});
      return sampleTexture(${a}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${s} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${m}, ${g}, index + ${E});
      return sampleTexture(${a}, uv);
    }
  `}function Yoe(e){let t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],i=t[3]*r,s=t[2]*i,o=t[1]*s,{newShape:u,keptDims:d}=O.squeezeShape(t);if(u.length<t.length){let v=jg(e,u),S=["row","col","depth","depth2","depth3"];return`
      ${Jg(v)}
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        return ${a}(${Qg(S,d)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${s}, ${i}, ${r})) +
          depth3;
        ${Yg(e)}
      }
    `;let c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,m=h[0],g=h[1];if(g===o&&c==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${s}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===r&&c==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;let x=Ph(n);return`
    float ${a}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${s} + depth * ${i} +
          depth2 * ${r} + depth3 + ${x};
      vec2 uv = uvFromFlat(${m}, ${g}, index);
      return sampleTexture(${n}, uv);
    }
  `}function joe(e){let t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:i}=O.squeezeShape(t);if(r.length<t.length){let S=jg(e,r),E=["row","col","depth","depth2","depth3","depth4"];return`
      ${Jg(S)}
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${a}(${Qg(E,i)});
      }
    `}let s=t[5],o=t[4]*s,u=t[3]*o,d=t[2]*u,c=t[1]*d;if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${d}, ${u}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${s}, 1)));
        ${Yg(e)}
      }
    `;let h=e.shapeInfo.flatOffset,m=e.shapeInfo.texShape,g=m[0],x=m[1];if(x===c&&h==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${d}, ${u}, ${o}, ${s})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${x}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(x===s&&h==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${x}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;let v=Ph(n);return`
    float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${d} + depth * ${u} +
          depth2 * ${o} + depth3 * ${s} + depth4 + ${v};
      vec2 uv = uvFromFlat(${g}, ${x}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Yg(e){let t=e.name,n=O.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Qoe(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",i=e.shapeInfo.logicalShape.length,s=t.logicalShape.length,o=W4(e.shapeInfo.logicalShape,t.logicalShape),u=$n(s),d=s-i,c,h=["x","y","z","w","u","v"];i===0?c="":s<2&&o.length>=1?c="coords = 0;":c=o.map(S=>`coords.${h[S+d]} = 0;`).join(`
`);let m="";s<2&&i>0?m="coords":m=e.shapeInfo.logicalShape.map((S,E)=>`coords.${h[E+d]}`).join(", ");let g="return outputValue;",x=O.sizeFromShape(e.shapeInfo.logicalShape)===1,v=O.sizeFromShape(t.logicalShape)===1;if(i===1&&!x&&!v)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!v)s===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(o.length){let S=i-2,E=i-1;o.indexOf(S)>-1&&o.indexOf(E)>-1?g="return vec4(outputValue.x);":o.indexOf(S)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(E)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${a}(${m});
      ${g}
    }
  `}function Zoe(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",i=t.texShape,s=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===u&&e.shapeInfo.flatOffset==null&&O.arraysEqual(s,i))return`
      float ${r}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let d=$n(u),c=W4(e.shapeInfo.logicalShape,t.logicalShape),h=u-o,m,g=["x","y","z","w","u","v"];o===0?m="":u<2&&c.length>=1?m="coords = 0;":m=c.map(v=>`coords.${g[v+h]} = 0;`).join(`
`);let x="";return u<2&&o>0?x="coords":x=e.shapeInfo.logicalShape.map((v,S)=>`coords.${g[S+h]}`).join(", "),`
    float ${r}() {
      ${d} coords = getOutputCoords();
      ${m}
      return get${a}(${x});
    }
  `}function $n(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function s_(e,t,n){let{newShape:a,keptDims:r}=O.squeezeShape(t),i=t.length,s=e&&i===3&&t[0]===1,o=s?t.slice(1):a,u=!e&&i>1&&!O.arraysEqual(t,n)&&a.length<i||s;return{useSqueezeShape:u,uniformShape:u?o:t,keptDims:r}}function jg(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Qg(e,t){return t.map(n=>e[n]).join(", ")}function Xoe(e,t,n,a){let r=n.map((c,h)=>{let m={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(m.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[h],shapeInfo:m}}),i=r.map(c=>c.shapeInfo),s={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},o=boe(r,s,t),u=w4(e.gl,o),d=e.createProgram(u);return Ae().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:o,webGLProgram:d,inShapeInfos:i,outShapeInfo:s,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(d),Object.assign({program:t,fragmentShader:u,source:o,webGLProgram:d,inShapeInfos:i,outShapeInfo:s},H4(e,t,d)))}function H4(e,t,n){let a=[],r=[],i,s,o,u=null,d=null;d=e.getUniformLocation(n,"NAN",!1),Ae().getNumber("WEBGL_VERSION")===1&&(u=e.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let h of t.variableNames){let m={name:h,uniform:e.getUniformLocation(n,h,c),offset:e.getUniformLocation(n,`offset${h}`,c)};t.enableShapeUniforms&&(m.shape=e.getUniformLocation(n,`${h}Shape`,c),m.texShape=e.getUniformLocation(n,`${h}TexShape`,c)),a.push(m)}if(t.enableShapeUniforms&&(i=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),s=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(let h of t.customUniforms)r.push(e.getUniformLocation(n,h.name,c));return{variablesLocations:a,customUniformLocations:r,infLoc:u,nanLoc:d,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:s}}function CR(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,a)=>{let r=n.logicalShape,i=t[a],s=i.shape;if(!O.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(n.isUniform&&i.isUniform)return;let o=n.texShape,u=i.isUniform?null:i.texData.texShape;if(!O.arraysEqual(o,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${u} must match`)})}function ele(e,t,n,a,r){t.program.enableShapeUniforms||(CR(t.inShapeInfos,n),CR([t.outShapeInfo],[a]));let i=a.texData.texture,s=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(i.texture,s[0],s[1]):e.setOutputMatrixTexture(i.texture,s[0],s[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),Ae().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<n.length;++u){let d=n[u],{uniform:c,offset:h,shape:m,texShape:g}=t.variablesLocations[u];if(m){let{uniformShape:x}=s_(t.program.packedInputs,d.shape,d.texData.texShape);switch(x.length){case 1:e.gl.uniform1iv(m,new Int32Array(x));break;case 2:e.gl.uniform2iv(m,new Int32Array(x));break;case 3:e.gl.uniform3iv(m,new Int32Array(x));break;case 4:e.gl.uniform4iv(m,new Int32Array(x));break}}if(g&&e.gl.uniform2i(g,d.texData.texShape[0],d.texData.texShape[1]),c!=null){if(d.isUniform){if(O.sizeFromShape(d.shape)<2)e.gl.uniform1f(c,d.uniformValues[0]);else{let x=d.uniformValues;x instanceof Float32Array||(x=new Float32Array(x)),e.gl.uniform1fv(c,x)}continue}d.texData.slice!=null&&h!=null&&e.gl.uniform1i(h,d.texData.slice.flatOffset),e.setInputMatrixTexture(d.texData.texture.texture,c,u)}}let o=t.outShapeLocation;if(o)switch(a.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(a.shape));break}if(t.outShapeStridesLocation){let u=O.computeStrides(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let u=0;u<t.program.customUniforms.length;++u){let d=t.program.customUniforms[u],c=t.customUniformLocations[u],h=r[u];if(d.type==="float")e.gl.uniform1fv(c,h);else if(d.type==="vec2")e.gl.uniform2fv(c,h);else if(d.type==="vec3")e.gl.uniform3fv(c,h);else if(d.type==="vec4")e.gl.uniform4fv(c,h);else if(d.type==="int")e.gl.uniform1iv(c,h);else if(d.type==="ivec2")e.gl.uniform2iv(c,h);else if(d.type==="ivec3")e.gl.uniform3iv(c,h);else if(d.type==="ivec4")e.gl.uniform4iv(c,h);else throw Error(`uniform type ${d.type} is not supported yet.`)}e.executeProgram()}function tle(e,t,n){let a="";t.concat(n).forEach(s=>{let o=s.texData!=null&&s.texData.slice!=null&&s.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!s.isUniform){let u=s.texData.texShape,{useSqueezeShape:d,uniformShape:c,keptDims:h}=s_(e.packedInputs,s.shape,u),m="",g="",x="";if(c.length===1&&e.packedInputs){let D=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${D[0]>1}_${D[1]>1}`}else if(c.length===2&&!e.packedInputs)g=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){let D=O.computeStrides(c);x=`${D[0]===u[1]}_${D[D.length-1]===u[1]}`}let v=s.shape.length,S=c.length===2&&O.arraysEqual(s.shape,u),E=O.sizeFromShape(s.shape)===1,C=P.getBroadcastDims(s.shape,n.shape),T=!e.packedInputs&&v===n.shape.length&&O.arraysEqual(u,n.texData.texShape),N=e.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;a+=`${v}_${T}_${d?h:""}_${c.length}_${E}_${C}_${S}_${m}_${g}_${x}_${N}_${o}`}else{let u=s.isUniform?"uniform":s.texData.texShape;a+=`${s.shape}_${u}_${o}`}});let r=e.userCode,i=e.constructor.name;return i+="_"+a+"_"+r+`${Ae().getNumber("WEBGL_VERSION")}`,i}function Or(e){return Ae().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var nle=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=a0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=jr();this.outputShape=e,this.enableShapeUniforms=Or(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?SS(["r","c","d"],e):qh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},ale=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=a0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=jr();this.outputShape=e,this.enableShapeUniforms=Or(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?SS(["r","c","d"],e):qh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},rle=class{constructor(e){this.variableNames=["A"],this.outTexUsage=Xi.DOWNLOAD;let t=jr();this.outputShape=e,this.userCode=`
      ${V4}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},ile=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Xi.DOWNLOAD;let t=jr();this.outputShape=e,this.userCode=`
      ${V4}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},sle={R:0,G:1,B:2,A:3},IR=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let a=jr();this.outputShape=e,this.enableShapeUniforms=Or(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let i="";for(let s=0;s<n.length;s++){let o=n[s];i+=`
          if(offset == ${s}) {
            result = values[${sle[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?i_():r_(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${a.texture2D}(A, uv);
          ${i}
        }
        ${a.output} = vec4(${r}, 0., 0., 0.);
      }
    `}},ole=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=jr();this.outputShape=e,this.enableShapeUniforms=Or(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let s=0;s<=1;s++){let o=i*2+s;a+=`
          localCoords = coords;
          if(localCoords[2] + ${s} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${s};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?i_():r_(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${a}

          ${n.output} = ${r};
        }
    `}},G4={};qt(G4,{bindVertexProgramAttributeStreams:()=>eL,createBufferFromOutputTexture:()=>aL,createFloat16MatrixTexture:()=>j4,createFloat16PackedMatrixTexture:()=>X4,createFloat32MatrixTexture:()=>Y4,createIndexBuffer:()=>J4,createPackedMatrixTexture:()=>Z4,createUnsignedBytesMatrixTexture:()=>Q4,createVertexBuffer:()=>$4,createVertexShader:()=>K4,downloadByteEncodedFloatMatrixFromOutputTexture:()=>iL,downloadFloat32MatrixFromBuffer:()=>rL,downloadMatrixFromPackedOutputTexture:()=>oL,downloadPackedMatrixFromBuffer:()=>sL,getInternalFormatForFloat16MatrixTexture:()=>l_,getInternalFormatForFloat16PackedMatrixTexture:()=>d_,getInternalFormatForFloat32MatrixTexture:()=>o_,getInternalFormatForPackedMatrixTexture:()=>c_,getInternalFormatForUnsignedBytesMatrixTexture:()=>u_,uploadDenseMatrixToTexture:()=>tL,uploadPixelDataToTexture:()=>nL});function K4(e){let t=jr(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return y4(e,n)}function $4(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return S4(e,t)}function J4(e){let t=new Uint16Array([0,1,2,2,1,3]);return k4(e,t)}function lw(e,t,n,a,r,i){E4(t,n);let s=A4(e),o=e.TEXTURE_2D;return nt(e,()=>e.bindTexture(o,s)),nt(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),nt(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),nt(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),nt(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),Ae().getNumber("WEBGL_VERSION")===1?nt(e,()=>e.texImage2D(o,0,a,t,n,0,r,i,null)):nt(e,()=>e.texStorage2D(o,1,a,t,n)),nt(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:s,texShape:[n,t]}}function o_(e){return e.internalFormatFloat}function Y4(e,t,n,a){let[r,i]=ow(t,n);return lw(e,r,i,o_(a),a.textureFormatFloat,e.FLOAT)}function l_(e){return e.internalFormatHalfFloat}function j4(e,t,n,a){let[r,i]=ow(t,n);return lw(e,r,i,l_(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function u_(e){return e.downloadTextureFormat}function Q4(e,t,n,a){let[r,i]=ow(t,n);return lw(e,r,i,u_(a),e.RGBA,e.UNSIGNED_BYTE)}function c_(e){return e.internalFormatPackedFloat}function Z4(e,t,n,a){let[r,i]=Kg(t,n);return lw(e,r,i,c_(a),e.RGBA,e.FLOAT)}function d_(e){return e.internalFormatPackedHalfFloat}function X4(e,t,n,a){let[r,i]=Kg(t,n);return lw(e,r,i,d_(a),e.RGBA,a.textureTypeHalfFloat)}function eL(e,t,n){return nt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),oA(e,t,"clipSpacePos",n,3,20,0)&&oA(e,t,"uv",n,2,20,12)}function tL(e,t,n,a,r,i){nt(e,()=>e.bindTexture(e.TEXTURE_2D,t));let s,o,u;r instanceof Uint8Array?(s=new Uint8Array(n*a*4),o=e.UNSIGNED_BYTE,u=e.RGBA):(s=new Float32Array(n*a*4),o=e.FLOAT,u=i.internalFormatPackedFloat),s.set(r),Ae().getNumber("WEBGL_VERSION")===2?nt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,o,s)):nt(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,a,0,e.RGBA,o,s)),nt(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function nL(e,t,n){nt(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?Ae().getNumber("WEBGL_VERSION")===2?nt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):nt(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):Ae().getNumber("WEBGL_VERSION")===2?nt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):nt(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),nt(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function aL(e,t,n,a){let r=e.createBuffer();nt(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));let i=4*4*t*n;return nt(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)),nt(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),nt(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}function rL(e,t,n){let a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}function iL(e,t,n,a){let[r,i]=ow(t,n),s=4,o=new Uint8Array(aoe(t*n,s));return nt(e,()=>e.readPixels(0,0,r,i,a.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function sL(e,t,n,a,r,i,s,o){let u=e,d=new Float32Array(roe(i,s));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,d),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),d}function oL(e,t,n){let a=new Float32Array(t*n*4);return nt(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a)),a}var f1=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=Ae().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,m4(t,e)):this.gl=co(t),e=this.gl,Ae().getNumber("WEBGL_VERSION")===2){let r=e;this.createVertexArray=()=>nt(r,()=>r.createVertexArray()),this.bindVertexArray=i=>nt(r,()=>r.bindVertexArray(i)),this.deleteVertexArray=i=>nt(r,()=>r.deleteVertexArray(i)),this.getVertexArray=()=>nt(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){let r=e.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>nt(e,()=>r.createVertexArrayOES()),this.bindVertexArray=i=>nt(e,()=>r.bindVertexArrayOES(i)),this.deleteVertexArray=i=>nt(e,()=>r.deleteVertexArrayOES(i)),this.getVertexArray=()=>nt(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Ae().getNumber("WEBGL_VERSION")===1){let r="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Cy(this.gl,r),es(this.gl,i))this.textureHalfFloatExtension=Cy(this.gl,i);else if(Ae().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),es(this.gl,a))this.colorBufferHalfFloatExtension=Cy(this.gl,a);else if(Ae().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",es(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(es(this.gl,a))this.colorBufferHalfFloatExtension=this.gl.getExtension(a);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=$4(this.gl),this.indexBuffer=J4(this.gl),this.framebuffer=C4(this.gl),this.textureConfig=n_(this.gl,this.textureHalfFloatExtension)}get debug(){return Ae().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;nt(e,()=>e.finish()),nt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),nt(e,()=>e.deleteFramebuffer(this.framebuffer)),nt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),nt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),nt(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Y4(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),j4(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Q4(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),nL(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),tL(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),X4(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Z4(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(lA(this.gl,this.framebuffer),this.outputTexture=null),nt(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>iL(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,a,r,i){return sL(this.gl,e,t,n,a,r,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return rL(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let a=aL(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Ae().getBool("WEBGL_FENCE_API_ENABLED")){let a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let i=a.clientWaitSync(r,0,0);return i===a.ALREADY_SIGNALED||i===a.CONDITION_SATISFIED},t=r}else Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>oL(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=K4(t));let n=x4(t);nt(t,()=>t.attachShader(n,this.vertexShader)),nt(t,()=>t.attachShader(n,e)),v4(t,n);let a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&c1(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;nt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),eL(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(nt(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&c1(this.gl,this.program),nt(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?_4(this.gl,e,t):T4(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),nt(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),N4(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[a,r]=Kg(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&c1(this.gl,this.program),Iy(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}nt(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),nt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Cy(this.gl,Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.createQuery();return n.beginQuery(a.TIME_ELAPSED_EXT,r),r}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await O.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),a=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=lle(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Ae().platform&&(n=Ae().platform.setTimeoutCustom.bind(Ae().platform)),O.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),d1(this.gl,e,this.framebuffer),this.debug&&Iy(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(d1(this.gl,this.outputTexture,this.framebuffer),this.debug&&Iy(this.gl)):lA(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let a=this.gl;d1(a,e,this.framebuffer),this.debug&&Iy(a),this.outputTexture=e,nt(a,()=>a.viewport(0,0,t,n)),nt(a,()=>a.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),nt(this.gl,()=>this.gl.scissor(e,t,n,a))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function lle(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:ule,bincountImpl:lL,bincountReduceImpl:cle,bitwiseAndImpl:dle,castImpl:ple,ceilImpl:hle,concatImpl:fle,equalImpl:mle,expImpl:gle,expm1Impl:ble,floorImpl:yle,gatherNdImpl:wle,gatherV2Impl:xle,greaterImpl:vle,greaterEqualImpl:Sle,lessImpl:kle,lessEqualImpl:Ale,linSpaceImpl:Ele,logImpl:Cle,maxImpl:Ile,maximumImpl:_le,minimumImpl:Tle,multiplyImpl:Nle,negImpl:Rle,notEqualImpl:Fle,prodImpl:Dle,raggedGatherImpl:Ole,raggedRangeImpl:Mle,raggedTensorToTensorImpl:Ble,rangeImpl:Lle,rsqrtImpl:zle,scatterImpl:Ule,sigmoidImpl:Vle,simpleAbsImpl:uL,sliceImpl:Wle,sparseFillEmptyRowsImpl:qle,sparseReshapeImpl:Ple,sparseSegmentReductionImpl:cL,sqrtImpl:Hle,staticRegexReplaceImpl:Gle,stridedSliceImpl:Kle,stringNGramsImpl:$le,stringSplitImpl:Jle,stringToHashBucketFastImpl:Yle,subImpl:jle,tileImpl:Qle,topKImpl:Zle,transposeImpl:p_,uniqueImpl:Xle}=VI;function dL(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function qr(e,t){return t===1?[e]:dL(e,t)}function eue(e,t){if(e===1)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}var tue=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Or(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=qr("rc",this.rank),n=$n(this.rank),a=this.getOutOfBoundsCondition(t),r=this.getSetup(t),i=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${a}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r=`${n===0?"r":"rp1"}, ${a===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)r=`${e[e.length-1-i]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],a=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${a};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},pL=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Or(this.outputShape.length);let n="";for(let a=0;a<4;a++){let r="thisRC = rc;";a%2===1&&(r+="thisRC.z += 1;"),a>1&&(r+="thisRC.y += 1;"),n+=`
        ${r}
        ${a>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${a}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${a>0?"}":""}
      `}this.userCode=`
      ${nue(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?i_():r_(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function nue(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?goe(["r","c","d"],"inputShape"):qh(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var aue=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let a=TR(t,n),r=NR(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);let i=_R(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let o=this.freeTextures[r].pop();return this.usedTextures[r].push(o),o}let s;return a===wr.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===wr.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===wr.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===wr.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===wr.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(s),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),s}releaseTexture(e,t,n,a){if(this.freeTextures==null)return;let r=TR(n,a),i=NR(t,r,a);i in this.freeTextures||(this.freeTextures[i]=[]);let s=_R(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),o=Ae().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;let u=this.usedTextures[i],d=u&&u.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[d]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function rue(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function _R(e,t,n,a,r){let i=iue(t,a),s;if(r){let[u,d]=Kg(e[0],e[1]);s=u*d}else{let[u,d]=ow(e[0],e[1]);s=u*d}let o=rue(n,i);return s*o}function iue(e,t){switch(e){case wr.PACKED_2X2_FLOAT32:return c_(t);case wr.PACKED_2X2_FLOAT16:return d_(t);case wr.UNPACKED_FLOAT32:return o_(t);case wr.UNPACKED_FLOAT16:return l_(t);case wr.PACKED_4X1_UNSIGNED_BYTE:return u_(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function sue(e){return Ae().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?wr.PACKED_2X2_FLOAT32:wr.UNPACKED_FLOAT32:e?wr.PACKED_2X2_FLOAT16:wr.UNPACKED_FLOAT16}function TR(e,t){if(e===Xi.UPLOAD)return wr.PACKED_2X2_FLOAT32;if(e===Xi.RENDER||e==null)return sue(t);if(e===Xi.DOWNLOAD||e===Xi.PIXELS)return wr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function NR(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var el=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Or(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Os="if (isnan(x)) return x;",oue="return x;",RR="return abs(x);",lue="return (x >= 0.0) ? x : (exp(x) - 1.0);",uue=Os+`
  return (x < 0.0) ? 0.0 : x;
`,cue=Os+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,uc="return x;",due="return 1.0 / (1.0 + exp(-1.0 * x));",pue="return x;",hue=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,fue=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mue=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gue="return 1.0 / (1.0 + exp(-1.0 * x));",fc=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Or(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},bue=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Or(this.outputShape.length);let t=e.length,n=qr("rc",t),a=$n(t),r=eue(t,n),i=n.slice(-2),s=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${a} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${s}));
      }
    `}},yue=cl.whereImpl,wue=1e-7,xue=1e-4,lk={};function vue(e){return e in lk||(lk[e]={}),lk[e]}var Sue=Ae().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),kue=600;function Aue(){return Ae().global.screen==null?1024:Ae().global.screen.height*Ae().global.screen.width*window.devicePixelRatio*kue/1024/1024}var h_=class hL extends u0{nextDataId(){return hL.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ae().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof f1)n=t;else{let a=co(Ae().getNumber("WEBGL_VERSION"),t);n=new f1(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let a=co(Ae().getNumber("WEBGL_VERSION"));n=new f1(a),this.binaryCache=vue(Ae().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new aue(this.gpgpu),this.numMBBeforeWarning=Aue(),this.texData=new ev(this,_s())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,a,r,i,s){let o=this.makeTensorInfo(n,a),u=this.texData.get(o.dataId);u.isPacked=!1,u.texture={texture:t,texShape:[r,i]},u.texShape=[r,i];let d=_y(n),c=new IR(d,!1,s),h=this.runWebGLProgram(c,[o],a,[[r,i]]);return h.shape=n,u.texture=null,this.disposeIntermediateTensorInfo(o),h.dataId}write(t,n,a){if((Ae().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ae().getBool("DEBUG"))&&this.checkNumericalProblems(t),a==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:a,values:t,usage:Xi.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,a,r,i){if(Ae().getBool("DEBUG")&&this.checkNumericalProblems(n),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:a,dtype:r,values:n,usage:Xi.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:a,dtype:r,complexTensorInfos:i,slice:s,shape:o,isPacked:u}=n;if(s!=null){let m;u?m=new fc(o,uc):m=new el(o,uc);let g=this.runWebGLProgram(m,[{dataId:t,shape:o,dtype:r}],r),x=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),x}if(a!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return a;let d=this.activeTimers!=null,c;d&&(c=O.now());let h;if(r==="complex64"){let m=this.readSync(i.real.dataId),g=this.readSync(i.imag.dataId);h=P.mergeRealAndImagArrays(m,g)}else h=this.getValuesFromTexture(t);return d&&(this.downloadWaitMs+=O.now()-c),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){let x=this.pendingRead.get(t);return new Promise(v=>x.push(v))}let n=this.texData.get(t),{values:a,shape:r,slice:i,dtype:s,complexTensorInfos:o,isPacked:u}=n;if(i!=null){let x;u?x=new fc(r,uc):x=new el(r,uc);let v=this.runWebGLProgram(x,[{dataId:t,shape:r,dtype:s}],s),S=this.read(v.dataId);return this.disposeIntermediateTensorInfo(v),S}if(a!=null)return this.convertAndCacheOnCPU(t);if(Ae().getBool("DEBUG")&&!Ae().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Ae().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let d=null,c;if(s!=="complex64"&&Ae().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let x=this.texData.get(c.dataId);d=this.gpgpu.createBufferFromTexture(x.texture.texture,...e1(r))}this.pendingRead.set(t,[]),s!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(s==="complex64"){let x=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),v=x[0],S=x[1];h=P.mergeRealAndImagArrays(v,S)}else if(d==null)h=this.getValuesFromTexture(t);else{let x=O.sizeFromShape(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(d,x)}if(c!=null&&this.disposeIntermediateTensorInfo(c),d!=null){let x=this.gpgpu.gl;nt(x,()=>x.deleteBuffer(d))}let m=this.convertAndCacheOnCPU(t,h),g=this.pendingRead.get(t);return this.pendingRead.delete(t),g.forEach(x=>x(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&_s().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,n={}){let a=this.texData.get(t),{values:r,shape:i,slice:s,dtype:o,isPacked:u,texture:d}=a;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(s!=null){let g;u?g=new fc(i,uc):g=new el(i,uc);let x=this.runWebGLProgram(g,[{dataId:t,shape:i,dtype:o}],o),v=this.readToGPU(x,n);return this.disposeIntermediateTensorInfo(x),v}if(d==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,n.customTexShape),h=_s().makeTensorFromTensorInfo(c),m=this.texData.get(c.dataId);return Object.assign({tensorRef:h},m.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let a=n.map(r=>O.decodeString(r));return Zt(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Zt(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let a=t[n];if(!g4(a))throw Ae().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${a} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:a,isPacked:r}=this.texData.get(t),i=O.sizeFromShape(n);if(Ae().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(t),g=this.texData.get(m.dataId),x=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...e1(n)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),x}let s=Ae().getBool("WEBGL_PACK")&&r===!0,o=s?_y(n):n,u=s?new ile(o):new rle(o),d=this.runWebGLProgram(u,[{shape:o,dtype:a,dataId:t}],"float32"),c=this.texData.get(d.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(d),h}timerAvailable(){return Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,a=[],r=!1;this.programTimersStack==null?(this.programTimersStack=a,r=!0):this.activeTimers.push(a),this.activeTimers=a,t();let i=O.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),s=O.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=n,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(i);o.kernelMs=O.sum(u),o.getExtraProfileInfo=()=>u.map((d,c)=>({name:s[c],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:O.now(),endMs:null}}endTimer(t){return Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=O.now(),t)}async getQueryTime(t){if(Ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:a}=this.texData.get(t);return a!=null&&(this.disposeData(a.real.dataId,n),this.disposeData(a.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:a,texShape:r,usage:i,isPacked:s,slice:o}=this.texData.get(t),u=o&&o.origDataId||t,d=this.dataRefCount.get(u);d>1?this.dataRefCount.set(u,d-1):(this.dataRefCount.delete(u),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,a),this.textureManager.releaseTexture(n,r,i,s)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=Sue){return Ae().getBool("WEBGL_CPU_FORWARD")&&t.every(a=>this.texData.get(a.dataId).texture==null&&O.sizeFromShape(a.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){P.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return yue(t.shape,n)}packedUnaryOp(t,n,a){let r=new fc(t.shape,n),i=this.compileAndRun(r,[t],a);return _s().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let r=uL(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(Ae().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,RR,t.dtype);let n=new el(t.shape,RR),a=this.compileAndRun(n,[t]);return _s().makeTensorFromTensorInfo(a)}makeTensorInfo(t,n,a){let r;if(n==="string"&&a!=null&&a.length>0&&O.isString(a[0])){let i=a.map(s=>O.encodeString(s));r=this.write(i,t,n)}else r=this.write(a,t,n);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:n}}makeOutput(t,n,a){return _s().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,a),this)}unpackTensor(t){let n=new bue(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new tue(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let a=[dp(t.shape),...pp(t.shape)],r={dtype:t.dtype,shape:a,dataId:t.dataId},i=[dp(n),...pp(n)],s=new pL(i,a),o=!0,u=[a],d=this.runWebGLProgram(s,[r],t.dtype,u,o);return{dataId:d.dataId,shape:n,dtype:d.dtype}}decode(t,n){let a=this.texData.get(t),{isPacked:r,shape:i,dtype:s}=a;if(n!=null){let m=O.sizeFromShape(i),g=n[0]*n[1]*4;O.assert(m<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=_y(i),u;r?u=new ale(o):u=new nle(o);let d=!0,c=[n??e1(o)],h=this.runWebGLProgram(u,[{shape:o,dtype:s,dataId:t}],s,c,d,n);return{dtype:s,shape:i,dataId:h.dataId}}runWebGLProgram(t,n,a,r,i=!1,s){let o=this.makeTensorInfo(t.outputShape,a),u=this.texData.get(o.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===a0.DENSE){let E=s??e1(t.outputShape);u.texShape=E.map(C=>C*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),O.sizeFromShape(o.shape)===0)return u.values=O.getTypedArrayFromDType(o.dtype,0),o;let d=[],c=n.map(E=>{if(E.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let C=this.texData.get(E.dataId);if(C.texture==null){if(!t.packedInputs&&O.sizeFromShape(E.shape)<=Ae().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:E.shape,texData:null,isUniform:!0,uniformValues:C.values};t.packedInputs&&(C.isPacked=!0,C.shape=E.shape)}if(this.uploadToGPU(E.dataId),!!C.isPacked!=!!t.packedInputs)E=C.isPacked?this.unpackTensor(E):this.packTensor(E),d.push(E),C=this.texData.get(E.dataId);else if(C.isPacked&&!r0(C.shape,E.shape)){let T=E,N=E.shape;E.shape=C.shape,E=this.packedReshape(E,N),d.push(E),C=this.texData.get(E.dataId),T.shape=N}return{shape:E.shape,texData:C,isUniform:!1}});this.uploadToGPU(o.dataId);let h={shape:o.shape,texData:u,isUniform:!1},m=tle(t,c,h),g=this.getAndSaveBinary(m,()=>Xoe(this.gpgpu,t,c,h)),x=this.activeTimers!=null,v;x&&(v=this.startTimer()),Ae().get("ENGINE_COMPILE_ONLY")||ele(this.gpgpu,g,c,h,r),d.forEach(E=>this.disposeIntermediateTensorInfo(E)),x&&(v=this.endTimer(v),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(v)}));let S=Ae().getNumber("WEBGL_FLUSH_THRESHOLD");if(S>0){let E=O.now();E-this.lastGlFlushTime>S&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=E)}if(!Ae().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&i===!1){let E=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),E}return o}compileAndRun(t,n,a,r,i=!1){return a=a||n[0].dtype,this.runWebGLProgram(t,n,a,r,i)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ae().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=be(()=>{if(!Ae().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=Ae().getBool("DEBUG");Ae().set("DEBUG",!1);let n=this.abs(gt(1e-8)).dataSync()[0];if(Ae().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?wue:xue}uploadToGPU(t){let n=this.texData.get(t),{shape:a,dtype:r,values:i,texture:s,usage:o,isPacked:u}=n;if(s!=null)return;let d=this.activeTimers!=null,c;d&&(c=O.now());let h=n.texShape;if(h==null&&(h=D4(a,u),n.texShape=h),i!=null){let m=_y(a),g,x=h[1],v=h[0],S=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!S)&&([x,v]=Kg(h[0],h[1])),u?g=new ole(m,S):g=new IR(m,S);let E=S?[v,x]:h,C=this.makeTensorInfo(E,r),T=this.texData.get(C.dataId);S?T.usage=Xi.PIXELS:T.usage=Xi.UPLOAD,T.texShape=E,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(C.dataId),x,v,i);let N=[[v,x]],D=this.runWebGLProgram(g,[C],r,N,!0),q=this.texData.get(D.dataId);n.texShape=q.texShape,n.isPacked=q.isPacked,n.usage=q.usage,Ae().get("ENGINE_COMPILE_ONLY")?this.disposeData(D.dataId):(n.texture=q.texture,n.values=null,this.texData.delete(D.dataId)),this.disposeIntermediateTensorInfo(C),d&&(this.uploadWaitMs+=O.now()-c)}else{let m=this.acquireTexture(h,o,r,u);n.texture=m}}convertAndCacheOnCPU(t,n){let a=this.texData.get(t),{dtype:r}=a;return n!=null&&(a.values=Eue(n,r)),a.values}acquireTexture(t,n,a,r){if(this.numBytesInGPU+=this.computeBytes(t,a),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,r)}computeBytes(t,n){return t[0]*t[1]*O.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let a=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(i){throw i}});t.push(a)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await nC(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(a_(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:a,infLoc:r,nanLoc:i,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:u}=H4(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=a,t.infLoc=r,t.nanLoc=i,t.outShapeLocation=s,t.outShapeStridesLocation=o,t.outTexShapeLocation=u}}createTensorFromGPUData(t,n,a){t.channels=t.channels||"RGBA";let{texture:r,height:i,width:s,channels:o}=t,u=_s().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let d=u.writeTexture(r,n,a,i,s,o);return _s().makeTensorFromDataId(d,n,a,u)}};h_.nextDataId=0;function Eue(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let a=0;a<n.length;++a)n[a]=Math.round(e[a]);return n}else throw new Error(`Unknown dtype ${t}`)}var Cue="4.22.0";function fL(){Ae().set("WEBGL_FORCE_F16_TEXTURES",!0)}M0.isBrowser()&&yv("webgl",()=>new h_,2);var Iue={forceHalfFloat:fL},f_=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,hp=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=P.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Or(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},Hh=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,Zg=class{constructor(e,t,n,a=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=P.assertAndGetBroadcastShape(t,n);let r=this.outputShape.length;this.enableShapeUniforms=Or(r);let i="";if(a)if(r===0||O.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${$n(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let s=qr("coords",r);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${s[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${s[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${s[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${s[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function Mi(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var _ue={kernelName:Kp,backendName:"webgl",kernelFunc:Mi};function Gc(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,i=n.makeTensorInfo(a.shape,"complex64"),s=n.texData.get(i.dataId),o=Mi({inputs:{x:a},backend:n}),u=Mi({inputs:{x:r},backend:n});return s.complexTensorInfos={real:o,imag:u},i}var Tue={kernelName:av,backendName:"webgl",kernelFunc:Gc},mL="return (a < 0.) ? b * a : a;",gL=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Nue(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:i}=a,s=n.makeTensorInfo([],"float32",O.createScalarValue(i,"float32")),o=Ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zg(gL,r.shape,s.shape):new hp(mL,r.shape,s.shape),u=n.runWebGLProgram(o,[r,s],"float32");return n.disposeIntermediateTensorInfo(s),u}var Rue={kernelName:jp,backendName:"webgl",kernelFunc:Nue},bL="return (a < 0.) ? b * a : a;",yL=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Fue(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,i=Ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zg(yL,a.shape,r.shape):new hp(bL,a.shape,r.shape);return n.runWebGLProgram(i,[a,r],"float32")}var Due={kernelName:ph,backendName:"webgl",kernelFunc:Fue},Xg="if (isnan(x)) return x;";function yn({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:a}){return({inputs:r,backend:i})=>{let{x:s}=r,o=i,u=a||s.dtype;if(o.shouldExecuteOnCPU([s])&&n!=null){let h=o.texData.get(s.dataId),m=n(h.values,u);return o.makeTensorInfo(s.shape,u,m)}let d=Ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return d?c=new fc(s.shape,t):c=new el(s.shape,e),o.runWebGLProgram(c,[s],u)}}function vr({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:a=!1,cpuKernelImpl:r,dtype:i}){return({inputs:s,backend:o})=>{let{a:u,b:d}=s,c=o;if(a&&u.dtype==="complex64"){let x=c.texData.get(u.dataId),v=c.texData.get(d.dataId),[S,E]=[[x.complexTensorInfos.real,v.complexTensorInfos.real],[x.complexTensorInfos.imag,v.complexTensorInfos.imag]].map(T=>{let[N,D]=T,q={dataId:N.dataId,dtype:N.dtype,shape:u.shape},H={dataId:D.dataId,dtype:D.dtype,shape:d.shape},K=new hp(e,u.shape,d.shape);return c.runWebGLProgram(K,[q,H],as(N.dtype,D.dtype))}),C=Gc({inputs:{real:S,imag:E},backend:c});return c.disposeIntermediateTensorInfo(S),c.disposeIntermediateTensorInfo(E),C}let h=i||as(u.dtype,d.dtype);if((u.dtype==="string"||d.dtype==="string"||c.shouldExecuteOnCPU([u,d]))&&r!=null){let x=c.texData.get(u.dataId).values,v=c.texData.get(d.dataId).values,S=u.dtype==="string"?P.fromUint8ToStringArray(x):x,E=u.dtype==="string"?P.fromUint8ToStringArray(v):v,[C,T]=r(u.shape,d.shape,S,E,h),N=c.makeTensorInfo(T,h),D=c.texData.get(N.dataId);return D.values=C,N}let m=Ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,g;return m?g=new Zg(t,u.shape,d.shape,n):g=new hp(e,u.shape,d.shape),c.runWebGLProgram(g,[u,d],h)}}function i0(e,t=!1){if(e==="linear")return t?pue:oue;if(e==="relu")return t?fue:uue;if(e==="elu")return t?hue:lue;if(e==="relu6")return t?mue:cue;if(e==="prelu")return t?yL:bL;if(e==="leakyrelu")return t?gL:mL;if(e==="sigmoid")return t?gue:due;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var wL=class{constructor(e,t,n,a=!1,r=!1,i=!1,s=null,o=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Or(this.outputShape.length);let d=a?e[1]:e[2],c=Math.ceil(d/2),h=a?"i * 2, rc.y":"rc.y, i * 2",m=r?"rc.z, i * 2":"i * 2, rc.z",g=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],v="",S="";s&&(o?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:u?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:v=`vec4 activation(vec4 x) {
          ${s}
        }`,S="result = activation(result);");let E=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let C="rc.x",T="rc.x";e[0]<t[0]?C=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(T=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${v}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${C};
        int batchB = ${T};
        for (int i = 0; i < ${c}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${m});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${g[0]} * ${x[0]});
          result += (${g[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${E}

        ${S}

        setOutput(result);
      }
    `}},FR={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},DR=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=P.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},OR="return a * b;";function m_(e){let{inputs:t,backend:n}=e,{a,b:r}=t,i=P.upcastType(a.dtype,r.dtype);if(a.dtype==="complex64"){let o=n.texData.get(a.dataId),u=n.texData.get(r.dataId),d=new DR(FR.REAL,a.shape,r.shape),c=new DR(FR.IMAG,a.shape,r.shape),h=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:a.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],m=n.runWebGLProgram(d,h,"float32"),g=n.runWebGLProgram(c,h,"float32"),x=Gc({inputs:{real:m,imag:g},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),x}if(n.shouldExecuteOnCPU([a,r])){let o=n.texData.get(a.dataId),u=n.texData.get(r.dataId),[d,c]=Nle(a.shape,r.shape,o.values,u.values,i),h=n.makeTensorInfo(c,i),m=n.texData.get(h.dataId);return m.values=d,h}let s;return Ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?s=new Zg(OR,a.shape,r.shape):s=new hp(OR,a.shape,r.shape),n.runWebGLProgram(s,[a,r],i)}var Oue={kernelName:lh,backendName:"webgl",kernelFunc:m_};function Mue(e,t,n){let a=[dp(e.shape),...pp(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},i=[dp(t),...pp(t)],s=new pL(i,a),o=!0,u=[a],d=n.runWebGLProgram(s,[r],e.dtype,u,o);return{dataId:d.dataId,shape:t,dtype:d.dtype}}function Xe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:i}=a,s=n,o=O.sizeFromShape(r.shape),u=O.inferFromImplicitShape(i,o),d=O.sizeFromShape(u);O.assert(o===d,()=>`The new shape (${u}) has ${d} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let c=s.texData.get(r.dataId);return c.isPacked&&!r0(r.shape,u)&&!(c.texture!==null&&r0(c.shape,u))?Mue(r,u,s):(s.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}var Bue={kernelName:bg,backendName:"webgl",kernelFunc:Xe},MR=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:a,inSize:r,outSize:i}=e;this.outputShape=[a,i];let s=Math.floor(n/4)*4,o=n%4,u="sumValue += dot(values, ones);";if(t!=null){let c=1/t;u=`sumValue += dot(values * ${O.isInt(c)?c.toPrecision(2):c}, ones);`}let d="";r%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${s}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${s};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}},Lue=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:a,inSize:r,outSize:i}=e;this.outputShape=[a,i];let s="0.0",o="";t==="prod"?s="1.0":t==="min"?(s="1.0 / 1e-20",o="min"):t==="max"&&(s="-1.0 / 1e-20",o="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");let d=Math.floor(n/4)*4,c=n%4,h=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,m="vec4";t==="all"?(s="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,m="bvec4"):t==="any"&&(s="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,m="bvec4");let g="";r%n>0&&(g=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${s};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${s});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${d};
        if (${c===1}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${c===2}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${c===3}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${u});
      }
    `}};function zue(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],a=P.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}function Gh(e,t,n,a){let r=zue(e.shape),i=e;for(let s=0;s<r.length;s++){let{inSize:o,windowSize:u,outSize:d}=r[s],c,h;n==="mean"?c=s===0?new MR({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:d},o):new MR({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:d}):c=new Lue({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:d},n),h=i,i=a.runWebGLProgram(c,[i],t),h.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(h)}return i}var Uue=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.rank=n.length;let a=$n(this.rank),r=Vue(t);this.userCode=`
    void main() {
      ${a} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}};function Vue(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}var Wue=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let d=0;d<n.length;d++)n[d]=e[t[d]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let a=$n(this.rank),r=dL("rc",this.rank),i=new Array(this.rank);for(let d=0;d<t.length;d++)i[t[d]]=r[d];let s=`vec2(${i.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${s})`;this.userCode=`
    void main() {
      ${a} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${o}) {
        result[1] = ${u};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${u};
        if(${o}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function kS(e,t,n){let a=Ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Wue(e.shape,t):new Uue(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function que(e,t,n,a){let r=t,i=e.shape.length,s=O.parseAxisParam(r,e.shape),o=s,u=P.getAxesPermutation(o,i),d=u!=null,c=e;d&&(c=kS(e,u,a),o=P.getInnerMostAxes(o.length,i)),P.assertAxesAreInnerMostDims("sum",o,i);let[h,m]=P.computeOutAndReduceShapes(c.shape,o),g=h;n&&(g=P.expandShapeToKeepDim(h,s));let x=O.sizeFromShape(m),v=O.sizeFromShape(e.shape)/x,S=Xe({inputs:{x:c},attrs:{shape:[v,x]},backend:a}),E=bv(e.dtype),C=Gh(S,E,"sum",a),T=Xe({inputs:{x:C},attrs:{shape:g},backend:a});return a.disposeIntermediateTensorInfo(S),a.disposeIntermediateTensorInfo(C),d&&a.disposeIntermediateTensorInfo(c),T}function AS(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:s}=a;return que(r,i,s,n)}var Pue={kernelName:Th,backendName:"webgl",kernelFunc:AS};function Gr(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:i}=a,s=n,o=r.shape.length,u=new Array(o);for(let c=0;c<u.length;c++)u[c]=r.shape[i[c]];let d;if(s.shouldExecuteOnCPU([r])){let c=s.texData.get(r.dataId).values,h=p_(c,r.shape,r.dtype,i,u);d=s.makeTensorInfo(u,r.dtype);let m=s.texData.get(d.dataId);m.values=h}else d=kS(r,i,s);return d}var Hue={kernelName:Xl,backendName:"webgl",kernelFunc:Gr},xL=1e3;function H1({a:e,b:t,transposeA:n,transposeB:a,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:u=null}){let d=e.shape.length,c=t.shape.length,h=n?e.shape[d-2]:e.shape[d-1],m=a?t.shape[c-1]:t.shape[c-2],g=n?e.shape[d-1]:e.shape[d-2],x=a?t.shape[c-2]:t.shape[c-1],v=e.shape.slice(0,-2),S=t.shape.slice(0,-2),E=O.sizeFromShape(v),C=O.sizeFromShape(S),T=Mg.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([g,x]);O.assert(h===m,()=>`Error in matMul: inner shapes (${h}) and (${m}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`);let N=n?[E,h,g]:[E,g,h],D=a?[C,x,m]:[C,m,x],q=Xe({inputs:{x:e},backend:r,attrs:{shape:N}}),H=Xe({inputs:{x:t},backend:r,attrs:{shape:D}}),K=[q,H],j=Math.max(E,C),te=n?q.shape[1]:q.shape[2],Q=i!=null,z=s!=null,ae=u==="leakyrelu",ue=u!=null?i0(u,!0):null,he=Q||z||ae||ue!=null,Z;if((g===1||x===1)&&te>xL&&he===!1){let de=q,Ce=H;n&&(de=Gr({inputs:{x:q},backend:r,attrs:{perm:[0,2,1]}}),K.push(de)),a&&(Ce=Gr({inputs:{x:H},backend:r,attrs:{perm:[0,2,1]}}),K.push(Ce));let Y=x!==1,ie=x===1,xe=de;Y&&(xe=Xe({inputs:{x:de},backend:r,attrs:{shape:[j,te,1]}}),K.push(xe));let me=x===1?2:1,_e=Ce;ie&&(_e=Xe({inputs:{x:Ce},backend:r,attrs:{shape:[j,1,te]}}),K.push(_e));let Le=m_({inputs:{a:xe,b:_e},backend:r});Z=AS({inputs:{x:Le},backend:r,attrs:{axis:me,keepDims:!0}}),K.push(Le)}else{let de=as(e.dtype,t.dtype),Ce=new wL(N,D,[j,g,x],n,a,Q,ue,z,ae),Y=[q,H];if(i!=null&&Y.push(i),z&&Y.push(s),ae){let ie=r.makeTensorInfo([],"float32",O.createScalarValue(o,"float32"));Y.push(ie),K.push(ie)}Z=r.runWebGLProgram(Ce,Y,de)}let se=Xe({inputs:{x:Z},backend:r,attrs:{shape:T}});K.push(Z);for(let de of K)r.disposeIntermediateTensorInfo(de);return se}function Gue(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:i,bias:s,preluActivationWeights:o}=t,{transposeA:u,transposeB:d,activation:c,leakyreluAlpha:h}=a;return H1({a:r,b:i,transposeA:u,transposeB:d,backend:n,bias:s,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}var Kue={kernelName:jd,backendName:"webgl",kernelFunc:Gue},BR="return abs(x);";function $ue(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&a.dtype!=="complex64"){let i=n.texData.get(a.dataId),s=uL(i.values);return n.makeTensorInfo(a.shape,a.dtype,s)}let r;return Ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new fc(a.shape,BR):r=new el(a.shape,BR),n.runWebGLProgram(r,[a],a.dtype)}var Jue={kernelName:Dm,backendName:"webgl",kernelFunc:$ue},Yue=Os+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,jue=yn({opSnippet:Yue}),Que={kernelName:bp,backendName:"webgl",kernelFunc:jue},Zue=Os+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Xue=yn({opSnippet:Zue}),ece={kernelName:yp,backendName:"webgl",kernelFunc:Xue},LR="return a + b;",tce=vr({opSnippet:LR,packedOpSnippet:LR,supportsComplex:!0,cpuKernelImpl:ule}),nce={kernelName:Mc,backendName:"webgl",kernelFunc:tce},ace=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,i)=>`T${i}`);let n=[];this.variableNames.forEach(r=>{n.push(`float v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${a};
        setOutput(result);
      }
    `}},rce=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,i)=>`T${i}`);let n=[];this.variableNames.forEach(r=>{n.push(`vec4 v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${a};
        setOutput(result);
      }
    `}};function m1(e){let{inputs:t,backend:n}=e,a=t;if(a.length===1)return Mi({inputs:{x:a[0]},backend:n});if(a.length>Ae().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(a.length/2),u=m1({inputs:a.slice(0,o),backend:n}),d=m1({inputs:a.slice(o),backend:n});return m1({inputs:[u,d],backend:n})}let r=a.map(o=>o.dtype).reduce((o,u)=>as(o,u)),i=a.map(o=>o.shape),s=Ae().getBool("WEBGL_PACK")?new rce(a[0].shape,i):new ace(a[0].shape,i);return n.runWebGLProgram(s,a,r)}var ice={kernelName:wp,backendName:"webgl",kernelFunc:m1};function sce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:s}=a,o=r.shape.length,u=O.parseAxisParam(i,r.shape),d=u,c=P.getAxesPermutation(d,o),h=r;c!=null&&(h=Gr({inputs:{x:r},backend:n,attrs:{perm:c}}),d=P.getInnerMostAxes(d.length,o)),P.assertAxesAreInnerMostDims("all",d,o);let[m,g]=P.computeOutAndReduceShapes(h.shape,d),x=O.sizeFromShape(g),v=Xe({inputs:{x:h},backend:n,attrs:{shape:[-1,x]}}),S=Gh(v,v.dtype,"all",n),E;if(s){let C=P.expandShapeToKeepDim(m,u);E=Xe({inputs:{x:S},backend:n,attrs:{shape:C}})}else E=Xe({inputs:{x:S},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(S),c!=null&&n.disposeIntermediateTensorInfo(h),E}var oce={kernelName:Om,backendName:"webgl",kernelFunc:sce};function lce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:s}=a,o=r.shape.length,u=O.parseAxisParam(i,r.shape),d=u,c=P.getAxesPermutation(d,o),h=r;c!=null&&(h=Gr({inputs:{x:r},backend:n,attrs:{perm:c}}),d=P.getInnerMostAxes(d.length,o)),P.assertAxesAreInnerMostDims("any",d,o);let[m,g]=P.computeOutAndReduceShapes(h.shape,d),x=O.sizeFromShape(g),v=Xe({inputs:{x:h},backend:n,attrs:{shape:[-1,x]}}),S=Gh(v,v.dtype,"any",n),E;if(s){let C=P.expandShapeToKeepDim(m,u);E=Xe({inputs:{x:S},backend:n,attrs:{shape:C}})}else E=Xe({inputs:{x:S},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(S),c!=null&&n.disposeIntermediateTensorInfo(h),E}var uce={kernelName:Mm,backendName:"webgl",kernelFunc:lce},cce=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:a,batchSize:r,outSize:i}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,i];let s=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${a}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${s} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},dce=class{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,O.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let r=e[e.length-1],i=Math.ceil(r/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),a||this.variableNames.push("bestIndicesA");let s=this.outputShape,o=s.length,u=$n(o),d=qr("coords",o),c,h;if(i===1){h=o+1;let H=$n(h);c=`
        ${H} sourceLocR = ${H}(${d.join()}, 0);
        ++${d[o-1]};
        ${H} sourceLocG = ${H}(${d.join()}, 0);
        ++${d[o-2]};
        ${H} sourceLocA = ${H}(${d.join()}, 0);
        --${d[o-1]};
        ${H} sourceLocB = ${H}(${d.join()}, 0);
        --${d[o-2]};`}else h=o,c=`
        ${u} sourceLocR = coords;
        ++${d[o-1]};
        ${u} sourceLocG = coords;
        ++${d[o-2]};
        ${u} sourceLocA = coords;
        --${d[o-1]};
        ${u} sourceLocB = coords;
        --${d[o-2]};`;let m=["x","y","z","w","u","v"].slice(0,h),g="."+m[h-1],x=m.map(H=>"int "+H),v=qr("sourceLocR",h-1).concat("inIdx.r"),S=qr("sourceLocG",h-1).concat("inIdx.g"),E=qr("sourceLocB",h-1).concat("inIdx.b"),C=qr("sourceLocA",h-1).concat("inIdx.a"),T=n==="max"?"greaterThan":"lessThan",N=a?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${E.join()}),
                             getBestIndicesAChannel(${C.join()})));`,D=`vec4(
            getAChannel(${v.join()}),
            hasNextCol ? getAChannel(${S.join()}) : 0.,
            hasNextRow ? getAChannel(${E.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,q=a?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${m.join()}),
                                          vec2(${m.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${m.join()}),
                               vec2(${m.slice(-2).join()}));
      }
      ${q}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${d[o-1]} < ${s[o-1]-1};
        bool hasNextRow = ${d[o-2]} < ${s[o-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},
          sourceLocB${g}, sourceLocA${g}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${D};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${N}
          vec4 candidate = ${D};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${T}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function vL(e,t,n,a=null){let r=t.shape[0],i=t.shape[1];a!=null&&(r=a.shape[0],i=a.shape[1]);let s=P.computeOptimalWindowSize(i),o={windowSize:s,inSize:i,batchSize:r,outSize:Math.ceil(i/s)},u=new cce(o,n,a==null),d=[t];a!=null&&d.push(a);let c=e.runWebGLProgram(u,d,"int32");if(c.shape[1]===1)return c;let h=vL(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function SL(e,t,n,a=null){let r=a!=null?a.shape:t.shape,i=r[r.length-1],s=P.computeOptimalWindowSize(i),o=new dce(r,s,n,a==null),u=a==null?[t]:[t,a],d=e.runWebGLProgram(o,u,"int32");if(d.shape.length===t.shape.length){let c=SL(e,t,n,d);return e.disposeIntermediateTensorInfo(d),c}return d}function kL(e,t,n,a){let r=[n];if(P.assertAxesAreInnerMostDims("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!Ae().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let i=[],s=e.texData.get(t.dataId),o=s!==null&&s.isPacked,u=t;o&&(u=e.unpackTensor(t),i.push(u));let[d,c]=P.computeOutAndReduceShapes(u.shape,r),h=O.sizeFromShape(c),m=Xe({inputs:{x:u},backend:e,attrs:{shape:[-1,h]}});i.push(m);let g=vL(e,m,a);i.push(g);let x=Xe({inputs:{x:g},backend:e,attrs:{shape:d}});return i.forEach(v=>e.disposeIntermediateTensorInfo(v)),x}return SL(e,t,a)}function pce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i}=a,s=O.parseAxisParam(i,r.shape),o=P.getAxesPermutation(s,r.shape.length),u=r,d=[];o!=null&&(u=Gr({inputs:{x:r},backend:n,attrs:{perm:o}}),d.push(u),s=P.getInnerMostAxes(s.length,u.shape.length)),P.assertAxesAreInnerMostDims("argMax",[s[0]],u.shape.length);let c=kL(n,u,s[0],"max");return d.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}var hce={kernelName:Bm,backendName:"webgl",kernelFunc:pce};function fce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i}=a,s=O.parseAxisParam(i,r.shape),o=P.getAxesPermutation(s,r.shape.length),u=r,d=[];o!=null&&(u=Gr({inputs:{x:r},backend:n,attrs:{perm:o}}),d.push(u),s=P.getInnerMostAxes(s.length,u.shape.length)),P.assertAxesAreInnerMostDims("argMin",[s[0]],u.shape.length);let c=kL(n,u,s[0],"min");return d.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}var mce={kernelName:Lm,backendName:"webgl",kernelFunc:fce},gce=Os+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,bce=yn({opSnippet:gce}),yce={kernelName:xp,backendName:"webgl",kernelFunc:bce},wce=Os+"return log(x + sqrt(x * x + 1.0));",xce=yn({opSnippet:wce}),vce={kernelName:vp,backendName:"webgl",kernelFunc:xce},Sce=Os+`
  return atan(x);
`,kce=yn({opSnippet:Sce}),Ace={kernelName:Sp,backendName:"webgl",kernelFunc:kce},Ece=f_+`
  return atan(a, b);
`,Cce=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Hh+`
  return result;
`,Ice=vr({opSnippet:Ece,packedOpSnippet:Cce}),_ce={kernelName:Ap,backendName:"webgl",kernelFunc:Ice},Tce=Os+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Nce=yn({opSnippet:Tce}),Rce={kernelName:kp,backendName:"webgl",kernelFunc:Nce},s0=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,s=e.strideHeight,o=e.strideWidth,u=e.dilationHeight,d=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,m=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;let x=t==="avg",v=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,S=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,E="0.0";if(x||(E="-1.0 / 1e-20"),n){let H=">=";this.userCode=`
        const ivec2 strides = ivec2(${s}, ${o});
        const ivec2 pads = ivec2(${m}, ${g});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${H} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${a?r?v:S:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let C="max",T=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(T="avgValue / max(count, 1.0)");let N=Math.floor(i/4)*4,D=i%4,q=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${o});
      const ivec2 pads = ivec2(${m}, ${g});
      const float initializationValue = ${E};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${E});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${N}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${q}
          }

          int xC = xCCorner + ${N};
          if (${D===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${q}
          } else if (${D===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${q}
          } else if (${D===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${q}
          }
        }
        setOutput(${T});
      }
    `}},g_=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,s=e.strideDepth,o=e.strideHeight,u=e.strideWidth,d=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,m=e.effectiveFilterDepth,g=e.effectiveFilterHeight,x=e.effectiveFilterWidth,v=e.padInfo.front,S=e.padInfo.top,E=e.padInfo.left;this.outputShape=e.outShape;let C=t==="avg",T="0.0";if(C||(T="-1.0 / 1e-20"),n){let j=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${s}, ${o}, ${u});
        const ivec3 pads = ivec3(${v}, ${S}, ${E});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${m};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${g};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${j} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${a?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${g} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let N="max",D=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(D="avgValue / max(count, 1.0)");let q=Math.floor(i/4)*4,H=i%4,K=`
      if (${C}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${s}, ${o}, ${u});
      const ivec3 pads = ivec3(${v}, ${S}, ${E});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${g};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${q}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${K}
            }

            int xC = xCCorner + ${q};
            if (${H===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${K}
            } else if (${H===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${K}
            } else if (${H===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${K}
            }
          }
        }
        setOutput(${D});
      }
    `}};function Fce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;$g(r,"avgPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:u}=a,d=1;O.assert(P.eitherStridesOrDilationsAreOne(s,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`);let c=P.computePool2DInfo(r.shape,i,s,d,o,u);if(c.filterWidth===1&&c.filterHeight===1&&O.arraysEqual(c.inShape,c.outShape))return Mi({inputs:{x:r},backend:n});let h=new s0(c,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}var Dce={kernelName:Ep,backendName:"webgl",kernelFunc:Fce};function Oce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:u,dataFormat:d}=a,c=[1,1,1],h=P.computePool3DInfo(r.shape,i,s,c,o,u,d),m=new g_(h,"avg",!1);return n.runWebGLProgram(m,[r],"float32")}var Mce={kernelName:zm,backendName:"webgl",kernelFunc:Oce},Bce=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,i=e.dilationHeight,s=e.dilationWidth,o=e.effectiveFilterHeight,u=e.effectiveFilterWidth,d=o-1-e.padInfo.top,c=u-1-e.padInfo.left,h=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${c});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${s}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Lce=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,i=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=c-1-e.padInfo.front,x=h-1-e.padInfo.top,v=m-1-e.padInfo.left,S=1/(t*n*a);this.userCode=`
      const ivec3 pads = ivec3(${g}, ${x}, ${v});
      const float avgMultiplier = float(${S});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function zce(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,s=i,{filterSize:o,strides:u,pad:d,dimRoundingMode:c}=a,h=[1,1,1],m=P.computePool3DInfo(s.shape,o,u,h,d,c),g=new Lce(m);return n.runWebGLProgram(g,[r],s.dtype)}var Uce={kernelName:p0,backendName:"webgl",kernelFunc:zce};function Vce(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,s=i;$g([r,i],"avgPoolGrad");let{filterSize:o,strides:u,pad:d}=a,c=P.computePool2DInfo(s.shape,o,u,1,d),h=new Bce(c);return n.runWebGLProgram(h,[r],s.dtype)}var Wce={kernelName:d0,backendName:"webgl",kernelFunc:Vce};function qce(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:i}=t,{transposeA:s,transposeB:o}=a;return H1({a:r,b:i,transposeA:s,transposeB:o,backend:n})}var Pce={kernelName:Cp,backendName:"webgl",kernelFunc:qce},Hce=class{constructor(e,t,n,a,r,i){this.outputShape=[],this.variableNames=["x","mean","variance"],P.assertAndGetBroadcastShape(e,t),P.assertAndGetBroadcastShape(e,n);let s="0.0";a!=null&&(P.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let o="1.0";r!=null&&(P.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${s};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},Gce=class{constructor(e,t,n,a,r,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],P.assertAndGetBroadcastShape(e,t),P.assertAndGetBroadcastShape(e,n);let s="vec4(0.0)";a!=null&&(P.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let o="vec4(1.0)";r!=null&&(P.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${s};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}},Kce=({inputs:e,backend:t,attrs:n})=>{let{x:a,mean:r,variance:i,offset:s,scale:o}=e;O.assert(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O.assert(s==null||r.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O.assert(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;u==null&&(u=.001);let d=[a,r,i],c=null;s!=null&&(c=s.shape,d.push(s));let h=null;o!=null&&(h=o.shape,d.push(o));let m=Ae().getBool("WEBGL_PACK_NORMALIZATION")?new Gce(a.shape,r.shape,i.shape,c,h,u):new Hce(a.shape,r.shape,i.shape,c,h,u);return t.runWebGLProgram(m,d,d[0].dtype)},$ce={kernelName:Hp,backendName:"webgl",kernelFunc:Kce},Jce=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=$n(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=Yce(this.rank),a,r=e.map((i,s)=>`sourceLoc.${dA[s]} = start[${s}] + coords.${dA[s]};`);a=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${a}
        setOutput(getSource(${n}));
      }
    `}},dA=["x","y","z","w","u","v"];function Yce(e){if(e===1)return"sourceLoc";if(e<=6)return dA.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var jce=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=$n(this.rank),n=qr("coords",this.rank),a=qr("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${a.slice(-2).join()})`,i=`getChannel(getSource(${a.join()}), ${r})`,s=`
      result.x = ${i};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${a[this.rank-1]};
        result.y = ${i};
        --${a[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${a[this.rank-2]};
        result.z = ${i};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${a[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,c)=>`start[${c}]`).join()});`:e.map((d,c)=>`${a[c]} = ${n[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${s}
        ${o}
        setOutput(result);
      }
    `}};function Qce(e,t,n,a){let r=a.texData.get(e.dataId),i=a.makeTensorInfo(n,e.dtype),s=a.texData.get(i.dataId);Object.assign(s,r),s.refCount=1,s.shape=n,s.dtype=e.dtype;let o=$a.computeFlatOffset(t,O.computeStrides(e.shape));r.slice&&(o+=r.slice.flatOffset),s.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||e.dataId};let u=a.dataRefCount.get(s.slice.origDataId)||1;return a.dataRefCount.set(s.slice.origDataId,u+1),i}function eb(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:i,size:s}=a,[o,u]=$a.parseSliceParams(r,i,s);if($a.assertParamsValid(r,o,u),O.sizeFromShape(u)===0)return n.makeTensorInfo(u,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype==="string"){let h=n.texData.get(r.dataId),m=Wle(h.values,o,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,m)}let{isPacked:d}=n.texData.get(r.dataId),c=$a.isSliceContinous(r.shape,o,u);if(d||!c){let h=Ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jce(u):new Jce(u),m=[o];return n.runWebGLProgram(h,[r],r.dtype,m)}return n.uploadToGPU(r.dataId),Qce(r,o,u,n)}var Zce={kernelName:Ag,backendName:"webgl",kernelFunc:eb},Xce=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:i,crops:s}=a;O.assert(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=i.reduce((C,T)=>C*T),u=P.getReshaped(r.shape,i,o),d=P.getPermuted(u.length,i.length),c=P.getReshapedPermuted(r.shape,i,o),h=P.getSliceBeginCoords(s,i.length),m=P.getSliceSize(c,s,i.length),g=[],x=Xe({inputs:{x:r},backend:n,attrs:{shape:u}}),v=Gr({inputs:{x},backend:n,attrs:{perm:d}}),S=Xe({inputs:{x:v},backend:n,attrs:{shape:c}}),E=eb({inputs:{x:S},backend:n,attrs:{begin:h,size:m}});return g.push(x),g.push(v),g.push(S),g.forEach(C=>n.disposeIntermediateTensorInfo(C)),E},ede={kernelName:Um,backendName:"webgl",kernelFunc:Xce};function tde(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:i}=t,{size:s}=a,o=n.readSync(r.dataId),u=n.readSync(i.dataId),d=lL(o,u,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,d)}var nde={kernelName:Vm,backendName:"webgl",kernelFunc:tde},ade=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,rde=`
  return float(int(a.r) & int(b.r));
`;function ide(e){let{inputs:t,backend:n}=e,{a,b:r}=t,i=Ae().getBool("WEBGL_PACK_BINARY_OPERATIONS"),s=Ae().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,r])||s===1){let u=n.texData.get(a.dataId).values,d=n.texData.get(r.dataId).values,[c,h]=dle(a.shape,r.shape,u,d,a.dtype),m=n.makeTensorInfo(h,a.dtype),g=n.texData.get(m.dataId);return g.values=c,m}let o;return i?o=new Zg(ade,a.shape,r.shape,!1):o=new hp(rde,a.shape,r.shape),n.runWebGLProgram(o,[a,r],a.dtype)}var sde={kernelName:Wm,backendName:"webgl",kernelFunc:ide};function ode(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,i=n.readSync(a.dataId),s=n.readSync(r.dataId),o=P.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var lde={kernelName:h0,backendName:"webgl",kernelFunc:ode},ude="return float(a != b);",AL=vr({opSnippet:ude,cpuKernelImpl:Fle,dtype:"bool"}),cde={kernelName:dg,backendName:"webgl",kernelFunc:AL};function uw(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return Mi({inputs:{x:r.complexTensorInfos.real},backend:n})}var dde={kernelName:mv,backendName:"webgl",kernelFunc:uw},pde="return float(int(x));";function hde(e,t){let n=new el(e.shape,pde),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}function pA(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:i}=a;if(i==="complex64"){if(r.dtype==="complex64")return Mi({inputs:{x:r},backend:n});let s=wa(r.shape),o=pA({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),u=Gc({inputs:{real:o,imag:s},backend:n});return s.dispose(),n.disposeIntermediateTensorInfo(o),u}if(r.dtype==="complex64"){let s=uw({inputs:{input:r},backend:n}),o=pA({inputs:{x:s},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(s),o}if(!O.hasEncodingLoss(r.dtype,i)){let s=Mi({inputs:{x:r},backend:n});return{dataId:s.dataId,shape:s.shape,dtype:i}}if(n.shouldExecuteOnCPU([r])){let s=n.texData.get(r.dataId).values,[o,u,d]=ple(s,r.shape,r.dtype,i);return n.makeTensorInfo(o,u,d)}if(i==="int32")return hde(r,n);if(i==="bool"){let s=n.makeTensorInfo([],"bool",O.getTypedArrayFromDType("bool",1)),o=AL({inputs:{a:r,b:s},backend:n});return n.disposeIntermediateTensorInfo(s),o}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}var fde={kernelName:Ip,backendName:"webgl",kernelFunc:pA},zR="return ceil(x);",mde=yn({opSnippet:zR,packedOpSnippet:zR,cpuKernelImpl:hle}),gde={kernelName:_p,backendName:"webgl",kernelFunc:mde},bde=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},yde=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function wde(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:i,clipValueMax:s}=a,o;Ae().getBool("WEBGL_PACK_CLIP")?o=new yde(r.shape):o=new bde(r.shape);let u=[[i],[s]];return n.runWebGLProgram(o,[r],r.dtype,u)}var xde={kernelName:Bc,backendName:"webgl",kernelFunc:wde},vde=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function UR(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function Sde(e){let{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),i=new vde(a.shape),s=[UR(a,r.complexTensorInfos.real),UR(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(i,s,s[0].dtype)}var kde={kernelName:f0,backendName:"webgl",kernelFunc:Sde},Ade=class{constructor(e){this.outputShape=[],this.outputShape=P.computeOutShape(e,1),this.variableNames=e.map((i,s)=>`T${s}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){let s=t[i-1];n.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${s}));`)}let a=t.length,r=t[t.length-1];n.push(`else setOutput(getT${a}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},Ede=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=P.computeOutShape(e,t);let n=this.outputShape,a=n.length,r=$n(a),i=qr("coords",a),s=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map((x,v)=>`T${v}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let x=1;x<o.length;x++)o[x]=o[x-1]+e[x][t];let u=s[t],d=s.slice(-2),c=s.join(),h=`if (${u} < ${o[0]}) {
        return getChannel(
            getT0(${c}), vec2(${d.join()}));
        }`;for(let x=1;x<o.length;x++){let v=o[x-1];h+=`
        if (${u} < ${o[x]}  && ${u} >= ${o[x-1]}) {
          return getChannel(
            getT${x}(${n1(s,u,v)}),
            vec2(${n1(d,u,v)}));
        }`}let m=o.length,g=o[o.length-1];h+=`
        return getChannel(
          getT${m}(${n1(s,u,g)}),
          vec2(${n1(d,u,g)}));`,this.userCode=`
      float getValue(${s.map(x=>"int "+x)}) {
        ${h}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[a-1]} = ${i[a-1]} + 1;
        if (${i[a-1]} < ${n[a-1]}) {
          result.g = getValue(${i});
        }

        ${i[a-2]} = ${i[a-2]} + 1;
        if (${i[a-2]} < ${n[a-2]}) {
          result.a = getValue(${i});
        }

        ${i[a-1]} = ${i[a-1]} - 1;
        if (${i[a-2]} < ${n[a-2]} &&
            ${i[a-1]} < ${n[a-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function n1(e,t,n){let a=e.indexOf(t);return e.map((r,i)=>i===a?`${r} - ${n}`:r).join()}function ES(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return Mi({inputs:{x:r.complexTensorInfos.imag},backend:n})}var Cde={kernelName:dv,backendName:"webgl",kernelFunc:ES};function Ty(e,t,n){let a=e[0].dtype;if(a==="complex64"){let g=e.map(C=>uw({inputs:{input:C},backend:n})),x=e.map(C=>ES({inputs:{input:C},backend:n})),v=Ty(g,t,n),S=Ty(x,t,n),E=Gc({inputs:{real:v,imag:S},backend:n});return g.forEach(C=>n.disposeIntermediateTensorInfo(C)),x.forEach(C=>n.disposeIntermediateTensorInfo(C)),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(S),E}let r=n.shouldExecuteOnCPU(e);if(a==="string"&&(r=!0),r){let g=e.map(N=>{let D=[-1,O.sizeFromShape(N.shape.slice(t))];return Xe({inputs:{x:N},backend:n,attrs:{shape:D}})}),x=g.map(N=>({vals:n.readSync(N.dataId),shape:N.shape})),v=P.computeOutShape(g.map(N=>N.shape),1),S=g[0].shape[0]===1,E=fle(x,v,a,S),C=P.computeOutShape(e.map(N=>N.shape),t),T=n.makeTensorInfo(C,a,E);return g.forEach(N=>n.disposeIntermediateTensorInfo(N)),T}let i=e.filter(g=>O.sizeFromShape(g.shape)>0),s=Ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){let g=s?new el(e[0].shape,uc):new fc(e[0].shape,uc);return n.runWebGLProgram(g,e,a)}let o=Ae().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>o){let g=[];for(let v=0;v<i.length;v+=o){let S=i.slice(v,v+o);g.push(Ty(S,t,n))}let x=Ty(g,t,n);for(let v of g)n.disposeIntermediateTensorInfo(v);return x}if(s){let g=new Ede(i.map(x=>x.shape),t);return n.runWebGLProgram(g,i,a)}let{tensors2D:u,outShape:d}=Ide(i,t,n),c=new Ade(u.map(g=>g.shape)),h=n.runWebGLProgram(c,u,a);u.forEach(g=>n.disposeIntermediateTensorInfo(g));let m=Xe({inputs:{x:h},attrs:{shape:d},backend:n});return n.disposeIntermediateTensorInfo(h),m}function Ide(e,t,n){let a=P.computeOutShape(e.map(r=>r.shape),t);return{tensors2D:e.map(r=>Xe({inputs:{x:r},attrs:{shape:[-1,O.sizeFromShape(r.shape.slice(t))]},backend:n})),outShape:a}}function EL(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,i=O.parseAxisParam(r,t[0].shape)[0],s=t.map(d=>d.shape);P.assertParamsConsistent(s,i);let o=P.computeOutShape(t.map(d=>d.shape),i);if(O.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let u=t.filter(d=>O.sizeFromShape(d.shape)>0);return u.length===1?Mi({inputs:{x:u[0]},backend:n}):Ty(u,i,n)}var _de={kernelName:qm,backendName:"webgl",kernelFunc:EL},CL=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let i=e.padInfo.top,s=e.padInfo.left,o=e.strideHeight,u=e.strideWidth,d=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,m=e.filterWidth,g=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,v=e.dataFormat==="channelsLast",S=v?1:2,E=v?2:3,C=v?3:1,T="",N="";n&&(a?T=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?T=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:T=`
          float activation(float x) {
            ${n}
          }
        `,N="result = activation(result);");let D=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${T}

      const ivec2 strides = ivec2(${o}, ${u});
      const ivec2 pads = ivec2(${i}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${C}];

        ivec2 xRCCorner =
            ivec2(coords[${S}], coords[${E}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${m}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${g}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${v}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${v}) {
                dotProd +=
                    getX(batch, xR, xC, ${g}) *
                    getW(wR, wC, ${g}, d2);
              } else {
                dotProd +=
                    getX(batch, ${g}, xR, xC) *
                    getW(wR, wC, ${g}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2)
              );

              if (${v}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2),
                getW(wR, wC, ${g} + 2, d2)
              );

              if (${v}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1),
                  getX(batch, xR, xC, ${g} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC),
                  getX(batch, ${g} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${D}
        ${N}
        setOutput(result);
      }
    `}},Tde=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,i=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,m=e.filterWidth,g=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${i}, ${s});
      const ivec3 pads = ivec3(${t}, ${n}, ${a});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${g}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${g}) *
                  getW(wF, wR, wC, ${g}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1),
                  getX(batch, xF, xR, xC, ${g} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2),
                  getW(wF, wR, wC, ${g} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},IL=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Or(this.outputShape.length);let i=e.padInfo.left,s=e.strideWidth,o=e.dilationWidth,u=e.filterHeight,d=e.filterWidth,c=d,h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<d;v++)h+=`
           vec4 xTexelC${v*2};
           int xTexelC${v*2}Ready;
           vec4 xTexelC${v*2+1};
           int xTexelC${v*2+1}Ready;
           vec4 xC${v};`;h+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let v=0;v<d;v++)h+=`
           xTexelC${v*2} = vec4(0.0);
           xTexelC${v*2}Ready = 0;
           xTexelC${v*2+1} = vec4(0.0);
           xTexelC${v*2+1}Ready = 0;
           xC${v} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let v=0;v<(c+1)/2;v++){let S=v*2;if(h+=`
           xC = xCCorner + ${S*o};
           `,s===1){if(S<d&&(i%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }
               `,o===1&&S>0?h+=`
                 xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                   } else {
                     xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xC${S} = xTexelC${S};
                 `,S+1<d)){let E=i%2===0?O.nearestLargerEven(o):o;o%2===0&&i%2===1||o%2!==0&&i%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${E};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                     xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${S+1}.zw = vec2(0.0);
                     }
                     xTexelC${S+1}Ready = 1;
                   }
                   `,o>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                     } else {
                      xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                     }
                     `:h+=`
                     xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                     `):E===1?h+=`
                     xC${S+1} = xTexelC${S};
                     `:h+=`
                     xCOffset = xC + ${E};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                       xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${S+1}.zw = vec2(0.0);
                       }
                       xTexelC${S+1}Ready = 1;
                     }

                     xC${S+1} = xTexelC${S+1};
                     `}}else S<d&&(i%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.0);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
               `,S+1<d&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(
                   xTexelC${S}.xy, xTexelC${S+1}.xy);
               `,S+1<d&&(h+=`
                   xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                 `)));S<d&&(h+=`
             wTexel = getW(r, ${S}, d1, d2);
             dotProd += xC${S}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${S}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,S+1<d&&(h+=`
               wTexel = getW(r, ${S+1}, d1, d2);
               dotProd += xC${S+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${S+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let m="",g="";n&&(a?m=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:r?m=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:m=`vec4 activation(vec4 x) {
           ${n}
         }`,g="result = activation(result);");let x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${m}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${g}
         setOutput(result);
       }
     `}},Nde=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Or(this.outputShape.length);let{dataFormat:n}=t,a=jr(),r=n==="channelsLast",i=r?1:2,s=r?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,u="";for(let d=0;d<=1;d++)for(let c=0;c<=1;c++)u+=`
          blockIndex = rc.z + ${c};
          pos = rc.y + ${d};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${s}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+c}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+c}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${a.output} = result;
      }
    `}};function G1(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function _L({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:o=null}){let u=e.shape,d=a.texData.get(e.dataId),c=n.inChannels,h=u[0]*u[1]*u[2],m=n.outChannels,g=n.dataFormat==="channelsLast",x=!1,v=!1,S,E=[];if(i!=null){let C=G1(i.shape,g);C!=null&&(i=Xe({inputs:{x:i},backend:a,attrs:{shape:C}}),E.push(i))}if(r!=null){let C=G1(r.shape,g);C!=null&&(r=Xe({inputs:{x:r},backend:a,attrs:{shape:C}}),E.push(r))}if(!((h===1||m===1)&&c>xL)&&d.isPacked&&g&&d.texture!=null&&u[2]%2!==0&&O.arraysEqual(d.shape.slice(-3),u.slice(-3))){let C=u[0]*u[1]*(u[2]+1),T={dataId:e.dataId,shape:[1,C,n.inChannels],dtype:e.dtype},N=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,O.assert(r0(d.shape,T.shape),()=>`packed reshape ${d.shape} to ${T.shape} isn't free`);let D=Xe({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}});E.push(D);let q=H1({a:T,b:D,backend:a,transposeA:x,transposeB:v,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:s}),H=a.texData.get(q.dataId);O.assert(H.isPacked,()=>"batchMatMul result is expected to be packed"),d.shape=N,H.shape=n.outShape,S=Mi({inputs:{x:q},backend:a}),S.shape=n.outShape,E.push(q)}else{let C=n.outHeight*n.outWidth,T=Xe({inputs:{x:e},backend:a,attrs:{shape:g?[n.batchSize,C,n.inChannels]:[n.batchSize,n.inChannels,C]}}),N=Xe({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}}),D=H1({a:g?T:N,b:g?N:T,transposeA:!g,transposeB:v,backend:a,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:s});S=Xe({inputs:{x:D},backend:a,attrs:{shape:n.outShape}}),E.push(T),E.push(N),E.push(D)}for(let C of E)a.disposeIntermediateTensorInfo(C);return S}function TL({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:o=null}){let{filterWidth:u,filterHeight:d,inChannels:c,outWidth:h,outHeight:m,dataFormat:g}=n,x=g==="channelsLast",v=u*d*c,S=m*h,E=[n.batchSize,v,S],C=!0,T=!1,N=[];if(i!=null){let de=G1(i.shape,x);de!=null&&(i=Xe({inputs:{x:i},backend:a,attrs:{shape:de}}),N.push(i))}if(r!=null){let de=G1(r.shape,x);de!=null&&(r=Xe({inputs:{x:r},backend:a,attrs:{shape:de}}),N.push(r))}let D=Xe({inputs:{x:t},backend:a,attrs:{shape:[1,v,O.sizeFromShape(t.shape)/v]}});N.push(D);let q=new Nde(E,n),H=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],K=a.runWebGLProgram(q,[e],"float32",H),j=Xe({inputs:{x:K},backend:a,attrs:{shape:E}});N.push(K),N.push(j);let te=r!=null,Q=i!=null,z=o==="leakyrelu",ae=o?i0(o,!0):null,ue=new wL(x?j.shape:D.shape,x?D.shape:j.shape,x?[n.batchSize,S,n.outChannels]:[n.batchSize,n.outChannels,S],C,T,te,ae,Q,z),he=x?[j,D]:[D,j];if(r&&he.push(r),Q&&he.push(i),z){let de=a.makeTensorInfo([],"float32",O.createScalarValue(s,"float32"));he.push(de),N.push(de)}let Z=a.runWebGLProgram(ue,he,"float32"),se=Xe({inputs:{x:Z},backend:a,attrs:{shape:n.outShape}});N.push(Z);for(let de of N)a.disposeIntermediateTensorInfo(de);return se}function Rde(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:s,pad:o,dataFormat:u,dilations:d,dimRoundingMode:c}=a,h=P.convertConv2DDataFormat(u),m=P.computeConv2DInfo(r.shape,i.shape,s,d,o,c,!1,h),g;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))g=_L({x:r,filter:i,convInfo:m,backend:n});else if(m.strideWidth<=2&&h==="channelsLast"&&Ae().getBool("WEBGL_EXP_CONV")){let v=new IL(m),S=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];g=n.runWebGLProgram(v,[r,i],"float32",S)}else if(Ae().getBool("WEBGL_CONV_IM2COL"))g=TL({x:r,filter:i,convInfo:m,backend:n});else{let v=new CL(m);g=n.runWebGLProgram(v,[r,i],"float32")}let x=Xe({inputs:{x:g},backend:n,attrs:{shape:m.outShape}});return n.disposeIntermediateTensorInfo(g),x}var Fde={kernelName:Tp,backendName:"webgl",kernelFunc:Rde},Dde=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${a};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Ode=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,i=e.dataFormat==="channelsLast",s=t-1-e.padInfo.top,o=n-1-e.padInfo.left,u=i?1:2,d=i?2:3,c=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Mde=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,i=e.padInfo.top,s=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${a} - ${s};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Bde=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,i=e.strideHeight,s=e.strideWidth,o=t-1-e.padInfo.front,u=n-1-e.padInfo.top,d=a-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${u}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${a}; wC++) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${a} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Lde(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:s,pad:o,dataFormat:u,dimRoundingMode:d,filterShape:c}=a,h=P.convertConv2DDataFormat(u),m=P.computeConv2DInfo(r.shape,c,s,1,o,d,!1,h),g=new Dde(m);return n.runWebGLProgram(g,[r,i],"float32")}var zde={kernelName:rv,backendName:"webgl",kernelFunc:Lde},Ude=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Or(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function Vde(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{inputShape:s,strides:o,pad:u,dataFormat:d,dimRoundingMode:c}=a,h=P.convertConv2DDataFormat(d),m=P.computeConv2DInfo(s,i.shape,o,1,u,c,!1,h);if(Ae().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){let g=[[m.strideHeight,m.strideWidth]],x=new Ude(m);return n.runWebGLProgram(x,[r,i],"float32",g)}else{let g=new Ode(m);return n.runWebGLProgram(g,[r,i],"float32")}}var Wde={kernelName:Np,backendName:"webgl",kernelFunc:Vde};function qde(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:s,pad:o,dilations:u}=a,d=P.computeConv3DInfo(r.shape,i.shape,s,u,o),c=new Tde(d);return n.runWebGLProgram(c,[r,i],"float32")}var Pde={kernelName:Rp,backendName:"webgl",kernelFunc:qde};function Hde(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:s,pad:o,filterShape:u}=a,d=P.computeConv3DInfo(r.shape,u,s,1,o),c=new Mde(d);return n.runWebGLProgram(c,[r,i],"float32")}var Gde={kernelName:Pm,backendName:"webgl",kernelFunc:Hde};function Kde(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{pad:s,strides:o,inputShape:u}=a,d=P.computeConv3DInfo(u,i.shape,o,1,s),c=new Bde(d);return n.runWebGLProgram(c,[r,i],"float32")}var $de={kernelName:Hm,backendName:"webgl",kernelFunc:Kde},Jde=Xg+`
  return cos(x);
`,Yde=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Hh}
  return result;
`,jde=yn({opSnippet:Jde,packedOpSnippet:Yde}),Qde={kernelName:Fp,backendName:"webgl",kernelFunc:jde},Zde=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Xde=yn({opSnippet:Zde}),epe={kernelName:Dp,backendName:"webgl",kernelFunc:Xde},tpe=class{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,s,o,u]=e,[d]=t,[c,h]=n;this.outputShape=[d,c,h,u];let m=a==="bilinear"?1:0,[g,x]=[`${s-1}.0`,`${o-1}.0`],[v,S,E]=c>1?[`${(s-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${g} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${g}`],[C,T,N]=h>1?[`${(o-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${v});
      const float width_ratio = float(${C});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${S};
        float width_scale = ${T};

        float in_y = ${E};
        if( in_y < 0.0 || in_y > ${g} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${N};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${m} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},npe=e=>{let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:i,boxInd:s}=t,{cropSize:o,method:u,extrapolationValue:d}=a,c=new tpe(r.shape,i.shape,o,u,d);return n.runWebGLProgram(c,[r,i,s],"float32")},ape={kernelName:Km,backendName:"webgl",kernelFunc:npe},o0;(function(e){e.Prod="*",e.Sum="+"})(o0||(o0={}));var VR=class{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let r=this.outputShape.length,i=this.op===o0.Prod?"1.0":"0.0",s=n?i:`getX(${WR(r,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],u="",d="";n?(u=a?`end != ${o-1}`:"end != 0",d=a?"end + 1":"end - 1"):(u=a?`end + pow2 < ${o}`:"end >= pow2",d=a?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${$n(r)} coords = getOutputCoords();
        int end = ${qR(r,"coords",this.op)};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${d};
          ${qR(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${WR(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function WR(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function qR(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function NL(e,t,n,a,r,i){let s=t.shape.length,o=P.getAxesPermutation([a],s),u=t;o!=null&&(u=Gr({inputs:{x:t},backend:n,attrs:{perm:o}}));let d=P.getInnerMostAxes(1,s)[0];if(d!==s-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${a}`);let c=u.shape[d],h=Mi({inputs:{x:u},backend:n});for(let m=0;m<=Math.ceil(Math.log2(c))-1;m++){let g=new VR(e,u.shape,!1,i),x=[[m]],v=h;h=n.runWebGLProgram(g,[h],h.dtype,x),n.disposeIntermediateTensorInfo(v)}if(r){let m=new VR(e,u.shape,r,i),g=h;h=n.runWebGLProgram(m,[h],h.dtype),n.disposeIntermediateTensorInfo(g)}if(o!=null){let m=P.getUndoAxesPermutation(o),g=Gr({inputs:{x:h},backend:n,attrs:{perm:m}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),g}return h}function rpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,exclusive:s,reverse:o}=a;return NL(o0.Prod,r,n,i,s,o)}var ipe={kernelName:Gm,backendName:"webgl",kernelFunc:rpe};function spe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,exclusive:s,reverse:o}=a;return NL(o0.Sum,r,n,i,s,o)}var ope={kernelName:Op,backendName:"webgl",kernelFunc:spe};function lpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:i}=t,{size:s,binaryOutput:o}=a;if(r.shape.length===1){let u=n.readSync(r.dataId),d=n.readSync(i.dataId),c=lL(u,d,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,c)}else if(r.shape.length===2){let u=n.bufferSync(r),d=n.bufferSync(i),c=cle(u,d,s,o);return n.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var upe={kernelName:m0,backendName:"webgl",kernelFunc:lpe},cpe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function dpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:i,dataFormat:s}=a,o=r.shape[0],u=s==="NHWC"?r.shape[1]:r.shape[2],d=s==="NHWC"?r.shape[2]:r.shape[3],c=s==="NHWC"?r.shape[3]:r.shape[1],h=u*i,m=d*i,g=c/(i*i),x=s==="NHWC"?[o,h,m,g]:[o,g,h,m],v=new cpe(x,i,s);return n.runWebGLProgram(v,[r],r.dtype)}var ppe={kernelName:$m,backendName:"webgl",kernelFunc:dpe},RL=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Or(this.outputShape.length);let i=e.filterHeight,s=e.filterWidth,o=e.outChannels/e.inChannels,u="",d="";n&&(a?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:u=`
          float activation(float x) {
            ${n}
          }
        `,d="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${s}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${d}
        setOutput(result);
      }
    `}},FL=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Or(this.outputShape.length);let i=e.outChannels/e.inChannels,s=e.padInfo.left,o=e.strideWidth,u=e.dilationWidth,d=e.filterHeight,c=e.filterWidth,h=c,m=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<c;S++)m+=`
          vec4 xTexelC${S*2};
          int xTexelC${S*2}Ready;
          vec4 xTexelC${S*2+1};
          int xTexelC${S*2+1}Ready;
          vec4 xC${S};`;m+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let S=0;S<c;S++)m+=`
          xTexelC${S*2} = vec4(0.0);
          xTexelC${S*2}Ready = 0;
          xTexelC${S*2+1} = vec4(0.0);
          xTexelC${S*2+1}Ready = 0;
          xC${S} = vec4(0.0);`;m+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let S=0;S<(h+1)/2;S++){let E=S*2;if(m+=`
          xC = xCCorner + ${E*u};
          `,o===1){if(E<c&&(s%2===1?(m+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${E}Ready == 0) {
                  xTexelC${E} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${E}.zw = vec2(0.0);
                  }
                  xTexelC${E}Ready = 1;
                }
              `,u===1&&E>0?m+=`
                xC${E} = vec4(xTexelC${E-2}.zw, xTexelC${E}.xy);
                `:m+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${E} = vec4(previous.zw, xTexelC${E}.xy);
                  } else {
                    xC${E} = vec4(0.0, 0.0, xTexelC${E}.xy);
                  }
                  `):m+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${E}Ready == 0) {
                  xTexelC${E} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${E}.zw = vec2(0.0);
                  }
                  xTexelC${E}Ready = 1;
                }

                xC${E} = xTexelC${E};
                `,E+1<c)){let C=s%2===0?O.nearestLargerEven(u):u;u%2===0&&s%2===1||u%2!==0&&s%2!==1?(m+=`
                  xCOffset = xC + imod(pads[1], 2) + ${C};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${E+1}Ready == 0) {
                    xTexelC${E+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${E+1}.zw = vec2(0.0);
                    }
                    xTexelC${E+1}Ready = 1;
                  }
                  `,u>1?m+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${E+1} = vec4(previous.zw, xTexelC${E+1}.xy);
                    } else {
                     xC${E+1} = vec4(0.0, 0.0, xTexelC${E+1}.xy);
                    }
                    `:m+=`
                    xC${E+1} = vec4(xTexelC${E}.zw, xTexelC${E+1}.xy);
                    `):C===1?m+=`
                    xC${E+1} = xTexelC${E};
                    `:m+=`
                    xCOffset = xC + ${C};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${E+1}Ready == 0) {
                      xTexelC${E+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${E+1}.zw = vec2(0.0);
                      }
                      xTexelC${E+1}Ready = 1;
                    }

                    xC${E+1} = xTexelC${E+1};
                    `}}else E<c&&(s%2===1?(m+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${E}Ready == 0) {
                  xTexelC${E} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${E}.zw = vec2(0.0);
                  }
                  xTexelC${E}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${E+1}Ready == 0) {
                  xTexelC${E+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${E+1}.zw = vec2(0.0);
                  }
                  xTexelC${E+1}Ready = 1;
                }

                xC${E} = vec4(xTexelC${E}.zw, xTexelC${E+1}.zw);
              `,E+1<c&&(m+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${E+1} = vec4(xTexelC${E+1}.xy, final.xy);
                `)):(m+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${E}Ready == 0) {
                  xTexelC${E} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${E}.zw = vec2(0.0);
                  }
                  xTexelC${E}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${E+1}Ready == 0) {
                  xTexelC${E+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${E+1}.zw = vec2(0.);
                  }
                  xTexelC${E+1}Ready = 1;
                }

                xC${E} = vec4(
                  xTexelC${E}.xy, xTexelC${E+1}.xy);
              `,E+1<c&&(m+=`
                  xC${E+1} = vec4(xTexelC${E}.zw, xTexelC${E+1}.zw);
                `)));E<c&&(m+=`
            wTexel = getW(r, ${E}, d1, q);
            dotProd += xC${E} * vec4(wTexel.xz, wTexel.xz);
          `,E+1<c&&(m+=`
              wTexel = getW(r, ${E+1}, d1, q);
              dotProd += xC${E+1} * vec4(wTexel.xz, wTexel.xz);
            `))}m+=`
    }
  `,m+=`
      }
    `;let g="",x="";n&&(a?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:g=`vec4 activation(vec4 x) {
          ${n}
        }`,x="result = activation(result);");let v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${m}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${v}
        ${x}
        setOutput(result);
      }
    `}};function hpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:s,pad:o,dilations:u,dimRoundingMode:d}=a,c=u;c==null&&(c=[1,1]),O.assert(P.eitherStridesOrDilationsAreOne(s,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);let h=P.computeConv2DInfo(r.shape,i.shape,s,c,o,d,!0),m;Ae().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?m=new FL(h):m=new RL(h);let g=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(m,[r,i],"float32",g)}var fpe={kernelName:Mp,backendName:"webgl",kernelFunc:hpe},mpe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${a};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},gpe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,i=t-1-e.padInfo.top,s=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function bpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:s,dilations:o,pad:u,dimRoundingMode:d,filterShape:c}=a,h=P.computeConv2DInfo(r.shape,c,s,o,u,d,!0),m=new mpe(h);return n.runWebGLProgram(m,[r,i],"float32")}var ype={kernelName:iv,backendName:"webgl",kernelFunc:bpe};function wpe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{strides:s,dilations:o,pad:u,dimRoundingMode:d,inputShape:c}=a,h=P.computeConv2DInfo(c,i.shape,s,o,u,d,!0),m=new gpe(h);return n.runWebGLProgram(m,[r,i],"float32")}var xpe={kernelName:sv,backendName:"webgl",kernelFunc:wpe},vpe=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Spe(e){let{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],i=O.sizeFromShape(a.shape),s=Xe({inputs:{x:a},backend:n,attrs:{shape:[i]}}),o=new vpe(i),u=n.runWebGLProgram(o,[s],s.dtype),d=Xe({inputs:{x:u},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(u),d}var kpe={kernelName:g0,backendName:"webgl",kernelFunc:Spe},Ape=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:i,filterHeight:s,filterWidth:o,dilationHeight:u,dilationWidth:d}=e,{top:c,left:h}=a;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${i});
      const ivec2 pads = ivec2(${c}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${s}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Epe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:s,pad:o,dilations:u}=a,d=P.computeDilation2DInfo(r.shape,i.shape,s,o,"NHWC",u),c,h=new Ape(d);c=n.runWebGLProgram(h,[r,i],"float32");let m=Xe({inputs:{x:c},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(c),m}var Cpe={kernelName:Bp,backendName:"webgl",kernelFunc:Epe};function Ipe(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,i=t,{allDims:s,summedDims:o,idDims:u}=P.decodeEinsumEquation(r,i.length);P.checkEinsumDimSizes(s.length,u,i);let{path:d,steps:c}=P.getEinsumComputePath(o,u),h=c.length,m=null,g=s.length,x=[];for(let v=0;v<h;++v){for(let S of c[v]){let{permutationIndices:E,expandDims:C}=P.getEinsumPermutation(g,u[S]),T;P.isIdentityPermutation(E)?T=i[S]:(T=Gr({inputs:{x:i[S]},backend:n,attrs:{perm:E}}),x.push(T));let N=T.shape.slice();for(let D=0;D<C.length;++D)N.splice(C[D],0,1);O.arraysEqual(T.shape,N)||(T=Xe({inputs:{x:T},backend:n,attrs:{shape:N}}),x.push(T)),m===null?m=T:(m=m_({inputs:{a:T,b:m},backend:n}),x.push(m))}v<h-1&&(d[v]>=0&&(m=AS({inputs:{x:m},backend:n,attrs:{axis:d[v]-(s.length-g),keepDims:!1}}),x.push(m)),g--)}for(let v of x)v!==m&&n.disposeIntermediateTensorInfo(v);return m}var _pe={kernelName:lv,backendName:"webgl",kernelFunc:Ipe},Tpe="return (x >= 0.0) ? x : (exp(x) - 1.0);",Npe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Rpe=yn({opSnippet:Tpe,packedOpSnippet:Npe}),Fpe={kernelName:zp,backendName:"webgl",kernelFunc:Rpe},Dpe="return (b >= 0.0) ? a : a * (b + 1.0);",Ope=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Mpe=e=>{let{inputs:t,backend:n}=e,{dy:a,y:r}=t,i=Ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zg(Ope,a.shape,r.shape):new hp(Dpe,a.shape,r.shape);return n.runWebGLProgram(i,[a,r],a.dtype)},Bpe={kernelName:Jm,backendName:"webgl",kernelFunc:Mpe},Lpe=`
  return vec4(equal(a, b));
`,zpe="return float(a == b);",Upe=vr({opSnippet:zpe,packedOpSnippet:Lpe,dtype:"bool",cpuKernelImpl:mle}),Vpe={kernelName:Ym,backendName:"webgl",kernelFunc:Upe},Wpe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${P.ERF_P};
  float a1 = ${P.ERF_A1};
  float a2 = ${P.ERF_A2};
  float a3 = ${P.ERF_A3};
  float a4 = ${P.ERF_A4};
  float a5 = ${P.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,qpe=yn({opSnippet:Wpe}),Ppe={kernelName:Up,backendName:"webgl",kernelFunc:qpe},Hpe=Xg+`
  return exp(x);
`,Gpe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DL=yn({opSnippet:Hpe,packedOpSnippet:Gpe,cpuKernelImpl:gle,dtype:"float32"}),Kpe={kernelName:Vp,backendName:"webgl",kernelFunc:DL};function hA(e){let{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:i}=t,s=i.shape.length,o=i.shape.slice(),u=r;return r<0&&(O.assert(-(s+1)<=r,()=>`Axis must be in the interval [${-(s+1)}, ${s}]`),u=s+r+1),o.splice(u,0,1),Xe({inputs:{x:i},backend:a,attrs:{shape:o}})}var $pe={kernelName:jm,backendName:"webgl",kernelFunc:hA},PR="return exp(x) - 1.0;",Jpe=yn({opSnippet:PR,packedOpSnippet:PR,cpuKernelImpl:ble}),Ype={kernelName:Wp,backendName:"webgl",kernelFunc:Jpe},HR=class{constructor(e,t,n){this.variableNames=["real","imag"];let a=t[1];this.outputShape=t;let r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${a}.0`:"1.0",s;if(e==="real")s="return real * expR - imag * expI;";else if(e==="imag")s="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${s}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${a});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${a}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function OL(e,t,n){let a=n.texData.get(e.dataId),r=O.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],s=r/i,o=Xe({inputs:{x:e},backend:n,attrs:{shape:[s,i]}}),u=o.shape,d=new HR("real",u,t),c=new HR("imag",u,t),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:u},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:u}],m=n.runWebGLProgram(d,h,"float32"),g=n.runWebGLProgram(c,h,"float32"),x=Gc({inputs:{real:m,imag:g},backend:n});n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g);let v=Xe({inputs:{x},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(x),v}function jpe(e){let{inputs:t,backend:n}=e,{input:a}=t;return OL(a,!1,n)}var Qpe={kernelName:uv,backendName:"webgl",kernelFunc:jpe},Zpe=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function cw(e){let{backend:t,attrs:n}=e,{shape:a,value:r}=n,{dtype:i}=n;if(i=i||O.inferDtype(r),i==="string"){let s=O.getArrayFromDType(i,O.sizeFromShape(a));return s.fill(r),t.makeTensorInfo(a,i,s)}else{let s=new Zpe(a,r),o=[[r]];return t.runWebGLProgram(s,[],i,o)}}var Xpe={kernelName:b0,backendName:"webgl",kernelFunc:cw},ehe=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},the={kernelName:Qm,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,a=t,r=new ehe(n.shape);return a.runWebGLProgram(r,[n],n.dtype)}},GR="return floor(x);",nhe=yn({opSnippet:GR,packedOpSnippet:GR,cpuKernelImpl:yle}),ahe={kernelName:qp,backendName:"webgl",kernelFunc:nhe},rhe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,ihe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,she=vr({opSnippet:rhe,packedOpSnippet:ihe,dtype:"int32"}),ohe={kernelName:Pp,backendName:"webgl",kernelFunc:she},lhe=class{constructor(e){this.variableNames=["A"];let t=jr(),[n,a]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},uhe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=jr(),[n,a]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${a}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},che={kernelName:k1,backendName:"webgl",kernelFunc:dhe},nm,uk=Ae().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function dhe(e){let{inputs:t,backend:n,attrs:a}=e,{pixels:r}=t,{numChannels:i}=a,s=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,d]=s?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[d,u],h=[d,u,i];if(o||s){let v=Ae().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(nm==null||v!==uk)&&(uk=v,nm=document.createElement("canvas").getContext("2d",{willReadFrequently:uk})),nm.canvas.width=u,nm.canvas.height=d,nm.drawImage(r,0,0,u,d),r=nm.canvas}let m=n.makeTensorInfo(c,"int32");n.texData.get(m.dataId).usage=Xi.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(m.dataId),r);let g=Ae().getBool("WEBGL_PACK")?new uhe(h):new lhe(h),x=n.runWebGLProgram(g,[m],"int32");return n.disposeData(m.dataId),x}function phe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i,bias:s,preluActivationWeights:o}=t,{strides:u,pad:d,dataFormat:c,dilations:h,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=a,v=P.convertConv2DDataFormat(c),S=P.computeConv2DInfo(r.shape,i.shape,u,h,d,m,!1,v),E,C=[],T=s!=null,N=o!=null,D=g==="leakyrelu",q=()=>{let K=[r,i],j=(te,Q)=>{if(Q==="NCHW"&&te.shape.length===1&&te.shape[0]!==1){let z=Xe({inputs:{x:te},backend:n,attrs:{shape:[te.shape[0],1,1]}});return C.push(z),z}return te};if(T&&K.push(j(s,c)),N&&K.push(j(o,c)),D){let te=n.makeTensorInfo([],"float32",O.createScalarValue(x,"float32"));K.push(te),C.push(te)}return K};if(S.filterHeight===1&&S.filterWidth===1&&S.dilationHeight===1&&S.dilationWidth===1&&S.strideHeight===1&&S.strideWidth===1&&(S.padInfo.type==="SAME"||S.padInfo.type==="VALID"))E=_L({x:r,filter:i,convInfo:S,backend:n,bias:s,activation:g,preluActivationWeights:o,leakyreluAlpha:x});else if(S.strideWidth<=2&&v==="channelsLast"&&Ae().getBool("WEBGL_EXP_CONV")){let K=g?i0(g,!0):null,j=new IL(S,T,K,N,D),te=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]],Q=q();E=n.runWebGLProgram(j,Q,"float32",te)}else if(Ae().getBool("WEBGL_CONV_IM2COL"))E=TL({x:r,filter:i,convInfo:S,backend:n,bias:s,activation:g,preluActivationWeights:o,leakyreluAlpha:x});else{let K=g?i0(g,!1):null,j=new CL(S,T,K,N,D),te=q();E=n.runWebGLProgram(j,te,"float32")}let H=Xe({inputs:{x:E},backend:n,attrs:{shape:S.outShape}});return C.push(E),C.forEach(K=>n.disposeIntermediateTensorInfo(K)),H}var hhe={kernelName:Qd,backendName:"webgl",kernelFunc:phe};function fhe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i,bias:s,preluActivationWeights:o}=t,{strides:u,pad:d,dilations:c,dimRoundingMode:h,activation:m,leakyreluAlpha:g}=a,x=[],v=c;v==null&&(v=[1,1]),O.assert(P.eitherStridesOrDilationsAreOne(u,v),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${v}'`);let S=P.computeConv2DInfo(r.shape,i.shape,u,v,d,h,!0),E=Ae().getBool("WEBGL_PACK_DEPTHWISECONV")&&S.strideWidth<=2&&S.outChannels/S.inChannels===1,C=m?i0(m,E):null,T=[r,i],N=s!=null,D=o!=null,q=m==="leakyrelu";if(N&&T.push(s),D&&T.push(o),q){let te=n.makeTensorInfo([],"float32",O.createScalarValue(g,"float32"));T.push(te),x.push(te)}let H;E?H=new FL(S,N,C,D,q):H=new RL(S,N,C,D,q);let K=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]],j=n.runWebGLProgram(H,T,"float32",K);return x.forEach(te=>n.disposeIntermediateTensorInfo(te)),j}var mhe={kernelName:Zd,backendName:"webgl",kernelFunc:fhe},ghe=class{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;let r=$n(n.length),i=`
    int index;`;for(let s=0;s<this.sliceDim;s++)i+=`
          index = round(getIndices(coords[0], ${s}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[s]};
          flattenIndex += index * ${this.strides[s]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function bhe(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,i=r.shape,s=i[i.length-1],o=O.sizeFromShape(a.shape),[u,d,c,h]=P.prepareAndValidate(a,r),m=Xe({inputs:{x:r},backend:n,attrs:{shape:[d,s]}}),g=Xe({inputs:{x:a},backend:n,attrs:{shape:[O.sizeFromShape(a.shape)/c,c]}});if(n.shouldExecuteOnCPU([a,r])||a.dtype==="string"){let E=n.readSync(r.dataId),C=n.bufferSync(a),T=wle(E,C,a.dtype,d,s,c,h,a.shape,o);return n.makeTensorInfo(u,a.dtype,T.values)}let x=new ghe(s,h,[d,c],a.shape),v=n.runWebGLProgram(x,[g,m],g.dtype),S=Xe({inputs:{x:v},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(v),S}var yhe={kernelName:Xm,backendName:"webgl",kernelFunc:bhe},whe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=$n(this.rank),a=xhe(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${a}));
      }
    `}};function xhe(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)r===2?a.push("index"):a.push(`${n[r]}`);return a.join()}function ML(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:i}=t,{axis:s,batchDims:o}=a,u=O.parseAxisParam(s,r.shape)[0];if(Ae().get("DEBUG")){let C=n.readSync(i.dataId),T=r.shape[u];for(let N=0;N<C.length;++N){let D=C[N];O.assert(D<=T-1&&D>=0,()=>`GatherV2: the index value ${D} is not in [0, ${T-1}]`)}}let d=P.segment_util.collectGatherOpShapeInfo(r,i,u,o),c=O.sizeFromShape(i.shape),h=[],m=Xe({inputs:{x:r},backend:n,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),g=Xe({inputs:{x:i},backend:n,attrs:{shape:[d.batchSize,c/d.batchSize]}});h.push(m),h.push(g);let x=[d.batchSize,d.outerSize,c/d.batchSize,d.sliceSize];if(n.shouldExecuteOnCPU([r,i])||r.dtype==="string"){let C=n.bufferSync(g),T=n.bufferSync(m),N=xle(T,C,x);return h.forEach(D=>n.disposeIntermediateTensorInfo(D)),n.makeTensorInfo(d.outputShape,N.dtype,N.values)}let v=new whe(m.shape,x),S=n.runWebGLProgram(v,[m,g],m.dtype);h.push(S);let E=Xe({inputs:{x:S},backend:n,attrs:{shape:d.outputShape}});return h.forEach(C=>n.disposeIntermediateTensorInfo(C)),E}var vhe={kernelName:Zm,backendName:"webgl",kernelFunc:ML},She="return float(a > b);",khe=`
  return vec4(greaterThan(a, b));
`,Ahe=vr({opSnippet:She,packedOpSnippet:khe,cpuKernelImpl:vle,dtype:"bool"}),Ehe={kernelName:eg,backendName:"webgl",kernelFunc:Ahe},Che="return float(a >= b);",Ihe=`
  return vec4(greaterThanEqual(a, b));
`,_he=vr({opSnippet:Che,packedOpSnippet:Ihe,dtype:"bool",cpuKernelImpl:Sle}),The={kernelName:Gp,backendName:"webgl",kernelFunc:_he};function Nhe(e){let{inputs:t,backend:n}=e,{input:a}=t;return OL(a,!0,n)}var Rhe={kernelName:cv,backendName:"webgl",kernelFunc:Nhe},Fhe="return float(!isnan(x) && !isinf(x));",Dhe=yn({opSnippet:Fhe,dtype:"bool"}),Ohe={kernelName:$p,backendName:"webgl",kernelFunc:Dhe},Mhe="return float(isinf(x));",Bhe=yn({opSnippet:Mhe,dtype:"bool"}),Lhe={kernelName:Jp,backendName:"webgl",kernelFunc:Bhe},zhe="return float(isnan(x));",Uhe=yn({opSnippet:zhe,dtype:"bool"}),Vhe={kernelName:Yp,backendName:"webgl",kernelFunc:Uhe},Whe="return float(a < b);",qhe=`
  return vec4(lessThan(a, b));
`,Phe=vr({opSnippet:Whe,packedOpSnippet:qhe,cpuKernelImpl:kle,dtype:"bool"}),Hhe={kernelName:tg,backendName:"webgl",kernelFunc:Phe},Ghe="return float(a <= b);",Khe=`
  return vec4(lessThanEqual(a, b));
`,$he=vr({opSnippet:Ghe,packedOpSnippet:Khe,cpuKernelImpl:Ale,dtype:"bool"}),Jhe={kernelName:ng,backendName:"webgl",kernelFunc:$he};function Yhe(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:i}=n,s=Ele(a,r,i);return t.makeTensorInfo([s.length],"float32",s)}var jhe={kernelName:ag,backendName:"webgl",kernelFunc:Yhe},Qhe=Xg+`
  return x < 0.0 ? 0./0. : log(x);
`,Zhe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Xhe=yn({opSnippet:Qhe,packedOpSnippet:Zhe,cpuKernelImpl:Cle}),efe={kernelName:Qp,backendName:"webgl",kernelFunc:Xhe},tfe=Xg+`
  return log(1.0 + x);
`,nfe=yn({opSnippet:tfe}),afe={kernelName:Zp,backendName:"webgl",kernelFunc:nfe},rfe="return float(a >= 1.0 && b >= 1.0);",ife=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,sfe=vr({opSnippet:rfe,packedOpSnippet:ife,dtype:"bool"}),ofe={kernelName:rg,backendName:"webgl",kernelFunc:sfe},lfe="return float(!(x >= 1.0));",ufe=yn({opSnippet:lfe}),cfe={kernelName:ig,backendName:"webgl",kernelFunc:ufe},dfe="return float(a >= 1.0 || b >= 1.0);",pfe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,hfe=vr({opSnippet:dfe,packedOpSnippet:pfe,dtype:"bool"}),ffe={kernelName:sg,backendName:"webgl",kernelFunc:hfe},mfe=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];let i=t,s=e[3]-1;this.outputShape=e;let o,u=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${u})`:r===1?o=`1.0/(${u})`:o=`exp(log(${u}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${s}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},gfe=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=t,s=e[3]-1;this.outputShape=e;let o,u=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${u})`:r===1?o=`1.0/(${u})`:o=`exp(log(${u}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${s}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},bfe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:i,bias:s,alpha:o,beta:u}=a,d=Ae().getBool("WEBGL_PACK_NORMALIZATION")?new gfe(r.shape,i,s,o,u):new mfe(r.shape,i,s,o,u);return n.runWebGLProgram(d,[r],r.dtype)},yfe={kernelName:Xp,backendName:"webgl",kernelFunc:bfe},wfe=class{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${a}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${a})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},xfe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r,y:i,dy:s}=t,{depthRadius:o,bias:u,alpha:d,beta:c}=a,h=new wfe(r.shape,o,u,d,c);return n.runWebGLProgram(h,[r,i,s],r.dtype)},vfe={kernelName:og,backendName:"webgl",kernelFunc:xfe};function Sfe(e,t,n,a){let r=O.sizeFromShape(t),i=O.sizeFromShape(e.shape)/r,s=Xe({inputs:{x:e},attrs:{shape:[i,r]},backend:a}),o=Gh(s,e.dtype,"max",a),u=Xe({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),u}function BL(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:i,keepDims:s}=a,o=r.shape.length,u=O.parseAxisParam(i,r.shape),d=u,c=P.getAxesPermutation(d,o),h=c!=null,m=n.shouldExecuteOnCPU([r]),g=r;if(h){if(m){let C=n.texData.get(g.dataId).values,T=new Array(o);for(let q=0;q<T.length;q++)T[q]=r.shape[c[q]];let N=p_(C,r.shape,r.dtype,c,T);g=n.makeTensorInfo(T,r.dtype);let D=n.texData.get(g.dataId);D.values=N}else g=kS(r,c,n);d=P.getInnerMostAxes(d.length,o)}P.assertAxesAreInnerMostDims("max",d,o);let[x,v]=P.computeOutAndReduceShapes(g.shape,d),S=x;s&&(S=P.expandShapeToKeepDim(x,u));let E;if(m){let C=n.texData.get(g.dataId).values,T=Ile(C,O.sizeFromShape(v),S,r.dtype);E=n.makeTensorInfo(S,r.dtype);let N=n.texData.get(E.dataId);N.values=T}else E=Sfe(g,v,S,n);return h&&n.disposeIntermediateTensorInfo(g),E}var kfe={kernelName:eh,backendName:"webgl",kernelFunc:BL},Afe=f_+`
  return max(a, b);
`,Efe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Hh+`
  return result;
`,Cfe=vr({opSnippet:Afe,packedOpSnippet:Efe,cpuKernelImpl:_le}),Ife={kernelName:th,backendName:"webgl",kernelFunc:Cfe};function _fe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;$g(r,"maxPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:u}=a,d=1;O.assert(P.eitherStridesOrDilationsAreOne(s,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`);let c=P.computePool2DInfo(r.shape,i,s,d,o,u);if(c.filterWidth===1&&c.filterHeight===1&&O.arraysEqual(c.inShape,c.outShape))return Mi({inputs:{x:r},backend:n});let h=new s0(c,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}var Tfe={kernelName:nh,backendName:"webgl",kernelFunc:_fe};function Nfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:i,strides:s,pad:o,dataFormat:u,dimRoundingMode:d}=a,c=[1,1,1],h=P.computePool3DInfo(r.shape,i,s,c,o,d,u),m=new g_(h,"max",!1);return n.runWebGLProgram(m,[r],r.dtype)}var Rfe={kernelName:lg,backendName:"webgl",kernelFunc:Nfe},Ffe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,i=e.effectiveFilterWidth,s=r-1-e.padInfo.top,o=i-1-e.padInfo.left,u=r*i-1;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Dfe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,i=e.dilationHeight,s=e.dilationWidth,o=e.effectiveFilterDepth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,c=o-1-e.padInfo.front,h=u-1-e.padInfo.top,m=d-1-e.padInfo.left,g=o*u*d-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${h}, ${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${s}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${g} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Ofe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,s=i,{filterSize:o,strides:u,pad:d,dimRoundingMode:c}=a,h=[1,1,1],m=P.computePool3DInfo(s.shape,o,u,h,d,c),g=new g_(m,"max",!0),x=n.runWebGLProgram(g,[s],s.dtype),v=new Dfe(m),S=n.runWebGLProgram(v,[r,x],s.dtype);return n.disposeIntermediateTensorInfo(x),S}var Mfe={kernelName:w0,backendName:"webgl",kernelFunc:Ofe};function Bfe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i,output:s}=t,o=i;$g([i,s],"maxPoolGrad");let{filterSize:u,strides:d,pad:c,dimRoundingMode:h}=a,m=P.computePool2DInfo(o.shape,u,d,1,c,h),g=!0,x=new s0(m,"max",g),v=n.runWebGLProgram(x,[o],o.dtype),S=new Ffe(m),E=n.runWebGLProgram(S,[r,v],o.dtype);return n.disposeIntermediateTensorInfo(v),E}var Lfe={kernelName:y0,backendName:"webgl",kernelFunc:Bfe};function zfe(e,t,n,a){let r=new s0(n,"max",!1),i=a.runWebGLProgram(r,[e],"float32");r=new s0(n,"max",!0,!0,t);let s=a.runWebGLProgram(r,[e],"float32");return[i,s]}var Ufe={kernelName:x0,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:i,pad:s,includeBatchInIndex:o}=t,u=n;O.assert(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);let d=[1,1];O.assert(P.eitherStridesOrDilationsAreOne(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=P.computePool2DInfo(a.shape,r,i,d,s),[h,m]=zfe(a,o,c,u);return[h,m]}};function Vfe(e,t,n,a){let r=O.sizeFromShape(t),i=O.sizeFromShape(e.shape)/r,s=Xe({inputs:{x:e},attrs:{shape:[i,r]},backend:a}),o=Gh(s,"float32","mean",a),u=Xe({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),u}var Wfe={kernelName:ah,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{keepDims:r,axis:i}=t,s=n,o=a.shape.length,u=O.parseAxisParam(i,a.shape),d=u,c=P.getAxesPermutation(d,o),h=c!=null,m=s.shouldExecuteOnCPU([a]),g=[],x=a;if(h){if(m){let T=s.texData.get(x.dataId).values,N=new Array(o);for(let H=0;H<N.length;H++)N[H]=a.shape[c[H]];let D=p_(T,a.shape,a.dtype,c,N);x=s.makeTensorInfo(N,a.dtype);let q=s.texData.get(x.dataId);q.values=D}else x=kS(a,c,s);g.push(x),d=P.getInnerMostAxes(d.length,o)}P.assertAxesAreInnerMostDims("sum",d,o);let[v,S]=P.computeOutAndReduceShapes(x.shape,d),E=v;r&&(E=P.expandShapeToKeepDim(v,u));let C=Vfe(x,S,E,s);for(let T of g)s.disposeIntermediateTensorInfo(T);return C}};function qfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:s}=a,o=r.shape.length,u=O.parseAxisParam(i,r.shape),d=u,c=P.getAxesPermutation(d,o),h=r;c!=null&&(h=Gr({inputs:{x:r},backend:n,attrs:{perm:c}}),d=P.getInnerMostAxes(d.length,r.shape.length)),P.assertAxesAreInnerMostDims("min",d,o);let[m,g]=P.computeOutAndReduceShapes(h.shape,d),x=O.sizeFromShape(g),v=Xe({inputs:{x:h},backend:n,attrs:{shape:[-1,x]}}),S=Gh(v,v.dtype,"min",n),E;if(s){let C=P.expandShapeToKeepDim(m,u);E=Xe({inputs:{x:S},backend:n,attrs:{shape:C}})}else E=Xe({inputs:{x:S},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(S),c!=null&&n.disposeIntermediateTensorInfo(h),E}var Pfe={kernelName:rh,backendName:"webgl",kernelFunc:qfe},Hfe=f_+`
  return min(a, b);
`,Gfe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Hh+`
  return result;
`,Kfe=vr({opSnippet:Hfe,packedOpSnippet:Gfe,cpuKernelImpl:Tle}),$fe={kernelName:ih,backendName:"webgl",kernelFunc:Kfe},Jfe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((d,c)=>d[0]+e[c]+d[1]);let a=e.length,r=$n(a),i=t.map(d=>d[0]).join(","),s=t.map((d,c)=>d[0]+e[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),u=n==="reflect"?0:1;if(a===1){this.userCode=`
        int start = ${i};
        int end = ${s};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${i});
      ${r} end = ${r}(${s});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${a}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},Yfe=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((g,x)=>g[0]+e[x]+g[1]);let a=e.length,r=$n(a),i=t.map(g=>g[0]).join(","),s=t.map((g,x)=>g[0]+e[x]).join(","),o=qr("rc",a),u=qr("source",a),d=`${o[a-1]} < ${this.outputShape[a-1]}`,c=a===1?"source":`vec2(${u.slice(-2).join()})`,h=n==="reflect"?0:1,m="";if(a===1){let g=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;m=`
        ${r} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${c});
        ${o[a-1]} += 1;
        if(${d}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${c});
        }
      `}else{let g=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;m=`
        ${r} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${c});
        ${o[a-1]} += 1;
        if(${d}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${c});
        }
        rc = outputLoc;
        ${o[a-2]} += 1;
        if(${o[a-2]} < ${this.outputShape[a-2]}) {
          ${g}
          result[2] = getChannel(getX(${u.join()}), ${c});
          ${o[a-1]} += 1;
          if(${d}) {
            ${g}
            result[3] = getChannel(getX(${u.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${i});
      const ${r} end = ${r}(${s});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}},jfe=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{paddings:r,mode:i}=n,s=Ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Yfe(a.shape,r,i):new Jfe(a.shape,r,i);return t.runWebGLProgram(s,[a],a.dtype)},Qfe={kernelName:sh,backendName:"webgl",kernelFunc:jfe},Zfe=`if (b == 0.0) return NAN;
  return mod(a, b);`,Xfe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Hh+`
  return result;
`,eme=vr({opSnippet:Zfe,packedOpSnippet:Xfe}),tme={kernelName:oh,backendName:"webgl",kernelFunc:eme},nme=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},ame=`
if (a == b) {
  return 1.0;
};
return a / b;`,rme=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,LL=vr({opSnippet:ame,packedOpSnippet:rme,checkOutOfBounds:!0}),ime={kernelName:Lp,backendName:"webgl",kernelFunc:LL},KR="return a - b;",zL=vr({opSnippet:KR,packedOpSnippet:KR,supportsComplex:!0,cpuKernelImpl:jle}),sme={kernelName:Fh,backendName:"webgl",kernelFunc:zL};function UL(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:i}=a,s=O.parseAxisParam([i],r.shape),o=BL({inputs:{x:r},backend:n,attrs:{reductionIndices:s,keepDims:!1}}),u=P.expandShapeToKeepDim(o.shape,s),d=Xe({inputs:{x:o},backend:n,attrs:{shape:u}}),c=zL({inputs:{a:r,b:d},backend:n}),h=DL({inputs:{x:c},backend:n}),m=AS({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:!1}}),g=Xe({inputs:{x:m},backend:n,attrs:{shape:u}}),x=LL({inputs:{a:h,b:g},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),x}var ome={kernelName:Nh,backendName:"webgl",kernelFunc:UL};function lme(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:i,seed:s,normalized:o}=a,u=o?r:UL({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),d=u.shape[0],c=u.shape[1],h=new nme(d,c,i),m=[[s]],g=n.runWebGLProgram(h,[u],"int32",m);return o||n.disposeIntermediateTensorInfo(u),g}var ume={kernelName:ug,backendName:"webgl",kernelFunc:lme},cme=Os+`
  return -x;
`,dme=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function pme(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){let i=n.texData.get(a.dataId),[s,o]=Rle(i.values,a.shape,a.dtype);return n.makeTensorInfo(o,a.dtype,s)}let r;return Ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new fc(a.shape,dme):r=new el(a.shape,cme),n.runWebGLProgram(r,[a],a.dtype)}var hme={kernelName:cg,backendName:"webgl",kernelFunc:pme},fme=cl.nonMaxSuppressionV3Impl;function mme(e){P.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:u}=a,d=n.readSync(r.dataId),c=n.readSync(i.dataId),{selectedIndices:h}=fme(d,c,s,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var gme={kernelName:pg,backendName:"webgl",kernelFunc:mme},bme=cl.nonMaxSuppressionV4Impl;function yme(e){P.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:d}=a,c=n.readSync(r.dataId),h=n.readSync(i.dataId),{selectedIndices:m,validOutputs:g}=bme(c,h,s,o,u,d);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}var wme={kernelName:hg,backendName:"webgl",kernelFunc:yme},xme=cl.nonMaxSuppressionV5Impl;function vme(e){P.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:u,softNmsSigma:d}=a,c=n.readSync(r.dataId),h=n.readSync(i.dataId),m=s,g=o,x=u,v=d,{selectedIndices:S,selectedScores:E}=xme(c,h,m,g,x,v);return[n.makeTensorInfo([S.length],"int32",new Int32Array(S)),n.makeTensorInfo([E.length],"float32",new Float32Array(E))]}var Sme={kernelName:fg,backendName:"webgl",kernelFunc:vme},kme=class{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${a}), float(${n}),
                      float(index == coords.y)));
      }
    `}},Ame=e=>{let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:i,depth:s,onValue:o,offValue:u}=a,d=O.sizeFromShape(r.shape),c=new kme(d,s,o,u),h=Xe({inputs:{x:r},backend:n,attrs:{shape:[d]}}),m=n.runWebGLProgram(c,[h],i);n.disposeIntermediateTensorInfo(h);let g=[...r.shape,s],x=Xe({inputs:{x:m},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(m),x},Eme={kernelName:uh,backendName:"webgl",kernelFunc:Ame};function K1(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="complex64"){let r=uw({inputs:{input:a},backend:n}),i=K1({inputs:{x:r},backend:n}),s=ES({inputs:{input:a},backend:n}),o=K1({inputs:{x:s},backend:n}),u=Gc({inputs:{real:i,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),u}else return cw({attrs:{shape:a.shape,dtype:a.dtype,value:a.dtype==="string"?"":0},backend:n})}var Cme={kernelName:Dg,backendName:"webgl",kernelFunc:K1};function VL(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(a.dtype==="complex64"){let r=uw({inputs:{input:a},backend:n}),i=VL({inputs:{x:r},backend:n}),s=ES({inputs:{input:a},backend:n}),o=K1({inputs:{x:s},backend:n}),u=Gc({inputs:{real:i,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),u}else return cw({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:n})}var Ime={kernelName:mg,backendName:"webgl",kernelFunc:VL};function _me(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return hA({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let i=t[0].shape,s=t[0].dtype;t.forEach(c=>{O.assertShapesMatch(i,c.shape,"All tensors passed to stack must have matching shapes"),O.assert(s===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(c=>{let h=hA({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(h),h}),d=EL({inputs:u,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),d}var Tme={kernelName:gg,backendName:"webgl",kernelFunc:_me},Nme=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,d)=>u[0]+e[d]+u[1]);let a=e.length,r=$n(a),i=t.map(u=>u[0]).join(","),s=t.map((u,d)=>u[0]+e[d]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);if(a===1){this.userCode=`
        int start = ${i};
        int end = ${s};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${i});
      ${r} end = ${r}(${s});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},Rme=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((x,v)=>x[0]+e[v]+x[1]);let a=e.length,r=$n(a),i=t.map(x=>x[0]).join(","),s=t.map((x,v)=>x[0]+e[v]).join(","),o=qr("rc",a),u=qr("source",a),d=`${o[a-1]} < ${this.outputShape[a-1]}`,c=a===1?"source":`vec2(${u.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${o[a-1]} += 1;
       if(${d}) {
      `,a===1?"":`}
       rc = outputLoc;
       ${o[a-2]} += 1;
       if(${o[a-2]} < ${this.outputShape[a-2]}) {`,a===1?"":`  ${o[a-1]} += 1;
         if(${d}) {`],m=a===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",g="";for(let x=0,v=a===1?2:4;x<v;x++)g+=`
        ${h[x]}
        if (${m}) {
          result[${x}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${x}] = getChannel(getX(${u.join()}), ${c});
        }
      `;g+=a===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${i});
      const ${r} end = ${r}(${s});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}},WL=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:i,constantValue:s}=a;if(O.sizeFromShape(r.shape)===0){let d=i.map((c,h)=>c[0]+r.shape[h]+c[1]);return cw({backend:n,attrs:{shape:d,value:s,dtype:r.dtype}})}let o=Ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rme(r.shape,i,s):new Nme(r.shape,i,s),u=[[s]];return n.runWebGLProgram(o,[r],r.dtype,u)},Fme={kernelName:ch,backendName:"webgl",kernelFunc:WL},Dme=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Ome=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Hh+`
  return result;
`,Mme=vr({opSnippet:Dme,packedOpSnippet:Ome}),Bme={kernelName:dh,backendName:"webgl",kernelFunc:Mme};function Lme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:s}=a,o=r.shape.length,u=[],d=O.parseAxisParam(i,r.shape),c=d,h=P.getAxesPermutation(c,o),m=r;h!=null&&(m=Gr({inputs:{x:r},backend:n,attrs:{perm:h}}),c=P.getInnerMostAxes(c.length,o),u.push(m)),P.assertAxesAreInnerMostDims("prod",c,o);let g;if(n.shouldExecuteOnCPU([m])){let x=n.texData.get(m.dataId).values,{outVals:v,outShape:S,outDtype:E}=Dle(m.shape,m.dtype,x,c);g=n.makeTensorInfo(S,E,v)}else{let[x,v]=P.computeOutAndReduceShapes(m.shape,c),S=O.sizeFromShape(v),E=Xe({inputs:{x:m},backend:n,attrs:{shape:[-1,S]}}),C=bv(r.dtype),T=Gh(E,C,"prod",n);g=Xe({inputs:{x:T},backend:n,attrs:{shape:x}}),u.push(E),u.push(T)}if(s){u.push(g);let x=P.expandShapeToKeepDim(g.shape,d);g=Xe({inputs:{x:g},backend:n,attrs:{shape:x}})}return u.forEach(x=>n.disposeIntermediateTensorInfo(x)),g}var zme={kernelName:hh,backendName:"webgl",kernelFunc:Lme};function Ume(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:i,indices:s}=t,{outputRaggedRank:o}=a,u=r.map(E=>n.readSync(E.dataId)),d=r.map(E=>E.shape),c=n.readSync(i.dataId),h=n.readSync(s.dataId),[m,g,x]=Ole(u,d,c,i.shape,i.dtype,h,s.shape,o),v=m.map(E=>n.makeTensorInfo([E.length],"int32",E)),S=n.makeTensorInfo(x,i.dtype,g);return v.concat([S])}var Vme={kernelName:pv,backendName:"webgl",kernelFunc:Ume};function Wme(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:i}=t,s=n.readSync(a.dataId),o=n.readSync(r.dataId),u=n.readSync(i.dataId),[d,c]=Mle(s,a.shape,a.dtype,o,r.shape,u,i.shape),h=n.makeTensorInfo([d.length],"int32",d),m=n.makeTensorInfo([c.length],a.dtype,c);return[h,m]}var qme={kernelName:hv,backendName:"webgl",kernelFunc:Wme};function Pme(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:i,defaultValue:s,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=a,d=n.readSync(r.dataId),c=n.readSync(i.dataId),h=n.readSync(s.dataId),m=o.map(S=>n.readSync(S.dataId)),g=o.map(S=>S.shape),[x,v]=Ble(d,r.shape,c,i.shape,i.dtype,h,s.shape,m,g,u);return n.makeTensorInfo(x,i.dtype,v)}var Hme={kernelName:fv,backendName:"webgl",kernelFunc:Pme},qL=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:i,dtype:s}=n,o=Lle(a,r,i,s);return t.makeTensorInfo([o.length],s,o)},Gme={kernelName:v0,backendName:"webgl",kernelFunc:qL},Kme="return 1.0 / x;",$me=yn({opSnippet:Kme}),Jme={kernelName:fh,backendName:"webgl",kernelFunc:$me},Yme=Os+`
  return (x < 0.0) ? 0.0 : x;
`,jme=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Qme=yn({opSnippet:Yme,packedOpSnippet:jme}),Zme={kernelName:mh,backendName:"webgl",kernelFunc:Qme},Xme=Os+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ege=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tge=yn({opSnippet:Xme,packedOpSnippet:ege}),nge={kernelName:yh,backendName:"webgl",kernelFunc:tge},age=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];let[i,s,o,u]=e;this.outputShape=[i,t,n,u];let d=[a&&t>1?s-1:s,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],h;r?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/c[0]},
          ${d[1]/c[1]});
      const vec2 inputShapeRC = vec2(${s}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},rge=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,s,o,u]=e;this.outputShape=[i,t,n,u];let d=[a&&t>1?s-1:s,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],h;r?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/c[0]},
          ${d[1]/c[1]},
          ${d[1]/c[1]});
      const vec3 inputShapeRC = vec3(${s}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function ige(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:s,size:o}=a,[u,d]=o,c=Ae().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new rge(r.shape,u,d,i,s):new age(r.shape,u,d,i,s);return n.runWebGLProgram(c,[r],"float32")}var sge={kernelName:bh,backendName:"webgl",kernelFunc:ige},oge=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,i,s]=e,o=[n&&i>1?a-1:a,n&&s>1?r-1:r],u=[n&&i>1?i-1:i,n&&s>1?s-1:s],d=o[0]/u[0],c=o[1]/u[1],h=1/d,m=1/c,g=Math.ceil(h)*2+2,x=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${c});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${s}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function lge(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:i}=t,{alignCorners:s}=a,o=new oge(i.shape,r.shape,s);return n.runWebGLProgram(o,[i],i.dtype)}var uge={kernelName:wg,backendName:"webgl",kernelFunc:lge},cge=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];let[i,s,o,u]=e;this.outputShape=[i,t,n,u];let d=[a&&t>1?s-1:s,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0",m;r?m="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/c[0]},
          ${d[1]/c[1]});
      const vec2 inputShapeRC = vec2(${s}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},dge=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,s,o,u]=e;this.outputShape=[i,t,n,u];let d=[a&&t>1?s-1:s,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0",m;r?m="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/c[0]},
          ${d[1]/c[1]},
          ${d[1]/c[1]});
      const vec3 inputShapeRC = vec3(${s}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function pge(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:s,size:o}=a,[u,d]=o,c=Ae().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new dge(r.shape,u,d,i,s):new cge(r.shape,u,d,i,s);return n.runWebGLProgram(c,[r],r.dtype)}var hge={kernelName:gh,backendName:"webgl",kernelFunc:pge},fge=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,i,s]=e,o=[n&&i>1?a-1:a,n&&s>1?r-1:r],u=[n&&i>1?i-1:i,n&&s>1?s-1:s],d=o[0]/u[0],c=o[1]/u[1],h=1/d,m=1/c,g=Math.ceil(h)*2+2,x=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${c});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${s}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function mge(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:i}=t,{alignCorners:s}=a,o=new fge(i.shape,r.shape,s);return n.runWebGLProgram(o,[i],i.dtype)}var gge={kernelName:yg,backendName:"webgl",kernelFunc:mge},bge=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let a=s=>t.indexOf(s)!==-1&&e[s]!==1?`${e[s]} - coords[${s}] - 1`:`coords[${s}]`,r=e.map((s,o)=>a(o)).join(","),i=$n(n);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}},yge=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let a=qr("rc",n),r=`${a[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${a[n-2]} + 1 < ${this.outputShape[n-2]}`,s=$n(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(a.slice())};
          if(${r}){
            result.g = ${u(a.slice())};
          }
          if(${i}) {
            result.b = ${d(a.slice())};
            if(${r}) {
              result.a = ${c(a.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(g){return h(g)}function u(g){return g[n-1]="("+g[n-1]+" + 1)",h(g)}function d(g){return g[n-2]="("+g[n-2]+" + 1)",h(g)}function c(g){return g[n-1]="("+g[n-1]+" + 1)",g[n-2]="("+g[n-2]+" + 1)",h(g)}function h(g){let x=e.map((E,C)=>m(C,g)),v=x.join(","),S=x.slice(-2).join(",");return`getChannel(getX(${v}), vec2(${S}))`}function m(g,x){return t.indexOf(g)!==-1&&e[g]!==1?`${e[g]} - ${x[g]} - 1`:`${x[g]}`}}};function wge(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:i}=a,s=r.shape.length,o=O.parseAxisParam(i,r.shape);if(s===0)return Mi({inputs:{x:r},backend:n});let u=Ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yge(r.shape,o):new bge(r.shape,o);return n.runWebGLProgram(u,[r],r.dtype)}var xge={kernelName:wh,backendName:"webgl",kernelFunc:wge},vge=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],a=e[2];this.outputShape=e;let r="";typeof t=="number"?r=`float outputValue = ${t.toFixed(2)};`:r=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Sge={kernelName:Og,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:i,center:s}=t,o=n,u=new vge(a.shape,i),[d,c]=P.getImageCenter(s,a.shape[1],a.shape[2]),h=[[d,c,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(u,[a],a.dtype,h)}},kge=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Age=yn({opSnippet:kge}),Ege={kernelName:xh,backendName:"webgl",kernelFunc:Age},Cge="return inversesqrt(x);",Ige=yn({opSnippet:Cge,cpuKernelImpl:zle}),_ge={kernelName:vh,backendName:"webgl",kernelFunc:Ige},b_=class{constructor(e,t,n,a,r,i,s=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let u=$n(r.length),d=$n(i.length),c="";n===1?c="i":n===2&&(c="i, j");let h=`getIndices(${c})`,m="";a===1?m="i":a===2&&(m="i, coords[1]");let g=`getUpdates(${m})`,x="";o&&(x="coords[0], coords[1]");let v=`getDefaultValue(${x})`,S=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${r});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${S};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${g};
              found = true;
            }
          }
          setOutput(mix(${v}, sum, float(found)));
        }
      `}},Tge=class{constructor(e,t,n,a,r,i,s=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let u=$n(r.length),d=$n(i.length),c="";n===1?c="i":n===2&&(c="i, j");let h=`getIndices(${c})`,m="";a===1?m="i":a===2&&(m="i, coords[1]");let g=`getUpdates(${m})`,x="";o&&(x="coords[0], coords[1]");let v=`getDefaultValue(${x})`,S=t>1?"strides[j]":"strides",E=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${r});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${S};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${E};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${g};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${v}, sum, found));
        }
      `}};function Nge(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:i}=t,{shape:s}=a,{sliceRank:o,numUpdates:u,sliceSize:d,strides:c,outputSize:h}=P.calculateShapes(i,r,s),m=[h/d,d];if(h===0)return n.makeTensorInfo(s,r.dtype);let g=Xe({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),x=Xe({inputs:{x:i},backend:n,attrs:{shape:[u,d]}}),v=n.makeTensorInfo([],"float32",new Float32Array([0])),S;Ae().getBool("WEBGL_PACK")?S=new Tge(u,o,g.shape.length,x.shape.length,c,m):S=new b_(u,o,g.shape.length,x.shape.length,c,m);let E=n.runWebGLProgram(S,[x,g,v],x.dtype),C=Xe({inputs:{x:E},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(E),n.disposeIntermediateTensorInfo(v),C}var Rge={kernelName:xg,backendName:"webgl",kernelFunc:Nge},Fge=class{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let r="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=Ae().getNumber("WEBGL_VERSION")===2?r:i,o=a==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${s}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Dge(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:i}=t,{side:s}=a,o=new Fge(r.shape[0],r.shape[1],i.shape[1],s),u=[[r.shape[1]]];return n.runWebGLProgram(o,[r,i],"int32",u)}var Oge={kernelName:Sg,backendName:"webgl",kernelFunc:Dge},Mge=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let a,r;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)r="resRC",a="resRC";else{let s=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],u=[];for(let d=0;d<t.length;d++)u.push(`${s[d]}`),d<e&&o.push(`${s[d]}`);a=o.join(),r=u.join()}let i=$n(n);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${a});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}};function Bge(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:i}=t,s=new Mge(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(s,[a,r,i],as(r.dtype,i.dtype))}var Lge={kernelName:kg,backendName:"webgl",kernelFunc:Bge},zge=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${P.SELU_SCALEALPHA};
  float scale = ${P.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Uge=yn({opSnippet:zge}),Vge={kernelName:Sh,backendName:"webgl",kernelFunc:Uge},Wge=Xg+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,qge=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Pge=yn({opSnippet:Wge,packedOpSnippet:qge,cpuKernelImpl:Vle}),Hge={kernelName:Ch,backendName:"webgl",kernelFunc:Pge},Gge=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Kge=yn({opSnippet:Gge}),$ge={kernelName:Eh,backendName:"webgl",kernelFunc:Kge},Jge=Xg+`
  return sin(x);
`,Yge=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Hh}
  return result;
`,jge=yn({opSnippet:Jge,packedOpSnippet:Yge}),Qge={kernelName:kh,backendName:"webgl",kernelFunc:jge},Zge=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Xge=yn({opSnippet:Zge}),ebe={kernelName:Ah,backendName:"webgl",kernelFunc:Xge},tbe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,nbe=yn({opSnippet:tbe}),abe={kernelName:Ih,backendName:"webgl",kernelFunc:nbe},rbe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:i,paddings:s}=a;O.assert(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=i.reduce((E,C)=>E*C),u=[[0,0]];u.push(...s);for(let E=1+i.length;E<r.shape.length;++E)u.push([0,0]);let d=[],c=WL({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),h=P.getReshaped(c.shape,i,o,!1),m=P.getPermuted(h.length,i.length,!1),g=P.getReshapedPermuted(c.shape,i,o,!1),x=Xe({inputs:{x:c},backend:n,attrs:{shape:h}}),v=Gr({inputs:{x},backend:n,attrs:{perm:m}}),S=Xe({inputs:{x:v},backend:n,attrs:{shape:g}});return d.push(c),d.push(x),d.push(v),d.forEach(E=>n.disposeIntermediateTensorInfo(E)),S},ibe={kernelName:Eg,backendName:"webgl",kernelFunc:rbe};function sbe(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:i,defaultValue:s}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(s.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${s.shape}`);let o=n.readSync(a.dataId),u=n.readSync(r.dataId),d=n.readSync(i.dataId),c=n.readSync(s.dataId)[0],[h,m,g,x,v]=qle(o,a.shape,a.dtype,u,r.dtype,d,c);return[n.makeTensorInfo(m,a.dtype,h),n.makeTensorInfo([m[0]],r.dtype,g),n.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(S=>Number(S)))),n.makeTensorInfo([v.length],a.dtype,new Int32Array(v))]}var obe={kernelName:S0,backendName:"webgl",kernelFunc:sbe};function lbe(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:i}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let s=Array.from(n.readSync(r.dataId)),o=n.readSync(a.dataId),u=Array.from(n.readSync(i.dataId)),[d,c,h]=Ple(o,a.shape,a.dtype,s,u);return[n.makeTensorInfo(c,a.dtype,d),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}var ube={kernelName:Ig,backendName:"webgl",kernelFunc:lbe};function cbe(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:i}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);let s=n.readSync(a.dataId),o=n.readSync(r.dataId),u=n.readSync(i.dataId),[d,c]=cL(s,a.shape,a.dtype,o,u,!0);return n.makeTensorInfo(c,a.dtype,d)}var dbe={kernelName:k0,backendName:"webgl",kernelFunc:cbe};function pbe(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:i}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);let s=n.readSync(a.dataId),o=n.readSync(r.dataId),u=n.readSync(i.dataId),[d,c]=cL(s,a.shape,a.dtype,o,u);return n.makeTensorInfo(c,a.dtype,d)}var hbe={kernelName:A0,backendName:"webgl",kernelFunc:pbe};function fbe(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:i,defaultValue:s}=t,{outputShape:o}=a,{sliceRank:u,numUpdates:d,sliceSize:c,strides:h,outputSize:m}=P.calculateShapes(i,r,o),g=!1;if(i.dtype==="string"){let E=n.bufferSync(r),C=n.bufferSync(i),T=O.decodeString(n.readSync(s.dataId)[0]),N=Ule(E,C,o,m,c,d,u,h,T,g);return n.makeTensorInfo(o,N.dtype,N.values)}let x=new b_(d,u,r.shape.length,i.shape.length,h,[m,1],g),v=n.runWebGLProgram(x,[i,r,s],i.dtype),S=Xe({inputs:{x:v},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(v),S}var mbe={kernelName:_g,backendName:"webgl",kernelFunc:fbe};function gbe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:i,axis:s}=a,o=O.parseAxisParam(s,r.shape)[0],u=P.prepareSplitSize(r,i,o),d=r.shape.length,c=new Array(d).fill(0),h=r.shape.slice();return u.map(m=>{let g=[...h];g[o]=m;let x=eb({inputs:{x:r},backend:n,attrs:{begin:c,size:g}});return c[o]+=m,x})}var bbe={kernelName:Cg,backendName:"webgl",kernelFunc:gbe},$R="return sqrt(x);",ybe=yn({opSnippet:$R,packedOpSnippet:$R,cpuKernelImpl:Hle}),wbe={kernelName:_h,backendName:"webgl",kernelFunc:ybe},xbe="return x * x;",vbe=yn({opSnippet:xbe}),Sbe={kernelName:E0,backendName:"webgl",kernelFunc:vbe},JR="return (a - b) * (a - b);",kbe=vr({opSnippet:JR,packedOpSnippet:JR}),Abe={kernelName:Rh,backendName:"webgl",kernelFunc:kbe};function Ebe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");let i=n.readSync(r.dataId),s=P.fromUint8ToStringArray(i),o=Gle(s,"string",a);return n.makeTensorInfo(r.shape,"string",o)}var Cbe={kernelName:C0,backendName:"webgl",kernelFunc:Ebe};function Ibe({inputs:e,attrs:t,backend:n}){let{x:a}=e,r=Os+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,i=new el(a.shape,r);return n.runWebGLProgram(i,[a],a.dtype)}var _be={kernelName:zc,backendName:"webgl",kernelFunc:Ibe},Tbe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let a=n.length,r=$n(n.length),i=$n(n.length),s="";if(a===1)s="coords * strides + begin";else{let o=0;s=n.map((u,d)=>(o++,n.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${o-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};function Nbe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:i,end:s,strides:o,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:m}=a,{finalShapeSparse:g,finalShape:x,isIdentity:v,sliceDim0:S,isSimpleSlice:E,begin:C,end:T,strides:N}=$a.sliceInfo(r.shape,i,s,o,u,d,c,h,m),D;if(v)D=Xe({inputs:{x:r},backend:n,attrs:{shape:x}});else if(S||E){O.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let H=$a.computeOutShape(C,T,N),K=eb({inputs:{x:r},backend:n,attrs:{begin:C,size:H}});D=Xe({inputs:{x:K},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(K)}else if(n.shouldExecuteOnCPU([r])){let H=n.readSync(r.dataId),K=Zt(r.shape,r.dtype,H),j=Kle(g,K,N,C);D=n.makeTensorInfo(x,r.dtype,j.values)}else{let H=new Tbe(C,N,g);D=n.runWebGLProgram(H,[r],r.dtype)}let q=Xe({inputs:{x:D},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(D),q}var Rbe={kernelName:Tg,backendName:"webgl",kernelFunc:Nbe};function Fbe(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:i,leftPad:s,rightPad:o,padWidth:u,preserveShortSequences:d}=a,{data:c,dataSplits:h}=t,m=n.readSync(c.dataId),g=n.readSync(h.dataId),[x,v]=$le(m,g,r,i,s,o,u,d);return[n.makeTensorInfo([x.length],"string",x),n.makeTensorInfo(h.shape,"int32",v)]}var Dbe={kernelName:I0,backendName:"webgl",kernelFunc:Fbe};function Obe(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:i,delimiter:s}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(s.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);let o=n.readSync(i.dataId),u=n.readSync(s.dataId)[0],[d,c,h]=Jle(o,u,r),m=c.length;return[n.makeTensorInfo([m,2],"int32",d),n.makeTensorInfo([m],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var Mbe={kernelName:_0,backendName:"webgl",kernelFunc:Obe};function Bbe(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let s=n.readSync(i.dataId),o=Yle(s,r);return n.makeTensorInfo(i.shape,"int32",o)}var Lbe={kernelName:T0,backendName:"webgl",kernelFunc:Bbe},zbe="return tan(x);",Ube=yn({opSnippet:zbe}),Vbe={kernelName:Dh,backendName:"webgl",kernelFunc:Ube},Wbe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,qbe=yn({opSnippet:Wbe}),Pbe={kernelName:Oh,backendName:"webgl",kernelFunc:qbe};function Hbe(e){let{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:i,updates:s}=t,{sliceRank:o,numUpdates:u,sliceSize:d,strides:c,outputSize:h}=P.calculateShapes(s,i,r.shape),m=[h/d,d];if(h===0)return n.makeTensorInfo(r.shape,i.dtype);let g=Xe({inputs:{x:i},backend:n,attrs:{shape:[u,o]}}),x=Xe({inputs:{x:s},backend:n,attrs:{shape:[u,d]}}),v=Xe({inputs:{x:r},backend:n,attrs:{shape:m}}),S=new b_(u,o,g.shape.length,x.shape.length,c,m,!1,!0),E=n.runWebGLProgram(S,[x,g,v],v.dtype),C=Xe({inputs:{x:E},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(E),C}var Gbe={kernelName:vg,backendName:"webgl",kernelFunc:Hbe},Kbe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.rank=n.length;let a=$n(this.rank),r=$be(e);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}};function $be(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push(`imod(${n[r]}, ${e[r]})`);return a.join()}function PL(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:i}=a;if(r.dtype==="string"||r.shape.length>5){let o=n.readSync(r.dataId),u=r.dtype==="string"?o.map(h=>O.decodeString(h)):o,d=Zt(r.shape,r.dtype,u),c=Qle(d,i);return n.makeTensorInfo(c.shape,c.dtype,c.values)}let s=new Kbe(r.shape,i);return n.runWebGLProgram(s,[r],r.dtype)}var Jbe={kernelName:Lc,backendName:"webgl",kernelFunc:PL},Ybe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},jbe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Od(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function YR(e){let t=1;for(;t<e;)t*=2;return t}function Qbe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:i,sorted:s}=a,o=Ae().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=Ae().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),d=r.shape,c=d[d.length-1];if(n.shouldExecuteOnCPU([r])||c<o||i>u){let j=n.readSync(r.dataId),[te,Q]=Zle(j,d,r.dtype,i,s);return[n.makeTensorInfo(te.shape,te.dtype,te.values),n.makeTensorInfo(Q.shape,Q.dtype,Q.values)]}if(i===0)return d[d.length-1]=0,[n.makeTensorInfo(d,r.dtype,[]),n.makeTensorInfo(d,"int32",[])];if(c===1)return[r,cw({attrs:{shape:d,dtype:"int32",value:0},backend:n})];let h=n.texData.get(r.dataId),m=h!==null&&h.isPacked,g=m?n.unpackTensor(r):r,x=O.sizeFromShape(d)/c,v=Xe({inputs:{x:g},attrs:{shape:[x,c]},backend:n});m&&Od(n,g);let S=YR(i),E=YR(c),C=null,T=()=>C===null?[v,v]:[v,C],N=(j,te,Q)=>{let z=T(),ae=new Ybe(Q),ue=[[c],[C===null?1:0],[Number.NEGATIVE_INFINITY],[j],[te]],he=C;C=n.runWebGLProgram(ae,z,"int32",ue),Od(n,he)};for(let j=1;j<S;j*=2){let te=j*2;for(let Q=j;Q>=1;Q/=2)N(te,Q,[x,E])}for(let j=E;j>S;j/=2){let te=T(),Q=new jbe([x,j/2]),z=[[c],[C===null?1:0],[S]],ae=C;C=n.runWebGLProgram(Q,te,"int32",z),Od(n,ae);let ue=S/2,he=ue*2;for(let Z=ue;Z>=1;Z/=2)N(he,Z,C.shape)}let D=C;C=eb({inputs:{x:C},backend:n,attrs:{begin:0,size:[x,i]}}),Od(n,D);let q=ML({inputs:{x:v,indices:C},backend:n,attrs:{axis:1,batchDims:1}});Od(n,v);let H=d.slice(0,-1);H.push(i),D=C,C=Xe({inputs:{x:C},attrs:{shape:H},backend:n}),Od(n,D);let K=q;return q=Xe({inputs:{x:q},attrs:{shape:H},backend:n}),Od(n,K),[q,C]}var Zbe={kernelName:Ng,backendName:"webgl",kernelFunc:Qbe},Xbe=class{constructor(e,t,n,a,r,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let s=n==="nearest"?1:2,o;switch(a){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${s} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function eye(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:i}=t,{interpolation:s,fillMode:o,fillValue:u,outputShape:d}=a,[c,h,m,g]=r.shape,[x,v]=d??[h,m],S=[c,x,v,g],E=new Xbe(h,m,s,o,u,S);return n.runWebGLProgram(E,[r,i],"float32")}var tye={kernelName:Rg,backendName:"webgl",kernelFunc:eye};function nye(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:i}=t;$g(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let s=a.readSync(i.dataId),{outputValues:o,outputShape:u,indices:d}=Xle(s,r,i.shape,i.dtype);return[a.makeTensorInfo(u,i.dtype,o),a.makeTensorInfo([d.length],"int32",d)]}var aye={kernelName:N0,backendName:"webgl",kernelFunc:nye};function rye(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:i}=a;i<0&&(i+=r.shape.length);let s=r,o=s.shape.length,u=r.shape[i],d=new Array(o-1),c=0;for(let v=0;v<o;v++)v!==i&&(d[c++]=s.shape[v]);let h=[],m=new Array(o).fill(0),g=s.shape.slice();g[i]=1;let x=new Array(u);for(let v=0;v<x.length;v++){m[i]=v;let S=eb({inputs:{x:s},backend:n,attrs:{begin:m,size:g}}),E=Xe({inputs:{x:S},backend:n,attrs:{shape:d}});x[v]=E,h.push(S)}return h.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}var iye={kernelName:Fg,backendName:"webgl",kernelFunc:rye},sye=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,a=e.batchSize,r=e.inSize,i=e.numSegments,s=i*Math.ceil(r/n);this.outputShape=[a,s];let o="0.0",u="sumValue",d=Math.floor(n/4)*4,c=n%4,h=`
        sumValue += dot(values, segFilter);
    `,m="";r%n>0&&(m=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let g="";r%n>0&&(g=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${g}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${d};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${u});
      }
    `}};function oye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:i}=t,{numSegments:s}=a,o=r.shape.length,u=[],d=0,c=P.getAxesPermutation([d],o),h=r;c!=null&&(h=Gr({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(h),d=P.getInnerMostAxes(1,o)[0]);let m=P.segment_util.computeOutShape(h.shape,d,s),g=O.sizeFromShape([h.shape[d]]),x=Xe({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}});u.push(x);let v=bv(r.dtype),S=(N,D,q,H,K)=>{let j=N.shape[0],te=N.shape[1],Q=P.segment_util.segOpComputeOptimalWindowSize(te,K),z={windowSize:Q,inSize:te,batchSize:j,numSegments:K},ae=new sye(z,D),ue=n.compileAndRun(ae,[N,q],H);if(u.push(ue),ue.shape[1]===K)return ue;let he=qL({backend:n,attrs:{start:0,stop:K,step:1,dtype:"float32"}}),Z=PL({inputs:{x:he},backend:n,attrs:{reps:[te/Q]}});return u.push(he),u.push(Z),S(ue,D,Z,H,K)},E=S(x,"unsortedSegmentSum",i,v,s),C=Xe({inputs:{x:E},backend:n,attrs:{shape:m}}),T=C;if(c!=null){u.push(C);let N=P.getUndoAxesPermutation(c);T=Gr({inputs:{x:T},backend:n,attrs:{perm:N}})}return u.forEach(N=>n.disposeIntermediateTensorInfo(N)),T}var lye={kernelName:R0,backendName:"webgl",kernelFunc:oye},uye=[Kue,Jue,Que,ece,nce,ice,oce,uce,hce,mce,yce,vce,Ace,_ce,Rce,Dce,Mce,Uce,Wce,Pce,$ce,ede,nde,sde,lde,fde,gde,xde,Tue,kde,_de,Fde,zde,Wde,Pde,Gde,$de,Qde,epe,ape,ipe,ope,upe,ppe,fpe,ype,xpe,kpe,Cpe,_pe,Fpe,Bpe,Vpe,Ppe,Kpe,$pe,Ype,Qpe,Xpe,the,ahe,ohe,che,hhe,mhe,yhe,vhe,Ehe,The,_ue,Rhe,Cde,Ohe,Lhe,Vhe,Rue,Hhe,Jhe,jhe,efe,afe,ofe,cfe,ffe,yfe,vfe,kfe,Ife,Tfe,Rfe,Mfe,Lfe,Ufe,Wfe,Pfe,$fe,Qfe,tme,ume,Oue,hme,gme,wme,Sme,cde,Eme,Ime,Tme,Fme,Bme,Due,zme,Vme,qme,Hme,Gme,dde,ime,Jme,Zme,nge,Bue,sge,uge,hge,gge,xge,Sge,Ege,_ge,Rge,Oge,Lge,Vge,Hge,$ge,Qge,ebe,Zce,ome,abe,ibe,obe,ube,dbe,hbe,mbe,bbe,wbe,Sbe,Abe,Cbe,_be,Rbe,Dbe,Mbe,Lbe,sme,Pue,Vbe,Pbe,Gbe,Jbe,Zbe,tye,Hue,aye,iye,lye,Cme];for(let e of uye)F0(e);var Sn;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(Sn||(Sn={}));var l0;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(l0||(l0={}));var HL;function cye(e){HL=e.wasm.cwrap(jd,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function dye(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:i,bias:s,preluActivationWeights:o}=t;if(r.dtype!=="float32"||i.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:d,activation:c,leakyreluAlpha:h}=a,m=n.dataIdMap.get(r.dataId).id,g=n.dataIdMap.get(i.dataId).id,x=0;if(s!=null){let K=n.dataIdMap.get(s.dataId);if(K.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${K.shape.length}.`);x=K.id}let v=o==null?0:n.dataIdMap.get(o.dataId).id,S=l0[c];if(S==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let E=u?r.shape[2]:r.shape[1],C=d?i.shape[1]:i.shape[2],T=Mg.assertAndGetBroadcastShape(r.shape.slice(0,-2),i.shape.slice(0,-2)),N=n.makeOutput([...T,E,C],r.dtype),D=n.dataIdMap.get(N.dataId).id,q=new Uint8Array(new Int32Array(r.shape).buffer),H=new Uint8Array(new Int32Array(i.shape).buffer);return HL(m,q,r.shape.length,g,H,i.shape.length,u,d,S,x,v,h||0,D),N}var pye={kernelName:jd,backendName:"wasm",setupFunc:cye,kernelFunc:dye};function bn(e,t){let n;function a(i){n=i.wasm.cwrap(e,null,["number","number","number"])}function r(i){let{backend:s,inputs:{x:o}}=i,u=s.dataIdMap.get(o.dataId).id,d=s.makeOutput(o.shape,t||o.dtype),c=s.dataIdMap.get(d.dataId).id;return O.sizeFromShape(d.shape)===0||n(u,Sn[o.dtype],c),d}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:r}}var hye=bn(Dm),fye=bn(bp),mye=bn(yp);function Ua(e,t,n){let a;function r(s){a=s.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function i(s){let{backend:o,inputs:u}=s,{a:d,b:c}=u,h=o.dataIdMap.get(d.dataId).id,m=o.dataIdMap.get(c.dataId).id,g=n??d.dtype,x=P.assertAndGetBroadcastShape(d.shape,c.shape),v=o.makeOutput(x,g);if(O.sizeFromShape(x)===0)return v;let S=new Uint8Array(new Int32Array(d.shape).buffer),E=new Uint8Array(new Int32Array(c.shape).buffer),C=o.dataIdMap.get(v.dataId).id;return a(h,S,d.shape.length,m,E,c.shape.length,Sn[d.dtype],C),v}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:i}}var gye=Ua(Mc),GL;function bye(e){GL=e.wasm.cwrap(wp,null,["array","number","number","number"])}function yye(e){let{inputs:t,backend:n}=e,a=n.makeOutput(t[0].shape,t[0].dtype);if(O.sizeFromShape(a.shape)===0)return a;let r=t.map(o=>n.dataIdMap.get(o.dataId).id),i=new Uint8Array(new Int32Array(r).buffer),s=n.dataIdMap.get(a.dataId).id;return GL(i,r.length,Sn[a.dtype],s),a}var wye={kernelName:wp,backendName:"wasm",setupFunc:bye,kernelFunc:yye};function CS(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return Pr(n.readSync(t.dataId),t.shape,t.dtype);let a=n.makeOutput(t.shape,t.dtype),r=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(a).set(r),a}var xye={kernelName:Kp,backendName:"wasm",kernelFunc:CS},KL;function vye(e){KL=e.wasm.cwrap(Xl,null,["number","array","number","number","number","array","number"])}function Rc(e){let{inputs:t,backend:n,attrs:a}=e,[r,i]=kye(t.x.shape,a.perm),s=!0;for(let x=0;x<i.length;x++)i[x]!==x&&(s=!1);let o=Sye(t.x.shape,a.perm),u={dataId:t.x.dataId,shape:r,dtype:t.x.dtype};if(s){let x=CS({inputs:t,backend:n});return x.shape=o,x}let d=n.makeOutput(o,u.dtype),c=n.dataIdMap.get(u.dataId).id,h=n.dataIdMap.get(d.dataId).id,m=new Uint8Array(new Int32Array(i).buffer),g=new Uint8Array(new Int32Array(u.shape).buffer);return KL(c,g,u.shape.length,Sn[u.dtype],h,m,i.length),d}function Sye(e,t){let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];return n}function kye(e,t){let n=[],a=[];for(let r=0;r<e.length;++r)e[r]!==1&&n.push(e[r]),e[t[r]]!==1&&a.push(t[r]);for(let r=0;r<a.length;++r){let i=-1;for(let s=0;s<a.length;++s)a[s]>=r&&(i===-1||a[i]>a[s])&&(i=s);a[i]=r}return[n,a]}var Aye={kernelName:Xl,backendName:"wasm",kernelFunc:Rc,setupFunc:vye};function Kc(e,t,n){let a=e.shape,r=e.shape.length,i=O.parseAxisParam(t,a),s=i,o=P.getAxesPermutation(s,r),u=null,d=!1;if(o!=null){let c=new Array(r);for(let m=0;m<c.length;m++)c[m]=a[o[m]];s=P.getInnerMostAxes(s.length,r),u=Rc({inputs:{x:e},attrs:{perm:o},backend:n});let h=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(u.dataId).id!==h&&(d=!0)}return{transposed:u,originalAxes:i,axes:s,inputWasTransposed:d}}var $L;function Eye(e){$L=e.wasm.cwrap(Om,null,["number, number, number"])}function Cye(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:i}=a,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,u=s,{transposed:d,axes:c,originalAxes:h,inputWasTransposed:m}=Kc(s,r,t);if(m){let C=t.dataIdMap.get(d.dataId).id;u=d,o=C}let g=u.shape.length;P.assertAxesAreInnerMostDims("all",c,g);let[x,v]=P.computeOutAndReduceShapes(u.shape,c),S=O.sizeFromShape(v),E=t.makeOutput(x,s.dtype);if(O.sizeFromShape(u.shape)!==0){let C=t.dataIdMap.get(E.dataId).id;$L(o,S,C)}if(m&&t.disposeData(d.dataId),i){let C=P.expandShapeToKeepDim(E.shape,h);E.shape=C}return E}var Iye={kernelName:Om,backendName:"wasm",setupFunc:Eye,kernelFunc:Cye},JL;function _ye(e){JL=e.wasm.cwrap(Mm,null,["number, number, number"])}function Tye(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:i}=a,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,u=s,{transposed:d,axes:c,originalAxes:h,inputWasTransposed:m}=Kc(s,r,t);if(m){let C=t.dataIdMap.get(d.dataId).id;u=d,o=C}let g=u.shape.length;P.assertAxesAreInnerMostDims("any",c,g);let[x,v]=P.computeOutAndReduceShapes(u.shape,c),S=O.sizeFromShape(v),E=t.makeOutput(x,s.dtype);if(O.sizeFromShape(u.shape)!==0){let C=t.dataIdMap.get(E.dataId).id;JL(o,S,C)}if(m&&t.disposeData(d.dataId),i){let C=P.expandShapeToKeepDim(E.shape,h);E.shape=C}return E}var Nye={kernelName:Mm,backendName:"wasm",setupFunc:_ye,kernelFunc:Tye};function YL(e){let t;function n(r){t=r.wasm.cwrap(e,null,["number","number","number","number","number"])}function a(r){let{backend:i,inputs:s,attrs:o}=r,{axis:u}=o,{x:d}=s,c=i.dataIdMap.get(d.dataId).id,h=c,m=d,{transposed:g,axes:x,inputWasTransposed:v}=Kc(d,u,i);if(v){let D=i.dataIdMap.get(g.dataId).id;D!==c&&(m=g,h=D)}let S=m.shape.slice(0,-1),E=i.makeOutput(S,"int32"),C=i.dataIdMap.get(E.dataId).id,T=O.sizeFromShape(E.shape),N=m.shape[x[0]];return t(h,Sn[m.dtype],T,N,C),v&&i.disposeData(g.dataId),E}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:a}}var Rye=YL(Bm),Fye=YL(Lm),Dye=bn(xp),Oye=bn(vp),Mye=bn(Sp),Bye=Ua(Ap),Lye=bn(kp),jL;function zye(e){jL=e.wasm.cwrap(Ep,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Uye(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,i=a.dataIdMap.get(r.dataId).id,{filterSize:s,strides:o,pad:u,dimRoundingMode:d}=n,c=P.computePool2DInfo(r.shape,s,o,1,u,d),h=c.filterHeight,m=c.filterWidth,g=c.padInfo.top,x=c.padInfo.right,v=c.padInfo.bottom,S=c.padInfo.left,E=c.strideHeight,C=c.strideWidth,T=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let N=a.makeOutput(c.outShape,"float32"),D=a.dataIdMap.get(N.dataId).id;return jL(i,r.shape[0],r.shape[1],r.shape[2],h,m,g,x,v,S,E,C,T,D),N}var Vye={kernelName:Ep,backendName:"wasm",setupFunc:zye,kernelFunc:Uye},QL;function Wye(e){QL=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function qye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:u,dataFormat:d}=a,c=P.computePool3DInfo(r.shape,i,s,1,o,u,d),h=n.makeOutput(c.outShape,r.dtype);return QL(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}var Pye={kernelName:zm,backendName:"wasm",setupFunc:Wye,kernelFunc:qye},ZL;function Hye(e){ZL=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Gye(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,{filterSize:s,strides:o,pad:u,dimRoundingMode:d}=a,c=P.computePool3DInfo(i.shape,s,o,1,u,d),h=n.makeOutput(i.shape,i.dtype);return ZL(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),h}var Kye={kernelName:p0,backendName:"wasm",setupFunc:Hye,kernelFunc:Gye},XL;function $ye(e){XL=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Jye(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,{filterSize:s,strides:o,pad:u}=a,d=P.computePool2DInfo(i.shape,s,o,1,u),c=n.makeOutput(i.shape,i.dtype);return XL(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.top,d.padInfo.left,d.filterHeight,d.filterWidth),c}var Yye={kernelName:d0,backendName:"wasm",setupFunc:$ye,kernelFunc:Jye};function ui(e){let{inputs:t,attrs:n}=e,{x:a}=t,{shape:r}=n,i=O.sizeFromShape(a.shape),s=O.inferFromImplicitShape(r,i);return O.assert(i===O.sizeFromShape(s),()=>`new shape: ${s}, old shape: ${a.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:s,dtype:a.dtype}}var jye={kernelName:bg,backendName:"wasm",kernelFunc:ui},ez;function Qye(e){ez=e.wasm.cwrap(Cp,null,["number","array","number","number","array","number","number","number","number"])}function Zye(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:i}=t,{transposeA:s,transposeB:o}=a;if(r.dtype!=="float32"||i.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=r.shape.length,d=i.shape.length,c=s?r.shape[u-2]:r.shape[u-1],h=o?i.shape[d-1]:i.shape[d-2],m=s?r.shape[u-1]:r.shape[u-2],g=o?i.shape[d-2]:i.shape[d-1],x=r.shape.slice(0,-2),v=i.shape.slice(0,-2),S=O.sizeFromShape(x),E=O.sizeFromShape(v),C=Mg.assertAndGetBroadcastShape(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,g]);O.assert(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${s} and transposeB=${o} must match.`);let T=s?[S,c,m]:[S,m,c],N=o?[E,g,h]:[E,h,g],D=ui({inputs:{x:r},backend:n,attrs:{shape:T}}),q=ui({inputs:{x:i},backend:n,attrs:{shape:N}}),H=n.dataIdMap.get(D.dataId).id,K=n.dataIdMap.get(q.dataId).id,j=s?D.shape[2]:D.shape[1],te=o?q.shape[1]:q.shape[2],Q=Math.max(S,E),z=n.makeOutput([Q,j,te],D.dtype),ae=n.dataIdMap.get(z.dataId).id,ue=new Uint8Array(new Int32Array(D.shape).buffer),he=new Uint8Array(new Int32Array(q.shape).buffer);return ez(H,ue,D.shape.length,K,he,q.shape.length,s,o,ae),n.disposeData(D.dataId),n.disposeData(q.dataId),z.shape=C,z}var Xye={kernelName:Cp,backendName:"wasm",setupFunc:Qye,kernelFunc:Zye};function fp(e){let{inputs:{x:t},attrs:{begin:n,size:a},backend:r}=e,[i,s]=$a.parseSliceParams(t,n,a),o=$a.isSliceContinous(t.shape,i,s),u=r.readSync(t.dataId),d=r.makeOutput(s,t.dtype),c=O.computeStrides(t.shape),h=r.dataIdMap.get(d.dataId);if(o){let x=$a.computeFlatOffset(i,c);return t.dtype==="string"?h.stringBytes=u.slice(x,x+O.sizeFromShape(s)):r.typedArrayFromHeap(d).set(u.subarray(x,x+O.sizeFromShape(s))),d}if(t.dtype==="string"){let x=V1(u,i,s,t.shape,t.dtype);return h.stringBytes=x,d}let m=r.typedArrayFromHeap(d),g=t.shape.length;if(g===2)e0e(u,c[0],m,i,s);else if(g===3)t0e(u,c[0],c[1],m,i,s);else if(g===4)n0e(u,c[0],c[1],c[2],m,i,s);else{let x=V1(u,i,s,t.shape,t.dtype);m.set(x)}return d}function e0e(e,t,n,a,r){let i=0,s=a[0],o=a[1],u=s+r[0];for(let d=s;d<u;d++){let c=d*t+o;n.set(e.subarray(c,c+r[1]),i),i+=r[1]}}function t0e(e,t,n,a,r,i){let s=0,o=r[0],u=r[1],d=r[2],c=o+i[0],h=u+i[1];for(let m=o;m<c;m++)for(let g=u;g<h;g++){let x=m*t+g*n+d;a.set(e.subarray(x,x+i[2]),s),s+=i[2]}}function n0e(e,t,n,a,r,i,s){let o=0,u=i[0],d=i[1],c=i[2],h=u+s[0],m=d+s[1],g=c+s[2],x=i[3];for(let v=u;v<h;v++)for(let S=d;S<m;S++)for(let E=c;E<g;E++){let C=v*t+S*n+E*a+x;r.set(e.subarray(C,C+s[3]),o),o+=s[3]}}var a0e={kernelName:Ag,backendName:"wasm",kernelFunc:fp};function r0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:i,crops:s}=a,o=i.reduce((E,C)=>E*C),u=P.getReshaped(r.shape,i,o),d=P.getPermuted(u.length,i.length),c=P.getReshapedPermuted(r.shape,i,o),h=P.getSliceBeginCoords(s,i.length),m=P.getSliceSize(c,s,i.length),g=ui({inputs:{x:r},backend:n,attrs:{shape:u}}),x=Rc({inputs:{x:g},backend:n,attrs:{perm:d}}),v=ui({inputs:{x},backend:n,attrs:{shape:c}}),S=fp({inputs:{x:v},backend:n,attrs:{begin:h,size:m}});return n.disposeData(g.dataId),n.disposeData(x.dataId),n.disposeData(v.dataId),S}var i0e={kernelName:Um,backendName:"wasm",kernelFunc:r0e},tz;function s0e(e){tz=e.wasm.cwrap(Vm,null,["number","number","boolean","number","number","number"])}function o0e(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:i}=n,{size:s}=a,o=i.shape.reduce((h,m)=>h*m,1)!==0,u=r.shape.length===1?[s]:[r.shape[0],s],d=t.makeOutput(u,i.dtype);function c(h){return t.dataIdMap.get(h.dataId).id}return tz(c(r),s,o,c(i),Sn[i.dtype],c(d)),d}var l0e={kernelName:Vm,backendName:"wasm",setupFunc:s0e,kernelFunc:o0e},u0e=Ua(Wm);function c0e(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,i=n.typedArrayFromHeap(a),s=n.typedArrayFromHeap(r),o=P.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var d0e={kernelName:h0,backendName:"wasm",kernelFunc:c0e};function $c(e){let{inputs:{x:t},attrs:{dtype:n},backend:a}=e,r=a.makeOutput(t.shape,n),i=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(r).set(i),r}var p0e={kernelName:Ip,backendName:"wasm",kernelFunc:$c},h0e=bn(_p),nz;function f0e(e){nz=e.wasm.cwrap(Bc,null,["number","number","number","number"])}function m0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:i,clipValueMax:s}=a,o=n.dataIdMap.get(r.dataId).id,u=n.makeOutput(r.shape,r.dtype),d=n.dataIdMap.get(u.dataId).id;return nz(o,i,s,d),u}var g0e={kernelName:Bc,backendName:"wasm",setupFunc:f0e,kernelFunc:m0e};function az(e){let{inputs:t,backend:n}=e,a=O.parseAxisParam(e.attrs.axis,t[0].shape)[0],r=t.map(g=>g.shape);P.assertParamsConsistent(r,a);let i=P.computeOutShape(t.map(g=>g.shape),a),s=t.filter(g=>O.sizeFromShape(g.shape)>0);if(s.length===1)return CS({inputs:{x:s[0]},backend:n});let o=n.makeOutput(i,t[0].dtype);if(O.sizeFromShape(i)===0)return o;if(s[0].dtype==="string"){let g=s.map(T=>{let N=[-1,O.sizeFromShape(T.shape.slice(a))];return ui({inputs:{x:T},backend:n,attrs:{shape:N}})}),x=g.map(T=>({vals:n.readSync(T.dataId),shape:T.shape}));i=P.computeOutShape(g.map(T=>T.shape),1);let v=g[0].shape[0]===1,S=PI(x,i,t[0].dtype,v),E=P.computeOutShape(s.map(T=>T.shape),a);o.shape=E;let C=n.dataIdMap.get(o.dataId);return C.stringBytes=P.fromStringArrayToUint8(S),g.forEach(T=>n.disposeData(T.dataId)),o}let u=O.sizeFromShape(s[0].shape.slice(0,a)),d=0,c=s.map(g=>{let x=O.sizeFromShape(g.shape.slice(a));return d+=x,x}),h=s.map(g=>n.typedArrayFromHeap(g)),m=n.typedArrayFromHeap(o);for(let g=0;g<u;g++){let x=g*d;for(let v=0;v<h.length;v++){let S=c[v],E=g*S,C=h[v].subarray(E,E+S);m.set(C,x),x+=S}}return o}var b0e={kernelName:qm,backendName:"wasm",kernelFunc:az},rz;function y0e(e){rz=e.wasm.cwrap(Tp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function w0e(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:i}=t,s=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(i.dataId).id,{strides:u,dilations:d,pad:c,dimRoundingMode:h,dataFormat:m}=n,g=P.convertConv2DDataFormat(m),x=P.computeConv2DInfo(r.shape,i.shape,u,d,c,h,!1,g),v=x.filterHeight,S=x.filterWidth,E=x.padInfo.top,C=x.padInfo.right,T=x.padInfo.bottom,N=x.padInfo.left,D=x.dilationHeight,q=x.dilationWidth,H=x.strideHeight,K=x.strideWidth,j=x.inChannels,te=x.outChannels,Q=x.padInfo.type==="SAME"?1:0;if(x.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${x.dataFormat}'. Please use 'channelsLast'.`);let z=a.makeOutput(x.outShape,"float32"),ae=a.dataIdMap.get(z.dataId).id;return rz(s,r.shape[0],r.shape[1],r.shape[2],o,v,S,E,C,T,N,Q,D,q,H,K,j,te,ae),z}var x0e={kernelName:Tp,backendName:"wasm",setupFunc:y0e,kernelFunc:w0e},iz;function v0e(e){iz=e.wasm.cwrap(Np,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function S0e(e){let{backend:t,inputs:n,attrs:a}=e,{dy:r,filter:i}=n,{strides:s,pad:o,dataFormat:u,dimRoundingMode:d,inputShape:c}=a,h=1,m=P.convertConv2DDataFormat(u),g=P.computeConv2DInfo(c,i.shape,s,h,o,d,!1,m),{batchSize:x,filterHeight:v,filterWidth:S,inChannels:E,inHeight:C,inWidth:T,outChannels:N,outHeight:D,outWidth:q,strideHeight:H,strideWidth:K}=g,j=v-1-g.padInfo.top,te=S-1-g.padInfo.left,Q=g.dataFormat==="channelsLast",z=O.computeStrides(g.inShape),ae=O.computeStrides(r.shape),[ue,he,Z]=O.computeStrides(i.shape),se=z[0],de=Q?z[1]:z[2],Ce=Q?z[2]:1,Y=Q?1:z[1],ie=ae[0],xe=Q?ae[1]:ae[2],me=Q?ae[2]:1,_e=Q?1:ae[1],Le=t.makeOutput(g.inShape,"float32"),qe=t.dataIdMap.get(Le.dataId).id,$e=t.dataIdMap.get(r.dataId).id,Ke=t.dataIdMap.get(i.dataId).id;return iz($e,Ke,x,v,S,C,T,E,D,q,N,H,K,j,te,ue,he,Z,se,de,Ce,Y,ie,xe,me,_e,qe),Le}var k0e={kernelName:Np,backendName:"wasm",setupFunc:v0e,kernelFunc:S0e},sz;function A0e(e){sz=e.wasm.cwrap(Rp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function E0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:s,pad:o,dilations:u}=a;if(r.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${r.dtype}`);if(i.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let d=P.computeConv3DInfo(r.shape,i.shape,s,u,o),c=n.makeOutput(d.outShape,r.dtype);return sz(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}var C0e={kernelName:Rp,backendName:"wasm",setupFunc:A0e,kernelFunc:E0e},oz;function I0e(e){oz=e.wasm.cwrap(Pm,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:s,pad:o,filterShape:u}=a;if(r.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(i.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let d=P.computeConv3DInfo(r.shape,u,s,1,o),c=n.makeOutput(d.filterShape,i.dtype);return oz(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}var T0e={kernelName:Pm,backendName:"wasm",setupFunc:I0e,kernelFunc:_0e},lz;function N0e(e){lz=e.wasm.cwrap(Hm,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function R0e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{pad:s,strides:o,inputShape:u}=a;if(r.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(i.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let d=P.computeConv3DInfo(u,i.shape,o,1,s),c=n.makeOutput(d.inShape,r.dtype);return lz(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}var F0e={kernelName:Hm,backendName:"wasm",setupFunc:N0e,kernelFunc:R0e},D0e=bn(Fp),O0e=bn(Dp),fA;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(fA||(fA={}));var uz;function M0e(e){uz=e.wasm.cwrap(Km,null,["number","number","number","number","array","number","number","number","number","number"])}function B0e(e){let{backend:t,inputs:n,attrs:a}=e,{method:r,extrapolationValue:i,cropSize:s}=a,{image:o,boxes:u,boxInd:d}=n,c=u.shape[0],[h,m]=s,g=[c,h,m,o.shape[3]],x=t.dataIdMap.get(o.dataId),v;o.dtype!=="float32"&&(v=$c({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),x=t.dataIdMap.get(v.dataId));let S=x.id,E=t.dataIdMap.get(u.dataId).id,C=t.dataIdMap.get(d.dataId).id,T=t.makeOutput(g,"float32"),N=t.dataIdMap.get(T.dataId).id,D=new Uint8Array(new Int32Array(o.shape).buffer);return uz(S,E,C,c,D,h,m,fA[r],i,N),v!=null&&t.disposeData(v.dataId),T}var L0e={kernelName:Km,backendName:"wasm",setupFunc:M0e,kernelFunc:B0e},cz;function z0e(e){cz=e.wasm.cwrap(Gm,null,["number","number","number","number","number","number"])}function U0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,exclusive:s,reverse:o}=a,u=r.shape.length;O.assert(r.dtype==="float32"||r.dtype==="int32",()=>`cumprod does not support ${r.dtype} tensors in the WASM backend`);let d=P.getAxesPermutation([i],u),c=r;d!==null&&(c=Rc({inputs:{x:r},attrs:{perm:d},backend:n}));let h=P.getInnerMostAxes(1,u)[0];P.assertAxesAreInnerMostDims("cumprod",[h],u);let m=n.makeOutput(c.shape,c.dtype),g=c.shape[h],x=n.dataIdMap.get(c.dataId).id,v=n.dataIdMap.get(m.dataId).id;cz(x,s?1:0,o?1:0,g,v,Sn[r.dtype]);let S=m;if(d!==null){let E=P.getUndoAxesPermutation(d);S=Rc({inputs:{x:m},attrs:{perm:E},backend:n}),n.disposeData(c.dataId),n.disposeData(m.dataId)}return S}var V0e={kernelName:Gm,backendName:"wasm",setupFunc:z0e,kernelFunc:U0e},dz;function W0e(e){dz=e.wasm.cwrap(Op,null,["number","number","number","number","number","number"])}function q0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,exclusive:s,reverse:o}=a,u=r.shape.length;O.assert(r.dtype==="float32"||r.dtype==="int32",()=>`cumsum does not support ${r.dtype} tensors in the WASM backend`);let d=P.getAxesPermutation([i],u),c=r;d!==null&&(c=Rc({inputs:{x:r},attrs:{perm:d},backend:n}));let h=P.getInnerMostAxes(1,u)[0];P.assertAxesAreInnerMostDims("cumsum",[h],u);let m=n.makeOutput(c.shape,c.dtype),g=c.shape[h],x=n.dataIdMap.get(c.dataId).id,v=n.dataIdMap.get(m.dataId).id;dz(x,s?1:0,o?1:0,g,v,Sn[r.dtype]);let S=m;if(d!==null){let E=P.getUndoAxesPermutation(d);S=Rc({inputs:{x:m},attrs:{perm:E},backend:n}),n.disposeData(c.dataId),n.disposeData(m.dataId)}return S}var P0e={kernelName:Op,backendName:"wasm",setupFunc:W0e,kernelFunc:q0e},pz;function H0e(e){pz=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function G0e(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:i}=n,{size:s,binaryOutput:o}=a,u=i.shape.reduce((m,g)=>m*g,1)!==0,d=r.shape.length===1?[s]:[r.shape[0],s],c=t.makeOutput(d,i.dtype);function h(m){return t.dataIdMap.get(m.dataId).id}return pz(h(r),new Uint8Array(new Int32Array(r.shape).buffer),r.shape.length,s,u,h(i),Sn[i.dtype],o,h(c)),c}var K0e={kernelName:m0,backendName:"wasm",setupFunc:H0e,kernelFunc:G0e},hz;function $0e(e){hz=e.wasm.cwrap($m,null,["number","number","number","array","number","array","array","number","number"])}function J0e(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{blockSize:i,dataFormat:s}=a,o=r.shape[0],u=s==="NHWC"?r.shape[1]:r.shape[2],d=s==="NHWC"?r.shape[2]:r.shape[3],c=s==="NHWC"?r.shape[3]:r.shape[1],h=u*i,m=d*i,g=c/(i*i),x=s==="NHWC"?[o,h,m,g]:[o,g,h,m],v=t.makeOutput(x,"float32"),S=t.dataIdMap.get(r.dataId).id,E=new Uint8Array(new Int32Array(O.computeStrides(r.shape)).buffer),C=new Uint8Array(new Int32Array(x).buffer),T=new Uint8Array(new Int32Array(O.computeStrides(x)).buffer),N=t.dataIdMap.get(v.dataId).id;return hz(S,i,s==="NHWC"?1:0,E,r.shape.length-1,C,T,x.length,N),v}var Y0e={kernelName:$m,backendName:"wasm",setupFunc:$0e,kernelFunc:J0e},fz;function j0e(e){fz=e.wasm.cwrap(Mp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Q0e(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:i}=t,s=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(i.dataId).id,{strides:u,dilations:d,pad:c,dimRoundingMode:h}=n,m=d??[1,1],g=P.computeConv2DInfo(r.shape,i.shape,u,m,c,h,!0),x=g.filterHeight,v=g.filterWidth,S=g.padInfo.top,E=g.padInfo.right,C=g.padInfo.bottom,T=g.padInfo.left,N=g.dilationHeight,D=g.dilationWidth,q=g.strideHeight,H=g.strideWidth,K=g.inChannels,j=g.outChannels,te=g.padInfo.type==="SAME"?1:0;if(g.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${g.dataFormat}'. Please use 'channelsLast'.`);let Q=a.makeOutput(g.outShape,"float32"),z=a.dataIdMap.get(Q.dataId).id;return fz(s,r.shape[0],r.shape[1],r.shape[2],o,x,v,S,E,C,T,te,N,D,q,H,K,j,z),Q}var Z0e={kernelName:Mp,backendName:"wasm",setupFunc:j0e,kernelFunc:Q0e},mz;function X0e(e){mz=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function ewe(e){let{inputs:t,backend:n}=e,{x:a}=t,r=O.sizeFromShape(a.shape),i=n.makeOutput([...a.shape,...a.shape],a.dtype);return mz(n.dataIdMap.get(a.dataId).id,Sn[a.dtype],r,n.dataIdMap.get(i.dataId).id),i}var twe={kernelName:g0,backendName:"wasm",setupFunc:X0e,kernelFunc:ewe},gz;function nwe(e){gz=e.wasm.cwrap(Bp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function awe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:s,pad:o,dilations:u}=a;if(r.dtype!==i.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${r.dtype} and ${i.dtype}`);let d=P.computeDilation2DInfo(r.shape,i.shape,s,o,"NHWC",u),c=n.makeOutput(d.outShape,r.dtype);return gz(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,Sn[r.dtype],d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.filterHeight,d.filterWidth,d.padInfo.top,d.padInfo.left),c}var rwe={kernelName:Bp,backendName:"wasm",setupFunc:nwe,kernelFunc:awe},bz;function iwe(e){bz=e.wasm.cwrap(gm,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function swe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i,dy:s}=t,{strides:o,pad:u,dilations:d}=a;if(r.dtype!==i.dtype||r.dtype!==s.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${i.dtype}, and ${s.dtype}`);let c=P.computeDilation2DInfo(r.shape,i.shape,o,u,"NHWC",d),h=n.makeOutput(i.shape,i.dtype);return bz(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(h.dataId).id,Sn[r.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),h}var owe={kernelName:gm,backendName:"wasm",setupFunc:iwe,kernelFunc:swe},yz;function lwe(e){yz=e.wasm.cwrap(mm,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function uwe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i,dy:s}=t,{strides:o,pad:u,dilations:d}=a;if(r.dtype!==i.dtype||r.dtype!==s.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${i.dtype}, and ${s.dtype}`);let c=P.computeDilation2DInfo(r.shape,i.shape,o,u,"NHWC",d),h=n.makeOutput(r.shape,r.dtype);return yz(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(h.dataId).id,Sn[r.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),h}var cwe={kernelName:mm,backendName:"wasm",setupFunc:lwe,kernelFunc:uwe},dwe=bn(zp),wz;function pwe(e){wz=e.wasm.cwrap(Jm,null,["number","number","number"])}function hwe(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t,i=n.makeOutput(r.shape,"float32"),s=o=>n.dataIdMap.get(o.dataId).id;return wz(s(r),s(a),s(i)),i}var fwe={kernelName:Jm,backendName:"wasm",setupFunc:pwe,kernelFunc:hwe},mwe=!1,gwe=Ua(Ym,mwe,"bool"),bwe=bn(Up),ywe=bn(Vp,"float32");function mA(e){let{inputs:t,attrs:n,backend:a}=e,{input:r}=t,{dim:i}=n,s=r.shape.length,o=r.shape.slice(),u=i;return i<0&&(O.assert(-(s+1)<=i,()=>`Axis must be in the interval [${-(s+1)}, ${s}]`),u=s+i+1),o.splice(u,0,1),ui({inputs:{x:r},backend:a,attrs:{shape:o}})}var wwe={kernelName:jm,backendName:"wasm",kernelFunc:mA},xwe=bn(Wp,"float32");function xz(e){let{attrs:{shape:t,value:n},backend:a}=e,{attrs:{dtype:r}}=e;r=r||O.inferDtype(n);let i=a.makeOutput(t,r);return a.typedArrayFromHeap(i).fill(n),i}var vwe={kernelName:b0,backendName:"wasm",kernelFunc:xz},vz;function Swe(e){vz=e.wasm.cwrap(Qm,null,["number","number","number","number","number","number"])}function kwe(e){let{inputs:t,backend:n}=e,{image:a}=t,r=n.makeOutput(a.shape,a.dtype),i=n.dataIdMap.get(a.dataId).id,s=n.dataIdMap.get(r.dataId).id,[o,u,d,c]=a.shape;return vz(i,o,u,d,c,s),r}var Awe={kernelName:Qm,backendName:"wasm",kernelFunc:kwe,setupFunc:Swe},Ewe=bn(qp),Cwe=Ua(Pp),Sz;function Iwe(e){Sz=e.wasm.cwrap(Hp,null,["number","number","number","number","number","number","number"])}function _we(e){let{backend:t,inputs:n,attrs:a}=e,{varianceEpsilon:r}=a,{x:i,mean:s,variance:o,offset:u,scale:d}=n,c=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(o.dataId).id,g=u!=null?t.dataIdMap.get(u.dataId).id:0,x=d!=null?t.dataIdMap.get(d.dataId).id:0,v=t.makeOutput(i.shape,i.dtype);if(O.sizeFromShape(i.shape)===0)return v;let S=t.dataIdMap.get(v.dataId).id;return Sz(c,h,m,g,x,r,S),v}var Twe={kernelName:Hp,backendName:"wasm",setupFunc:Iwe,kernelFunc:_we},kz;function Nwe(e){kz=e.wasm.cwrap(Qd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Rwe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:i,bias:s,preluActivationWeights:o}=t,{strides:u,pad:d,dilations:c,dataFormat:h,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=n,v=P.computeConv2DInfo(r.shape,i.shape,u,c,d,m),S=l0[g];if(S==null)throw new Error(`${g} activation not yet supported for FusedConv2D in the wasm backend.`);let E=a.dataIdMap.get(r.dataId).id,C=a.dataIdMap.get(i.dataId).id,T=v.outChannels,N=0;if(s!=null){let me=a.dataIdMap.get(s.dataId);if(me.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${me.shape.length}.`);if(me.shape[0]!==T)throw new Error(`FusedConv2D bias shape (${me.shape}) does not match the number of output channels (${T})`);N=me.id}let D=v.filterHeight,q=v.filterWidth,H=v.padInfo.top,K=v.padInfo.right,j=v.padInfo.bottom,te=v.padInfo.left,Q=v.dilationHeight,z=v.dilationWidth,ae=v.strideHeight,ue=v.strideWidth,he=v.inChannels,Z=v.padInfo.type==="SAME"?1:0,se=v.batchSize,de=v.inHeight,Ce=v.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let Y=a.makeOutput(v.outShape,"float32"),ie=a.dataIdMap.get(Y.dataId).id,xe=o==null?0:a.dataIdMap.get(o.dataId).id;return kz(E,se,de,Ce,C,D,q,N,H,K,j,te,Z,Q,z,ae,ue,he,T,S,xe,x||0,ie),Y}var Fwe={kernelName:Qd,backendName:"wasm",setupFunc:Nwe,kernelFunc:Rwe},Az;function Dwe(e){Az=e.wasm.cwrap(Zd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Owe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:i,bias:s,preluActivationWeights:o}=t,{strides:u,pad:d,dilations:c,dataFormat:h,dimRoundingMode:m,activation:g,leakyreluAlpha:x}=n,v=P.computeConv2DInfo(r.shape,i.shape,u,c,d,m,!0),S=l0[g];if(S==null)throw new Error(`${g} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let E=a.dataIdMap.get(r.dataId).id,C=a.dataIdMap.get(i.dataId).id,T=v.outChannels,N=0;if(s!=null){let me=a.dataIdMap.get(s.dataId);if(me.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${me.shape.length}.`);if(me.shape[0]!==T)throw new Error(`FusedDepthwiseConv2D bias shape (${me.shape}) does not match the number of output channels (${T})`);N=me.id}let D=v.filterHeight,q=v.filterWidth,H=v.padInfo.top,K=v.padInfo.right,j=v.padInfo.bottom,te=v.padInfo.left,Q=v.dilationHeight,z=v.dilationWidth,ae=v.strideHeight,ue=v.strideWidth,he=v.inChannels,Z=v.padInfo.type==="SAME"?1:0,se=v.batchSize,de=v.inHeight,Ce=v.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let Y=a.makeOutput(v.outShape,"float32"),ie=a.dataIdMap.get(Y.dataId).id,xe=o==null?0:a.dataIdMap.get(o.dataId).id;return Az(E,se,de,Ce,C,D,q,N,H,K,j,te,Z,Q,z,ae,ue,he,T,S,xe,x||0,ie),Y}var Mwe={kernelName:Zd,backendName:"wasm",setupFunc:Dwe,kernelFunc:Owe},Ez;function Bwe(e){Ez=e.wasm.cwrap(Xm,null,["number","number","number","number","number","number","array","number"])}function Lwe(e){let{backend:t,inputs:n}=e,{params:a,indices:r}=n,[i,s,o,u]=tC.prepareAndValidate(a,r),d=t.makeOutput(i,a.dtype);if(s===0)return d;let c=r.shape,h=c[c.length-1],m=t.dataIdMap.get(a.dataId).id,g=t.dataIdMap.get(r.dataId).id,x=new Uint8Array(new Int32Array(u).buffer),v=t.dataIdMap.get(d.dataId).id;return Ez(m,Sn[a.dtype],g,s,h,o,x,v),d}var zwe={kernelName:Xm,backendName:"wasm",setupFunc:Bwe,kernelFunc:Lwe},Cz;function Uwe(e){Cz=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function Vwe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,indices:i}=n,{axis:s,batchDims:o}=a,u=O.parseAxisParam(s,r.shape)[0],d=t.readSync(i.dataId),c=r.shape[u];for(let H=0;H<d.length;++H){let K=d[H];O.assert(K<=c-1&&K>=0,()=>`GatherV2: the index value ${K} is not in [0, ${c-1}]`)}let h=P.segment_util.collectGatherOpShapeInfo(r,i,u,o),m=ui({inputs:{x:r},attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]},backend:t}),g=O.sizeFromShape(i.shape),x=ui({inputs:{x:i},attrs:{shape:[h.batchSize,g/h.batchSize]},backend:t}),v=[h.batchSize,h.outerSize,g/h.batchSize,h.sliceSize],S=t.makeOutput(v,r.dtype);if(O.sizeFromShape(r.shape)===0)return S;let E=m.shape.length-1,C=t.dataIdMap.get(m.dataId).id,T=t.dataIdMap.get(x.dataId).id,N=t.dataIdMap.get(S.dataId).id,D=new Uint8Array(new Int32Array(O.computeStrides(m.shape)).buffer),q=new Uint8Array(new Int32Array(O.computeStrides(v)).buffer);return Cz(C,Sn[r.dtype],D,E,T,h.batchSize,q,N),t.disposeData(m.dataId),t.disposeData(x.dataId),S.shape=h.outputShape,S}var Wwe={kernelName:Zm,backendName:"wasm",setupFunc:Uwe,kernelFunc:Vwe},qwe=!1,Pwe=Ua(eg,qwe,"bool"),Hwe=!1,Gwe=Ua(Gp,Hwe,"bool"),Kwe=bn($p,"bool"),$we=bn(Jp,"bool"),Jwe=bn(Yp,"bool"),Iz;function Ywe(e){Iz=e.wasm.cwrap(jp,null,["number","number","number","number"])}function jwe(e){let{inputs:{x:t},attrs:{alpha:n},backend:a}=e,r=a.dataIdMap.get(t.dataId).id,i=a.makeOutput(t.shape,"float32");if(O.sizeFromShape(t.shape)!==0){let s=a.dataIdMap.get(i.dataId).id;Iz(r,Sn[t.dtype],n,s)}return i}var Qwe={kernelName:jp,backendName:"wasm",setupFunc:Ywe,kernelFunc:jwe},Zwe=!1,Xwe=Ua(tg,Zwe,"bool"),exe=!1,txe=Ua(ng,exe,"bool"),_z;function nxe(e){_z=e.wasm.cwrap(ag,null,["number","number","number","number"])}function axe(e){let{attrs:t,backend:n}=e,{start:a,stop:r,num:i}=t,s=Math.floor(i),o=n.makeOutput([s],"float32");return _z(n.dataIdMap.get(o.dataId).id,a,r,s),o}var rxe={kernelName:ag,backendName:"wasm",setupFunc:nxe,kernelFunc:axe},ixe=bn(Qp),sxe=bn(Zp),oxe=!1,lxe=Ua(rg,oxe,"bool"),uxe=bn(ig),cxe=!1,dxe=Ua(sg,cxe,"bool"),pxe=!1,hxe=Ua(I3,pxe,"bool"),Tz;function fxe(e){Tz=e.wasm.cwrap(Xp,null,["number","number","number","number","number","number","number"])}function mxe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:i,bias:s,alpha:o,beta:u}=a;if(r.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let d=n.makeOutput(r.shape,r.dtype);return Tz(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,r.shape[3],i,s,o,u),d}var gxe={kernelName:Xp,backendName:"wasm",setupFunc:fxe,kernelFunc:mxe},Nz;function bxe(e){Nz=e.wasm.cwrap(og,null,["number","number","number","number","number","number","number","number","number"])}function yxe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:i,dy:s}=t,{depthRadius:o,bias:u,alpha:d,beta:c}=a;if(r.dtype!=="float32"||i.dtype!=="float32"||s.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let h=n.makeOutput(r.shape,r.dtype);return Nz(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(h.dataId).id,s.shape[3],o,u,d,c),h}var wxe={kernelName:og,backendName:"wasm",setupFunc:bxe,kernelFunc:yxe},Rz;function xxe(e){Rz=e.wasm.cwrap(eh,null,["number","number","number","number"])}function vxe(e){let{backend:t,inputs:n,attrs:a}=e,{reductionIndices:r,keepDims:i}=a,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,u=s,{transposed:d,axes:c,originalAxes:h,inputWasTransposed:m}=Kc(s,r,t);if(m){let C=t.dataIdMap.get(d.dataId).id;u=d,o=C}let g=u.shape.length;P.assertAxesAreInnerMostDims("max",c,g);let[x,v]=P.computeOutAndReduceShapes(u.shape,c),S=O.sizeFromShape(v),E=t.makeOutput(x,s.dtype);if(O.sizeFromShape(u.shape)!==0){let C=t.dataIdMap.get(E.dataId).id;Rz(o,Sn[s.dtype],S,C)}if(m&&t.disposeData(d.dataId),i){let C=P.expandShapeToKeepDim(E.shape,h);E.shape=C}return E}var Sxe={kernelName:eh,backendName:"wasm",setupFunc:xxe,kernelFunc:vxe},kxe=Ua(th),Fz;function Axe(e){Fz=e.wasm.cwrap(nh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Exe(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,i=a.dataIdMap.get(r.dataId).id;O.assert(r.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${r.dtype}.`);let{filterSize:s,strides:o,pad:u,dimRoundingMode:d}=n,c=P.computePool2DInfo(r.shape,s,o,1,u,d),h=c.filterHeight,m=c.filterWidth,g=c.padInfo.top,x=c.padInfo.right,v=c.padInfo.bottom,S=c.padInfo.left,E=c.dilationHeight,C=c.dilationWidth,T=c.strideHeight,N=c.strideWidth,D=c.inChannels,q=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let H=a.makeOutput(c.outShape,"float32"),K=a.dataIdMap.get(H.dataId).id;return Fz(i,r.shape[0],r.shape[1],r.shape[2],h,m,g,x,v,S,E,C,T,N,D,q,K),H}var Cxe={kernelName:nh,backendName:"wasm",setupFunc:Axe,kernelFunc:Exe},Dz;function Ixe(e){Dz=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _xe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:u,dataFormat:d}=a,c=P.computePool3DInfo(r.shape,i,s,1,o,u,d),h=n.makeOutput(c.outShape,r.dtype);return Dz(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}var Txe={kernelName:lg,backendName:"wasm",setupFunc:Ixe,kernelFunc:_xe},Oz;function Nxe(e){Oz=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Rxe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,{filterSize:s,strides:o,pad:u,dimRoundingMode:d}=a,c=P.computePool3DInfo(i.shape,s,o,1,u,d),h=n.makeOutput(i.shape,i.dtype);return Oz(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}var Fxe={kernelName:w0,backendName:"wasm",setupFunc:Nxe,kernelFunc:Rxe},Mz;function Dxe(e){Mz=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Oxe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,{filterSize:s,strides:o,pad:u,dimRoundingMode:d}=a,c=P.computePool2DInfo(i.shape,s,o,1,u,d),h=n.makeOutput(i.shape,i.dtype);return Mz(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),h}var Mxe={kernelName:y0,backendName:"wasm",setupFunc:Dxe,kernelFunc:Oxe},Bz;function Bxe(e){Bz=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Lxe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:i,strides:s,pad:o,includeBatchInIndex:u}=a;O.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let d=[1,1];O.assert(P.eitherStridesOrDilationsAreOne(s,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`);let c=P.computePool2DInfo(r.shape,i,s,[1,1],o),h=n.makeOutput(c.outShape,r.dtype),m=n.makeOutput(c.outShape,"int32");return Bz(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,n.dataIdMap.get(m.dataId).id,Sn[r.dtype],u,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[h,m]}var zxe={kernelName:x0,backendName:"wasm",setupFunc:Bxe,kernelFunc:Lxe},Lz;function Uxe(e){Lz=e.wasm.cwrap(ah,null,["number, number, number"])}function Vxe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:i}=a,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,u=o,d=s,{transposed:c,axes:h,originalAxes:m,inputWasTransposed:g}=Kc(s,r,t),x=h;if(g){let N=t.dataIdMap.get(c.dataId).id;N!==o&&(d=c,u=N,x=P.getInnerMostAxes(x.length,d.shape.length))}P.assertAxesAreInnerMostDims("mean",x,d.shape.length);let[v,S]=P.computeOutAndReduceShapes(d.shape,x),E=O.sizeFromShape(S),C=d;d.dtype!=="float32"&&(C=$c({backend:t,inputs:{x:d},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(C.dataId).id);let T=t.makeOutput(v,"float32");if(O.sizeFromShape(d.shape)!==0){let N=t.dataIdMap.get(T.dataId).id;Lz(u,E,N)}if(g&&t.disposeData(c.dataId),i){let N=P.expandShapeToKeepDim(T.shape,m);T.shape=N}return d.dtype!=="float32"&&t.disposeData(C.dataId),T}var Wxe={kernelName:ah,backendName:"wasm",setupFunc:Uxe,kernelFunc:Vxe},zz;function qxe(e){zz=e.wasm.cwrap(rh,null,["number","number","number","number"])}function Pxe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:i}=a,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,u=o,d=s,{transposed:c,axes:h,originalAxes:m,inputWasTransposed:g}=Kc(s,r,t);if(g){let T=t.dataIdMap.get(c.dataId).id;T!==o&&(d=c,u=T)}let x=d.shape.length;P.assertAxesAreInnerMostDims("min",h,x);let[v,S]=P.computeOutAndReduceShapes(d.shape,h),E=O.sizeFromShape(S),C=t.makeOutput(v,d.dtype);if(O.sizeFromShape(d.shape)!==0){let T=t.dataIdMap.get(C.dataId).id;zz(u,Sn[s.dtype],E,T)}if(g&&t.disposeData(c.dataId),i){let T=P.expandShapeToKeepDim(C.shape,m);C.shape=T}return C}var Hxe={kernelName:rh,backendName:"wasm",setupFunc:qxe,kernelFunc:Pxe},Gxe=Ua(ih),gA;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(gA||(gA={}));var Uz;function Kxe(e){Uz=e.wasm.cwrap(sh,null,["number","array","number","number","array","array","number","number"])}function $xe(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,mode:r}}=e,i=a.map((x,v)=>x[0]+t.shape[v]+x[1]),s=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(i,t.dtype),u=n.dataIdMap.get(o.dataId).id,d=new Uint8Array(new Int32Array(t.shape).buffer),c=a.map(x=>x[0]),h=a.map(x=>x[1]),m=new Uint8Array(new Int32Array(c).buffer),g=new Uint8Array(new Int32Array(h).buffer);return Uz(s,d,t.shape.length,Sn[t.dtype],m,g,gA[r],u),o}var Jxe={kernelName:sh,backendName:"wasm",kernelFunc:$xe,setupFunc:Kxe},Vz;function Yxe(e){Vz=e.wasm.cwrap(Nh,null,["number","number","number","number"])}function Wz(e){let{backend:t,inputs:{logits:n},attrs:{dim:a}}=e,r=t.dataIdMap.get(n.dataId).id,i=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(i.dataId).id,o=n.shape[a],u=O.sizeFromShape(n.shape)/o;return O.sizeFromShape(i.shape)===0||Vz(r,s,o,u),i}var jxe={kernelName:Nh,backendName:"wasm",setupFunc:Yxe,kernelFunc:Wz},qz;function Qxe(e){qz=e.wasm.cwrap(ug,null,["number","number","number","number","number","number"])}function Zxe(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:i,seed:s,normalized:o}=a;if(r.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);let u=o?r:Wz({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),[d,c]=u.shape,h=n.makeOutput([d,i],"int32");return qz(n.dataIdMap.get(u.dataId).id,d,c,i,s,n.dataIdMap.get(h.dataId).id),o||n.disposeData(u.dataId),h}var Xxe={kernelName:ug,backendName:"wasm",setupFunc:Qxe,kernelFunc:Zxe},e1e=Ua(oh),t1e=Ua(lh),n1e=bn(cg);function y_(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),a=n[0],r=n[1],i=n[2],s=n[3];return e.wasm._free(t),{pSelectedIndices:a,selectedSize:r,pSelectedScores:i,pValidOutputs:s}}var Pz;function a1e(e){Pz=e.wasm.cwrap(pg,"number",["number","number","number","number","number"])}function r1e(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:i,scoreThreshold:s}=a,{boxes:o,scores:u}=n,d=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(u.dataId).id,h=Pz(d,c,i,r,s),{pSelectedIndices:m,selectedSize:g,pSelectedScores:x,pValidOutputs:v}=y_(t,h);return t.wasm._free(x),t.wasm._free(v),t.makeOutput([g],"int32",m)}var i1e={kernelName:pg,backendName:"wasm",setupFunc:a1e,kernelFunc:r1e},Hz;function s1e(e){Hz=e.wasm.cwrap(hg,"number",["number","number","number","number","number","bool"])}function o1e(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:i,scoreThreshold:s,padToMaxOutputSize:o}=a,{boxes:u,scores:d}=n,c=t.dataIdMap.get(u.dataId).id,h=t.dataIdMap.get(d.dataId).id,m=Hz(c,h,i,r,s,o),{pSelectedIndices:g,selectedSize:x,pSelectedScores:v,pValidOutputs:S}=y_(t,m);t.wasm._free(v);let E=t.makeOutput([x],"int32",g),C=t.makeOutput([],"int32",S);return[E,C]}var l1e={kernelName:hg,backendName:"wasm",setupFunc:s1e,kernelFunc:o1e},Gz;function u1e(e){Gz=e.wasm.cwrap(fg,"number",["number","number","number","number","number","number"])}function c1e(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:i,scoreThreshold:s,softNmsSigma:o}=a,{boxes:u,scores:d}=n,c=t.dataIdMap.get(u.dataId).id,h=t.dataIdMap.get(d.dataId).id,m=Gz(c,h,i,r,s,o),{pSelectedIndices:g,selectedSize:x,pSelectedScores:v,pValidOutputs:S}=y_(t,m);t.wasm._free(S);let E=t.makeOutput([x],"int32",g),C=t.makeOutput([x],"float32",v);return[E,C]}var d1e={kernelName:fg,backendName:"wasm",setupFunc:u1e,kernelFunc:c1e},p1e=!1,h1e=Ua(dg,p1e,"bool"),Kz;function f1e(e){Kz=e.wasm.cwrap(uh,null,["number","number","number","number","number"])}function m1e(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:i,depth:s,onValue:o,offValue:u}=a,d=n.makeOutput([...r.shape,s],i),c=n.dataIdMap.get(d.dataId).id,h=n.dataIdMap.get(r.dataId).id;return Kz(h,s,o,u,c),d}var g1e={kernelName:uh,backendName:"wasm",setupFunc:f1e,kernelFunc:m1e};function b1e(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(1),a}var y1e={kernelName:mg,backendName:"wasm",kernelFunc:b1e};function w1e(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return mA({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let i=t[0].shape,s=t[0].dtype;t.forEach(c=>{O.assertShapesMatch(i,c.shape,"All tensors passed to stack must have matching shapes"),O.assert(s===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(c=>{let h=mA({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(h),h}),d=az({inputs:u,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeData(c.dataId)),d}var x1e={kernelName:gg,backendName:"wasm",kernelFunc:w1e},$z;function v1e(e){$z=e.wasm.cwrap(ch,null,["number","array","number","number","array","array","number","number"])}function S1e(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,constantValue:r}}=e,i=a.map((x,v)=>x[0]+t.shape[v]+x[1]);if(O.sizeFromShape(t.shape)===0)return xz({backend:n,attrs:{shape:i,value:r,dtype:t.dtype}});let s=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(i,t.dtype),u=n.dataIdMap.get(o.dataId).id,d=new Uint8Array(new Int32Array(t.shape).buffer),c=a.map(x=>x[0]),h=a.map(x=>x[1]),m=new Uint8Array(new Int32Array(c).buffer),g=new Uint8Array(new Int32Array(h).buffer);return $z(s,d,t.shape.length,Sn[t.dtype],m,g,r,u),o}var Jz={kernelName:ch,backendName:"wasm",kernelFunc:S1e,setupFunc:v1e},k1e=Ua(dh),Yz;function A1e(e){Yz=e.wasm.cwrap(ph,null,["number","number","number"])}function E1e(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,i=n.dataIdMap.get(a.dataId).id,s=n.dataIdMap.get(r.dataId).id,o=i,u=a,d=u;u.dtype!=="float32"&&(d=$c({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(d.dataId).id);let c=n.makeOutput(a.shape,"float32"),h=n.dataIdMap.get(c.dataId).id;return Yz(o,s,h),u.dtype!=="float32"&&n.disposeData(d.dataId),c}var C1e={kernelName:ph,backendName:"wasm",setupFunc:A1e,kernelFunc:E1e},jz;function I1e(e){jz=e.wasm.cwrap(hh,null,["number","number","number","number"])}function _1e(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:i}=a,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,u=o,d=s,{transposed:c,axes:h,originalAxes:m,inputWasTransposed:g}=Kc(s,r,t),x=h;if(g){let T=t.dataIdMap.get(c.dataId).id;T!==o&&(d=c,u=T,x=P.getInnerMostAxes(x.length,d.shape.length))}P.assertAxesAreInnerMostDims("prod",x,d.shape.length);let[v,S]=P.computeOutAndReduceShapes(d.shape,x),E=O.sizeFromShape(S),C=t.makeOutput(v,d.dtype);if(O.sizeFromShape(d.shape)!==0){let T=t.dataIdMap.get(C.dataId).id;jz(u,E,Sn[C.dtype],T)}if(g&&t.disposeData(c.dataId),i){let T=P.expandShapeToKeepDim(C.shape,m);C.shape=T}return C}var T1e={kernelName:hh,backendName:"wasm",setupFunc:I1e,kernelFunc:_1e},N1e=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:i,dtype:s}=n,o=KI(a,r,i,s),u=t.makeOutput([o.length],s);return t.typedArrayFromHeap(u).set(o),u},R1e={kernelName:v0,backendName:"wasm",kernelFunc:N1e},F1e=Ua(Lp),D1e=bn(fh),O1e=bn(mh),M1e=bn(yh),Qz;function B1e(e){Qz=e.wasm.cwrap(bh,null,["number","number","number","number","number","number","number","number","number","number"])}function L1e(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:i,halfPixelCenters:s,size:o}=a,[u,d]=o,[c,h,m,g]=r.shape,x=[c,u,d,g],v=t.dataIdMap.get(r.dataId),S;v.dtype!=="float32"&&(S=$c({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),v=t.dataIdMap.get(S.dataId));let E=v.id,C=t.makeOutput(x,"float32");if(O.sizeFromShape(r.shape)===0)return C;let T=t.dataIdMap.get(C.dataId).id;return Qz(E,c,h,m,g,u,d,i?1:0,s?1:0,T),S!=null&&t.disposeData(S.dataId),C}var z1e={kernelName:bh,backendName:"wasm",setupFunc:B1e,kernelFunc:L1e},Zz;function U1e(e){Zz=e.wasm.cwrap(wg,null,["number","number","number","array","array","boolean"])}function V1e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:i}=t,{alignCorners:s}=a,o=n.makeOutput(r.shape,"float32"),u=n.dataIdMap.get(r.dataId),d;return u.dtype!=="float32"&&(d=$c({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(d.dataId)),Zz(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),s),d!=null&&n.disposeData(d.dataId),o}var W1e={kernelName:wg,backendName:"wasm",setupFunc:U1e,kernelFunc:V1e},Xz;function q1e(e){Xz=e.wasm.cwrap(gh,null,["number","number","number","number","number","number","number","number","number","number"])}function P1e(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:i,halfPixelCenters:s,size:o}=a,[u,d]=o,[c,h,m,g]=r.shape,x=[c,u,d,g],v=t.makeOutput(x,"float32");if(O.sizeFromShape(r.shape)===0)return v;let S=t.dataIdMap.get(r.dataId),E;S.dtype!=="float32"&&(E=$c({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),S=t.dataIdMap.get(E.dataId));let C=S.id,T=t.dataIdMap.get(v.dataId).id;return Xz(C,c,h,m,g,u,d,i?1:0,s?1:0,T),E!=null&&t.disposeData(E.dataId),v}var H1e={kernelName:gh,backendName:"wasm",setupFunc:q1e,kernelFunc:P1e},eU;function G1e(e){eU=e.wasm.cwrap(yg,null,["number","number","number","array","array","boolean"])}function K1e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:i}=t,{alignCorners:s}=a,o=n.makeOutput(r.shape,"float32"),u=n.dataIdMap.get(r.dataId),d;return u.dtype!=="float32"&&(d=$c({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(d.dataId)),eU(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),s),d!=null&&n.disposeData(d.dataId),o}var $1e={kernelName:yg,backendName:"wasm",setupFunc:G1e,kernelFunc:K1e},tU;function J1e(e){tU=e.wasm.cwrap(wh,null,["number","array","number","array","number","number"])}function Y1e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:i}=a,s=O.parseAxisParam(i,r.shape);if(r.shape.length===0)return CS({inputs:{x:r},backend:n});let o=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(r.dataId).id,d=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(s).buffer),h=new Uint8Array(new Int32Array(r.shape).buffer);tU(u,c,s.length,h,r.shape.length,d);let m=ui({inputs:{x:o},attrs:{shape:r.shape},backend:n});return n.disposeData(o.dataId),m}var j1e={kernelName:wh,backendName:"wasm",kernelFunc:Y1e,setupFunc:J1e},nU;function Q1e(e){nU=e.wasm.cwrap(Og,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Z1e(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{radians:i,fillValue:s,center:o}=a,u=n.makeOutput(r.shape,r.dtype),d=n.dataIdMap.get(r.dataId).id,c=n.dataIdMap.get(u.dataId).id,[h,m,g,x]=r.shape,[v,S]=P.getImageCenter(o,m,g),E=s===0,C=255,T=typeof s=="number"?[s,s,s,E?0:C]:[...s,C],N=new Uint8Array(new Int32Array(T).buffer);return nU(d,h,m,g,x,i,v,S,N,T.length,c),u}var X1e={kernelName:Og,backendName:"wasm",kernelFunc:Z1e,setupFunc:Q1e},eve=bn(xh),tve=bn(vh),aU;function nve(e){aU=e.wasm.cwrap(xg,null,["number","number","number","number","number","number","array","number","number"])}function ave(e){let{backend:t,inputs:n,attrs:a}=e,{indices:r,updates:i}=n,{shape:s}=a,o=t.makeOutput(s,i.dtype);if(O.sizeFromShape(s)===0)return o;let{sliceRank:u,numUpdates:d,sliceSize:c,strides:h,outputSize:m}=qv.calculateShapes(i,r,s),g=t.dataIdMap.get(r.dataId).id,x=t.dataIdMap.get(i.dataId).id,v=new Uint8Array(new Int32Array(h).buffer),S=t.dataIdMap.get(o.dataId).id;return aU(g,x,Sn[i.dtype],u,d,c,v,m,S),o}var rve={kernelName:xg,backendName:"wasm",setupFunc:nve,kernelFunc:ave},rU;function ive(e){rU=e.wasm.cwrap(Sg,null,["number","number","number","number","number","number","bool","number"])}function sve(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:i}=t,{side:s}=a;if(r.dtype!==i.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${i.dtype}`);let o=n.makeOutput(i.shape,"int32");function u(d){return n.dataIdMap.get(d.dataId).id}return rU(u(r),u(i),r.shape[0],r.shape[1],i.shape[1],Sn[r.dtype],s==="left",u(o)),o}var ove={kernelName:Sg,backendName:"wasm",setupFunc:ive,kernelFunc:sve},iU;function lve(e){iU=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function uve(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:i}=t,s=n.dataIdMap.get(a.dataId).id,o=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(i.dataId).id,d=n.makeOutput(r.shape,r.dtype),c=n.dataIdMap.get(d.dataId).id,h=a.shape.length,m=r.shape.length,g=h===0||h>1||m===1?1:O.sizeFromShape(r.shape.slice(1));return iU(s,o,u,g,c),d}var cve={kernelName:kg,backendName:"wasm",kernelFunc:uve,setupFunc:lve},dve=bn(Sh),sU;function pve(e){sU=e.wasm.cwrap(Ch,null,["number","number"])}function hve(e){let{backend:t,inputs:{x:n}}=e,a=t.dataIdMap.get(n.dataId).id,r=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(r.dataId).id;return O.sizeFromShape(r.shape)===0||sU(a,i),r}var fve={kernelName:"Sigmoid",backendName:"wasm",setupFunc:pve,kernelFunc:hve},mve=bn(Eh),gve=bn(kh),bve=bn(Ah),yve=bn(Ih);function wve(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:i,paddings:s}=a,o=O.sizeFromShape(i),u=[[0,0]];u.push(...s);for(let S=1+i.length;S<r.shape.length;++S)u.push([0,0]);let d=Jz.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),c=P.getReshaped(d.shape,i,o,!1),h=P.getPermuted(c.length,i.length,!1),m=P.getReshapedPermuted(d.shape,i,o,!1),g=ui({inputs:{x:d},backend:n,attrs:{shape:c}}),x=Rc({inputs:{x:g},backend:n,attrs:{perm:h}}),v=ui({inputs:{x},backend:n,attrs:{shape:m}});return n.disposeData(d.dataId),n.disposeData(g.dataId),n.disposeData(x.dataId),v}var xve={kernelName:Eg,backendName:"wasm",kernelFunc:wve},oU;function vve(e){oU=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Sve(e){let{backend:t,inputs:n}=e,{indices:a,values:r,denseShape:i,defaultValue:s}=n,o=a.shape[0],u=a.shape[1],d=t.readSync(i.dataId)[0],c=[o+d,u],h=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(r.dataId).id,g=t.dataIdMap.get(s.dataId).id,x=t.makeOutput(c,a.dtype),v=t.dataIdMap.get(x.dataId).id,S=t.makeOutput(c.slice(0,1),r.dtype),E=t.dataIdMap.get(S.dataId).id,C=t.makeOutput([d],"bool"),T=t.dataIdMap.get(C.dataId).id,N=t.makeOutput([o],a.dtype),D=t.dataIdMap.get(N.dataId).id,q=t.makeOutput([4],"int32"),H=t.dataIdMap.get(q.dataId).id,K=oU(h,m,Sn[r.dtype],o,d,u,g,v,E,T,D,H),j=t.readSync(q.dataId),te;switch(j[0]){case 1:{te=P.getSparseFillEmptyRowsIndicesDenseShapeMismatch(j[1]);break}case 2:{te=P.getSparseFillEmptyRowsNegativeIndexErrorMessage(j[1],j[2]);break}case 3:te=P.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(j[1],j[2],j[3]);break;default:te=""}if(t.disposeData(q.dataId),te)throw t.disposeData(x.dataId),t.disposeData(S.dataId),t.disposeData(C.dataId),t.disposeData(N.dataId),new Error(te);let Q=x,z=S;return K!==c[0]&&(Q=fp({inputs:{x},attrs:{begin:0,size:[K,u]},backend:t}),z=fp({inputs:{x:S},attrs:{begin:0,size:K},backend:t}),t.disposeData(x.dataId),t.disposeData(S.dataId)),[Q,z,C,N]}var kve={kernelName:S0,backendName:"wasm",setupFunc:vve,kernelFunc:Sve},lU;function Ave(e){lU=e.wasm.cwrap(Ig,null,["number","number","number","number","number","number","number"])}function Eve(e){let{backend:t,inputs:n}=e,{inputIndices:a,inputShape:r,newShape:i}=n;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let s=t.dataIdMap.get(a.dataId).id,o=t.dataIdMap.get(r.dataId).id,u=t.dataIdMap.get(i.dataId).id,d=a.shape[0],c=O.sizeFromShape(i.shape),h=t.makeOutput([d,c],a.dtype),m=t.dataIdMap.get(h.dataId).id,g=t.makeOutput([c],i.dtype),x=t.dataIdMap.get(g.dataId).id,v=t.makeOutput([3],"int32"),S=t.dataIdMap.get(v.dataId).id;lU(s,o,u,d,m,x,S);let E=t.readSync(v.dataId),C;switch(E[0]){case 0:{C=P.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(E[1],E[2]);break}case 1:{C=P.getSparseReshapeNegativeOutputDimErrorMessage(E[1],E[2]);break}case 2:C=P.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let T=Array.from(t.readSync(r.dataId)),N=Array.from(t.readSync(g.dataId));C=P.getSparseReshapeInputOutputMultipleErrorMessage(T,N);break}case 4:{let T=Array.from(t.readSync(r.dataId)),N=Array.from(t.readSync(g.dataId));C=P.getSparseReshapeInputOutputMismatchErrorMessage(T,N);break}default:C=""}if(t.disposeData(v.dataId),C)throw t.disposeData(h.dataId),t.disposeData(g.dataId),new Error(C);return[h,g]}var Cve={kernelName:Ig,backendName:"wasm",setupFunc:Ave,kernelFunc:Eve},uU;function cU(e){uU=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function dU(e,t){let{backend:n,inputs:a}=e,{data:r,indices:i,segmentIds:s}=a,o=i.shape[0],u=n.readSync(s.dataId,o-1,o)[0],d=o>0?u+1:0;if(d<0)throw new Error(P.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=r.shape.slice();c[0]=d;let h=n.dataIdMap.get(r.dataId).id,m=n.dataIdMap.get(i.dataId).id,g=n.dataIdMap.get(s.dataId).id,x=n.makeOutput(c,r.dtype),v=n.dataIdMap.get(x.dataId).id,S=n.makeOutput([4],"int32"),E=n.dataIdMap.get(S.dataId).id;uU(h,Sn[r.dtype],r.shape[0],m,g,v,E,t,0);let C=n.readSync(S.dataId),T;switch(C[0]){case 0:{T=P.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{T=P.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:T=P.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(C[1],C[2]);break;case 3:T=P.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(C[1],C[2],C[3]);break;default:T=""}if(n.disposeData(S.dataId),T)throw n.disposeData(x.dataId),new Error(T);return x}function Ive(e){return dU(e,!0)}var _ve={kernelName:k0,backendName:"wasm",setupFunc:cU,kernelFunc:Ive};function Tve(e){return dU(e,!1)}var Nve={kernelName:A0,backendName:"wasm",setupFunc:cU,kernelFunc:Tve},pU;function Rve(e){pU=e.wasm.cwrap(_g,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Fve(e){let{backend:t,inputs:n,attrs:a}=e,{sparseIndices:r,sparseValues:i,defaultValue:s}=n,{outputShape:o}=a,u=t.makeOutput(o,s.dtype);if(O.sizeFromShape(o)===0)return u;let{sliceRank:d,numUpdates:c,sliceSize:h,strides:m,outputSize:g}=P.calculateShapes(i,r,o),x=t.dataIdMap.get(r.dataId).id,v=t.dataIdMap.get(i.dataId).id,S=t.dataIdMap.get(s.dataId).id,E=new Uint8Array(new Int32Array(m).buffer),C=t.dataIdMap.get(u.dataId).id;return pU(x,v,i.shape.length,S,Sn[s.dtype],d,c,h,E,g,C),u}var Dve={kernelName:_g,backendName:"wasm",setupFunc:Rve,kernelFunc:Fve};function Ove(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{numOrSizeSplits:i,axis:s}=n,o=O.parseAxisParam(s,r.shape)[0],u=P.prepareSplitSize(r,i,o),d=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(h=>{let m=[...c];m[o]=h;let g=fp({inputs:{x:r},attrs:{begin:d,size:m},backend:a});return d[o]+=h,g})}var Mve={kernelName:Cg,backendName:"wasm",kernelFunc:Ove},Bve=bn(_h),Lve=bn(E0),zve=Ua(Rh),hU;function Uve(e){hU=e.wasm.cwrap(zc,null,["number","number","number","number"])}function Vve(e){let{backend:t,inputs:n,attrs:a}=e,{alpha:r}=a,{x:i}=n,s=t.dataIdMap.get(i.dataId).id,o=t.makeOutput(i.shape,i.dtype),u=t.dataIdMap.get(o.dataId).id;return hU(s,r,Sn[i.dtype],u),o}var Wve={kernelName:zc,backendName:"wasm",setupFunc:Uve,kernelFunc:Vve},fU;function qve(e){fU=e.wasm.cwrap(Tg,null,["number","array","number","array","array","array","array","array","number","number"])}function Pve(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{begin:i,end:s,strides:o,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:m}=a,{finalShapeSparse:g,finalShape:x,isIdentity:v,sliceDim0:S,isSimpleSlice:E,begin:C,end:T,strides:N}=$a.sliceInfo(r.shape,i,s,o,u,d,c,h,m),D;if(v)D=ui({inputs:{x:r},backend:t,attrs:{shape:x}});else if(S||E){O.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let q=$a.computeOutShape(C,T,N),H=fp({inputs:{x:r},backend:t,attrs:{begin:C,size:q}});D=ui({inputs:{x:H},backend:t,attrs:{shape:x}}),t.disposeData(H.dataId)}else{let q=t.makeOutput(g,"float32"),H=t.dataIdMap.get(r.dataId).id,K=new Uint8Array(new Int32Array(O.computeStrides(r.shape)).buffer),j=new Uint8Array(new Int32Array(C).buffer),te=new Uint8Array(new Int32Array(T).buffer),Q=new Uint8Array(new Int32Array(N).buffer),z=new Uint8Array(new Int32Array(g).buffer),ae=new Uint8Array(new Int32Array(O.computeStrides(g)).buffer),ue=t.dataIdMap.get(q.dataId).id;fU(H,K,r.shape.length,j,te,Q,z,ae,g.length,ue),D=ui({inputs:{x:q},backend:t,attrs:{shape:x}}),t.disposeData(q.dataId)}return D}var Hve={kernelName:Tg,backendName:"wasm",setupFunc:qve,kernelFunc:Pve};function Gve(e){let{backend:t,inputs:n,attrs:a}=e,{data:r,dataSplits:i}=n,{separator:s,nGramWidths:o,leftPad:u,rightPad:d,padWidth:c,preserveShortSequences:h}=a,m=t.readSync(r.dataId),g=t.readSync(i.dataId),[x,v]=JI(m,g,s,o,u,d,c,h),S=t.makeOutput([x.length],"string"),E=t.dataIdMap.get(S.dataId);E.stringBytes=x;let C=t.makeOutput(i.shape,"int32");return t.typedArrayFromHeap(C).set(v),[S,C]}var Kve={kernelName:I0,backendName:"wasm",kernelFunc:Gve};function $ve(e){let{backend:t,inputs:n,attrs:a}=e,{input:r,delimiter:i}=n,{skipEmpty:s}=a,o=t.readSync(r.dataId),u=t.readSync(i.dataId),[d,c,h]=YI(o,u[0],s),m=c.length,g=t.makeOutput([m,2],"int32");t.typedArrayFromHeap(g).set(d);let x=t.makeOutput([m],"string"),v=t.dataIdMap.get(x.dataId);v.stringBytes=c;let S=t.makeOutput([2],"int32");return t.typedArrayFromHeap(S).set(h),[g,x,S]}var Jve={kernelName:_0,backendName:"wasm",kernelFunc:$ve};function Yve(e){let{backend:t,inputs:n,attrs:a}=e,{input:r}=n,{numBuckets:i}=a,s=t.readSync(r.dataId),o=jI(s,i),u=t.makeOutput(r.shape,"int32");return t.typedArrayFromHeap(u).set(o),u}var jve={kernelName:T0,backendName:"wasm",kernelFunc:Yve},Qve=Ua(Fh),mU;function Zve(e){mU=e.wasm.cwrap(Th,null,["number","number","number","number"])}function Xve(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:i}=a,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,u=o,d=s,{transposed:c,axes:h,originalAxes:m,inputWasTransposed:g}=Kc(s,r,t),x=h;if(g){let T=t.dataIdMap.get(c.dataId).id;T!==o&&(d=c,u=T,x=P.getInnerMostAxes(x.length,d.shape.length))}P.assertAxesAreInnerMostDims("sum",x,d.shape.length);let[v,S]=P.computeOutAndReduceShapes(d.shape,x),E=O.sizeFromShape(S),C=t.makeOutput(v,d.dtype);if(O.sizeFromShape(d.shape)!==0){let T=t.dataIdMap.get(C.dataId).id;mU(u,E,Sn[C.dtype],T)}if(g&&t.disposeData(c.dataId),i){let T=P.expandShapeToKeepDim(C.shape,m);C.shape=T}return C}var eSe={kernelName:Th,backendName:"wasm",setupFunc:Zve,kernelFunc:Xve},tSe=bn(Dh),nSe=bn(Oh),gU;function aSe(e){gU=e.wasm.cwrap(vg,null,["number","number","number","number","number","number","array","number","number","number"])}function rSe(e){let{backend:t,inputs:n,attrs:a}=e,{tensor:r,indices:i,updates:s}=n,o=t.makeOutput(r.shape,r.dtype);if(O.sizeFromShape(r.shape)===0)return o;let{sliceRank:u,numUpdates:d,sliceSize:c,strides:h,outputSize:m}=qv.calculateShapes(s,i,r.shape),g=t.dataIdMap.get(i.dataId).id,x=t.dataIdMap.get(s.dataId).id,v=t.dataIdMap.get(r.dataId).id,S=new Uint8Array(new Int32Array(h).buffer),E=t.dataIdMap.get(o.dataId).id;return gU(g,x,Sn[s.dtype],u,d,c,S,m,E,v),o}var iSe={kernelName:vg,backendName:"wasm",setupFunc:aSe,kernelFunc:rSe},bU;function sSe(e){bU=e.wasm.cwrap(Lc,null,["number","array","number","array","number","number"])}function oSe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,i=n.dataIdMap.get(r.dataId).id,{reps:s}=a,o=new Array(r.shape.length);for(let m=0;m<o.length;m++)o[m]=r.shape[m]*s[m];let u=new Uint8Array(new Int32Array(r.shape).buffer),d=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,r.dtype),h=n.dataIdMap.get(c.dataId).id;return bU(i,u,r.shape.length,d,o.length,Sn[c.dtype],h),c}var lSe={kernelName:Lc,backendName:"wasm",setupFunc:sSe,kernelFunc:oSe},yU;function uSe(e){yU=e.wasm.cwrap(Ng,null,["number","array","number","number","number","bool","number","number"])}var cSe=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{k:r,sorted:i}=n,s=t.dataIdMap.get(a.dataId).id,o=new Uint8Array(new Int32Array(a.shape).buffer),u=a.shape.slice();u[u.length-1]=r;let d=t.makeOutput(u,a.dtype),c=t.dataIdMap.get(d.dataId).id,h=t.makeOutput(u,"int32"),m=t.dataIdMap.get(h.dataId).id;return yU(s,o,a.shape.length,Sn[a.dtype],r,i,c,m),[d,h]},dSe={kernelName:Ng,backendName:"wasm",setupFunc:uSe,kernelFunc:cSe},wU;function pSe(e){wU=e.wasm.cwrap(Rg,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function hSe(e){let{backend:t,inputs:n,attrs:a}=e,{image:r,transforms:i}=n,{interpolation:s,fillMode:o,fillValue:u,outputShape:d}=a,[c,h,m,g]=r.shape,[x,v]=d??[h,m],S=[c,x,v,g],E=new Uint8Array(new Int32Array(O.computeStrides(r.shape)).buffer),C=new Uint8Array(new Int32Array(O.computeStrides(S)).buffer),T=t.makeOutput(S,r.dtype),N=t.dataIdMap.get(T.dataId).id,D=t.dataIdMap.get(r.dataId).id,q=t.dataIdMap.get(i.dataId).id,H=s==="nearest"?1:2,K;switch(o){case"constant":K=1;break;case"reflect":K=2;break;case"wrap":K=3;break;case"nearest":K=4;break;default:K=1;break}return wU(D,q,i.shape[0]>1,c,x,v,g,m,h,E,r.shape.length-1,C,S.length-1,H,K,u,N),T}var fSe={kernelName:Rg,backendName:"wasm",setupFunc:pSe,kernelFunc:hSe};function mSe(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:i}=t,{outputValues:s,outputShape:o,indices:u}=ZI(a.readSync(i.dataId),r,i.shape,i.dtype);return[a.makeOutput(o,i.dtype,void 0,s),a.makeOutput([u.length],"int32",void 0,u)]}var gSe={kernelName:N0,backendName:"wasm",kernelFunc:mSe};function bSe(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:i}=a;i<0&&(i+=r.shape.length);let s=r.shape[i],o=r.shape.length,u=new Array(o-1),d=0;for(let g=0;g<o;g++)g!==i&&(u[d++]=r.shape[g]);let c=new Array(s),h=new Array(o).fill(0),m=r.shape.slice();m[i]=1;for(let g=0;g<c.length;g++)h[i]=g,c[g]=fp({inputs:{x:r},attrs:{begin:h,size:m},backend:n});return c.map(({dataId:g,dtype:x})=>({dataId:g,dtype:x,shape:u}))}var ySe={kernelName:Fg,backendName:"wasm",kernelFunc:bSe};function wSe(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(0),a}var xSe={kernelName:Dg,backendName:"wasm",kernelFunc:wSe},vSe=[pye,hye,fye,mye,gye,wye,Iye,Nye,Rye,Fye,Dye,Oye,Mye,Bye,Lye,Vye,Yye,Pye,Kye,Xye,i0e,l0e,u0e,d0e,p0e,h0e,g0e,b0e,x0e,k0e,C0e,T0e,F0e,D0e,O0e,L0e,V0e,P0e,K0e,Y0e,Z0e,twe,rwe,owe,cwe,dwe,fwe,gwe,bwe,ywe,wwe,xwe,vwe,Awe,Ewe,Cwe,Twe,Fwe,Mwe,zwe,Wwe,Pwe,Gwe,xye,Kwe,$we,Jwe,Qwe,Xwe,txe,rxe,sxe,ixe,lxe,uxe,dxe,hxe,gxe,wxe,Sxe,kxe,Cxe,Txe,Fxe,Mxe,zxe,Wxe,Hxe,Gxe,Jxe,Xxe,e1e,t1e,n1e,i1e,l1e,d1e,h1e,g1e,y1e,x1e,Jz,k1e,C1e,T1e,R1e,F1e,D1e,O1e,M1e,jye,z1e,W1e,H1e,$1e,j1e,X1e,eve,tve,rve,ove,cve,dve,fve,mve,gve,bve,a0e,jxe,yve,xve,kve,Cve,_ve,Nve,Dve,Mve,Bve,Lve,zve,Wve,Hve,Kve,Jve,jve,Qve,eSe,tSe,nSe,iSe,lSe,dSe,fSe,Aye,gSe,ySe,xSe];for(let e of vSe)F0(e);var bA=Ae();bA.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});bA.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(bA.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var jR=Oc(nW()),SSe=Oc(aW()),QR=Oc(rW()),ZR=jR.default||jR,kSe=QR.default||QR,xU=class extends u0{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(vU),yA=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new ev(this,_s())}write(e,t,n){let a={id:this.dataIdNextNumber++};return this.move(a,e,t,n,1),a}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=O.now();return e(),{kernelMs:O.now()-t}}move(e,t,n,a,r){let i=this.dataIdNextNumber++;if(a==="string"){let d=t;this.dataIdMap.set(e,{id:i,stringBytes:d,shape:n,dtype:a,memoryOffset:null,refCount:r});return}let s=O.sizeFromShape(n),o=s*O.bytesPerElement(a),u=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:i,memoryOffset:u,shape:n,dtype:a,refCount:r}),this.wasm.tfjs.registerTensor(i,s,u),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),u)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:a,dtype:r,shape:i,stringBytes:s}=this.dataIdMap.get(e);if(r==="string")return(t==null||t===0)&&(n==null||n>=s.length)?s:s.slice(t,n);t=t||0,n=n||O.sizeFromShape(i);let o=O.bytesPerElement(r),u=this.wasm.HEAPU8.slice(a+t*o,a+n*o);return CSe(u.buffer,r)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,a){let r;if(n==null)r=this.write(a??null,e,t);else{let i=this.dataIdNextNumber++;r={id:i},this.dataIdMap.set(r,{id:i,memoryOffset:n,shape:e,dtype:t,refCount:1});let s=O.sizeFromShape(e);this.wasm.tfjs.registerTensor(i,s,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let a=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(n),i=O.sizeFromShape(e);switch(t){case"float32":return new Float32Array(a,r,i);case"int32":return new Int32Array(a,r,i);case"bool":return new Uint8Array(a,r,i);default:throw new Error(`Unknown dtype ${t}`)}}};function ASe(e){return(t,n)=>(O.fetch(e,{credentials:"same-origin"}).then(a=>{a.ok||t.env.a(`failed to load wasm binary file at '${e}'`),a.arrayBuffer().then(r=>{WebAssembly.instantiate(r,t).then(i=>{n(i.instance,i.module)})})}),{})}function XR(e,t,n){if($1!=null)return $1;let a="tfjs-backend-wasm.wasm";return e&&t?a="tfjs-backend-wasm-threaded-simd.wasm":e&&(a="tfjs-backend-wasm-simd.wasm"),Uy!=null&&Uy[a]!=null?Uy[a]:n+a}async function ESe(){let[e,t]=await Promise.all([Ae().getAsync("WASM_HAS_SIMD_SUPPORT"),Ae().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,a)=>{let r={};r.locateFile=(o,u)=>{if(o.endsWith(".worker.js")){let d=SSe.wasmWorkerContents.replace(/\n/g,"\\n"),c=new Blob([d],{type:"application/javascript"});return URL.createObjectURL(c)}return o.endsWith(".wasm")?XR(e,t,Ny??u):u+o},w_&&(r.instantiateWasm=ASe(XR(e,t,Ny??"")));let i=!1;r.onAbort=()=>{i||Vy||(Vy=!0,a({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let s;t&&e&&$1==null?(r.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+ZR.toString()],{type:"text/javascript"}),s=ZR(r)):s=kSe(r),s.then(o=>{i=!0,Vy=!1;let u=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",u,["number"]),dispose:o.cwrap("dispose",u,[])},n({wasm:o})}).catch(a)})}function CSe(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var ISe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],$1=null,Ny=null,Uy={},Vy=!1,w_=!1;function _Se(e,t=!1){if(q3("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Vy)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");$1=e,w_=t}function TSe(e,t=!1){if(Vy)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")Ny=e;else{Uy=e;let n=ISe.filter(a=>Uy[a]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}w_=t}var vU=-1,yA=-1;function NSe(e){vU=e}function RSe(){if(yA===-1)throw new Error("WASM backend not initialized.");return yA}var FSe="4.22.0",DSe=2;yv("wasm",async()=>{let{wasm:e}=await ESe();return new xU(e)},DSe);var e3="4.22.0",OSe="4.22.0",MSe="4.22.0",BSe="4.22.0",LSe="4.22.0",zSe={tfjs:e3,"tfjs-core":e3,"tfjs-converter":OSe,"tfjs-backend-cpu":MSe,"tfjs-backend-webgl":BSe,"tfjs-backend-wasm":LSe},wA={};IA(wA,{AnchorPosition:()=>LU,DrawBox:()=>VU,DrawBoxOptions:()=>UU,DrawFaceLandmarks:()=>aV,DrawFaceLandmarksOptions:()=>nV,DrawTextField:()=>C_,DrawTextFieldOptions:()=>E_,drawContour:()=>oc,drawDetections:()=>QSe,drawFaceExpressions:()=>c2e,drawFaceLandmarks:()=>p2e});function oc(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:a,y:r},i)=>{let s=t[i];e.moveTo(s.x,s.y),e.lineTo(a,r)}),n){let a=t[t.length-1],r=t[0];if(!a||!r)return;e.moveTo(a.x,a.y),e.lineTo(r.x,r.y)}e.stroke()}var USe={};IA(USe,{computeReshapedDimensions:()=>EU,getCenterPoint:()=>v_,isDimensions:()=>vA,isEven:()=>xA,isFloat:()=>AU,isTensor:()=>tb,isTensor1D:()=>VSe,isTensor2D:()=>kU,isTensor3D:()=>dw,isTensor4D:()=>tu,isValidNumber:()=>Jd,isValidProbablitiy:()=>WSe,range:()=>Rm,round:()=>x_});var pm=class SU{constructor(t,n){if(!Jd(t)||!Jd(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new SU(1/this.width,1/this.height)}};function tb(e,t){return e instanceof $t&&e.shape.length===t}function VSe(e){return tb(e,1)}function kU(e){return tb(e,2)}function dw(e){return tb(e,3)}function tu(e){return tb(e,4)}function AU(e){return e%1!==0}function xA(e){return e%2===0}function x_(e,t=2){let n=10**t;return Math.floor(e*n)/n}function vA(e){return e&&e.width&&e.height}function EU({width:e,height:t},n){let a=n/Math.max(t,e);return new pm(Math.round(e*a),Math.round(t*a))}function v_(e){return e.reduce((t,n)=>t.add(n),new Pn(0,0)).div(new Pn(e.length,e.length))}function Rm(e,t,n){return Array(e).fill(0).map((a,r)=>t+r*n)}function Jd(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function WSe(e){return Jd(e)&&e>=0&&e<=1}var Pn=class Ld{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new Ld(this.x+t.x,this.y+t.y)}sub(t){return new Ld(this.x-t.x,this.y-t.y)}mul(t){return new Ld(this.x*t.x,this.y*t.y)}div(t){return new Ld(this.x/t.x,this.y/t.y)}abs(){return new Ld(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Ld(Math.floor(this.x),Math.floor(this.y))}},mp=class to{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(Jd)}static assertIsValidBox(t,n,a=!1){if(!to.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!a&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let a=t||{},r=[a.left,a.top,a.right,a.bottom].every(Jd),i=[a.x,a.y,a.width,a.height].every(Jd);if(!i&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(a)}`);let[s,o,u,d]=i?[a.x,a.y,a.width,a.height]:[a.left,a.top,a.right-a.left,a.bottom-a.top];to.assertIsValidBox({x:s,y:o,width:u,height:d},"Box.constructor",n),this._x=s,this._y=o,this._width=u,this._height=d}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Pn(this.left,this.top)}get topRight(){return new Pn(this.right,this.top)}get bottomLeft(){return new Pn(this.left,this.bottom)}get bottomRight(){return new Pn(this.right,this.bottom)}round(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(i=>Math.round(i));return new to({x:t,y:n,width:a,height:r})}floor(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(i=>Math.floor(i));return new to({x:t,y:n,width:a,height:r})}toSquare(){let{x:t,y:n,width:a,height:r}=this,i=Math.abs(a-r);return a<r&&(t-=i/2,a+=i),r<a&&(n-=i/2,r+=i),new to({x:t,y:n,width:a,height:r})}rescale(t){let n=vA(t)?t.width:t,a=vA(t)?t.height:t;return new to({x:this.x*n,y:this.y*a,width:this.width*n,height:this.height*a})}pad(t,n){let[a,r,i,s]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new to({x:a,y:r,width:i,height:s})}clipAtImageBorders(t,n){let{x:a,y:r,right:i,bottom:s}=this,o=Math.max(a,0),u=Math.max(r,0),d=i-o,c=s-u,h=Math.min(d,t-o),m=Math.min(c,n-u);return new to({x:o,y:u,width:h,height:m}).floor()}shift(t,n){let{width:a,height:r}=this,i=this.x+t,s=this.y+n;return new to({x:i,y:s,width:a,height:r})}padAtBorders(t,n){let a=this.width+1,r=this.height+1,i=1,s=1,o=a,u=r,d=this.left,c=this.top,h=this.right,m=this.bottom;return h>n&&(o=-h+n+a,h=n),m>t&&(u=-m+t+r,m=t),d<1&&(u=2-d,d=1),c<1&&(u=2-c,c=1),{dy:s,edy:u,dx:i,edx:o,y:c,ey:m,x:d,ex:h,w:a,h:r}}calibrate(t){return new to({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},CU=class extends mp{constructor(e,t,n,a,r=!1){super({left:e,top:t,right:n,bottom:a},r)}},IU=class _U{constructor(t,n,a,r,i){this._imageDims=new pm(i.width,i.height),this._score=t,this._classScore=n,this._className=a,this._box=new mp(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new mp(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new _U(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},po=class TU extends IU{constructor(t,n,a){super(t,t,"",n,a)}forSize(t,n){let{score:a,relativeBox:r,imageDims:i}=super.forSize(t,n);return new TU(a,r,i)}};function qSe(e,t,n=!0){let a=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),r=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),i=a*r;return n?i/(e.area+t.area-i):i/Math.min(e.area,t.area)}function PSe(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),a=t.reduce((o,u)=>u<o?u:o,1/0),r=n.reduce((o,u)=>u<o?u:o,1/0),i=t.reduce((o,u)=>o<u?u:o,0),s=n.reduce((o,u)=>o<u?u:o,0);return new CU(a,r,i,s)}function HSe(e,t,n,a=!0){let r=t.map((s,o)=>({score:s,boxIndex:o})).sort((s,o)=>s.score-o.score).map(s=>s.boxIndex),i=[];for(;r.length>0;){let s=r.pop();i.push(s);let o=r,u=[];for(let d=0;d<o.length;d++){let c=o[d],h=e[s],m=e[c];u.push(qSe(h,m,a))}r=r.filter((d,c)=>u[c]<=n)}return i}function pw(e,t){return be(()=>{let[n,a,r]=t,i=Ni([...e.shape.slice(0,3),1],n,"float32"),s=Ni([...e.shape.slice(0,3),1],a,"float32"),o=Ni([...e.shape.slice(0,3),1],r,"float32"),u=Gn([i,s,o],3);return at(e,u)})}function GSe(e,t=!1){return be(()=>{let[n,a]=e.shape.slice(1);if(n===a)return e;let r=Math.abs(n-a),i=Math.round(r*(t?.5:1)),s=n>a?2:1,o=h=>{let m=e.shape.slice();return m[s]=h,Ni(m,0,"float32")},u=o(i),d=r-u.shape[s],c=[t&&d?o(d):null,e,u].filter(h=>!!h).map(h=>je(h,"float32"));return Gn(c,s)})}function ck(e){return 1/(1+Math.exp(-e))}var NU=class extends mp{constructor(e,t,n,a,r=!1){super({x:e,y:t,width:n,height:a},r)}},KSe=.5,$Se=.43,JSe=.45,J1=class{constructor(e,t,n=new Pn(0,0)){let{width:a,height:r}=t;this._imgDims=new pm(a,r),this._shift=n,this._positions=e.map(i=>i.mul(new Pn(a,r)).add(n))}get shift(){return new Pn(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new Pn(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Pn(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let r=e instanceof po?e.box.floor():new mp(e);return this.shiftBy(r.x,r.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:a}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(a)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,a]=e,r=c=>a.sub(c).magnitude(),i=(r(t)+r(n))/2,s=Math.floor(i/JSe),o=v_(e),u=Math.floor(Math.max(0,o.x-KSe*s)),d=Math.floor(Math.max(0,o.y-$Se*s));return new NU(u,d,Math.min(s,this.imageWidth+u),Math.min(s,this.imageHeight+d))}alignMinBbox(e){let t=PSe(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},RU=class extends J1{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(v_)}};function Y1(e){return e.detection instanceof po}function FU(e,t){return{...e,detection:t}}function DU(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function S_(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function OU(e){let t="";if(!e&&S_())try{e=O6("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((a,r)=>{e.readFile(n,(i,s)=>i?r(i):a(s))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function MU(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,a=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},r=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},i=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},s=global.fetch,o=OU();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:a,createImageElement:r,createVideoElement:i,fetch:s,...o}}function BU(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var nr;function YSe(){if(!nr)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return nr}function SA(e){nr=e}function k_(){return BU()?SA(DU()):S_()?SA(MU()):null}function jSe(e){if(nr||k_(),!nr)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=nr.Canvas,Image:n=nr.Image}=e;nr.Canvas=t,nr.Image=n,nr.createCanvasElement=e.createCanvasElement||(()=>new t),nr.createImageElement=e.createImageElement||(()=>new n),nr.ImageData=e.ImageData||nr.ImageData,nr.Video=e.Video||nr.Video,nr.fetch=e.fetch||nr.fetch,nr.readFile=e.readFile||nr.readFile}var hi={getEnv:YSe,setEnv:SA,initialize:k_,createBrowserEnv:DU,createFileSystem:OU,createNodejsEnv:MU,monkeyPatch:jSe,isBrowser:BU,isNodejs:S_};k_();function A_(e){return!hi.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function Fc(e){let{Canvas:t,CanvasRenderingContext2D:n}=hi.getEnv();if(e instanceof n)return e;let a=A_(e);if(!(a instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let r=a.getContext("2d",{willReadFrequently:!0});if(!r)throw new Error("resolveContext2d - canvas 2d context is null");return r}var LU=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(LU||{}),E_=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:a,fontSize:r,fontStyle:i,padding:s}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=a||"rgba(255, 255, 255, 1)",this.fontSize=r||14,this.fontStyle=i||"Georgia",this.padding=s||4}},C_=class zU{constructor(t,n,a={}){this.text=typeof t=="string"?[t]:t instanceof zU?t.text:t,this.anchor=n,this.options=new E_(a)}measureWidth(t){let{padding:n}=this.options;return this.text.map(a=>t.measureText(a).width).reduce((a,r)=>a<r?r:a,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:a}=this.options,r=a==="BOTTOM_RIGHT"||a==="TOP_RIGHT",i=a==="BOTTOM_LEFT"||a==="BOTTOM_RIGHT",s=this.measureWidth(t),o=this.measureHeight(),u=r?this.anchor.x-s:this.anchor.x,d=i?this.anchor.y-o:this.anchor.y;if(n){let{width:c,height:h}=n,m=Math.max(Math.min(u,c-s),0),g=Math.max(Math.min(d,h-o),0);return{x:m,y:g}}return{x:u,y:d}}draw(t){let n=A_(t),a=Fc(n),{backgroundColor:r,fontColor:i,fontSize:s,fontStyle:o,padding:u}=this.options;a.font=`${s}px ${o}`;let d=this.measureWidth(a),c=this.measureHeight();a.fillStyle=r;let h=this.getUpperLeft(a,n);a.fillRect(h.x,h.y,d,c),a.fillStyle=i,this.text.forEach((m,g)=>{let x=u+h.x,v=u+h.y+(g+1)*s;a.fillText(m,x,v)})}},UU=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:a,drawLabelOptions:r}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=a;let i={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new E_({...i,...r})}},VU=class{constructor(e,t={}){this.box=new mp(e),this.options=new UU(t)}draw(e){let t=Fc(e),{boxColor:n,lineWidth:a}=this.options,{x:r,y:i,width:s,height:o}=this.box;t.strokeStyle=n,t.lineWidth=a,t.strokeRect(r,i,s,o);let{label:u}=this.options;u&&new C_([u],{x:r-a/2,y:i},this.options.drawLabelOptions).draw(e)}};function QSe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let a=n instanceof po?n.score:Y1(n)?n.detection.score:void 0,r=n instanceof po?n.box:Y1(n)?n.detection.box:new mp(n),i=a?`${x_(a)}`:void 0;new VU(r,{label:i}).draw(e)})}function WU(e){let{Image:t,Video:n}=hi.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function ZSe(e){return new Promise((t,n)=>{if(e instanceof hi.getEnv().Canvas||WU(e)){t(null);return}function a(i){i.currentTarget&&(i.currentTarget.removeEventListener("load",r),i.currentTarget.removeEventListener("error",a),n(i))}function r(i){i.currentTarget&&(i.currentTarget.removeEventListener("load",r),i.currentTarget.removeEventListener("error",a),t(i))}e.addEventListener("load",r),e.addEventListener("error",a)})}function qU(e){let{Image:t,Video:n}=hi.getEnv();return e instanceof t?new pm(e.naturalWidth,e.naturalHeight):e instanceof n?new pm(e.videoWidth,e.videoHeight):new pm(e.width,e.height)}function j1({width:e,height:t}){let{createCanvasElement:n}=hi.getEnv(),a=n();return a.width=e,a.height=t,a}function PU(e,t){let{ImageData:n}=hi.getEnv();if(!(e instanceof n)&&!WU(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:a,height:r}=qU(e),i=j1({width:a,height:r});return e instanceof n?Fc(i).putImageData(e,0,0):Fc(i).drawImage(e,0,0,a,r),i}async function XSe(e,t){let n=t||hi.getEnv().createCanvasElement(),[a,r,i]=e.shape.slice(tu(e)?1:0),s=be(()=>e.as3D(a,r,i).toInt());return await Q0.toPixels(s,n),s.dispose(),n}function t3(e){let{Image:t,Canvas:n,Video:a}=hi.getEnv();return e instanceof t||e instanceof n||e instanceof a}function e2e(e,t,n=!1){let{Image:a,Canvas:r}=hi.getEnv();if(!(e instanceof a||e instanceof r))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return j1({width:1,height:1});let i=qU(e),s=t/Math.max(i.height,i.width),o=s*i.width,u=s*i.height,d=j1({width:t,height:t}),c=e instanceof r?e:PU(e),h=Math.abs(o-u)/2,m=n&&o<u?h:0,g=n&&u<o?h:0;return c.width>0&&c.height>0&&Fc(d).drawImage(c,m,g,o,u),d}var Q1=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,a)=>{if(dw(n)){this._imageTensors[a]=n,this._inputDimensions[a]=n.shape;return}if(tu(n)){let i=n.shape[0];if(i!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${i} passed, but not supported in input array`);this._imageTensors[a]=n,this._inputDimensions[a]=n.shape.slice(1);return}let r=n instanceof hi.getEnv().Canvas?n:PU(n);this._canvases[a]=r,this._inputDimensions[a]=[r.height,r.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return Rm(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return EU({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,be(()=>{let n=Rm(this.batchSize,0,1).map(a=>{let r=this.getInput(a);if(r instanceof $t){let i=tu(r)?r:sr(r);return i=GSe(i,t),(i.shape[1]!==e||i.shape[2]!==e)&&(i=Zi.resizeBilinear(i,[e,e],!1,!1)),i.as3D(e,e,3)}if(r instanceof hi.getEnv().Canvas)return Q0.fromPixels(e2e(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${a}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)});return Ba(n.map(a=>je(a,"float32"))).as4D(this.batchSize,e,e,3)})}};async function Kr(e){if(e instanceof Q1)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=r=>Array.isArray(e)?` at input index ${r}:`:"",a=t.map(A_);return a.forEach((r,i)=>{if(!t3(r)&&!dw(r)&&!tu(r))throw typeof t[i]=="string"?new Error(`toNetInput -${n(i)} string passed, but could not resolve HTMLElement for element id ${t[i]}`):new Error(`toNetInput -${n(i)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(tu(r)){let s=r.shape[0];if(s!==1)throw new Error(`toNetInput -${n(i)} tf.Tensor4D with batchSize ${s} passed, but not supported in input array`)}}),await Promise.all(a.map(r=>t3(r)&&ZSe(r))),new Q1(a,Array.isArray(e))}async function I_(e,t){let{Canvas:n}=hi.getEnv(),a=e;if(!(e instanceof n)){let i=await Kr(e);if(i.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let s=i.getInput(0);a=s instanceof n?s:await XSe(s)}let r=Fc(a);return t.map(i=>i instanceof po?i.forSize(a.width,a.height).box.floor():i).map(i=>i.clipAtImageBorders(a.width,a.height)).map(({x:i,y:s,width:o,height:u})=>{let d=j1({width:o,height:u});return o>0&&u>0&&Fc(d).putImageData(r.getImageData(i,s,o,u),0,0),d})}async function __(e,t){if(!dw(e)&&!tu(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(tu(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return be(()=>{let[n,a,r]=e.shape.slice(tu(e)?1:0);return t.map(i=>i instanceof po?i.forSize(a,n).box:i).map(i=>i.clipAtImageBorders(a,n)).filter(i=>i.width>0&&i.height>0).map(({x:i,y:s,width:o,height:u})=>Wg(e.as3D(n,a,r),[s,i,0],[u,o,r]))})}async function t2e(e,t){let{fetch:n}=hi.getEnv(),a=await n(e,t);if(!(a.status<400))throw new Error(`failed to fetch: (${a.status}) ${a.statusText}, from url: ${a.url}`);return a}async function n2e(e){return(await t2e(e)).json()}function HU(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let a=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(a,"");let r=e.split("/").filter(o=>o),i=e.endsWith(".json")?r[r.length-1]:n,s=a+(e.endsWith(".json")?r.slice(0,r.length-1):r).join("/");return s=e.startsWith("/")?`/${s}`:s,{modelBaseUri:s,manifestUri:s==="/"?`/${i}`:`${s}/${i}`}}async function a2e(e,t){let{manifestUri:n,modelBaseUri:a}=HU(e,t),r=await n2e(n);return xr.loadWeights(r,a)}var Jc=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:a}=this.traversePropertyPath(e);n[a].dispose(),n[a]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Xd)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Xd))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=Pr(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await a2e(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=hi.getEnv(),{manifestUri:n,modelBaseUri:a}=HU(e,this.getDefaultModelName()),r=u=>Promise.all(u.map(d=>t(d).then(c=>typeof c=="string"?Buffer.from(c):c.buffer))),i=xr.weightsLoaderFactory(r),s=JSON.parse((await t(n)).toString()),o=await i(s,a);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((r,i)=>{if(!r.nextObj.hasOwnProperty(i))throw new Error(`traversePropertyPath - object does not have property ${i}, for path ${e}`);return{obj:r.nextObj,objProp:i,nextObj:r.nextObj[i]}},{nextObj:this.params}),{obj:n,objProp:a}=t;if(!n||!a||!(n[a]instanceof $t))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:a}}};function ts(e,t,n){return be(()=>{let a=Vg(e,t.depthwise_filter,t.pointwise_filter,n,"same");return a=Oe(a,t.bias),a})}function dk(e,t,n=!1){return be(()=>{let a=zn(n?Oe(Hr(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):ts(e,t.conv0,[2,2])),r=ts(a,t.conv1,[1,1]),i=zn(Oe(a,r)),s=ts(i,t.conv2,[1,1]);return zn(Oe(a,Oe(r,s)))})}function a1(e,t,n=!1,a=!0){return be(()=>{let r=zn(n?Oe(Hr(e,t.conv0.filters,a?[2,2]:[1,1],"same"),t.conv0.bias):ts(e,t.conv0,a?[2,2]:[1,1])),i=ts(r,t.conv1,[1,1]),s=zn(Oe(r,i)),o=ts(s,t.conv2,[1,1]),u=zn(Oe(r,Oe(i,o))),d=ts(u,t.conv3,[1,1]);return zn(Oe(r,Oe(i,Oe(o,d))))})}function Wy(e,t,n="same",a=!1){return be(()=>{let r=Oe(Hr(e,t.filters,[1,1],n),t.bias);return a?zn(r):r})}function Yc(e,t){Object.keys(e).forEach(n=>{t.some(a=>a.originalPath===n)||e[n].dispose()})}function T_(e,t){return(n,a,r,i)=>{let s=Ec(e(n*a*r*r),[r,r,n,a]),o=Dn(e(a));return t.push({paramPath:`${i}/filters`},{paramPath:`${i}/bias`}),{filters:s,bias:o}}}function GU(e,t){return(n,a,r)=>{let i=nl(e(n*a),[n,a]),s=Dn(e(a));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/bias`}),{weights:i,bias:s}}}var KU=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function N_(e,t){return(n,a,r)=>{let i=Ec(e(9*n),[3,3,n,1]),s=Ec(e(n*a),[1,1,n,a]),o=Dn(e(a));return t.push({paramPath:`${r}/depthwise_filter`},{paramPath:`${r}/pointwise_filter`},{paramPath:`${r}/bias`}),new KU(i,s,o)}}function R_(e){return t=>{let n=e(`${t}/depthwise_filter`,4),a=e(`${t}/pointwise_filter`,4),r=e(`${t}/bias`,1);return new KU(n,a,r)}}function Kh(e,t){return(n,a,r)=>{let i=e[n];if(!tb(i,a))throw new Error(`expected weightMap[${n}] to be a Tensor${a}D, instead have ${i}`);return t.push({originalPath:n,paramPath:r||n}),i}}function jc(e){let t=e;function n(r){let i=t.slice(0,r);return t=t.slice(r),i}function a(){return t}return{extractWeights:n,getRemainingWeights:a}}function $U(e,t){let n=T_(e,t),a=N_(e,t);function r(s,o,u,d=!1){let c=d?n(s,o,3,`${u}/conv0`):a(s,o,`${u}/conv0`),h=a(o,o,`${u}/conv1`),m=a(o,o,`${u}/conv2`);return{conv0:c,conv1:h,conv2:m}}function i(s,o,u,d=!1){let{conv0:c,conv1:h,conv2:m}=r(s,o,u,d),g=a(o,o,`${u}/conv3`);return{conv0:c,conv1:h,conv2:m,conv3:g}}return{extractDenseBlock3Params:r,extractDenseBlock4Params:i}}function r2e(e){let t=[],{extractWeights:n,getRemainingWeights:a}=jc(e),{extractDenseBlock4Params:r}=$U(n,t),i=r(3,32,"dense0",!0),s=r(32,64,"dense1"),o=r(64,128,"dense2"),u=r(128,256,"dense3");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:i,dense1:s,dense2:o,dense3:u}}}function JU(e){return t=>{let n=e(`${t}/filters`,4),a=e(`${t}/bias`,1);return{filters:n,bias:a}}}function YU(e,t){let n=Kh(e,t),a=JU(n),r=R_(n);function i(o,u=!1){let d=u?a(`${o}/conv0`):r(`${o}/conv0`),c=r(`${o}/conv1`),h=r(`${o}/conv2`);return{conv0:d,conv1:c,conv2:h}}function s(o,u=!1){let d=u?a(`${o}/conv0`):r(`${o}/conv0`),c=r(`${o}/conv1`),h=r(`${o}/conv2`),m=r(`${o}/conv3`);return{conv0:d,conv1:c,conv2:h,conv3:m}}return{extractDenseBlock3Params:i,extractDenseBlock4Params:s}}function i2e(e){let t=[],{extractDenseBlock4Params:n}=YU(e,t),a={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Yc(e,t),{params:a,paramMappings:t}}var jU=class extends Jc{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return be(()=>{let n=je(e.toBatchTensor(112,!0),"float32"),a=pw(n,[122.782,117.001,104.298]).div(255),r=a1(a,t.dense0,!0);return r=a1(r,t.dense1),r=a1(r,t.dense2),r=a1(r,t.dense3),r=su(r,[7,7],[2,2],"valid"),r})}async forward(e){return this.forwardInput(await Kr(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return i2e(e)}extractParams(e){return r2e(e)}};function kA(e,t){return be(()=>Oe(jt(e,t.weights),t.bias))}function s2e(e,t,n){let a=[],{extractWeights:r,getRemainingWeights:i}=jc(e),s=GU(r,a)(t,n,"fc");if(i().length!==0)throw new Error(`weights remaing after extract: ${i().length}`);return{paramMappings:a,params:{fc:s}}}function o2e(e){let t=[],n=Kh(e,t);function a(i){let s=n(`${i}/weights`,2),o=n(`${i}/bias`,1);return{weights:s,bias:o}}let r={fc:a("fc")};return Yc(e,t),{params:r,paramMappings:t}}function QU(e){let t={},n={};return Object.keys(e).forEach(a=>{let r=a.startsWith("fc")?n:t;r[a]=e[a]}),{featureExtractorMap:t,classifierMap:n}}var ZU=class extends Jc{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return be(()=>{let n=e instanceof Q1?this.faceFeatureExtractor.forwardInput(e):e;return kA(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return s2e(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=QU(e);return this.faceFeatureExtractor.loadFromWeightMap(t),o2e(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),a=n*t+n,r=e.slice(0,e.length-a),i=e.slice(e.length-a);return this.faceFeatureExtractor.extractWeights(r),this.extractClassifierParams(i)}},n3=["neutral","happy","sad","angry","fearful","disgusted","surprised"],F_=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);n3.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return n3.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},l2e=class extends ZU{constructor(e=new jU){super("FaceExpressionNet",e)}forwardInput(e){return be(()=>qc(this.runNet(e)))}async forward(e){return this.forwardInput(await Kr(e))}async predictExpressions(e){let t=await Kr(e),n=await this.forwardInput(t),a=await Promise.all(Aa(n).map(async i=>{let s=i.dataSync();return i.dispose(),s}));n.dispose();let r=a.map(i=>new F_(i));return t.isBatchInput?r:r[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function u2e(e){return e.expressions instanceof F_}function XU(e,t){return{...e,expressions:t}}function c2e(e,t,n=.1,a){(Array.isArray(t)?t:[t]).forEach(r=>{let i=r instanceof F_?r:u2e(r)?r.expressions:void 0;if(!i)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let s=i.asSortedArray().filter(u=>u.probability>n),o=Y1(r)?r.detection.box.bottomLeft:a||new Pn(0,0);new C_(s.map(u=>`${u.expression} (${x_(u.probability)})`),o).draw(e)})}function eV(e){return Y1(e)&&e.landmarks instanceof J1&&e.unshiftedLandmarks instanceof J1&&e.alignedRect instanceof po}function d2e(e){let t=u=>u*180/Math.PI,n=(u,d)=>Math.sqrt((u.x-d.x)**2+(u.y-d.y)**2),a={roll:void 0,pitch:void 0,yaw:void 0},r=(u,d,c)=>{let h=Math.floor(u.x-d.x),m=Math.floor(d.x-c.x);return h-m},i=(u,d)=>{let c=Math.hypot(d.x-u.x,d.y-u.y),h=d.y-u.y,m=Math.asin(h/c),g=t(m),x=Math.floor(90-g),v=d.x-u.x<0?-1:1;return x*v},s=(u,d,c)=>{let h=n(u,c),m=new Pn((u.x+c.x)/2,(u.y+c.y)/2),g=n(d,m),x=Math.atan(g/h),v=Math.floor(t(x)),S=m.y-d.y<0?-1:1;return v*S};if(!e||!e.positions||e.positions.length!==68)return a;let o=e.positions;return a.roll=i(o[27],o[66]),a.pitch=s(o[14],o[30],o[2]),a.yaw=r(o[14],o[33],o[2]),a}function tV(e,t){let{box:n}=e.detection,a=t.shiftBy(n.x,n.y),r=a.align(),{imageDims:i}=e.detection,s=new po(e.detection.score,r.rescale(i.reverse()),i),o=d2e(t);return{...e,landmarks:a,unshiftedLandmarks:t,alignedRect:s,angle:o}}var nV=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:a,lineColor:r,pointSize:i,pointColor:s}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=a||1,this.pointSize=i||2,this.lineColor=r||"rgba(0, 255, 255, 1)",this.pointColor=s||"rgba(255, 0, 255, 1)"}},aV=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new nV(t)}draw(e){let t=Fc(e),{drawLines:n,drawPoints:a,lineWidth:r,lineColor:i,pointSize:s,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof RU&&(t.strokeStyle=i,t.lineWidth=r,oc(t,this.faceLandmarks.getJawOutline()),oc(t,this.faceLandmarks.getLeftEyeBrow()),oc(t,this.faceLandmarks.getRightEyeBrow()),oc(t,this.faceLandmarks.getNose()),oc(t,this.faceLandmarks.getLeftEye(),!0),oc(t,this.faceLandmarks.getRightEye(),!0),oc(t,this.faceLandmarks.getMouth(),!0)),a){t.strokeStyle=o,t.fillStyle=o;let u=d=>{t.beginPath(),t.arc(d.x,d.y,s,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(u)}}};function p2e(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let a=n instanceof J1?n:eV(n)?n.landmarks:void 0;if(!a)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new aV(a).draw(e)})}function h2e(e,t){let n=T_(e,t),a=N_(e,t);function r(s,o,u){let d=a(s,o,`${u}/separable_conv0`),c=a(o,o,`${u}/separable_conv1`),h=n(s,o,1,`${u}/expansion_conv`);return{separable_conv0:d,separable_conv1:c,expansion_conv:h}}function i(s,o){let u=a(s,s,`${o}/separable_conv0`),d=a(s,s,`${o}/separable_conv1`),c=a(s,s,`${o}/separable_conv2`);return{separable_conv0:u,separable_conv1:d,separable_conv2:c}}return{extractConvParams:n,extractSeparableConvParams:a,extractReductionBlockParams:r,extractMainBlockParams:i}}function f2e(e,t){let n=[],{extractWeights:a,getRemainingWeights:r}=jc(e),{extractConvParams:i,extractSeparableConvParams:s,extractReductionBlockParams:o,extractMainBlockParams:u}=h2e(a,n),d=i(3,32,3,"entry_flow/conv_in"),c=o(32,64,"entry_flow/reduction_block_0"),h=o(64,128,"entry_flow/reduction_block_1"),m={conv_in:d,reduction_block_0:c,reduction_block_1:h},g={};Rm(t,0,1).forEach(E=>{g[`main_block_${E}`]=u(128,`middle_flow/main_block_${E}`)});let x=o(128,256,"exit_flow/reduction_block"),v=s(256,512,"exit_flow/separable_conv"),S={reduction_block:x,separable_conv:v};if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:n,params:{entry_flow:m,middle_flow:g,exit_flow:S}}}function m2e(e,t){let n=Kh(e,t),a=JU(n),r=R_(n);function i(o){let u=r(`${o}/separable_conv0`),d=r(`${o}/separable_conv1`),c=a(`${o}/expansion_conv`);return{separable_conv0:u,separable_conv1:d,expansion_conv:c}}function s(o){let u=r(`${o}/separable_conv0`),d=r(`${o}/separable_conv1`),c=r(`${o}/separable_conv2`);return{separable_conv0:u,separable_conv1:d,separable_conv2:c}}return{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:i,extractMainBlockParams:s}}function g2e(e,t){let n=[],{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:i,extractMainBlockParams:s}=m2e(e,n),o=a("entry_flow/conv_in"),u=i("entry_flow/reduction_block_0"),d=i("entry_flow/reduction_block_1"),c={conv_in:o,reduction_block_0:u,reduction_block_1:d},h={};Rm(t,0,1).forEach(v=>{h[`main_block_${v}`]=s(`middle_flow/main_block_${v}`)});let m=i("exit_flow/reduction_block"),g=r("exit_flow/separable_conv"),x={reduction_block:m,separable_conv:g};return Yc(e,n),{params:{entry_flow:c,middle_flow:h,exit_flow:x},paramMappings:n}}function rV(e,t,n){return Oe(Hr(e,t.filters,n,"same"),t.bias)}function pk(e,t,n=!0){let a=n?zn(e):e;return a=ts(a,t.separable_conv0,[1,1]),a=ts(zn(a),t.separable_conv1,[1,1]),a=ar(a,[3,3],[2,2],"same"),a=Oe(a,rV(e,t.expansion_conv,[2,2])),a}function b2e(e,t){let n=ts(zn(e),t.separable_conv0,[1,1]);return n=ts(zn(n),t.separable_conv1,[1,1]),n=ts(zn(n),t.separable_conv2,[1,1]),n=Oe(n,e),n}var y2e=class extends Jc{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return be(()=>{let n=je(e.toBatchTensor(112,!0),"float32"),a=pw(n,[122.782,117.001,104.298]).div(255),r=zn(rV(a,t.entry_flow.conv_in,[2,2]));return r=pk(r,t.entry_flow.reduction_block_0,!1),r=pk(r,t.entry_flow.reduction_block_1),Rm(this._numMainBlocks,0,1).forEach(i=>{r=b2e(r,t.middle_flow[`main_block_${i}`])}),r=pk(r,t.exit_flow.reduction_block),r=zn(ts(r,t.exit_flow.separable_conv,[1,1])),r})}async forward(e){return this.forwardInput(await Kr(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return g2e(e,this._numMainBlocks)}extractParams(e){return f2e(e,this._numMainBlocks)}};function w2e(e){let t=[],{extractWeights:n,getRemainingWeights:a}=jc(e),r=GU(n,t),i=r(512,1,"fc/age"),s=r(512,2,"fc/gender");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{fc:{age:i,gender:s}}}}function x2e(e){let t=[],n=Kh(e,t);function a(i){let s=n(`${i}/weights`,2),o=n(`${i}/bias`,1);return{weights:s,bias:o}}let r={fc:{age:a("fc/age"),gender:a("fc/gender")}};return Yc(e,t),{params:r,paramMappings:t}}var v2e=(e=>(e.FEMALE="female",e.MALE="male",e))(v2e||{}),S2e=class extends Jc{constructor(e=new y2e(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return be(()=>{let n=e instanceof Q1?this.faceFeatureExtractor.forwardInput(e):e,a=su(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),r=kA(a,t.fc.age).as1D(),i=kA(a,t.fc.gender);return{age:r,gender:i}})}forwardInput(e){return be(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:qc(n)}})}async forward(e){return this.forwardInput(await Kr(e))}async predictAgeAndGender(e){let t=await Kr(e),n=await this.forwardInput(t),a=Aa(n.age),r=Aa(n.gender),i=a.map((o,u)=>({ageTensor:o,genderTensor:r[u]})),s=await Promise.all(i.map(async({ageTensor:o,genderTensor:u})=>{let d=o.dataSync()[0],c=u.dataSync()[0],h=c>.5,m=h?"male":"female",g=h?c:1-c;return o.dispose(),u.dispose(),{age:d,gender:m,genderProbability:g}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?s:s[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return w2e(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=QU(e);return this.faceFeatureExtractor.loadFromWeightMap(t),x2e(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},iV=class extends ZU{postProcess(e,t,n){let a=n.map(({width:i,height:s})=>{let o=t/Math.max(s,i);return{width:i*o,height:s*o}}),r=a.length;return be(()=>{let i=(d,c)=>Ba([Ni([68],d,"float32"),Ni([68],c,"float32")],1).as2D(1,136).as1D(),s=(d,c)=>{let{width:h,height:m}=a[d];return c(h,m)?Math.abs(h-m)/2:0},o=d=>s(d,(c,h)=>c<h),u=d=>s(d,(c,h)=>h<c);return e.mul(Ni([r,136],t,"float32")).sub(Ba(Array.from(Array(r),(d,c)=>i(o(c),u(c))))).div(Ba(Array.from(Array(r),(d,c)=>i(a[c].width,a[c].height))))})}forwardInput(e){return be(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,a])=>({height:n,width:a})))})}async forward(e){return this.forwardInput(await Kr(e))}async detectLandmarks(e){let t=await Kr(e),n=be(()=>Aa(this.forwardInput(t))),a=await Promise.all(n.map(async(r,i)=>{let s=Array.from(r.dataSync()),o=s.filter((d,c)=>xA(c)),u=s.filter((d,c)=>!xA(c));return new RU(Array(68).fill(0).map((d,c)=>new Pn(o[c],u[c])),{height:t.getInputHeight(i),width:t.getInputWidth(i)})}));return n.forEach(r=>r.dispose()),t.isBatchInput?a:a[0]}getClassifierChannelsOut(){return 136}},k2e=class extends iV{constructor(e=new jU){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function A2e(e){let t=[],{extractDenseBlock3Params:n}=YU(e,t),a={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Yc(e,t),{params:a,paramMappings:t}}function E2e(e){let t=[],{extractWeights:n,getRemainingWeights:a}=jc(e),{extractDenseBlock3Params:r}=$U(n,t),i=r(3,32,"dense0",!0),s=r(32,64,"dense1"),o=r(64,128,"dense2");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:i,dense1:s,dense2:o}}}var C2e=class extends Jc{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return be(()=>{let n=je(e.toBatchTensor(112,!0),"float32"),a=pw(n,[122.782,117.001,104.298]).div(255),r=dk(a,t.dense0,!0);return r=dk(r,t.dense1),r=dk(r,t.dense2),r=su(r,[14,14],[2,2],"valid"),r})}async forward(e){return this.forwardInput(await Kr(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return A2e(e)}extractParams(e){return E2e(e)}},I2e=class extends iV{constructor(e=new C2e){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function _2e(e,t){return Oe(pe(e,t.weights),t.biases)}function D_(e,t,n,a,r="same"){let{filters:i,bias:s}=t.conv,o=Hr(e,i,n,r);return o=Oe(o,s),o=_2e(o,t.scale),a?zn(o):o}function T2e(e,t){return D_(e,t,[1,1],!0)}function sV(e,t){return D_(e,t,[1,1],!1)}function oV(e,t){return D_(e,t,[2,2],!0,"valid")}function N2e(e,t){function n(o,u,d){let c=e(o),h=c.length/(u*d*d);if(AU(h))throw new Error(`depth has to be an integer: ${h}, weights.length: ${c.length}, numFilters: ${u}, filterSize: ${d}`);return be(()=>Qt(Ec(c,[u,h,d,d]),[2,3,1,0]))}function a(o,u,d,c){let h=n(o,u,d),m=Dn(e(u));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/bias`}),{filters:h,bias:m}}function r(o,u){let d=Dn(e(o)),c=Dn(e(o));return t.push({paramPath:`${u}/weights`},{paramPath:`${u}/biases`}),{weights:d,biases:c}}function i(o,u,d,c){let h=a(o,u,d,`${c}/conv`),m=r(u,`${c}/scale`);return{conv:h,scale:m}}function s(o,u,d,c,h=!1){let m=i((h?.5:1)*o,u,d,`${c}/conv1`),g=i(o,u,d,`${c}/conv2`);return{conv1:m,conv2:g}}return{extractConvLayerParams:i,extractResidualLayerParams:s}}function R2e(e){let{extractWeights:t,getRemainingWeights:n}=jc(e),a=[],{extractConvLayerParams:r,extractResidualLayerParams:i}=N2e(t,a),s=r(4704,32,7,"conv32_down"),o=i(9216,32,3,"conv32_1"),u=i(9216,32,3,"conv32_2"),d=i(9216,32,3,"conv32_3"),c=i(36864,64,3,"conv64_down",!0),h=i(36864,64,3,"conv64_1"),m=i(36864,64,3,"conv64_2"),g=i(36864,64,3,"conv64_3"),x=i(147456,128,3,"conv128_down",!0),v=i(147456,128,3,"conv128_1"),S=i(147456,128,3,"conv128_2"),E=i(589824,256,3,"conv256_down",!0),C=i(589824,256,3,"conv256_1"),T=i(589824,256,3,"conv256_2"),N=i(589824,256,3,"conv256_down_out"),D=be(()=>Qt(nl(t(256*128),[128,256]),[1,0]));if(a.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:s,conv32_1:o,conv32_2:u,conv32_3:d,conv64_down:c,conv64_1:h,conv64_2:m,conv64_3:g,conv128_down:x,conv128_1:v,conv128_2:S,conv256_down:E,conv256_1:C,conv256_2:T,conv256_down_out:N,fc:D},paramMappings:a}}function F2e(e,t){let n=Kh(e,t);function a(s){let o=n(`${s}/scale/weights`,1),u=n(`${s}/scale/biases`,1);return{weights:o,biases:u}}function r(s){let o=n(`${s}/conv/filters`,4),u=n(`${s}/conv/bias`,1),d=a(s);return{conv:{filters:o,bias:u},scale:d}}function i(s){return{conv1:r(`${s}/conv1`),conv2:r(`${s}/conv2`)}}return{extractConvLayerParams:r,extractResidualLayerParams:i}}function D2e(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:a}=F2e(e,t),r=n("conv32_down"),i=a("conv32_1"),s=a("conv32_2"),o=a("conv32_3"),u=a("conv64_down"),d=a("conv64_1"),c=a("conv64_2"),h=a("conv64_3"),m=a("conv128_down"),g=a("conv128_1"),x=a("conv128_2"),v=a("conv256_down"),S=a("conv256_1"),E=a("conv256_2"),C=a("conv256_down_out"),{fc:T}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!kU(T))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${T}`);let N={conv32_down:r,conv32_1:i,conv32_2:s,conv32_3:o,conv64_down:u,conv64_1:d,conv64_2:c,conv64_3:h,conv128_down:m,conv128_1:g,conv128_2:x,conv256_down:v,conv256_1:S,conv256_2:E,conv256_down_out:C,fc:T};return Yc(e,t),{params:N,paramMappings:t}}function Go(e,t){let n=T2e(e,t.conv1);return n=sV(n,t.conv2),n=Oe(n,e),n=zn(n),n}function r1(e,t){let n=oV(e,t.conv1);n=sV(n,t.conv2);let a=su(e,2,2,"valid"),r=wa(a.shape),i=a.shape[3]!==n.shape[3];if(a.shape[1]!==n.shape[1]||a.shape[2]!==n.shape[2]){let s=[...n.shape];s[1]=1;let o=wa(s);n=Gn([n,o],1);let u=[...n.shape];u[2]=1;let d=wa(u);n=Gn([n,d],2)}return a=i?Gn([a,r],3):a,n=Oe(a,n),n=zn(n),n}var O2e=class extends Jc{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return be(()=>{let n=je(e.toBatchTensor(150,!0),"float32"),a=pw(n,[122.782,117.001,104.298]).div(255),r=oV(a,t.conv32_down);r=ar(r,3,2,"valid"),r=Go(r,t.conv32_1),r=Go(r,t.conv32_2),r=Go(r,t.conv32_3),r=r1(r,t.conv64_down),r=Go(r,t.conv64_1),r=Go(r,t.conv64_2),r=Go(r,t.conv64_3),r=r1(r,t.conv128_down),r=Go(r,t.conv128_1),r=Go(r,t.conv128_2),r=r1(r,t.conv256_down),r=Go(r,t.conv256_1),r=Go(r,t.conv256_2),r=r1(r,t.conv256_down_out);let i=r.mean([1,2]);return jt(i,t.fc)})}async forward(e){return this.forwardInput(await Kr(e))}async computeFaceDescriptor(e){var t;if((t=e==null?void 0:e.shape)!=null&&t.some(i=>i<=0))return new Float32Array(128);let n=await Kr(e),a=be(()=>Aa(this.forwardInput(n))),r=await Promise.all(a.map(i=>i.data()));return a.forEach(i=>i.dispose()),n.isBatchInput?r:r[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return D2e(e)}extractParams(e){return R2e(e)}};function lV(e,t){return{...e,descriptor:t}}function uV(e,t){return{...e,age:t}}function cV(e,t,n){return{...e,gender:t,genderProbability:n}}function M2e(e,t){function n(u,d){let c=Ec(e(9*u),[3,3,u,1]),h=Dn(e(u)),m=Dn(e(u)),g=Dn(e(u)),x=Dn(e(u));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/batch_norm_scale`},{paramPath:`${d}/batch_norm_offset`},{paramPath:`${d}/batch_norm_mean`},{paramPath:`${d}/batch_norm_variance`}),{filters:c,batch_norm_scale:h,batch_norm_offset:m,batch_norm_mean:g,batch_norm_variance:x}}function a(u,d,c,h,m){let g=Ec(e(u*d*c*c),[c,c,u,d]),x=Dn(e(d));return t.push({paramPath:`${h}/filters`},{paramPath:`${h}/${m?"batch_norm_offset":"bias"}`}),{filters:g,bias:x}}function r(u,d,c,h){let{filters:m,bias:g}=a(u,d,c,h,!0);return{filters:m,batch_norm_offset:g}}function i(u,d,c){let h=n(u,`${c}/depthwise_conv`),m=r(u,d,1,`${c}/pointwise_conv`);return{depthwise_conv:h,pointwise_conv:m}}function s(){let u=r(3,32,3,"mobilenetv1/conv_0"),d=i(32,64,"mobilenetv1/conv_1"),c=i(64,128,"mobilenetv1/conv_2"),h=i(128,128,"mobilenetv1/conv_3"),m=i(128,256,"mobilenetv1/conv_4"),g=i(256,256,"mobilenetv1/conv_5"),x=i(256,512,"mobilenetv1/conv_6"),v=i(512,512,"mobilenetv1/conv_7"),S=i(512,512,"mobilenetv1/conv_8"),E=i(512,512,"mobilenetv1/conv_9"),C=i(512,512,"mobilenetv1/conv_10"),T=i(512,512,"mobilenetv1/conv_11"),N=i(512,1024,"mobilenetv1/conv_12"),D=i(1024,1024,"mobilenetv1/conv_13");return{conv_0:u,conv_1:d,conv_2:c,conv_3:h,conv_4:m,conv_5:g,conv_6:x,conv_7:v,conv_8:S,conv_9:E,conv_10:C,conv_11:T,conv_12:N,conv_13:D}}function o(){let u=r(1024,256,1,"prediction_layer/conv_0"),d=r(256,512,3,"prediction_layer/conv_1"),c=r(512,128,1,"prediction_layer/conv_2"),h=r(128,256,3,"prediction_layer/conv_3"),m=r(256,128,1,"prediction_layer/conv_4"),g=r(128,256,3,"prediction_layer/conv_5"),x=r(256,64,1,"prediction_layer/conv_6"),v=r(64,128,3,"prediction_layer/conv_7"),S=a(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),E=a(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),C=a(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),T=a(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),N=a(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),D=a(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),q=a(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),H=a(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),K=a(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),j=a(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),te=a(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),Q=a(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:u,conv_1:d,conv_2:c,conv_3:h,conv_4:m,conv_5:g,conv_6:x,conv_7:v,box_predictor_0:{box_encoding_predictor:S,class_predictor:E},box_predictor_1:{box_encoding_predictor:C,class_predictor:T},box_predictor_2:{box_encoding_predictor:N,class_predictor:D},box_predictor_3:{box_encoding_predictor:q,class_predictor:H},box_predictor_4:{box_encoding_predictor:K,class_predictor:j},box_predictor_5:{box_encoding_predictor:te,class_predictor:Q}}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:o}}function B2e(e){let t=[],{extractWeights:n,getRemainingWeights:a}=jc(e),{extractMobilenetV1Params:r,extractPredictionLayerParams:i}=M2e(n,t),s=r(),o=i(),u={extra_dim:Wv(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:{mobilenetv1:s,prediction_layer:o,output_layer:u},paramMappings:t}}function L2e(e,t){let n=Kh(e,t);function a(d,c,h){let m=n(`${d}/Conv2d_${c}_pointwise/weights`,4,`${h}/filters`),g=n(`${d}/Conv2d_${c}_pointwise/convolution_bn_offset`,1,`${h}/batch_norm_offset`);return{filters:m,batch_norm_offset:g}}function r(d){let c=`mobilenetv1/conv_${d}`,h=`MobilenetV1/Conv2d_${d}_depthwise`,m=`${c}/depthwise_conv`,g=`${c}/pointwise_conv`,x=n(`${h}/depthwise_weights`,4,`${m}/filters`),v=n(`${h}/BatchNorm/gamma`,1,`${m}/batch_norm_scale`),S=n(`${h}/BatchNorm/beta`,1,`${m}/batch_norm_offset`),E=n(`${h}/BatchNorm/moving_mean`,1,`${m}/batch_norm_mean`),C=n(`${h}/BatchNorm/moving_variance`,1,`${m}/batch_norm_variance`);return{depthwise_conv:{filters:x,batch_norm_scale:v,batch_norm_offset:S,batch_norm_mean:E,batch_norm_variance:C},pointwise_conv:a("MobilenetV1",d,g)}}function i(){return{conv_0:a("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:r(1),conv_2:r(2),conv_3:r(3),conv_4:r(4),conv_5:r(5),conv_6:r(6),conv_7:r(7),conv_8:r(8),conv_9:r(9),conv_10:r(10),conv_11:r(11),conv_12:r(12),conv_13:r(13)}}function s(d,c){let h=n(`${d}/weights`,4,`${c}/filters`),m=n(`${d}/biases`,1,`${c}/bias`);return{filters:h,bias:m}}function o(d){let c=s(`Prediction/BoxPredictor_${d}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${d}/box_encoding_predictor`),h=s(`Prediction/BoxPredictor_${d}/ClassPredictor`,`prediction_layer/box_predictor_${d}/class_predictor`);return{box_encoding_predictor:c,class_predictor:h}}function u(){return{conv_0:a("Prediction",0,"prediction_layer/conv_0"),conv_1:a("Prediction",1,"prediction_layer/conv_1"),conv_2:a("Prediction",2,"prediction_layer/conv_2"),conv_3:a("Prediction",3,"prediction_layer/conv_3"),conv_4:a("Prediction",4,"prediction_layer/conv_4"),conv_5:a("Prediction",5,"prediction_layer/conv_5"),conv_6:a("Prediction",6,"prediction_layer/conv_6"),conv_7:a("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:u}}function z2e(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:a}=L2e(e,t),r=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!dw(r))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${r}`);let i={mobilenetv1:n(),prediction_layer:a(),output_layer:{extra_dim:r}};return Yc(e,t),{params:i,paramMappings:t}}function Yo(e,t,n){return be(()=>{let a=Hr(e,t.filters,n,"same");return a=Oe(a,t.batch_norm_offset),Rr(a,0,6)})}var U2e=.0010000000474974513;function V2e(e,t,n){return be(()=>{let a=Bh(e,t.filters,n,"same");return a=Mh(a,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,U2e),Rr(a,0,6)})}function W2e(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function q2e(e,t){return be(()=>{let n,a=Yo(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((r,i)=>{let s=i+1,o=W2e(s);a=V2e(a,r.depthwise_conv,o),a=Yo(a,r.pointwise_conv,[1,1]),s===11&&(n=a)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:a,conv11:n}})}function P2e(e,t,n){let a=e.arraySync(),r=Math.min(a[t][0],a[t][2]),i=Math.min(a[t][1],a[t][3]),s=Math.max(a[t][0],a[t][2]),o=Math.max(a[t][1],a[t][3]),u=Math.min(a[n][0],a[n][2]),d=Math.min(a[n][1],a[n][3]),c=Math.max(a[n][0],a[n][2]),h=Math.max(a[n][1],a[n][3]),m=(s-r)*(o-i),g=(c-u)*(h-d);if(m<=0||g<=0)return 0;let x=Math.max(r,u),v=Math.max(i,d),S=Math.min(s,c),E=Math.min(o,h),C=Math.max(S-x,0)*Math.max(E-v,0);return C/(m+g-C)}function H2e(e,t,n,a,r){let i=e.shape[0],s=Math.min(n,i),o=t.map((c,h)=>({score:c,boxIndex:h})).filter(c=>c.score>r).sort((c,h)=>h.score-c.score),u=c=>c<=a?1:0,d=[];return o.forEach(c=>{if(d.length>=s)return;let h=c.score;for(let m=d.length-1;m>=0;--m){let g=P2e(e,c.boxIndex,d[m]);if(g!==0&&(c.score*=u(g),c.score<=r))break}h===c.score&&d.push(c.boxIndex)}),d}function G2e(e){let t=Aa(Qt(e,[1,0])),n=[at(t[2],t[0]),at(t[3],t[1])],a=[Oe(t[0],it(n[0],2)),Oe(t[1],it(n[1],2))];return{sizes:n,centers:a}}function K2e(e,t){let{sizes:n,centers:a}=G2e(e),r=Aa(Qt(t,[1,0])),i=it(pe(Fr(it(r[2],5)),n[0]),2),s=Oe(pe(it(r[0],10),n[0]),a[0]),o=it(pe(Fr(it(r[3],5)),n[1]),2),u=Oe(pe(it(r[1],10),n[1]),a[1]);return Qt(Ba([at(s,i),at(u,o),Oe(s,i),Oe(u,o)]),[1,0])}function $2e(e,t,n){return be(()=>{let a=e.shape[0],r=K2e(ge(Ti(n.extra_dim,[a,1,1]),[-1,4]),ge(e,[-1,4]));r=ge(r,[a,r.shape[0]/a,4]);let i=Ns(un(t,[0,0,1],[-1,-1,-1])),s=un(i,[0,0,0],[-1,-1,1]);s=ge(s,[a,s.shape[1]]);let o=Aa(r),u=Aa(s);return{boxes:o,scores:u}})}function am(e,t){return be(()=>{let n=e.shape[0],a=ge(Wy(e,t.box_encoding_predictor),[n,-1,1,4]),r=ge(Wy(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:a,classPrediction:r}})}function J2e(e,t,n){return be(()=>{let a=Yo(e,n.conv_0,[1,1]),r=Yo(a,n.conv_1,[2,2]),i=Yo(r,n.conv_2,[1,1]),s=Yo(i,n.conv_3,[2,2]),o=Yo(s,n.conv_4,[1,1]),u=Yo(o,n.conv_5,[2,2]),d=Yo(u,n.conv_6,[1,1]),c=Yo(d,n.conv_7,[2,2]),h=am(t,n.box_predictor_0),m=am(e,n.box_predictor_1),g=am(r,n.box_predictor_2),x=am(s,n.box_predictor_3),v=am(u,n.box_predictor_4),S=am(c,n.box_predictor_5),E=Gn([h.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding,x.boxPredictionEncoding,v.boxPredictionEncoding,S.boxPredictionEncoding],1),C=Gn([h.classPrediction,m.classPrediction,g.classPrediction,x.classPrediction,v.classPrediction,S.classPrediction],1);return{boxPredictions:E,classPredictions:C}})}var IS=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},Y2e=class extends Jc{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return be(()=>{let n=je(e.toBatchTensor(512,!1),"float32"),a=at(it(n,127.5),1),r=q2e(a,t.mobilenetv1),{boxPredictions:i,classPredictions:s}=J2e(r.out,r.conv11,t.prediction_layer);return $2e(i,s,t.output_layer)})}async forward(e){return this.forwardInput(await Kr(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:a}=new IS(t),r=await Kr(e),{boxes:i,scores:s}=this.forwardInput(r),o=i[0],u=s[0];for(let E=1;E<i.length;E++)i[E].dispose(),s[E].dispose();let d=Array.from(u.dataSync()),c=H2e(o,d,n,.5,a),h=r.getReshapedInputDimensions(0),m=r.inputSize,g=m/h.width,x=m/h.height,v=o.arraySync(),S=c.map(E=>{let[C,T]=[Math.max(0,v[E][0]),Math.min(1,v[E][2])].map(q=>q*x),[N,D]=[Math.max(0,v[E][1]),Math.min(1,v[E][3])].map(q=>q*g);return new po(d[E],new NU(N,C,D-N,T-C),{height:r.getInputHeight(0),width:r.getInputWidth(0)})});return o.dispose(),u.dispose(),S}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return z2e(e)}extractParams(e){return B2e(e)}},j2e=.4,Q2e=[new Pn(.738768,.874946),new Pn(2.42204,2.65704),new Pn(4.30971,7.04493),new Pn(10.246,4.59428),new Pn(12.6868,11.8741)],Z2e=[new Pn(1.603231,2.094468),new Pn(6.041143,7.080126),new Pn(2.882459,3.518061),new Pn(4.266906,5.178857),new Pn(9.041765,10.66308)],X2e=[117.001,114.697,97.404],eke="tiny_yolov2_model",tke="tiny_yolov2_separable_conv_model",i1=e=>typeof e=="number";function nke(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!i1(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>i1(t.x)&&i1(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(i1)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function O_(e){return be(()=>{let t=pe(e,gt(.10000000149011612));return Oe(zn(at(e,t)),t)})}function ac(e,t){return be(()=>{let n=ho(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Hr(n,t.conv.filters,[1,1],"valid"),n=at(n,t.bn.sub),n=pe(n,t.bn.truediv),n=Oe(n,t.conv.bias),O_(n)})}function rc(e,t){return be(()=>{let n=ho(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Vg(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=Oe(n,t.bias),O_(n)})}function ake(e,t){let n=T_(e,t);function a(s,o){let u=Dn(e(s)),d=Dn(e(s));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:u,truediv:d}}function r(s,o,u){let d=n(s,o,3,`${u}/conv`),c=a(o,`${u}/bn`);return{conv:d,bn:c}}let i=N_(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:r,extractSeparableConvParams:i}}function rke(e,t,n,a){let{extractWeights:r,getRemainingWeights:i}=jc(e),s=[],{extractConvParams:o,extractConvWithBatchNormParams:u,extractSeparableConvParams:d}=ake(r,s),c;if(t.withSeparableConvs){let[h,m,g,x,v,S,E,C,T]=a,N=t.isFirstLayerConv2d?o(h,m,3,"conv0"):d(h,m,"conv0"),D=d(m,g,"conv1"),q=d(g,x,"conv2"),H=d(x,v,"conv3"),K=d(v,S,"conv4"),j=d(S,E,"conv5"),te=C?d(E,C,"conv6"):void 0,Q=T?d(C,T,"conv7"):void 0,z=o(T||C||E,5*n,1,"conv8");c={conv0:N,conv1:D,conv2:q,conv3:H,conv4:K,conv5:j,conv6:te,conv7:Q,conv8:z}}else{let[h,m,g,x,v,S,E,C,T]=a,N=u(h,m,"conv0"),D=u(m,g,"conv1"),q=u(g,x,"conv2"),H=u(x,v,"conv3"),K=u(v,S,"conv4"),j=u(S,E,"conv5"),te=u(E,C,"conv6"),Q=u(C,T,"conv7"),z=o(T,5*n,1,"conv8");c={conv0:N,conv1:D,conv2:q,conv3:H,conv4:K,conv5:j,conv6:te,conv7:Q,conv8:z}}if(i().length!==0)throw new Error(`weights remaing after extract: ${i().length}`);return{params:c,paramMappings:s}}function ike(e,t){let n=Kh(e,t);function a(o){let u=n(`${o}/sub`,1),d=n(`${o}/truediv`,1);return{sub:u,truediv:d}}function r(o){let u=n(`${o}/filters`,4),d=n(`${o}/bias`,1);return{filters:u,bias:d}}function i(o){let u=r(`${o}/conv`),d=a(`${o}/bn`);return{conv:u,bn:d}}let s=R_(n);return{extractConvParams:r,extractConvWithBatchNormParams:i,extractSeparableConvParams:s}}function ske(e,t){let n=[],{extractConvParams:a,extractConvWithBatchNormParams:r,extractSeparableConvParams:i}=ike(e,n),s;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;s={conv0:t.isFirstLayerConv2d?a("conv0"):i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:o>7?i("conv6"):void 0,conv7:o>8?i("conv7"):void 0,conv8:a("conv8")}}else s={conv0:r("conv0"),conv1:r("conv1"),conv2:r("conv2"),conv3:r("conv3"),conv4:r("conv4"),conv5:r("conv5"),conv6:r("conv6"),conv7:r("conv7"),conv8:a("conv8")};return Yc(e,n),{params:s,paramMappings:n}}var M_=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},dV=class pV extends Jc{constructor(t){super("TinyYolov2"),nke(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let a=ac(t,n.conv0);return a=ar(a,[2,2],[2,2],"same"),a=ac(a,n.conv1),a=ar(a,[2,2],[2,2],"same"),a=ac(a,n.conv2),a=ar(a,[2,2],[2,2],"same"),a=ac(a,n.conv3),a=ar(a,[2,2],[2,2],"same"),a=ac(a,n.conv4),a=ar(a,[2,2],[2,2],"same"),a=ac(a,n.conv5),a=ar(a,[2,2],[1,1],"same"),a=ac(a,n.conv6),a=ac(a,n.conv7),Wy(a,n.conv8,"valid",!1)}runMobilenet(t,n){let a=this.config.isFirstLayerConv2d?O_(Wy(t,n.conv0,"valid",!1)):rc(t,n.conv0);return a=ar(a,[2,2],[2,2],"same"),a=rc(a,n.conv1),a=ar(a,[2,2],[2,2],"same"),a=rc(a,n.conv2),a=ar(a,[2,2],[2,2],"same"),a=rc(a,n.conv3),a=ar(a,[2,2],[2,2],"same"),a=rc(a,n.conv4),a=ar(a,[2,2],[2,2],"same"),a=rc(a,n.conv5),a=ar(a,[2,2],[1,1],"same"),a=n.conv6?rc(a,n.conv6):a,a=n.conv7?rc(a,n.conv7):a,Wy(a,n.conv8,"valid",!1)}forwardInput(t,n){let{params:a}=this;if(!a)throw new Error("TinyYolov2 - load model before inference");return be(()=>{let r=je(t.toBatchTensor(n,!1),"float32");return r=this.config.meanRgb?pw(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,a):this.runTinyYolov2(r,a)})}async forward(t,n){return this.forwardInput(await Kr(t),n)}async detect(t,n={}){let{inputSize:a,scoreThreshold:r}=new M_(n),i=await Kr(t),s=await this.forwardInput(i,a),o=be(()=>Aa(s)[0].expandDims()),u={width:i.getInputWidth(0),height:i.getInputHeight(0)},d=await this.extractBoxes(o,i.getReshapedInputDimensions(0),r);s.dispose(),o.dispose();let c=d.map(x=>x.box),h=d.map(x=>x.score),m=d.map(x=>x.classScore),g=d.map(x=>this.config.classes[x.label]);return HSe(c.map(x=>x.rescale(a)),h,this.config.iouThreshold,!0).map(x=>new IU(h[x],m[x],g[x],c[x],u))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return ske(t,this.config)}extractParams(t){let n=this.config.filterSizes||pV.DEFAULT_FILTER_SIZES,a=n?n.length:void 0;if(a!==7&&a!==8&&a!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${a} filterSizes in config`);return rke(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,a){let{width:r,height:i}=n,s=Math.max(r,i),o=s/r,u=s/i,d=t.shape[1],c=this.config.anchors.length,[h,m,g]=be(()=>{let E=t.reshape([d,d,c,this.boxEncodingSize]),C=E.slice([0,0,0,0],[d,d,c,4]),T=E.slice([0,0,0,4],[d,d,c,1]),N=this.withClassScores?qc(E.slice([0,0,0,5],[d,d,c,this.config.classes.length]),3):gt(0);return[C,T,N]}),x=[],v=await m.array(),S=await h.array();for(let E=0;E<d;E++)for(let C=0;C<d;C++)for(let T=0;T<c;T++){let N=ck(v[E][C][T][0]);if(!a||N>a){let D=(C+ck(S[E][C][T][0]))/d*o,q=(E+ck(S[E][C][T][1]))/d*u,H=Math.exp(S[E][C][T][2])*this.config.anchors[T].x/d*o,K=Math.exp(S[E][C][T][3])*this.config.anchors[T].y/d*u,j=D-H/2,te=q-K/2,Q={row:E,col:C,anchor:T},{classScore:z,label:ae}=this.withClassScores?await this.extractPredictedClass(g,Q):{classScore:1,label:0};x.push({box:new CU(j,te,j+H,te+K),score:N,classScore:N*z,label:ae,...Q})}}return h.dispose(),m.dispose(),g.dispose(),x}async extractPredictedClass(t,n){let{row:a,col:r,anchor:i}=n,s=await t.array();return Array(this.config.classes.length).fill(0).map((o,u)=>s[a][r][i][u]).map((o,u)=>({classScore:o,label:u})).reduce((o,u)=>o.classScore>u.classScore?o:u)}};dV.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var hV=dV,oke=class extends hV{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:j2e,classes:["face"],...e?{anchors:Z2e,meanRgb:X2e}:{anchors:Q2e,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new po(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?tke:eke}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},lke=class extends M_{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},hw=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function _S(e,t,n,a,r=({alignedRect:i})=>i){let i=e.map(u=>eV(u)?r(u):u.detection),s=a||(t instanceof $t?await __(t,i):await I_(t,i)),o=await n(s);return s.forEach(u=>u instanceof $t&&u.dispose()),o}async function B_(e,t,n,a,r){return _S([e],t,async i=>n(i[0]),a,r)}var uke=.4,cke=[new Pn(1.603231,2.094468),new Pn(6.041143,7.080126),new Pn(2.882459,3.518061),new Pn(4.266906,5.178857),new Pn(9.041765,10.66308)],dke=[117.001,114.697,97.404],pke=class extends hV{constructor(){let e={withSeparableConvs:!0,iouThreshold:uke,classes:["face"],anchors:cke,meanRgb:dke,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new po(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Ri={ssdMobilenetv1:new Y2e,tinyFaceDetector:new pke,tinyYolov2:new oke,faceLandmark68Net:new k2e,faceLandmark68TinyNet:new I2e,faceRecognitionNet:new O2e,faceExpressionNet:new l2e,ageGenderNet:new S2e},fV=class extends hw{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},L_=class extends fV{async run(){let e=await this.parentTask,t=await _S(e,this.input,async n=>Promise.all(n.map(a=>Ri.faceExpressionNet.predictExpressions(a))),this.extractedFaces);return e.map((n,a)=>XU(n,t[a]))}withAgeAndGender(){return new W_(this,this.input)}},z_=class extends fV{async run(){let e=await this.parentTask;if(!e)return;let t=await B_(e,this.input,n=>Ri.faceExpressionNet.predictExpressions(n),this.extractedFaces);return XU(e,t)}withAgeAndGender(){return new q_(this,this.input)}},U_=class extends L_{withAgeAndGender(){return new P_(this,this.input)}withFaceDescriptors(){return new G_(this,this.input)}},V_=class extends z_{withAgeAndGender(){return new H_(this,this.input)}withFaceDescriptor(){return new K_(this,this.input)}},mV=class extends hw{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},W_=class extends mV{async run(){let e=await this.parentTask,t=await _S(e,this.input,async n=>Promise.all(n.map(a=>Ri.ageGenderNet.predictAgeAndGender(a))),this.extractedFaces);return e.map((n,a)=>{let{age:r,gender:i,genderProbability:s}=t[a];return uV(cV(n,i,s),r)})}withFaceExpressions(){return new L_(this,this.input)}},q_=class extends mV{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:a}=await B_(e,this.input,r=>Ri.ageGenderNet.predictAgeAndGender(r),this.extractedFaces);return uV(cV(e,n,a),t)}withFaceExpressions(){return new z_(this,this.input)}},P_=class extends W_{withFaceExpressions(){return new U_(this,this.input)}withFaceDescriptors(){return new G_(this,this.input)}},H_=class extends q_{withFaceExpressions(){return new V_(this,this.input)}withFaceDescriptor(){return new K_(this,this.input)}},gV=class extends hw{constructor(e,t){super(),this.parentTask=e,this.input=t}},G_=class extends gV{async run(){let e=await this.parentTask;return(await _S(e,this.input,t=>Promise.all(t.map(n=>Ri.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>lV(e[n],t))}withFaceExpressions(){return new U_(this,this.input)}withAgeAndGender(){return new P_(this,this.input)}},K_=class extends gV{async run(){let e=await this.parentTask;if(!e)return;let t=await B_(e,this.input,n=>Ri.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return lV(e,t)}withFaceExpressions(){return new V_(this,this.input)}withAgeAndGender(){return new H_(this,this.input)}},bV=class extends hw{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Ri.faceLandmark68TinyNet:Ri.faceLandmark68Net}},hke=class extends bV{async run(){let e=await this.parentTask,t=e.map(r=>r.detection),n=this.input instanceof $t?await __(this.input,t):await I_(this.input,t),a=await Promise.all(n.map(r=>this.landmarkNet.detectLandmarks(r)));return n.forEach(r=>r instanceof $t&&r.dispose()),e.filter((r,i)=>a[i]).map((r,i)=>tV(r,a[i]))}withFaceExpressions(){return new U_(this,this.input)}withAgeAndGender(){return new P_(this,this.input)}withFaceDescriptors(){return new G_(this,this.input)}},fke=class extends bV{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof $t?await __(this.input,[t]):await I_(this.input,[t]),a=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(r=>r instanceof $t&&r.dispose()),tV(e,a)}withFaceExpressions(){return new V_(this,this.input)}withAgeAndGender(){return new H_(this,this.input)}withFaceDescriptor(){return new K_(this,this.input)}},yV=class extends hw{constructor(e,t=new IS){super(),this.input=e,this.options=t}},mke=class extends yV{async run(){let{input:e,options:t}=this,n;if(t instanceof lke)n=Ri.tinyFaceDetector.locateFaces(e,t);else if(t instanceof IS)n=Ri.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof M_)n=Ri.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(a=>FU({},a)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new hke(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new L_(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new W_(this.runAndExtendWithFaceDetections(),this.input)}},gke=class extends yV{async run(){let e=await new mke(this.input,this.options),t=e[0];return e.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?FU({},t):void 0)})}withFaceLandmarks(e=!1){return new fke(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new z_(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new q_(this.runAndExtendWithFaceDetection(),this.input)}};function hk(e,t=new IS){return new gke(e,t)}let ua;const Ql=new Array(128).fill(void 0);Ql.push(void 0,null,!0,!1);function yt(e){return Ql[e]}let qy=Ql.length;function bke(e){e<132||(Ql[e]=qy,qy=e)}function Py(e){const t=yt(e);return bke(e),t}let Yd=0,Ry=null;function hm(){return(Ry===null||Ry.byteLength===0)&&(Ry=new Uint8Array(ua.memory.buffer)),Ry}const g1=typeof TextEncoder<"u"?new TextEncoder("utf-8"):{encode:()=>{throw Error("TextEncoder not available")}},yke=typeof g1.encodeInto=="function"?function(e,t){return g1.encodeInto(e,t)}:function(e,t){const n=g1.encode(e);return t.set(n),{read:e.length,written:n.length}};function fk(e,t,n){if(n===void 0){const o=g1.encode(e),u=t(o.length)>>>0;return hm().subarray(u,u+o.length).set(o),Yd=o.length,u}let a=e.length,r=t(a)>>>0;const i=hm();let s=0;for(;s<a;s++){const o=e.charCodeAt(s);if(o>127)break;i[r+s]=o}if(s!==a){s!==0&&(e=e.slice(s)),r=n(r,a,a=s+e.length*3)>>>0;const o=hm().subarray(r+s,r+a),u=yke(e,o);s+=u.written}return Yd=s,r}function mk(e){return e==null}let Fy=null;function no(){return(Fy===null||Fy.byteLength===0)&&(Fy=new Int32Array(ua.memory.buffer)),Fy}function Nn(e){qy===Ql.length&&Ql.push(Ql.length+1);const t=qy;return qy=Ql[t],Ql[t]=e,t}const wV=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&wV.decode();function wy(e,t){return e=e>>>0,wV.decode(hm().subarray(e,e+t))}let Dy=null;function wke(){return(Dy===null||Dy.byteLength===0)&&(Dy=new Float64Array(ua.memory.buffer)),Dy}function AA(e){const t=typeof e;if(t=="number"||t=="boolean"||e==null)return`${e}`;if(t=="string")return`"${e}"`;if(t=="symbol"){const r=e.description;return r==null?"Symbol":`Symbol(${r})`}if(t=="function"){const r=e.name;return typeof r=="string"&&r.length>0?`Function(${r})`:"Function"}if(Array.isArray(e)){const r=e.length;let i="[";r>0&&(i+=AA(e[0]));for(let s=1;s<r;s++)i+=", "+AA(e[s]);return i+="]",i}const n=/\[object ([^\]]+)\]/.exec(toString.call(e));let a;if(n.length>1)a=n[1];else return toString.call(e);if(a=="Object")try{return"Object("+JSON.stringify(e)+")"}catch{return"Object"}return e instanceof Error?`${e.name}: ${e.message}
${e.stack}`:a}function xke(e,t,n,a){const r={a:e,b:t,cnt:1,dtor:n},i=(...s)=>{r.cnt++;const o=r.a;r.a=0;try{return a(o,r.b,...s)}finally{--r.cnt===0?ua.__wbindgen_export_2.get(r.dtor)(o,r.b):r.a=o}};return i.original=r,i}function vke(e,t,n){ua.wasm_bindgen__convert__closures__invoke1_mut__h0d2f2cab014f8c52(e,t,Nn(n))}function Ske(e,t){const n=t(e.length*1)>>>0;return hm().set(e,n/1),Yd=e.length,n}function kke(e,t,n){const a=Ske(e,ua.__wbindgen_malloc),r=Yd,i=ua.executeProgram(a,r,Nn(t),Nn(n));return Py(i)}function Ake(e,t){return e=e>>>0,hm().subarray(e/1,e/1+t)}function Eke(e){try{const s=ua.__wbindgen_add_to_stack_pointer(-16);ua.compressWitnessStack(s,Nn(e));var t=no()[s/4+0],n=no()[s/4+1],a=no()[s/4+2],r=no()[s/4+3];if(r)throw Py(a);var i=Ake(t,n).slice();return ua.__wbindgen_free(t,n*1),i}finally{ua.__wbindgen_add_to_stack_pointer(16)}}function Cke(e,t,n,a,r){ua.wasm_bindgen__convert__closures__invoke3_mut__h2e8a0e541cb0c3bc(e,t,Nn(n),a,Nn(r))}function xy(e,t){try{return e.apply(this,t)}catch(n){ua.__wbindgen_exn_store(Nn(n))}}function a3(e,t,n,a){ua.wasm_bindgen__convert__closures__invoke2_mut__h56728cbaf4bbea81(e,t,Nn(n),Nn(a))}async function Ike(e,t){if(typeof Response=="function"&&e instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(e,t)}catch(a){if(e.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",a);else throw a}const n=await e.arrayBuffer();return await WebAssembly.instantiate(n,t)}else{const n=await WebAssembly.instantiate(e,t);return n instanceof WebAssembly.Instance?{instance:n,module:e}:n}}function _ke(){const e={};return e.wbg={},e.wbg.__wbindgen_object_drop_ref=function(t){Py(t)},e.wbg.__wbindgen_is_array=function(t){return Array.isArray(yt(t))},e.wbg.__wbindgen_is_string=function(t){return typeof yt(t)=="string"},e.wbg.__wbindgen_string_get=function(t,n){const a=yt(n),r=typeof a=="string"?a:void 0;var i=mk(r)?0:fk(r,ua.__wbindgen_malloc,ua.__wbindgen_realloc),s=Yd;no()[t/4+1]=s,no()[t/4+0]=i},e.wbg.__wbg_new_9f82ec4c0bc017c1=function(){return Nn(new Map)},e.wbg.__wbindgen_number_new=function(t){return Nn(t)},e.wbg.__wbindgen_string_new=function(t,n){const a=wy(t,n);return Nn(a)},e.wbg.__wbindgen_cb_drop=function(t){const n=Py(t).original;return n.cnt--==1?(n.a=0,!0):!1},e.wbg.__wbg_constructor_3697b3eaa19355e5=function(t){const n=new Error(Py(t));return Nn(n)},e.wbg.__wbg_new_0fe3b501601ef88e=function(){const t=new Array;return Nn(t)},e.wbg.__wbindgen_number_get=function(t,n){const a=yt(n),r=typeof a=="number"?a:void 0;wke()[t/8+1]=mk(r)?0:r,no()[t/4+0]=!mk(r)},e.wbg.__wbg_new_abda76e883ba8a5f=function(){const t=new Error;return Nn(t)},e.wbg.__wbg_stack_658279fe44541cf6=function(t,n){const a=yt(n).stack,r=fk(a,ua.__wbindgen_malloc,ua.__wbindgen_realloc),i=Yd;no()[t/4+1]=i,no()[t/4+0]=r},e.wbg.__wbg_error_f851667af71bcfc6=function(t,n){let a,r;try{a=t,r=n,console.error(wy(t,n))}finally{ua.__wbindgen_free(a,r)}},e.wbg.__wbg_debug_e3f6a1578e6d45ca=function(t){console.debug(yt(t))},e.wbg.__wbg_debug_efabe4eb183aa5d4=function(t,n,a,r){console.debug(yt(t),yt(n),yt(a),yt(r))},e.wbg.__wbg_error_a7e23606158b68b9=function(t){console.error(yt(t))},e.wbg.__wbg_error_50f42b952a595a23=function(t,n,a,r){console.error(yt(t),yt(n),yt(a),yt(r))},e.wbg.__wbg_info_05db236d79f1b785=function(t){console.info(yt(t))},e.wbg.__wbg_info_24d8f53d98f12b95=function(t,n,a,r){console.info(yt(t),yt(n),yt(a),yt(r))},e.wbg.__wbg_warn_9bdd743e9f5fe1e0=function(t){console.warn(yt(t))},e.wbg.__wbg_warn_8342bfbc6028193a=function(t,n,a,r){console.warn(yt(t),yt(n),yt(a),yt(r))},e.wbg.__wbg_get_7303ed2ef026b2f5=function(t,n){const a=yt(t)[n>>>0];return Nn(a)},e.wbg.__wbg_length_820c786973abdd8a=function(t){return yt(t).length},e.wbg.__wbg_new_0394642eae39db16=function(){const t=new Array;return Nn(t)},e.wbg.__wbg_new_0f2b71ca2f2a6029=function(){return Nn(new Map)},e.wbg.__wbg_from_6bc98a09a0b58bb1=function(t){const n=Array.from(yt(t));return Nn(n)},e.wbg.__wbg_forEach_5ae261259d7517c8=function(t,n,a){try{var r={a:n,b:a},i=(s,o,u)=>{const d=r.a;r.a=0;try{return Cke(d,r.b,s,o,u)}finally{r.a=d}};yt(t).forEach(i)}finally{r.a=r.b=0}},e.wbg.__wbg_push_109cfc26d02582dd=function(t,n){return yt(t).push(yt(n))},e.wbg.__wbg_reverse_a322332d916e2705=function(t){const n=yt(t).reverse();return Nn(n)},e.wbg.__wbg_new_87297f22973157c8=function(t,n){const a=new Error(wy(t,n));return Nn(a)},e.wbg.__wbg_setcause_394738aae0ce9341=function(t,n){yt(t).cause=yt(n)},e.wbg.__wbg_call_587b30eea3e09332=function(){return xy(function(t,n,a){const r=yt(t).call(yt(n),yt(a));return Nn(r)},arguments)},e.wbg.__wbg_call_4c73e4aecced6a7d=function(){return xy(function(t,n,a,r){const i=yt(t).call(yt(n),yt(a),yt(r));return Nn(i)},arguments)},e.wbg.__wbg_forEach_942772130a8d06a6=function(t,n,a){try{var r={a:n,b:a},i=(s,o)=>{const u=r.a;r.a=0;try{return a3(u,r.b,s,o)}finally{r.a=u}};yt(t).forEach(i)}finally{r.a=r.b=0}},e.wbg.__wbg_set_da7be7bf0e037b14=function(t,n,a){const r=yt(t).set(yt(n),yt(a));return Nn(r)},e.wbg.__wbg_fromEntries_d1b310956d20d858=function(){return xy(function(t){const n=Object.fromEntries(yt(t));return Nn(n)},arguments)},e.wbg.__wbg_values_099fd000c271c313=function(t){const n=Object.values(yt(t));return Nn(n)},e.wbg.__wbg_new_2b55e405e4af4986=function(t,n){try{var a={a:t,b:n},r=(s,o)=>{const u=a.a;a.a=0;try{return a3(u,a.b,s,o)}finally{a.a=u}};const i=new Promise(r);return Nn(i)}finally{a.a=a.b=0}},e.wbg.__wbg_resolve_ae38ad63c43ff98b=function(t){const n=Promise.resolve(yt(t));return Nn(n)},e.wbg.__wbg_then_8df675b8bb5d5e3c=function(t,n){const a=yt(t).then(yt(n));return Nn(a)},e.wbg.__wbg_then_835b073a479138e5=function(t,n,a){const r=yt(t).then(yt(n),yt(a));return Nn(r)},e.wbg.__wbg_parse_76a8a18ca3f8730b=function(){return xy(function(t,n){const a=JSON.parse(wy(t,n));return Nn(a)},arguments)},e.wbg.__wbg_set_07da13cc24b69217=function(){return xy(function(t,n,a){return Reflect.set(yt(t),yt(n),yt(a))},arguments)},e.wbg.__wbindgen_debug_string=function(t,n){const a=AA(yt(n)),r=fk(a,ua.__wbindgen_malloc,ua.__wbindgen_realloc),i=Yd;no()[t/4+1]=i,no()[t/4+0]=r},e.wbg.__wbindgen_throw=function(t,n){throw new Error(wy(t,n))},e.wbg.__wbindgen_closure_wrapper782=function(t,n,a){const r=xke(t,n,298,vke);return Nn(r)},e}function Tke(e,t){return ua=e.exports,xV.__wbindgen_wasm_module=t,Dy=null,Fy=null,Ry=null,ua}async function xV(e){if(ua!==void 0)return ua;typeof e>"u"&&(e=new URL("/zkFace/assets/acvm_js_bg-DX4lGI0K.wasm",import.meta.url));const t=_ke();(typeof e=="string"||typeof Request=="function"&&e instanceof Request||typeof URL=="function"&&e instanceof URL)&&(e=fetch(e));const{instance:n,module:a}=await Ike(await e,t);return Tke(n,a)}let ka;const Zl=new Array(128).fill(void 0);Zl.push(void 0,null,!0,!1);function Jo(e){return Zl[e]}let Z1=0,Oy=null;function b1(){return(Oy===null||Oy.byteLength===0)&&(Oy=new Uint8Array(ka.memory.buffer)),Oy}const y1=typeof TextEncoder<"u"?new TextEncoder("utf-8"):{encode:()=>{throw Error("TextEncoder not available")}},Nke=typeof y1.encodeInto=="function"?function(e,t){return y1.encodeInto(e,t)}:function(e,t){const n=y1.encode(e);return t.set(n),{read:e.length,written:n.length}};function r3(e,t,n){if(n===void 0){const o=y1.encode(e),u=t(o.length)>>>0;return b1().subarray(u,u+o.length).set(o),Z1=o.length,u}let a=e.length,r=t(a)>>>0;const i=b1();let s=0;for(;s<a;s++){const o=e.charCodeAt(s);if(o>127)break;i[r+s]=o}if(s!==a){s!==0&&(e=e.slice(s)),r=n(r,a,a=s+e.length*3)>>>0;const o=b1().subarray(r+s,r+a),u=Nke(e,o);s+=u.written}return Z1=s,r}function w1(e){return e==null}let My=null;function _i(){return(My===null||My.byteLength===0)&&(My=new Int32Array(ka.memory.buffer)),My}let Hy=Zl.length;function Rke(e){e<132||(Zl[e]=Hy,Hy=e)}function Dc(e){const t=Jo(e);return Rke(e),t}function br(e){Hy===Zl.length&&Zl.push(Zl.length+1);const t=Hy;return Hy=Zl[t],Zl[t]=e,t}const vV=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&vV.decode();function s1(e,t){return e=e>>>0,vV.decode(b1().subarray(e,e+t))}let By=null;function Fke(){return(By===null||By.byteLength===0)&&(By=new Float64Array(ka.memory.buffer)),By}function Dke(e,t,n){try{const s=ka.__wbindgen_add_to_stack_pointer(-16);ka.abiEncode(s,br(e),br(t),w1(n)?0:br(n));var a=_i()[s/4+0],r=_i()[s/4+1],i=_i()[s/4+2];if(i)throw Dc(r);return Dc(a)}finally{ka.__wbindgen_add_to_stack_pointer(16)}}function Oke(e,t){try{const i=ka.__wbindgen_add_to_stack_pointer(-16);ka.abiDecode(i,br(e),br(t));var n=_i()[i/4+0],a=_i()[i/4+1],r=_i()[i/4+2];if(r)throw Dc(a);return Dc(n)}finally{ka.__wbindgen_add_to_stack_pointer(16)}}function Mke(e,t){try{const i=ka.__wbindgen_add_to_stack_pointer(-16);ka.abiDecodeError(i,br(e),br(t));var n=_i()[i/4+0],a=_i()[i/4+1],r=_i()[i/4+2];if(r)throw Dc(a);return Dc(n)}finally{ka.__wbindgen_add_to_stack_pointer(16)}}function Bke(e,t,n,a){ka.wasm_bindgen__convert__closures__invoke2_mut__h56728cbaf4bbea81(e,t,br(n),br(a))}function i3(e,t){try{return e.apply(this,t)}catch(n){ka.__wbindgen_exn_store(br(n))}}async function Lke(e,t){if(typeof Response=="function"&&e instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(e,t)}catch(a){if(e.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",a);else throw a}const n=await e.arrayBuffer();return await WebAssembly.instantiate(n,t)}else{const n=await WebAssembly.instantiate(e,t);return n instanceof WebAssembly.Instance?{instance:n,module:e}:n}}function zke(){const e={};return e.wbg={},e.wbg.__wbg_constructor_4993331818866f11=function(t){const n=new Error(Dc(t));return br(n)},e.wbg.__wbindgen_string_get=function(t,n){const a=Jo(n),r=typeof a=="string"?a:void 0;var i=w1(r)?0:r3(r,ka.__wbindgen_malloc,ka.__wbindgen_realloc),s=Z1;_i()[t/4+1]=s,_i()[t/4+0]=i},e.wbg.__wbindgen_object_drop_ref=function(t){Dc(t)},e.wbg.__wbg_new_5b651b9b6590037e=function(){return br(new Map)},e.wbg.__wbindgen_number_new=function(t){return br(t)},e.wbg.__wbindgen_string_new=function(t,n){const a=s1(t,n);return br(a)},e.wbg.__wbindgen_number_get=function(t,n){const a=Jo(n),r=typeof a=="number"?a:void 0;Fke()[t/8+1]=w1(r)?0:r,_i()[t/4+0]=!w1(r)},e.wbg.__wbindgen_is_undefined=function(t){return Jo(t)===void 0},e.wbg.__wbg_new_abda76e883ba8a5f=function(){const t=new Error;return br(t)},e.wbg.__wbg_stack_658279fe44541cf6=function(t,n){const a=Jo(n).stack,r=r3(a,ka.__wbindgen_malloc,ka.__wbindgen_realloc),i=Z1;_i()[t/4+1]=i,_i()[t/4+0]=r},e.wbg.__wbg_error_f851667af71bcfc6=function(t,n){let a,r;try{a=t,r=n,console.error(s1(t,n))}finally{ka.__wbindgen_free(a,r)}},e.wbg.__wbg_forEach_942772130a8d06a6=function(t,n,a){try{var r={a:n,b:a},i=(s,o)=>{const u=r.a;r.a=0;try{return Bke(u,r.b,s,o)}finally{r.a=u}};Jo(t).forEach(i)}finally{r.a=r.b=0}},e.wbg.__wbg_set_da7be7bf0e037b14=function(t,n,a){const r=Jo(t).set(Jo(n),Jo(a));return br(r)},e.wbg.__wbg_parse_76a8a18ca3f8730b=function(){return i3(function(t,n){const a=JSON.parse(s1(t,n));return br(a)},arguments)},e.wbg.__wbg_stringify_d06ad2addc54d51e=function(){return i3(function(t){const n=JSON.stringify(Jo(t));return br(n)},arguments)},e.wbg.__wbindgen_throw=function(t,n){throw new Error(s1(t,n))},e}function Uke(e,t){return ka=e.exports,EA.__wbindgen_wasm_module=t,By=null,My=null,Oy=null,ka}async function EA(e){if(ka!==void 0)return ka;typeof e>"u"&&(e=new URL("/zkFace/assets/noirc_abi_wasm_bg-DeBmP7Z4.wasm",import.meta.url));const t=zke();(typeof e=="string"||typeof Request=="function"&&e instanceof Request||typeof URL=="function"&&e instanceof URL)&&(e=fetch(e));const{instance:n,module:a}=await Lke(await e,t);return Uke(n,a)}function Vke(e){if(typeof Buffer<"u")return Buffer.from(e,"base64");if(typeof atob=="function")return Uint8Array.from(atob(e),t=>t.charCodeAt(0));throw new Error("No implementation found for base64 decoding.")}const Wke=async(e,t)=>{if(e=="print")return[];throw Error(`Unexpected oracle during execution: ${e}(${t.join(", ")})`)};function qke(e,t){const n=t.rawAssertionPayload;if(!n)return t;const a=t;try{const r=Mke(e,n);typeof r=="string"?a.message=`Circuit execution failed: ${r}`:a.decodedAssertionPayload=r}catch{}return a}async function Pke(e,t,n=Wke){const a=Dke(e.abi,t);try{return await kke(Vke(e.bytecode),a,n)}catch(r){throw typeof r=="object"&&r!==null&&"rawAssertionPayload"in r?qke(e.abi,r):new Error(`Circuit execution failed: ${r}`)}}class SV{constructor(t){iN(this,"circuit");this.circuit=t}async init(){typeof EA=="function"&&await Promise.all([EA(),xV()])}async execute(t,n){await this.init();const a=await Pke(this.circuit,t,n),r=a[0].witness,{return_value:i}=Oke(this.circuit.abi,r);return{witness:Eke(a),returnValue:i}}}const Hke="modulepreload",Gke=function(e){return"/zkFace/"+e},s3={},o3=function(t,n,a){let r=Promise.resolve();if(n&&n.length>0){let s=function(d){return Promise.all(d.map(c=>Promise.resolve(c).then(h=>({status:"fulfilled",value:h}),h=>({status:"rejected",reason:h}))))};document.getElementsByTagName("link");const o=document.querySelector("meta[property=csp-nonce]"),u=(o==null?void 0:o.nonce)||(o==null?void 0:o.getAttribute("nonce"));r=s(n.map(d=>{if(d=Gke(d),d in s3)return;s3[d]=!0;const c=d.endsWith(".css"),h=c?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${d}"]${h}`))return;const m=document.createElement("link");if(m.rel=c?"stylesheet":Hke,c||(m.as="script"),m.crossOrigin="",m.href=d,u&&m.setAttribute("nonce",u),document.head.appendChild(m),c)return new Promise((g,x)=>{m.addEventListener("load",g),m.addEventListener("error",()=>x(new Error(`Unable to preload CSS for ${d}`)))})}))}function i(s){const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=s,window.dispatchEvent(o),!o.defaultPrevented)throw s}return r.then(s=>{for(const o of s||[])o.status==="rejected"&&i(o.reason);return t().catch(i)})};var Kke={};/*! For license information please see index.js.LICENSE.txt */var kV={742:(e,t)=>{t.byteLength=d,t.toByteArray=h,t.fromByteArray=x;for(var n=[],a=[],r=typeof Uint8Array<"u"?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,o=i.length;s<o;++s)n[s]=i[s],a[i.charCodeAt(s)]=s;a[45]=62,a[95]=63;function u(v){var S=v.length;if(S%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var E=v.indexOf("=");E===-1&&(E=S);var C=E===S?0:4-E%4;return[E,C]}function d(v){var S=u(v),E=S[0],C=S[1];return(E+C)*3/4-C}function c(v,S,E){return(S+E)*3/4-E}function h(v){var S,E=u(v),C=E[0],T=E[1],N=new r(c(v,C,T)),D=0,q=T>0?C-4:C,H;for(H=0;H<q;H+=4)S=a[v.charCodeAt(H)]<<18|a[v.charCodeAt(H+1)]<<12|a[v.charCodeAt(H+2)]<<6|a[v.charCodeAt(H+3)],N[D++]=S>>16&255,N[D++]=S>>8&255,N[D++]=S&255;return T===2&&(S=a[v.charCodeAt(H)]<<2|a[v.charCodeAt(H+1)]>>4,N[D++]=S&255),T===1&&(S=a[v.charCodeAt(H)]<<10|a[v.charCodeAt(H+1)]<<4|a[v.charCodeAt(H+2)]>>2,N[D++]=S>>8&255,N[D++]=S&255),N}function m(v){return n[v>>18&63]+n[v>>12&63]+n[v>>6&63]+n[v&63]}function g(v,S,E){for(var C,T=[],N=S;N<E;N+=3)C=(v[N]<<16&16711680)+(v[N+1]<<8&65280)+(v[N+2]&255),T.push(m(C));return T.join("")}function x(v){for(var S,E=v.length,C=E%3,T=[],N=16383,D=0,q=E-C;D<q;D+=N)T.push(g(v,D,D+N>q?q:D+N));return C===1?(S=v[E-1],T.push(n[S>>2]+n[S<<4&63]+"==")):C===2&&(S=(v[E-2]<<8)+v[E-1],T.push(n[S>>10]+n[S>>4&63]+n[S<<2&63]+"=")),T.join("")}},764:(e,t,n)=>{const a=n(742),r=n(645),i=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;t.lW=d,t.h2=50;const s=2147483647;d.TYPED_ARRAY_SUPPORT=o(),!d.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function o(){try{const G=new Uint8Array(1),F={foo:function(){return 42}};return Object.setPrototypeOf(F,Uint8Array.prototype),Object.setPrototypeOf(G,F),G.foo()===42}catch{return!1}}Object.defineProperty(d.prototype,"parent",{enumerable:!0,get:function(){if(d.isBuffer(this))return this.buffer}}),Object.defineProperty(d.prototype,"offset",{enumerable:!0,get:function(){if(d.isBuffer(this))return this.byteOffset}});function u(G){if(G>s)throw new RangeError('The value "'+G+'" is invalid for option "size"');const F=new Uint8Array(G);return Object.setPrototypeOf(F,d.prototype),F}function d(G,F,L){if(typeof G=="number"){if(typeof F=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return g(G)}return c(G,F,L)}d.poolSize=8192;function c(G,F,L){if(typeof G=="string")return x(G,F);if(ArrayBuffer.isView(G))return S(G);if(G==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof G);if(kn(G,ArrayBuffer)||G&&kn(G.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(kn(G,SharedArrayBuffer)||G&&kn(G.buffer,SharedArrayBuffer)))return E(G,F,L);if(typeof G=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const ne=G.valueOf&&G.valueOf();if(ne!=null&&ne!==G)return d.from(ne,F,L);const ke=C(G);if(ke)return ke;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof G[Symbol.toPrimitive]=="function")return d.from(G[Symbol.toPrimitive]("string"),F,L);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof G)}d.from=function(G,F,L){return c(G,F,L)},Object.setPrototypeOf(d.prototype,Uint8Array.prototype),Object.setPrototypeOf(d,Uint8Array);function h(G){if(typeof G!="number")throw new TypeError('"size" argument must be of type number');if(G<0)throw new RangeError('The value "'+G+'" is invalid for option "size"')}function m(G,F,L){return h(G),G<=0?u(G):F!==void 0?typeof L=="string"?u(G).fill(F,L):u(G).fill(F):u(G)}d.alloc=function(G,F,L){return m(G,F,L)};function g(G){return h(G),u(G<0?0:T(G)|0)}d.allocUnsafe=function(G){return g(G)},d.allocUnsafeSlow=function(G){return g(G)};function x(G,F){if((typeof F!="string"||F==="")&&(F="utf8"),!d.isEncoding(F))throw new TypeError("Unknown encoding: "+F);const L=N(G,F)|0;let ne=u(L);const ke=ne.write(G,F);return ke!==L&&(ne=ne.slice(0,ke)),ne}function v(G){const F=G.length<0?0:T(G.length)|0,L=u(F);for(let ne=0;ne<F;ne+=1)L[ne]=G[ne]&255;return L}function S(G){if(kn(G,Uint8Array)){const F=new Uint8Array(G);return E(F.buffer,F.byteOffset,F.byteLength)}return v(G)}function E(G,F,L){if(F<0||G.byteLength<F)throw new RangeError('"offset" is outside of buffer bounds');if(G.byteLength<F+(L||0))throw new RangeError('"length" is outside of buffer bounds');let ne;return F===void 0&&L===void 0?ne=new Uint8Array(G):L===void 0?ne=new Uint8Array(G,F):ne=new Uint8Array(G,F,L),Object.setPrototypeOf(ne,d.prototype),ne}function C(G){if(d.isBuffer(G)){const F=T(G.length)|0,L=u(F);return L.length===0||G.copy(L,0,0,F),L}if(G.length!==void 0)return typeof G.length!="number"||pa(G.length)?u(0):v(G);if(G.type==="Buffer"&&Array.isArray(G.data))return v(G.data)}function T(G){if(G>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return G|0}d.isBuffer=function(F){return F!=null&&F._isBuffer===!0&&F!==d.prototype},d.compare=function(F,L){if(kn(F,Uint8Array)&&(F=d.from(F,F.offset,F.byteLength)),kn(L,Uint8Array)&&(L=d.from(L,L.offset,L.byteLength)),!d.isBuffer(F)||!d.isBuffer(L))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(F===L)return 0;let ne=F.length,ke=L.length;for(let ve=0,ze=Math.min(ne,ke);ve<ze;++ve)if(F[ve]!==L[ve]){ne=F[ve],ke=L[ve];break}return ne<ke?-1:ke<ne?1:0},d.isEncoding=function(F){switch(String(F).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},d.concat=function(F,L){if(!Array.isArray(F))throw new TypeError('"list" argument must be an Array of Buffers');if(F.length===0)return d.alloc(0);let ne;if(L===void 0)for(L=0,ne=0;ne<F.length;++ne)L+=F[ne].length;const ke=d.allocUnsafe(L);let ve=0;for(ne=0;ne<F.length;++ne){let ze=F[ne];if(kn(ze,Uint8Array))ve+ze.length>ke.length?(d.isBuffer(ze)||(ze=d.from(ze)),ze.copy(ke,ve)):Uint8Array.prototype.set.call(ke,ze,ve);else if(d.isBuffer(ze))ze.copy(ke,ve);else throw new TypeError('"list" argument must be an Array of Buffers');ve+=ze.length}return ke};function N(G,F){if(d.isBuffer(G))return G.length;if(ArrayBuffer.isView(G)||kn(G,ArrayBuffer))return G.byteLength;if(typeof G!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof G);const L=G.length,ne=arguments.length>2&&arguments[2]===!0;if(!ne&&L===0)return 0;let ke=!1;for(;;)switch(F){case"ascii":case"latin1":case"binary":return L;case"utf8":case"utf-8":return wt(G).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return L*2;case"hex":return L>>>1;case"base64":return Ht(G).length;default:if(ke)return ne?-1:wt(G).length;F=(""+F).toLowerCase(),ke=!0}}d.byteLength=N;function D(G,F,L){let ne=!1;if((F===void 0||F<0)&&(F=0),F>this.length||((L===void 0||L>this.length)&&(L=this.length),L<=0)||(L>>>=0,F>>>=0,L<=F))return"";for(G||(G="utf8");;)switch(G){case"hex":return Y(this,F,L);case"utf8":case"utf-8":return he(this,F,L);case"ascii":return de(this,F,L);case"latin1":case"binary":return Ce(this,F,L);case"base64":return ue(this,F,L);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ie(this,F,L);default:if(ne)throw new TypeError("Unknown encoding: "+G);G=(G+"").toLowerCase(),ne=!0}}d.prototype._isBuffer=!0;function q(G,F,L){const ne=G[F];G[F]=G[L],G[L]=ne}d.prototype.swap16=function(){const F=this.length;if(F%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let L=0;L<F;L+=2)q(this,L,L+1);return this},d.prototype.swap32=function(){const F=this.length;if(F%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let L=0;L<F;L+=4)q(this,L,L+3),q(this,L+1,L+2);return this},d.prototype.swap64=function(){const F=this.length;if(F%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let L=0;L<F;L+=8)q(this,L,L+7),q(this,L+1,L+6),q(this,L+2,L+5),q(this,L+3,L+4);return this},d.prototype.toString=function(){const F=this.length;return F===0?"":arguments.length===0?he(this,0,F):D.apply(this,arguments)},d.prototype.toLocaleString=d.prototype.toString,d.prototype.equals=function(F){if(!d.isBuffer(F))throw new TypeError("Argument must be a Buffer");return this===F?!0:d.compare(this,F)===0},d.prototype.inspect=function(){let F="";const L=t.h2;return F=this.toString("hex",0,L).replace(/(.{2})/g,"$1 ").trim(),this.length>L&&(F+=" ... "),"<Buffer "+F+">"},i&&(d.prototype[i]=d.prototype.inspect),d.prototype.compare=function(F,L,ne,ke,ve){if(kn(F,Uint8Array)&&(F=d.from(F,F.offset,F.byteLength)),!d.isBuffer(F))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof F);if(L===void 0&&(L=0),ne===void 0&&(ne=F?F.length:0),ke===void 0&&(ke=0),ve===void 0&&(ve=this.length),L<0||ne>F.length||ke<0||ve>this.length)throw new RangeError("out of range index");if(ke>=ve&&L>=ne)return 0;if(ke>=ve)return-1;if(L>=ne)return 1;if(L>>>=0,ne>>>=0,ke>>>=0,ve>>>=0,this===F)return 0;let ze=ve-ke,ot=ne-L;const Lt=Math.min(ze,ot),Rt=this.slice(ke,ve),on=F.slice(L,ne);for(let hn=0;hn<Lt;++hn)if(Rt[hn]!==on[hn]){ze=Rt[hn],ot=on[hn];break}return ze<ot?-1:ot<ze?1:0};function H(G,F,L,ne,ke){if(G.length===0)return-1;if(typeof L=="string"?(ne=L,L=0):L>2147483647?L=2147483647:L<-2147483648&&(L=-2147483648),L=+L,pa(L)&&(L=ke?0:G.length-1),L<0&&(L=G.length+L),L>=G.length){if(ke)return-1;L=G.length-1}else if(L<0)if(ke)L=0;else return-1;if(typeof F=="string"&&(F=d.from(F,ne)),d.isBuffer(F))return F.length===0?-1:K(G,F,L,ne,ke);if(typeof F=="number")return F=F&255,typeof Uint8Array.prototype.indexOf=="function"?ke?Uint8Array.prototype.indexOf.call(G,F,L):Uint8Array.prototype.lastIndexOf.call(G,F,L):K(G,[F],L,ne,ke);throw new TypeError("val must be string, number or Buffer")}function K(G,F,L,ne,ke){let ve=1,ze=G.length,ot=F.length;if(ne!==void 0&&(ne=String(ne).toLowerCase(),ne==="ucs2"||ne==="ucs-2"||ne==="utf16le"||ne==="utf-16le")){if(G.length<2||F.length<2)return-1;ve=2,ze/=2,ot/=2,L/=2}function Lt(on,hn){return ve===1?on[hn]:on.readUInt16BE(hn*ve)}let Rt;if(ke){let on=-1;for(Rt=L;Rt<ze;Rt++)if(Lt(G,Rt)===Lt(F,on===-1?0:Rt-on)){if(on===-1&&(on=Rt),Rt-on+1===ot)return on*ve}else on!==-1&&(Rt-=Rt-on),on=-1}else for(L+ot>ze&&(L=ze-ot),Rt=L;Rt>=0;Rt--){let on=!0;for(let hn=0;hn<ot;hn++)if(Lt(G,Rt+hn)!==Lt(F,hn)){on=!1;break}if(on)return Rt}return-1}d.prototype.includes=function(F,L,ne){return this.indexOf(F,L,ne)!==-1},d.prototype.indexOf=function(F,L,ne){return H(this,F,L,ne,!0)},d.prototype.lastIndexOf=function(F,L,ne){return H(this,F,L,ne,!1)};function j(G,F,L,ne){L=Number(L)||0;const ke=G.length-L;ne?(ne=Number(ne),ne>ke&&(ne=ke)):ne=ke;const ve=F.length;ne>ve/2&&(ne=ve/2);let ze;for(ze=0;ze<ne;++ze){const ot=parseInt(F.substr(ze*2,2),16);if(pa(ot))return ze;G[L+ze]=ot}return ze}function te(G,F,L,ne){return Jn(wt(F,G.length-L),G,L,ne)}function Q(G,F,L,ne){return Jn(oa(F),G,L,ne)}function z(G,F,L,ne){return Jn(Ht(F),G,L,ne)}function ae(G,F,L,ne){return Jn(en(F,G.length-L),G,L,ne)}d.prototype.write=function(F,L,ne,ke){if(L===void 0)ke="utf8",ne=this.length,L=0;else if(ne===void 0&&typeof L=="string")ke=L,ne=this.length,L=0;else if(isFinite(L))L=L>>>0,isFinite(ne)?(ne=ne>>>0,ke===void 0&&(ke="utf8")):(ke=ne,ne=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const ve=this.length-L;if((ne===void 0||ne>ve)&&(ne=ve),F.length>0&&(ne<0||L<0)||L>this.length)throw new RangeError("Attempt to write outside buffer bounds");ke||(ke="utf8");let ze=!1;for(;;)switch(ke){case"hex":return j(this,F,L,ne);case"utf8":case"utf-8":return te(this,F,L,ne);case"ascii":case"latin1":case"binary":return Q(this,F,L,ne);case"base64":return z(this,F,L,ne);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ae(this,F,L,ne);default:if(ze)throw new TypeError("Unknown encoding: "+ke);ke=(""+ke).toLowerCase(),ze=!0}},d.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function ue(G,F,L){return F===0&&L===G.length?a.fromByteArray(G):a.fromByteArray(G.slice(F,L))}function he(G,F,L){L=Math.min(G.length,L);const ne=[];let ke=F;for(;ke<L;){const ve=G[ke];let ze=null,ot=ve>239?4:ve>223?3:ve>191?2:1;if(ke+ot<=L){let Lt,Rt,on,hn;switch(ot){case 1:ve<128&&(ze=ve);break;case 2:Lt=G[ke+1],(Lt&192)===128&&(hn=(ve&31)<<6|Lt&63,hn>127&&(ze=hn));break;case 3:Lt=G[ke+1],Rt=G[ke+2],(Lt&192)===128&&(Rt&192)===128&&(hn=(ve&15)<<12|(Lt&63)<<6|Rt&63,hn>2047&&(hn<55296||hn>57343)&&(ze=hn));break;case 4:Lt=G[ke+1],Rt=G[ke+2],on=G[ke+3],(Lt&192)===128&&(Rt&192)===128&&(on&192)===128&&(hn=(ve&15)<<18|(Lt&63)<<12|(Rt&63)<<6|on&63,hn>65535&&hn<1114112&&(ze=hn))}}ze===null?(ze=65533,ot=1):ze>65535&&(ze-=65536,ne.push(ze>>>10&1023|55296),ze=56320|ze&1023),ne.push(ze),ke+=ot}return se(ne)}const Z=4096;function se(G){const F=G.length;if(F<=Z)return String.fromCharCode.apply(String,G);let L="",ne=0;for(;ne<F;)L+=String.fromCharCode.apply(String,G.slice(ne,ne+=Z));return L}function de(G,F,L){let ne="";L=Math.min(G.length,L);for(let ke=F;ke<L;++ke)ne+=String.fromCharCode(G[ke]&127);return ne}function Ce(G,F,L){let ne="";L=Math.min(G.length,L);for(let ke=F;ke<L;++ke)ne+=String.fromCharCode(G[ke]);return ne}function Y(G,F,L){const ne=G.length;(!F||F<0)&&(F=0),(!L||L<0||L>ne)&&(L=ne);let ke="";for(let ve=F;ve<L;++ve)ke+=Na[G[ve]];return ke}function ie(G,F,L){const ne=G.slice(F,L);let ke="";for(let ve=0;ve<ne.length-1;ve+=2)ke+=String.fromCharCode(ne[ve]+ne[ve+1]*256);return ke}d.prototype.slice=function(F,L){const ne=this.length;F=~~F,L=L===void 0?ne:~~L,F<0?(F+=ne,F<0&&(F=0)):F>ne&&(F=ne),L<0?(L+=ne,L<0&&(L=0)):L>ne&&(L=ne),L<F&&(L=F);const ke=this.subarray(F,L);return Object.setPrototypeOf(ke,d.prototype),ke};function xe(G,F,L){if(G%1!==0||G<0)throw new RangeError("offset is not uint");if(G+F>L)throw new RangeError("Trying to access beyond buffer length")}d.prototype.readUintLE=d.prototype.readUIntLE=function(F,L,ne){F=F>>>0,L=L>>>0,ne||xe(F,L,this.length);let ke=this[F],ve=1,ze=0;for(;++ze<L&&(ve*=256);)ke+=this[F+ze]*ve;return ke},d.prototype.readUintBE=d.prototype.readUIntBE=function(F,L,ne){F=F>>>0,L=L>>>0,ne||xe(F,L,this.length);let ke=this[F+--L],ve=1;for(;L>0&&(ve*=256);)ke+=this[F+--L]*ve;return ke},d.prototype.readUint8=d.prototype.readUInt8=function(F,L){return F=F>>>0,L||xe(F,1,this.length),this[F]},d.prototype.readUint16LE=d.prototype.readUInt16LE=function(F,L){return F=F>>>0,L||xe(F,2,this.length),this[F]|this[F+1]<<8},d.prototype.readUint16BE=d.prototype.readUInt16BE=function(F,L){return F=F>>>0,L||xe(F,2,this.length),this[F]<<8|this[F+1]},d.prototype.readUint32LE=d.prototype.readUInt32LE=function(F,L){return F=F>>>0,L||xe(F,4,this.length),(this[F]|this[F+1]<<8|this[F+2]<<16)+this[F+3]*16777216},d.prototype.readUint32BE=d.prototype.readUInt32BE=function(F,L){return F=F>>>0,L||xe(F,4,this.length),this[F]*16777216+(this[F+1]<<16|this[F+2]<<8|this[F+3])},d.prototype.readBigUInt64LE=An(function(F){F=F>>>0,Nt(F,"offset");const L=this[F],ne=this[F+7];(L===void 0||ne===void 0)&&Pt(F,this.length-8);const ke=L+this[++F]*2**8+this[++F]*2**16+this[++F]*2**24,ve=this[++F]+this[++F]*2**8+this[++F]*2**16+ne*2**24;return BigInt(ke)+(BigInt(ve)<<BigInt(32))}),d.prototype.readBigUInt64BE=An(function(F){F=F>>>0,Nt(F,"offset");const L=this[F],ne=this[F+7];(L===void 0||ne===void 0)&&Pt(F,this.length-8);const ke=L*2**24+this[++F]*2**16+this[++F]*2**8+this[++F],ve=this[++F]*2**24+this[++F]*2**16+this[++F]*2**8+ne;return(BigInt(ke)<<BigInt(32))+BigInt(ve)}),d.prototype.readIntLE=function(F,L,ne){F=F>>>0,L=L>>>0,ne||xe(F,L,this.length);let ke=this[F],ve=1,ze=0;for(;++ze<L&&(ve*=256);)ke+=this[F+ze]*ve;return ve*=128,ke>=ve&&(ke-=Math.pow(2,8*L)),ke},d.prototype.readIntBE=function(F,L,ne){F=F>>>0,L=L>>>0,ne||xe(F,L,this.length);let ke=L,ve=1,ze=this[F+--ke];for(;ke>0&&(ve*=256);)ze+=this[F+--ke]*ve;return ve*=128,ze>=ve&&(ze-=Math.pow(2,8*L)),ze},d.prototype.readInt8=function(F,L){return F=F>>>0,L||xe(F,1,this.length),this[F]&128?(255-this[F]+1)*-1:this[F]},d.prototype.readInt16LE=function(F,L){F=F>>>0,L||xe(F,2,this.length);const ne=this[F]|this[F+1]<<8;return ne&32768?ne|4294901760:ne},d.prototype.readInt16BE=function(F,L){F=F>>>0,L||xe(F,2,this.length);const ne=this[F+1]|this[F]<<8;return ne&32768?ne|4294901760:ne},d.prototype.readInt32LE=function(F,L){return F=F>>>0,L||xe(F,4,this.length),this[F]|this[F+1]<<8|this[F+2]<<16|this[F+3]<<24},d.prototype.readInt32BE=function(F,L){return F=F>>>0,L||xe(F,4,this.length),this[F]<<24|this[F+1]<<16|this[F+2]<<8|this[F+3]},d.prototype.readBigInt64LE=An(function(F){F=F>>>0,Nt(F,"offset");const L=this[F],ne=this[F+7];(L===void 0||ne===void 0)&&Pt(F,this.length-8);const ke=this[F+4]+this[F+5]*2**8+this[F+6]*2**16+(ne<<24);return(BigInt(ke)<<BigInt(32))+BigInt(L+this[++F]*2**8+this[++F]*2**16+this[++F]*2**24)}),d.prototype.readBigInt64BE=An(function(F){F=F>>>0,Nt(F,"offset");const L=this[F],ne=this[F+7];(L===void 0||ne===void 0)&&Pt(F,this.length-8);const ke=(L<<24)+this[++F]*2**16+this[++F]*2**8+this[++F];return(BigInt(ke)<<BigInt(32))+BigInt(this[++F]*2**24+this[++F]*2**16+this[++F]*2**8+ne)}),d.prototype.readFloatLE=function(F,L){return F=F>>>0,L||xe(F,4,this.length),r.read(this,F,!0,23,4)},d.prototype.readFloatBE=function(F,L){return F=F>>>0,L||xe(F,4,this.length),r.read(this,F,!1,23,4)},d.prototype.readDoubleLE=function(F,L){return F=F>>>0,L||xe(F,8,this.length),r.read(this,F,!0,52,8)},d.prototype.readDoubleBE=function(F,L){return F=F>>>0,L||xe(F,8,this.length),r.read(this,F,!1,52,8)};function me(G,F,L,ne,ke,ve){if(!d.isBuffer(G))throw new TypeError('"buffer" argument must be a Buffer instance');if(F>ke||F<ve)throw new RangeError('"value" argument is out of bounds');if(L+ne>G.length)throw new RangeError("Index out of range")}d.prototype.writeUintLE=d.prototype.writeUIntLE=function(F,L,ne,ke){if(F=+F,L=L>>>0,ne=ne>>>0,!ke){const ot=Math.pow(2,8*ne)-1;me(this,F,L,ne,ot,0)}let ve=1,ze=0;for(this[L]=F&255;++ze<ne&&(ve*=256);)this[L+ze]=F/ve&255;return L+ne},d.prototype.writeUintBE=d.prototype.writeUIntBE=function(F,L,ne,ke){if(F=+F,L=L>>>0,ne=ne>>>0,!ke){const ot=Math.pow(2,8*ne)-1;me(this,F,L,ne,ot,0)}let ve=ne-1,ze=1;for(this[L+ve]=F&255;--ve>=0&&(ze*=256);)this[L+ve]=F/ze&255;return L+ne},d.prototype.writeUint8=d.prototype.writeUInt8=function(F,L,ne){return F=+F,L=L>>>0,ne||me(this,F,L,1,255,0),this[L]=F&255,L+1},d.prototype.writeUint16LE=d.prototype.writeUInt16LE=function(F,L,ne){return F=+F,L=L>>>0,ne||me(this,F,L,2,65535,0),this[L]=F&255,this[L+1]=F>>>8,L+2},d.prototype.writeUint16BE=d.prototype.writeUInt16BE=function(F,L,ne){return F=+F,L=L>>>0,ne||me(this,F,L,2,65535,0),this[L]=F>>>8,this[L+1]=F&255,L+2},d.prototype.writeUint32LE=d.prototype.writeUInt32LE=function(F,L,ne){return F=+F,L=L>>>0,ne||me(this,F,L,4,4294967295,0),this[L+3]=F>>>24,this[L+2]=F>>>16,this[L+1]=F>>>8,this[L]=F&255,L+4},d.prototype.writeUint32BE=d.prototype.writeUInt32BE=function(F,L,ne){return F=+F,L=L>>>0,ne||me(this,F,L,4,4294967295,0),this[L]=F>>>24,this[L+1]=F>>>16,this[L+2]=F>>>8,this[L+3]=F&255,L+4};function _e(G,F,L,ne,ke){ln(F,ne,ke,G,L,7);let ve=Number(F&BigInt(4294967295));G[L++]=ve,ve=ve>>8,G[L++]=ve,ve=ve>>8,G[L++]=ve,ve=ve>>8,G[L++]=ve;let ze=Number(F>>BigInt(32)&BigInt(4294967295));return G[L++]=ze,ze=ze>>8,G[L++]=ze,ze=ze>>8,G[L++]=ze,ze=ze>>8,G[L++]=ze,L}function Le(G,F,L,ne,ke){ln(F,ne,ke,G,L,7);let ve=Number(F&BigInt(4294967295));G[L+7]=ve,ve=ve>>8,G[L+6]=ve,ve=ve>>8,G[L+5]=ve,ve=ve>>8,G[L+4]=ve;let ze=Number(F>>BigInt(32)&BigInt(4294967295));return G[L+3]=ze,ze=ze>>8,G[L+2]=ze,ze=ze>>8,G[L+1]=ze,ze=ze>>8,G[L]=ze,L+8}d.prototype.writeBigUInt64LE=An(function(F,L=0){return _e(this,F,L,BigInt(0),BigInt("0xffffffffffffffff"))}),d.prototype.writeBigUInt64BE=An(function(F,L=0){return Le(this,F,L,BigInt(0),BigInt("0xffffffffffffffff"))}),d.prototype.writeIntLE=function(F,L,ne,ke){if(F=+F,L=L>>>0,!ke){const Lt=Math.pow(2,8*ne-1);me(this,F,L,ne,Lt-1,-Lt)}let ve=0,ze=1,ot=0;for(this[L]=F&255;++ve<ne&&(ze*=256);)F<0&&ot===0&&this[L+ve-1]!==0&&(ot=1),this[L+ve]=(F/ze>>0)-ot&255;return L+ne},d.prototype.writeIntBE=function(F,L,ne,ke){if(F=+F,L=L>>>0,!ke){const Lt=Math.pow(2,8*ne-1);me(this,F,L,ne,Lt-1,-Lt)}let ve=ne-1,ze=1,ot=0;for(this[L+ve]=F&255;--ve>=0&&(ze*=256);)F<0&&ot===0&&this[L+ve+1]!==0&&(ot=1),this[L+ve]=(F/ze>>0)-ot&255;return L+ne},d.prototype.writeInt8=function(F,L,ne){return F=+F,L=L>>>0,ne||me(this,F,L,1,127,-128),F<0&&(F=255+F+1),this[L]=F&255,L+1},d.prototype.writeInt16LE=function(F,L,ne){return F=+F,L=L>>>0,ne||me(this,F,L,2,32767,-32768),this[L]=F&255,this[L+1]=F>>>8,L+2},d.prototype.writeInt16BE=function(F,L,ne){return F=+F,L=L>>>0,ne||me(this,F,L,2,32767,-32768),this[L]=F>>>8,this[L+1]=F&255,L+2},d.prototype.writeInt32LE=function(F,L,ne){return F=+F,L=L>>>0,ne||me(this,F,L,4,2147483647,-2147483648),this[L]=F&255,this[L+1]=F>>>8,this[L+2]=F>>>16,this[L+3]=F>>>24,L+4},d.prototype.writeInt32BE=function(F,L,ne){return F=+F,L=L>>>0,ne||me(this,F,L,4,2147483647,-2147483648),F<0&&(F=4294967295+F+1),this[L]=F>>>24,this[L+1]=F>>>16,this[L+2]=F>>>8,this[L+3]=F&255,L+4},d.prototype.writeBigInt64LE=An(function(F,L=0){return _e(this,F,L,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),d.prototype.writeBigInt64BE=An(function(F,L=0){return Le(this,F,L,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function qe(G,F,L,ne,ke,ve){if(L+ne>G.length)throw new RangeError("Index out of range");if(L<0)throw new RangeError("Index out of range")}function $e(G,F,L,ne,ke){return F=+F,L=L>>>0,ke||qe(G,F,L,4),r.write(G,F,L,ne,23,4),L+4}d.prototype.writeFloatLE=function(F,L,ne){return $e(this,F,L,!0,ne)},d.prototype.writeFloatBE=function(F,L,ne){return $e(this,F,L,!1,ne)};function Ke(G,F,L,ne,ke){return F=+F,L=L>>>0,ke||qe(G,F,L,8),r.write(G,F,L,ne,52,8),L+8}d.prototype.writeDoubleLE=function(F,L,ne){return Ke(this,F,L,!0,ne)},d.prototype.writeDoubleBE=function(F,L,ne){return Ke(this,F,L,!1,ne)},d.prototype.copy=function(F,L,ne,ke){if(!d.isBuffer(F))throw new TypeError("argument should be a Buffer");if(ne||(ne=0),!ke&&ke!==0&&(ke=this.length),L>=F.length&&(L=F.length),L||(L=0),ke>0&&ke<ne&&(ke=ne),ke===ne||F.length===0||this.length===0)return 0;if(L<0)throw new RangeError("targetStart out of bounds");if(ne<0||ne>=this.length)throw new RangeError("Index out of range");if(ke<0)throw new RangeError("sourceEnd out of bounds");ke>this.length&&(ke=this.length),F.length-L<ke-ne&&(ke=F.length-L+ne);const ve=ke-ne;return this===F&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(L,ne,ke):Uint8Array.prototype.set.call(F,this.subarray(ne,ke),L),ve},d.prototype.fill=function(F,L,ne,ke){if(typeof F=="string"){if(typeof L=="string"?(ke=L,L=0,ne=this.length):typeof ne=="string"&&(ke=ne,ne=this.length),ke!==void 0&&typeof ke!="string")throw new TypeError("encoding must be a string");if(typeof ke=="string"&&!d.isEncoding(ke))throw new TypeError("Unknown encoding: "+ke);if(F.length===1){const ze=F.charCodeAt(0);(ke==="utf8"&&ze<128||ke==="latin1")&&(F=ze)}}else typeof F=="number"?F=F&255:typeof F=="boolean"&&(F=Number(F));if(L<0||this.length<L||this.length<ne)throw new RangeError("Out of range index");if(ne<=L)return this;L=L>>>0,ne=ne===void 0?this.length:ne>>>0,F||(F=0);let ve;if(typeof F=="number")for(ve=L;ve<ne;++ve)this[ve]=F;else{const ze=d.isBuffer(F)?F:d.from(F,ke),ot=ze.length;if(ot===0)throw new TypeError('The value "'+F+'" is invalid for argument "value"');for(ve=0;ve<ne-L;++ve)this[ve+L]=ze[ve%ot]}return this};const rt={};function ht(G,F,L){rt[G]=class extends L{constructor(){super(),Object.defineProperty(this,"message",{value:F.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${G}]`,this.stack,delete this.name}get code(){return G}set code(ke){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:ke,writable:!0})}toString(){return`${this.name} [${G}]: ${this.message}`}}}ht("ERR_BUFFER_OUT_OF_BOUNDS",function(G){return G?`${G} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),ht("ERR_INVALID_ARG_TYPE",function(G,F){return`The "${G}" argument must be of type number. Received type ${typeof F}`},TypeError),ht("ERR_OUT_OF_RANGE",function(G,F,L){let ne=`The value of "${G}" is out of range.`,ke=L;return Number.isInteger(L)&&Math.abs(L)>2**32?ke=kt(String(L)):typeof L=="bigint"&&(ke=String(L),(L>BigInt(2)**BigInt(32)||L<-(BigInt(2)**BigInt(32)))&&(ke=kt(ke)),ke+="n"),ne+=` It must be ${F}. Received ${ke}`,ne},RangeError);function kt(G){let F="",L=G.length;const ne=G[0]==="-"?1:0;for(;L>=ne+4;L-=3)F=`_${G.slice(L-3,L)}${F}`;return`${G.slice(0,L)}${F}`}function _t(G,F,L){Nt(F,"offset"),(G[F]===void 0||G[F+L]===void 0)&&Pt(F,G.length-(L+1))}function ln(G,F,L,ne,ke,ve){if(G>L||G<F){const ze=typeof F=="bigint"?"n":"";let ot;throw F===0||F===BigInt(0)?ot=`>= 0${ze} and < 2${ze} ** ${(ve+1)*8}${ze}`:ot=`>= -(2${ze} ** ${(ve+1)*8-1}${ze}) and < 2 ** ${(ve+1)*8-1}${ze}`,new rt.ERR_OUT_OF_RANGE("value",ot,G)}_t(ne,ke,ve)}function Nt(G,F){if(typeof G!="number")throw new rt.ERR_INVALID_ARG_TYPE(F,"number",G)}function Pt(G,F,L){throw Math.floor(G)!==G?(Nt(G,L),new rt.ERR_OUT_OF_RANGE("offset","an integer",G)):F<0?new rt.ERR_BUFFER_OUT_OF_BOUNDS:new rt.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${F}`,G)}const Re=/[^+/0-9A-Za-z-_]/g;function ft(G){if(G=G.split("=")[0],G=G.trim().replace(Re,""),G.length<2)return"";for(;G.length%4!==0;)G=G+"=";return G}function wt(G,F){F=F||1/0;let L;const ne=G.length;let ke=null;const ve=[];for(let ze=0;ze<ne;++ze){if(L=G.charCodeAt(ze),L>55295&&L<57344){if(!ke){if(L>56319){(F-=3)>-1&&ve.push(239,191,189);continue}else if(ze+1===ne){(F-=3)>-1&&ve.push(239,191,189);continue}ke=L;continue}if(L<56320){(F-=3)>-1&&ve.push(239,191,189),ke=L;continue}L=(ke-55296<<10|L-56320)+65536}else ke&&(F-=3)>-1&&ve.push(239,191,189);if(ke=null,L<128){if((F-=1)<0)break;ve.push(L)}else if(L<2048){if((F-=2)<0)break;ve.push(L>>6|192,L&63|128)}else if(L<65536){if((F-=3)<0)break;ve.push(L>>12|224,L>>6&63|128,L&63|128)}else if(L<1114112){if((F-=4)<0)break;ve.push(L>>18|240,L>>12&63|128,L>>6&63|128,L&63|128)}else throw new Error("Invalid code point")}return ve}function oa(G){const F=[];for(let L=0;L<G.length;++L)F.push(G.charCodeAt(L)&255);return F}function en(G,F){let L,ne,ke;const ve=[];for(let ze=0;ze<G.length&&!((F-=2)<0);++ze)L=G.charCodeAt(ze),ne=L>>8,ke=L%256,ve.push(ke),ve.push(ne);return ve}function Ht(G){return a.toByteArray(ft(G))}function Jn(G,F,L,ne){let ke;for(ke=0;ke<ne&&!(ke+L>=F.length||ke>=G.length);++ke)F[ke+L]=G[ke];return ke}function kn(G,F){return G instanceof F||G!=null&&G.constructor!=null&&G.constructor.name!=null&&G.constructor.name===F.name}function pa(G){return G!==G}const Na=function(){const G="0123456789abcdef",F=new Array(256);for(let L=0;L<16;++L){const ne=L*16;for(let ke=0;ke<16;++ke)F[ne+ke]=G[L]+G[ke]}return F}();function An(G){return typeof BigInt>"u"?tn:G}function tn(){throw new Error("BigInt not supported")}},227:(e,t,n)=>{t.formatArgs=r,t.save=i,t.load=s,t.useColors=a,t.storage=o(),t.destroy=(()=>{let d=!1;return()=>{d||(d=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function a(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function r(d){if(d[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+d[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const c="color: "+this.color;d.splice(1,0,c,"color: inherit");let h=0,m=0;d[0].replace(/%[a-zA-Z%]/g,g=>{g!=="%%"&&(h++,g==="%c"&&(m=h))}),d.splice(m,0,c)}t.log=console.debug||console.log||(()=>{});function i(d){try{d?t.storage.setItem("debug",d):t.storage.removeItem("debug")}catch{}}function s(){let d;try{d=t.storage.getItem("debug")}catch{}return!d&&typeof process<"u"&&"env"in process&&(d=Kke.DEBUG),d}function o(){try{return localStorage}catch{}}e.exports=n(447)(t);const{formatters:u}=e.exports;u.j=function(d){try{return JSON.stringify(d)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}}},447:(e,t,n)=>{function a(r){s.debug=s,s.default=s,s.coerce=m,s.disable=d,s.enable=u,s.enabled=c,s.humanize=n(824),s.destroy=g,Object.keys(r).forEach(x=>{s[x]=r[x]}),s.names=[],s.skips=[],s.formatters={};function i(x){let v=0;for(let S=0;S<x.length;S++)v=(v<<5)-v+x.charCodeAt(S),v|=0;return s.colors[Math.abs(v)%s.colors.length]}s.selectColor=i;function s(x){let v,S=null,E,C;function T(...N){if(!T.enabled)return;const D=T,q=Number(new Date),H=q-(v||q);D.diff=H,D.prev=v,D.curr=q,v=q,N[0]=s.coerce(N[0]),typeof N[0]!="string"&&N.unshift("%O");let K=0;N[0]=N[0].replace(/%([a-zA-Z%])/g,(te,Q)=>{if(te==="%%")return"%";K++;const z=s.formatters[Q];if(typeof z=="function"){const ae=N[K];te=z.call(D,ae),N.splice(K,1),K--}return te}),s.formatArgs.call(D,N),(D.log||s.log).apply(D,N)}return T.namespace=x,T.useColors=s.useColors(),T.color=s.selectColor(x),T.extend=o,T.destroy=s.destroy,Object.defineProperty(T,"enabled",{enumerable:!0,configurable:!1,get:()=>S!==null?S:(E!==s.namespaces&&(E=s.namespaces,C=s.enabled(x)),C),set:N=>{S=N}}),typeof s.init=="function"&&s.init(T),T}function o(x,v){const S=s(this.namespace+(typeof v>"u"?":":v)+x);return S.log=this.log,S}function u(x){s.save(x),s.namespaces=x,s.names=[],s.skips=[];let v;const S=(typeof x=="string"?x:"").split(/[\s,]+/),E=S.length;for(v=0;v<E;v++)S[v]&&(x=S[v].replace(/\*/g,".*?"),x[0]==="-"?s.skips.push(new RegExp("^"+x.slice(1)+"$")):s.names.push(new RegExp("^"+x+"$")))}function d(){const x=[...s.names.map(h),...s.skips.map(h).map(v=>"-"+v)].join(",");return s.enable(""),x}function c(x){if(x[x.length-1]==="*")return!0;let v,S;for(v=0,S=s.skips.length;v<S;v++)if(s.skips[v].test(x))return!1;for(v=0,S=s.names.length;v<S;v++)if(s.names[v].test(x))return!0;return!1}function h(x){return x.toString().substring(2,x.toString().length-2).replace(/\.\*\?$/,"*")}function m(x){return x instanceof Error?x.stack||x.message:x}function g(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return s.enable(s.load()),s}e.exports=a},645:(e,t)=>{t.read=function(n,a,r,i,s){var o,u,d=s*8-i-1,c=(1<<d)-1,h=c>>1,m=-7,g=r?s-1:0,x=r?-1:1,v=n[a+g];for(g+=x,o=v&(1<<-m)-1,v>>=-m,m+=d;m>0;o=o*256+n[a+g],g+=x,m-=8);for(u=o&(1<<-m)-1,o>>=-m,m+=i;m>0;u=u*256+n[a+g],g+=x,m-=8);if(o===0)o=1-h;else{if(o===c)return u?NaN:(v?-1:1)*(1/0);u=u+Math.pow(2,i),o=o-h}return(v?-1:1)*u*Math.pow(2,o-i)},t.write=function(n,a,r,i,s,o){var u,d,c,h=o*8-s-1,m=(1<<h)-1,g=m>>1,x=s===23?Math.pow(2,-24)-Math.pow(2,-77):0,v=i?0:o-1,S=i?1:-1,E=a<0||a===0&&1/a<0?1:0;for(a=Math.abs(a),isNaN(a)||a===1/0?(d=isNaN(a)?1:0,u=m):(u=Math.floor(Math.log(a)/Math.LN2),a*(c=Math.pow(2,-u))<1&&(u--,c*=2),u+g>=1?a+=x/c:a+=x*Math.pow(2,1-g),a*c>=2&&(u++,c/=2),u+g>=m?(d=0,u=m):u+g>=1?(d=(a*c-1)*Math.pow(2,s),u=u+g):(d=a*Math.pow(2,g-1)*Math.pow(2,s),u=0));s>=8;n[r+v]=d&255,v+=S,d/=256,s-=8);for(u=u<<s|d,h+=s;h>0;n[r+v]=u&255,v+=S,u/=256,h-=8);n[r+v-S]|=E*128}},824:e=>{var t=1e3,n=t*60,a=n*60,r=a*24,i=r*7,s=r*365.25;e.exports=function(h,m){m=m||{};var g=typeof h;if(g==="string"&&h.length>0)return o(h);if(g==="number"&&isFinite(h))return m.long?d(h):u(h);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(h))};function o(h){if(h=String(h),!(h.length>100)){var m=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(h);if(m){var g=parseFloat(m[1]),x=(m[2]||"ms").toLowerCase();switch(x){case"years":case"year":case"yrs":case"yr":case"y":return g*s;case"weeks":case"week":case"w":return g*i;case"days":case"day":case"d":return g*r;case"hours":case"hour":case"hrs":case"hr":case"h":return g*a;case"minutes":case"minute":case"mins":case"min":case"m":return g*n;case"seconds":case"second":case"secs":case"sec":case"s":return g*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return g;default:return}}}}function u(h){var m=Math.abs(h);return m>=r?Math.round(h/r)+"d":m>=a?Math.round(h/a)+"h":m>=n?Math.round(h/n)+"m":m>=t?Math.round(h/t)+"s":h+"ms"}function d(h){var m=Math.abs(h);return m>=r?c(h,m,r,"day"):m>=a?c(h,m,a,"hour"):m>=n?c(h,m,n,"minute"):m>=t?c(h,m,t,"second"):h+" ms"}function c(h,m,g,x){var v=m>=g*1.5;return Math.round(h/g)+" "+x+(v?"s":"")}},477:e=>{e.exports=function(t,n,a,r){var i=self||window;try{try{var s;try{s=new i.Blob([t])}catch{var o=i.BlobBuilder||i.WebKitBlobBuilder||i.MozBlobBuilder||i.MSBlobBuilder;s=new o,s.append(t),s=s.getBlob()}var u=i.URL||i.webkitURL,d=u.createObjectURL(s),c=new i[n](d,a);return u.revokeObjectURL(d),c}catch{return new i[n]("data:application/javascript,".concat(encodeURIComponent(t)),a)}}catch{if(!r)throw Error("Inline worker is not supported");return new i[n](r,a)}}}},l3={};function Yt(e){var t=l3[e];if(t!==void 0)return t.exports;var n=l3[e]={exports:{}};return kV[e](n,n.exports,Yt),n.exports}Yt.m=kV;Yt.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return Yt.d(t,{a:t}),t};(()=>{var e=Object.getPrototypeOf?n=>Object.getPrototypeOf(n):n=>n.__proto__,t;Yt.t=function(n,a){if(a&1&&(n=this(n)),a&8||typeof n=="object"&&n&&(a&4&&n.__esModule||a&16&&typeof n.then=="function"))return n;var r=Object.create(null);Yt.r(r);var i={};t=t||[null,e({}),e([]),e(e)];for(var s=a&2&&n;typeof s=="object"&&!~t.indexOf(s);s=e(s))Object.getOwnPropertyNames(s).forEach(o=>i[o]=()=>n[o]);return i.default=()=>n,Yt.d(r,i),r}})();Yt.d=(e,t)=>{for(var n in t)Yt.o(t,n)&&!Yt.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})};Yt.f={},Yt.e=e=>Promise.all(Object.keys(Yt.f).reduce((t,n)=>(Yt.f[n](e,t),t),[]));Yt.u=e=>""+e+".6386c00ebfb22619e11b.js";Yt.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);(()=>{var e={},t="@aztec/bb.js:";Yt.l=(n,a,r,i)=>{if(e[n]){e[n].push(a);return}var s,o;if(r!==void 0)for(var u=document.getElementsByTagName("script"),d=0;d<u.length;d++){var c=u[d];if(c.getAttribute("src")==n||c.getAttribute("data-webpack")==t+r){s=c;break}}s||(o=!0,s=document.createElement("script"),s.type="module",s.charset="utf-8",s.timeout=120,Yt.nc&&s.setAttribute("nonce",Yt.nc),s.setAttribute("data-webpack",t+r),s.src=n),e[n]=[a];var h=(g,x)=>{s.onerror=s.onload=null,clearTimeout(m);var v=e[n];if(delete e[n],s.parentNode&&s.parentNode.removeChild(s),v&&v.forEach(S=>S(x)),g)return g(x)},m=setTimeout(h.bind(null,void 0,{type:"timeout",target:s}),12e4);s.onerror=h.bind(null,s.onerror),s.onload=h.bind(null,s.onload),o&&document.head.appendChild(s)}})();Yt.r=e=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};(()=>{var e;if(typeof import.meta.url=="string"&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),Yt.p=e})();(()=>{var e={826:0};Yt.f.j=(a,r)=>{var i=Yt.o(e,a)?e[a]:void 0;if(i!==0)if(i)r.push(i[2]);else{var s=new Promise((c,h)=>i=e[a]=[c,h]);r.push(i[2]=s);var o=Yt.p+Yt.u(a),u=new Error,d=c=>{if(Yt.o(e,a)&&(i=e[a],i!==0&&(e[a]=void 0),i)){var h=c&&(c.type==="load"?"missing":c.type),m=c&&c.target&&c.target.src;u.message="Loading chunk "+a+` failed.
(`+h+": "+m+")",u.name="ChunkLoadError",u.type=h,u.request=m,i[1](u)}};Yt.l(o,d,"chunk-"+a,a)}};var t=(a,r)=>{var[i,s,o]=r,u,d,c=0;if(i.some(m=>e[m]!==0)){for(u in s)Yt.o(s,u)&&(Yt.m[u]=s[u]);if(o)var h=o(Yt)}for(a&&a(r);c<i.length;c++)d=i[c],Yt.o(e,d)&&e[d]&&e[d][0](),e[d]=0},n=globalThis.webpackChunk_aztec_bb_js=globalThis.webpackChunk_aztec_bb_js||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))})();var os={};(()=>{Yt.d(os,{Dv:()=>tr,Zh:()=>qo,AL:()=>ql,tD:()=>Sd,i2:()=>h,Fr:()=>ve,pS:()=>m,ld:()=>$e,yh:()=>Ha,_7:()=>mx,H2:()=>Nf,ly:()=>Tf});function*e(){const y=[1,1,1,2,4,8,16,32,64];let k=0;for(;;)yield y[Math.min(k++,y.length-1)]}function*t(y){for(const k of y)yield k}async function n(y,k=e()){for(;;)try{return await y()}catch(w){const _=k.next().value;if(_===void 0)throw w;await new Promise(R=>setTimeout(R,_*1e3));continue}}class a{constructor(k){this.numPoints=k}async init(){await this.downloadG1Data(),await this.downloadG2Data()}async downloadG1Data(){if(this.numPoints===0)return this.data=new Uint8Array([]);const k=this.numPoints*64-1,w=await n(()=>fetch("https://aztec-ignition.s3.amazonaws.com/MAIN%20IGNITION/flat/g1.dat",{headers:{Range:`bytes=0-${k}`},cache:"force-cache"}),t([5,5,5]));return this.data=new Uint8Array(await w.arrayBuffer())}async downloadG2Data(){const k=await n(()=>fetch("https://aztec-ignition.s3.amazonaws.com/MAIN%20IGNITION/flat/g2.dat",{cache:"force-cache"}),t([5,5,5]));return this.g2Data=new Uint8Array(await k.arrayBuffer())}getG1Data(){return this.data}getG2Data(){return this.g2Data}}class r{constructor(k){this.numPoints=k}async init(){await this.downloadG1Data()}async downloadG1Data(){if(this.numPoints===0)return this.data=new Uint8Array([]);const k=28,w=k+(this.numPoints*64-1),_=await fetch("https://aztec-ignition.s3.amazonaws.com/TEST%20GRUMPKIN/monomial/transcript00.dat",{headers:{Range:`bytes=${k}-${w}`},cache:"force-cache"});return this.data=new Uint8Array(await _.arrayBuffer())}getG1Data(){return this.data}}function i(y){return new Promise((k,w)=>{y.oncomplete=y.onsuccess=()=>k(y.result),y.onabort=y.onerror=()=>w(y.error)})}function s(y,k){const w=indexedDB.open(y);w.onupgradeneeded=()=>w.result.createObjectStore(k);const _=i(w);return(R,M)=>_.then(U=>M(U.transaction(k,R).objectStore(k)))}let o;function u(){return o||(o=s("keyval-store","keyval")),o}function d(y,k=u()){return k("readonly",w=>i(w.get(y)))}function c(y,k,w=u()){return w("readwrite",_=>(_.put(k,y),i(_.transaction)))}class h{constructor(k){this.numPoints=k}static async new(k){const w=new h(k);return await w.init(),w}async init(){const k=await d("g1Data"),w=await d("g2Data"),_=new a(this.numPoints),R=this.numPoints*64;!k||k.length<R?(this.g1Data=await _.downloadG1Data(),await c("g1Data",this.g1Data)):this.g1Data=k,w?this.g2Data=w:(this.g2Data=await _.downloadG2Data(),await c("g2Data",this.g2Data))}getG1Data(){return this.g1Data}getG2Data(){return this.g2Data}}class m{constructor(k){this.numPoints=k}static async new(k){const w=new m(k);return await w.init(),w}async init(){const k=await d("grumpkinG1Data"),w=new r(this.numPoints),_=this.numPoints*64;!k||k.length<_?(this.g1Data=await w.downloadG1Data(),await c("grumpkinG1Data",this.g1Data)):this.g1Data=k}getG1Data(){return this.g1Data}}const g=Symbol("Comlink.proxy"),x=Symbol("Comlink.endpoint"),v=Symbol("Comlink.releaseProxy"),S=Symbol("Comlink.finalizer"),E=Symbol("Comlink.thrown"),C=y=>typeof y=="object"&&y!==null||typeof y=="function",T={canHandle:y=>C(y)&&y[g],serialize(y){const{port1:k,port2:w}=new MessageChannel;return H(y,k),[w,[w]]},deserialize(y){return y.start(),te(y)}},N={canHandle:y=>C(y)&&E in y,serialize({value:y}){let k;return y instanceof Error?k={isError:!0,value:{message:y.message,name:y.name,stack:y.stack}}:k={isError:!1,value:y},[k,[]]},deserialize(y){throw y.isError?Object.assign(new Error(y.value.message),y.value):y.value}},D=new Map([["proxy",T],["throw",N]]);function q(y,k){for(const w of y)if(k===w||w==="*"||w instanceof RegExp&&w.test(k))return!0;return!1}function H(y,k=globalThis,w=["*"]){k.addEventListener("message",function _(R){if(!R||!R.data)return;if(!q(w,R.origin)){console.warn(`Invalid origin '${R.origin}' for comlink proxy`);return}const{id:M,type:U,path:V}=Object.assign({path:[]},R.data),fe=(R.data.argumentList||[]).map(_e);let X;try{const ye=V.slice(0,-1).reduce((He,Pe)=>He[Pe],y),Qe=V.reduce((He,Pe)=>He[Pe],y);switch(U){case"GET":X=Qe;break;case"SET":ye[V.slice(-1)[0]]=_e(R.data.value),X=!0;break;case"APPLY":X=Qe.apply(ye,fe);break;case"CONSTRUCT":{const He=new Qe(...fe);X=xe(He)}break;case"ENDPOINT":{const{port1:He,port2:Pe}=new MessageChannel;H(y,Pe),X=ie(He,[He])}break;case"RELEASE":X=void 0;break;default:return}}catch(ye){X={value:ye,[E]:0}}Promise.resolve(X).catch(ye=>({value:ye,[E]:0})).then(ye=>{const[Qe,He]=me(ye);k.postMessage(Object.assign(Object.assign({},Qe),{id:M}),He),U==="RELEASE"&&(k.removeEventListener("message",_),j(k),S in y&&typeof y[S]=="function"&&y[S]())}).catch(ye=>{const[Qe,He]=me({value:new TypeError("Unserializable return value"),[E]:0});k.postMessage(Object.assign(Object.assign({},Qe),{id:M}),He)})}),k.start&&k.start()}function K(y){return y.constructor.name==="MessagePort"}function j(y){K(y)&&y.close()}function te(y,k){return se(y,[],k)}function Q(y){if(y)throw new Error("Proxy has been released and is not useable")}function z(y){return Le(y,{type:"RELEASE"}).then(()=>{j(y)})}const ae=new WeakMap,ue="FinalizationRegistry"in globalThis&&new FinalizationRegistry(y=>{const k=(ae.get(y)||0)-1;ae.set(y,k),k===0&&z(y)});function he(y,k){const w=(ae.get(k)||0)+1;ae.set(k,w),ue&&ue.register(y,k,y)}function Z(y){ue&&ue.unregister(y)}function se(y,k=[],w=function(){}){let _=!1;const R=new Proxy(w,{get(M,U){if(Q(_),U===v)return()=>{Z(R),z(y),_=!0};if(U==="then"){if(k.length===0)return{then:()=>R};const V=Le(y,{type:"GET",path:k.map(fe=>fe.toString())}).then(_e);return V.then.bind(V)}return se(y,[...k,U])},set(M,U,V){Q(_);const[fe,X]=me(V);return Le(y,{type:"SET",path:[...k,U].map(ye=>ye.toString()),value:fe},X).then(_e)},apply(M,U,V){Q(_);const fe=k[k.length-1];if(fe===x)return Le(y,{type:"ENDPOINT"}).then(_e);if(fe==="bind")return se(y,k.slice(0,-1));const[X,ye]=Ce(V);return Le(y,{type:"APPLY",path:k.map(Qe=>Qe.toString()),argumentList:X},ye).then(_e)},construct(M,U){Q(_);const[V,fe]=Ce(U);return Le(y,{type:"CONSTRUCT",path:k.map(X=>X.toString()),argumentList:V},fe).then(_e)}});return he(R,y),R}function de(y){return Array.prototype.concat.apply([],y)}function Ce(y){const k=y.map(me);return[k.map(w=>w[0]),de(k.map(w=>w[1]))]}const Y=new WeakMap;function ie(y,k){return Y.set(y,k),y}function xe(y){return Object.assign(y,{[g]:!0})}function me(y){for(const[k,w]of D)if(w.canHandle(y)){const[_,R]=w.serialize(y);return[{type:"HANDLER",name:k,value:_},R]}return[{type:"RAW",value:y},Y.get(y)||[]]}function _e(y){switch(y.type){case"HANDLER":return D.get(y.name).deserialize(y.value);case"RAW":return y.value}}function Le(y,k,w){return new Promise(_=>{const R=qe();y.addEventListener("message",function M(U){!U.data||!U.data.id||U.data.id!==R||(y.removeEventListener("message",M),_(U.data))}),y.start&&y.start(),y.postMessage(Object.assign({id:R},k),w)})}function qe(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}class $e extends Uint8Array{}function Ke(y){const k=new Uint8Array(1);return k[0]=y?1:0,k}function rt(y,k=4){const w=new Uint8Array(k);return new DataView(w.buffer).setUint32(w.byteLength-4,y,!1),w}function ht(y,k=4){const w=new Uint8Array(k);return new DataView(w.buffer).setInt32(w.byteLength-4,y,!1),w}function kt(y){const k=y.reduce((R,M)=>R+M.length,0),w=new Uint8Array(k);let _=0;for(const R of y)w.set(R,_),_+=R.length;return w}function _t(y){return y.reduce((k,w)=>k+w.toString(16).padStart(2,"0"),"")}function ln(y){return kt([ht(y.length),y])}function Nt(y,k=32){const w=new Uint8Array(k);for(let _=0;_<k;_++)w[k-_-1]=Number(y>>BigInt(_*8)&0xffn);return w}function Pt(y){return kt([rt(y.length),...y.flat()])}function Re(y){return Array.isArray(y)?Pt(y.map(Re)):y instanceof $e?y:y instanceof Uint8Array?ln(y):typeof y=="boolean"?Ke(y):typeof y=="number"?rt(y):typeof y=="bigint"?Nt(y):typeof y=="string"?ln(new TextEncoder().encode(y)):y.toBuffer()}class ft{constructor(k,w=0){this.buffer=k,this.index=w}static asReader(k){return k instanceof ft?k:new ft(k)}readNumber(){const k=new DataView(this.buffer.buffer,this.buffer.byteOffset+this.index,4);return this.index+=4,k.getUint32(0,!1)}readBoolean(){return this.index+=1,!!this.buffer.at(this.index-1)}readBytes(k){return this.index+=k,this.buffer.slice(this.index-k,this.index)}readNumberVector(){return this.readVector({fromBuffer:k=>k.readNumber()})}readVector(k){const w=this.readNumber(),_=new Array(w);for(let R=0;R<w;R++)_[R]=k.fromBuffer(this);return _}readArray(k,w){const _=new Array(k);for(let R=0;R<k;R++)_[R]=w.fromBuffer(this);return _}readObject(k){return k.fromBuffer(this)}peekBytes(k){return this.buffer.subarray(this.index,k?this.index+k:void 0)}readString(){return new TextDecoder().decode(this.readBuffer())}readBuffer(){const k=this.readNumber();return this.readBytes(k)}readMap(k){const w=this.readNumber(),_={};for(let R=0;R<w;R++){const M=this.readString(),U=this.readObject(k);_[M]=U}return _}}function wt(){return{SIZE_IN_BYTES:1,fromBuffer:y=>ft.asReader(y).readBoolean()}}function oa(){return{SIZE_IN_BYTES:4,fromBuffer:y=>ft.asReader(y).readNumber()}}function en(y){return{fromBuffer:k=>ft.asReader(k).readVector(y)}}function Ht(){return{fromBuffer:y=>ft.asReader(y).readBuffer()}}function Jn(){return{fromBuffer:y=>ft.asReader(y).readString()}}class kn{constructor(k){this.value=k}static fromBuffer(k){const w=ft.asReader(k);return new this(w.readBytes(this.SIZE_IN_BYTES))}toBuffer(){return this.value}}kn.SIZE_IN_BYTES=4;const pa=y=>{const w=(()=>{if(typeof window<"u"&&window.crypto)return window.crypto;if(typeof globalThis<"u"&&globalThis.crypto)return globalThis.crypto})();if(!w)throw new Error("randomBytes UnsupportedEnvironment");const _=new Uint8Array(y),R=65536;if(y>R)for(let M=0;M<y;M+=R)w.getRandomValues(_.subarray(M,M+R));else w.getRandomValues(_);return _};var Na=Yt(764).lW;function An(y){return(y.readBigUInt64BE(0)<<192n)+(y.readBigUInt64BE(8)<<128n)+(y.readBigUInt64BE(16)<<64n)+y.readBigUInt64BE(24)}function tn(y){const k=Na.from(y);return An(k)}function G(y,k=32){if(k!=32)throw new Error(`Only 32 bytes supported for conversion from bigint to buffer, attempted byte length: ${k}`);const w=Na.alloc(k);return w.writeBigUInt64BE(y>>192n,0),w.writeBigUInt64BE(y>>128n&0xffffffffffffffffn,8),w.writeBigUInt64BE(y>>64n&0xffffffffffffffffn,16),w.writeBigUInt64BE(y&0xffffffffffffffffn,24),w}function F(y,k=32){return new Uint8Array(G(y,k))}var L=Yt(764).lW,ne,ke;class ve{constructor(k){const w=typeof k=="bigint"?k:k instanceof L?An(k):tn(k);if(w>ne.MAX_VALUE)throw new Error(`Value 0x${w.toString(16)} is greater or equal to field modulus.`);this.value=typeof k=="bigint"?F(k):k instanceof L?new Uint8Array(k):k}static random(){const k=tn(pa(64))%ne.MODULUS;return new this(k)}static fromBuffer(k){const w=ft.asReader(k);return new this(w.readBytes(this.SIZE_IN_BYTES))}static fromBufferReduce(k){const w=ft.asReader(k);return new this(tn(w.readBytes(this.SIZE_IN_BYTES))%ne.MODULUS)}static fromString(k){return this.fromBuffer(L.from(k.replace(/^0x/i,""),"hex"))}toBuffer(){return this.value}toString(){return"0x"+_t(this.toBuffer())}equals(k){return this.value.every((w,_)=>w===k.value[_])}isZero(){return this.value.every(k=>k===0)}}ne=ve,ve.ZERO=new ne(0n),ve.MODULUS=0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001n,ve.MAX_VALUE=ne.MODULUS-1n,ve.SIZE_IN_BYTES=32;class ze{constructor(k){if(this.value=k,k>ke.MAX_VALUE)throw new Error(`Fq out of range ${k}.`)}static random(){const k=tn(pa(64))%ke.MODULUS;return new this(k)}static fromBuffer(k){const w=ft.asReader(k);return new this(tn(w.readBytes(this.SIZE_IN_BYTES)))}static fromBufferReduce(k){const w=ft.asReader(k);return new this(tn(w.readBytes(this.SIZE_IN_BYTES))%ve.MODULUS)}static fromString(k){return this.fromBuffer(L.from(k.replace(/^0x/i,""),"hex"))}toBuffer(){return G(this.value,ke.SIZE_IN_BYTES)}toString(){return"0x"+this.value.toString(16)}equals(k){return this.value===k.value}isZero(){return this.value===0n}}ke=ze,ze.MODULUS=0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47n,ze.MAX_VALUE=ke.MODULUS-1n,ze.SIZE_IN_BYTES=32;var ot=Yt(764).lW;class Lt{constructor(k,w){this.x=k,this.y=w}static random(){return new Lt(ve.random(),ve.random())}static fromBuffer(k){const w=ft.asReader(k);return new this(ve.fromBuffer(w),ve.fromBuffer(w))}static fromString(k){return Lt.fromBuffer(ot.from(k.replace(/^0x/i,""),"hex"))}toBuffer(){return ot.concat([this.x.toBuffer(),this.y.toBuffer()])}toString(){return"0x"+this.toBuffer().toString("hex")}equals(k){return this.x.equals(k.x)&&this.y.equals(k.y)}}Lt.SIZE_IN_BYTES=64,Lt.EMPTY=new Lt(ve.ZERO,ve.ZERO);class Rt{constructor(k){this.buffer=k}static fromBuffer(k){const w=ft.asReader(k);return new Rt(w.readBytes(this.SIZE_IN_BYTES))}static random(){return new Rt(pa(this.SIZE_IN_BYTES))}toBuffer(){return this.buffer}}Rt.SIZE_IN_BYTES=32;class on{constructor(k){this.buffer=k}static fromBuffer(k){const w=ft.asReader(k);return new on(w.readBytes(this.SIZE_IN_BYTES))}static random(){return new on(pa(this.SIZE_IN_BYTES))}toBuffer(){return this.buffer}}on.SIZE_IN_BYTES=128;function hn(y,k=!1){const w=new DataView(y.buffer,y.byteOffset,y.byteLength);let _=0,R=y.byteLength>>>2;k&&(R=w.getUint32(0,!1),_=4);const M=new Array(R);for(let U=0;U<R;U++)M[U]=w.getUint32(_,!1),_+=4;return M}class fi{constructor(k){this.wasm=k}async pedersenCommit(k,w){const _=[k,w].map(Re),R=[Lt];return(await this.wasm.callWasmExport("pedersen_commit",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async pedersenHash(k,w){const _=[k,w].map(Re),R=[ve];return(await this.wasm.callWasmExport("pedersen_hash",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async pedersenHashes(k,w){const _=[k,w].map(Re),R=[ve];return(await this.wasm.callWasmExport("pedersen_hashes",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async pedersenHashBuffer(k,w){const _=[k,w].map(Re),R=[ve];return(await this.wasm.callWasmExport("pedersen_hash_buffer",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async poseidon2Hash(k){const w=[k].map(Re),_=[ve];return(await this.wasm.callWasmExport("poseidon2_hash",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async poseidon2HashAccumulate(k){const w=[k].map(Re),_=[ve];return(await this.wasm.callWasmExport("poseidon2_hash_accumulate",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async poseidon2Hashes(k){const w=[k].map(Re),_=[ve];return(await this.wasm.callWasmExport("poseidon2_hashes",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async poseidon2Permutation(k){const w=[k].map(Re),_=[en(ve)];return(await this.wasm.callWasmExport("poseidon2_permutation",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async blake2s(k){const w=[k].map(Re),_=[Rt];return(await this.wasm.callWasmExport("blake2s",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async blake2sToField(k){const w=[k].map(Re),_=[ve];return(await this.wasm.callWasmExport("blake2s_to_field_",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async schnorrComputePublicKey(k){const w=[k].map(Re),_=[Lt];return(await this.wasm.callWasmExport("schnorr_compute_public_key",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async schnorrNegatePublicKey(k){const w=[k].map(Re),_=[Lt];return(await this.wasm.callWasmExport("schnorr_negate_public_key",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async schnorrConstructSignature(k,w){const _=[k,w].map(Re),R=[Rt,Rt];return(await this.wasm.callWasmExport("schnorr_construct_signature",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))}async schnorrVerifySignature(k,w,_,R){const M=[k,w,_,R].map(Re),U=[wt()];return(await this.wasm.callWasmExport("schnorr_verify_signature",M,U.map(X=>X.SIZE_IN_BYTES))).map((X,ye)=>U[ye].fromBuffer(X))[0]}async schnorrMultisigCreateMultisigPublicKey(k){const w=[k].map(Re),_=[on];return(await this.wasm.callWasmExport("schnorr_multisig_create_multisig_public_key",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async schnorrMultisigValidateAndCombineSignerPubkeys(k){const w=[k].map(Re),_=[Lt,wt()];return(await this.wasm.callWasmExport("schnorr_multisig_validate_and_combine_signer_pubkeys",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))}async schnorrMultisigConstructSignatureRound1(){const k=[].map(Re),w=[on,on];return(await this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_1",k,w.map(M=>M.SIZE_IN_BYTES))).map((M,U)=>w[U].fromBuffer(M))}async schnorrMultisigConstructSignatureRound2(k,w,_,R,M){const U=[k,w,_,R,M].map(Re),V=[ze,wt()];return(await this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_2",U,V.map(ye=>ye.SIZE_IN_BYTES))).map((ye,Qe)=>V[Qe].fromBuffer(ye))}async schnorrMultisigCombineSignatures(k,w,_,R){const M=[k,w,_,R].map(Re),U=[Rt,Rt,wt()];return(await this.wasm.callWasmExport("schnorr_multisig_combine_signatures",M,U.map(X=>X.SIZE_IN_BYTES))).map((X,ye)=>U[ye].fromBuffer(X))}async aesEncryptBufferCbc(k,w,_,R){const M=[k,w,_,R].map(Re),U=[Ht()];return(await this.wasm.callWasmExport("aes_encrypt_buffer_cbc",M,U.map(X=>X.SIZE_IN_BYTES))).map((X,ye)=>U[ye].fromBuffer(X))[0]}async aesDecryptBufferCbc(k,w,_,R){const M=[k,w,_,R].map(Re),U=[Ht()];return(await this.wasm.callWasmExport("aes_decrypt_buffer_cbc",M,U.map(X=>X.SIZE_IN_BYTES))).map((X,ye)=>U[ye].fromBuffer(X))[0]}async srsInitSrs(k,w,_){const R=[k,w,_].map(Re),M=[];(await this.wasm.callWasmExport("srs_init_srs",R,M.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>M[fe].fromBuffer(V))}async srsInitGrumpkinSrs(k,w){const _=[k,w].map(Re),R=[];(await this.wasm.callWasmExport("srs_init_grumpkin_srs",_,R.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>R[V].fromBuffer(U))}async examplesSimpleCreateAndVerifyProof(){const k=[].map(Re),w=[wt()];return(await this.wasm.callWasmExport("examples_simple_create_and_verify_proof",k,w.map(M=>M.SIZE_IN_BYTES))).map((M,U)=>w[U].fromBuffer(M))[0]}async testThreads(k,w){const _=[k,w].map(Re),R=[oa()];return(await this.wasm.callWasmExport("test_threads",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async commonInitSlabAllocator(k){const w=[k].map(Re),_=[];(await this.wasm.callWasmExport("common_init_slab_allocator",w,_.map(M=>M.SIZE_IN_BYTES))).map((M,U)=>_[U].fromBuffer(M))}async acirGetCircuitSizes(k,w,_){const R=[k,w,_].map(Re),M=[oa(),oa()];return(await this.wasm.callWasmExport("acir_get_circuit_sizes",R,M.map(fe=>fe.SIZE_IN_BYTES))).map((fe,X)=>M[X].fromBuffer(fe))}async acirGatesAztecClient(k){const w=[k].map(Re),_=[Ht()],R=await this.wasm.callWasmExport("acir_gates_aztec_client",w,_.map(M=>M.SIZE_IN_BYTES));return hn(R[0],!0)}async acirNewAcirComposer(k){const w=[k].map(Re),_=[kn];return(await this.wasm.callWasmExport("acir_new_acir_composer",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async acirDeleteAcirComposer(k){const w=[k].map(Re),_=[];(await this.wasm.callWasmExport("acir_delete_acir_composer",w,_.map(M=>M.SIZE_IN_BYTES))).map((M,U)=>_[U].fromBuffer(M))}async acirInitProvingKey(k,w,_){const R=[k,w,_].map(Re),M=[];(await this.wasm.callWasmExport("acir_init_proving_key",R,M.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>M[fe].fromBuffer(V))}async acirCreateProof(k,w,_,R){const M=[k,w,_,R].map(Re),U=[Ht()];return(await this.wasm.callWasmExport("acir_create_proof",M,U.map(X=>X.SIZE_IN_BYTES))).map((X,ye)=>U[ye].fromBuffer(X))[0]}async acirProveAndVerifyUltraHonk(k,w,_){const R=[k,w,_].map(Re),M=[wt()];return(await this.wasm.callWasmExport("acir_prove_and_verify_ultra_honk",R,M.map(fe=>fe.SIZE_IN_BYTES))).map((fe,X)=>M[X].fromBuffer(fe))[0]}async acirProveAndVerifyMegaHonk(k,w,_){const R=[k,w,_].map(Re),M=[wt()];return(await this.wasm.callWasmExport("acir_prove_and_verify_mega_honk",R,M.map(fe=>fe.SIZE_IN_BYTES))).map((fe,X)=>M[X].fromBuffer(fe))[0]}async acirFoldAndVerifyProgramStack(k,w,_){const R=[k,w,_].map(Re),M=[wt()];return(await this.wasm.callWasmExport("acir_fold_and_verify_program_stack",R,M.map(fe=>fe.SIZE_IN_BYTES))).map((fe,X)=>M[X].fromBuffer(fe))[0]}async acirLoadVerificationKey(k,w){const _=[k,w].map(Re),R=[];(await this.wasm.callWasmExport("acir_load_verification_key",_,R.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>R[V].fromBuffer(U))}async acirInitVerificationKey(k){const w=[k].map(Re),_=[];(await this.wasm.callWasmExport("acir_init_verification_key",w,_.map(M=>M.SIZE_IN_BYTES))).map((M,U)=>_[U].fromBuffer(M))}async acirGetVerificationKey(k){const w=[k].map(Re),_=[Ht()];return(await this.wasm.callWasmExport("acir_get_verification_key",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async acirGetProvingKey(k,w,_){const R=[k,w,_].map(Re),M=[Ht()];return(await this.wasm.callWasmExport("acir_get_proving_key",R,M.map(fe=>fe.SIZE_IN_BYTES))).map((fe,X)=>M[X].fromBuffer(fe))[0]}async acirVerifyProof(k,w){const _=[k,w].map(Re),R=[wt()];return(await this.wasm.callWasmExport("acir_verify_proof",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async acirGetSolidityVerifier(k){const w=[k].map(Re),_=[Jn()];return(await this.wasm.callWasmExport("acir_get_solidity_verifier",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async acirSerializeProofIntoFields(k,w,_){const R=[k,w,_].map(Re),M=[en(ve)];return(await this.wasm.callWasmExport("acir_serialize_proof_into_fields",R,M.map(fe=>fe.SIZE_IN_BYTES))).map((fe,X)=>M[X].fromBuffer(fe))[0]}async acirSerializeVerificationKeyIntoFields(k){const w=[k].map(Re),_=[en(ve),ve];return(await this.wasm.callWasmExport("acir_serialize_verification_key_into_fields",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))}async acirProveAndVerifyAztecClient(k,w){const _=[k,w].map(Re),R=[wt()];return(await this.wasm.callWasmExport("acir_prove_and_verify_aztec_client",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async acirProveAztecClient(k,w){const _=[k,w].map(Re),R=[Ht(),Ht()],U=(await this.wasm.callWasmExport("acir_prove_aztec_client",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V));return[U[0],U[1]]}async acirVerifyAztecClient(k,w){const _=[k,w].map(Re),R=[wt()];return(await this.wasm.callWasmExport("acir_verify_aztec_client",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async acirProveUltraHonk(k,w,_){const R=[k,w,_].map(Re),M=[Ht()];return(await this.wasm.callWasmExport("acir_prove_ultra_honk",R,M.map(fe=>fe.SIZE_IN_BYTES))).map((fe,X)=>M[X].fromBuffer(fe))[0]}async acirProveUltraKeccakHonk(k,w,_){const R=[k,w,_].map(Re),M=[Ht()];return(await this.wasm.callWasmExport("acir_prove_ultra_keccak_honk",R,M.map(fe=>fe.SIZE_IN_BYTES))).map((fe,X)=>M[X].fromBuffer(fe))[0]}async acirVerifyUltraHonk(k,w){const _=[k,w].map(Re),R=[wt()];return(await this.wasm.callWasmExport("acir_verify_ultra_honk",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async acirVerifyUltraKeccakHonk(k,w){const _=[k,w].map(Re),R=[wt()];return(await this.wasm.callWasmExport("acir_verify_ultra_keccak_honk",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async acirWriteVkUltraHonk(k,w){const _=[k,w].map(Re),R=[Ht()];return(await this.wasm.callWasmExport("acir_write_vk_ultra_honk",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async acirWriteVkUltraKeccakHonk(k,w){const _=[k,w].map(Re),R=[Ht()];return(await this.wasm.callWasmExport("acir_write_vk_ultra_keccak_honk",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async acirHonkSolidityVerifier(k,w){const _=[k,w].map(Re),R=[Ht()];return(await this.wasm.callWasmExport("acir_honk_solidity_verifier",_,R.map(V=>V.SIZE_IN_BYTES))).map((V,fe)=>R[fe].fromBuffer(V))[0]}async acirProofAsFieldsUltraHonk(k){const w=[k].map(Re),_=[en(ve)];return(await this.wasm.callWasmExport("acir_proof_as_fields_ultra_honk",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async acirVkAsFieldsUltraHonk(k){const w=[k].map(Re),_=[en(ve)];return(await this.wasm.callWasmExport("acir_vk_as_fields_ultra_honk",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}async acirVkAsFieldsMegaHonk(k){const w=[k].map(Re),_=[en(ve)];return(await this.wasm.callWasmExport("acir_vk_as_fields_mega_honk",w,_.map(U=>U.SIZE_IN_BYTES))).map((U,V)=>_[V].fromBuffer(U))[0]}}class ls{constructor(k){this.wasm=k}pedersenCommit(k,w){const _=[k,w].map(Re),R=[Lt];return this.wasm.callWasmExport("pedersen_commit",_,R.map(V=>V.SIZE_IN_BYTES)).map((V,fe)=>R[fe].fromBuffer(V))[0]}pedersenHash(k,w){const _=[k,w].map(Re),R=[ve];return this.wasm.callWasmExport("pedersen_hash",_,R.map(V=>V.SIZE_IN_BYTES)).map((V,fe)=>R[fe].fromBuffer(V))[0]}pedersenHashes(k,w){const _=[k,w].map(Re),R=[ve];return this.wasm.callWasmExport("pedersen_hashes",_,R.map(V=>V.SIZE_IN_BYTES)).map((V,fe)=>R[fe].fromBuffer(V))[0]}pedersenHashBuffer(k,w){const _=[k,w].map(Re),R=[ve];return this.wasm.callWasmExport("pedersen_hash_buffer",_,R.map(V=>V.SIZE_IN_BYTES)).map((V,fe)=>R[fe].fromBuffer(V))[0]}poseidon2Hash(k){const w=[k].map(Re),_=[ve];return this.wasm.callWasmExport("poseidon2_hash",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}poseidon2HashAccumulate(k){const w=[k].map(Re),_=[ve];return this.wasm.callWasmExport("poseidon2_hash_accumulate",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}poseidon2Hashes(k){const w=[k].map(Re),_=[ve];return this.wasm.callWasmExport("poseidon2_hashes",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}poseidon2Permutation(k){const w=[k].map(Re),_=[en(ve)];return this.wasm.callWasmExport("poseidon2_permutation",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}blake2s(k){const w=[k].map(Re),_=[Rt];return this.wasm.callWasmExport("blake2s",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}blake2sToField(k){const w=[k].map(Re),_=[ve];return this.wasm.callWasmExport("blake2s_to_field_",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}schnorrComputePublicKey(k){const w=[k].map(Re),_=[Lt];return this.wasm.callWasmExport("schnorr_compute_public_key",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}schnorrNegatePublicKey(k){const w=[k].map(Re),_=[Lt];return this.wasm.callWasmExport("schnorr_negate_public_key",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}schnorrConstructSignature(k,w){const _=[k,w].map(Re),R=[Rt,Rt];return this.wasm.callWasmExport("schnorr_construct_signature",_,R.map(V=>V.SIZE_IN_BYTES)).map((V,fe)=>R[fe].fromBuffer(V))}schnorrVerifySignature(k,w,_,R){const M=[k,w,_,R].map(Re),U=[wt()];return this.wasm.callWasmExport("schnorr_verify_signature",M,U.map(X=>X.SIZE_IN_BYTES)).map((X,ye)=>U[ye].fromBuffer(X))[0]}schnorrMultisigCreateMultisigPublicKey(k){const w=[k].map(Re),_=[on];return this.wasm.callWasmExport("schnorr_multisig_create_multisig_public_key",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}schnorrMultisigValidateAndCombineSignerPubkeys(k){const w=[k].map(Re),_=[Lt,wt()];return this.wasm.callWasmExport("schnorr_multisig_validate_and_combine_signer_pubkeys",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))}schnorrMultisigConstructSignatureRound1(){const k=[].map(Re),w=[on,on];return this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_1",k,w.map(M=>M.SIZE_IN_BYTES)).map((M,U)=>w[U].fromBuffer(M))}schnorrMultisigConstructSignatureRound2(k,w,_,R,M){const U=[k,w,_,R,M].map(Re),V=[ze,wt()];return this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_2",U,V.map(ye=>ye.SIZE_IN_BYTES)).map((ye,Qe)=>V[Qe].fromBuffer(ye))}schnorrMultisigCombineSignatures(k,w,_,R){const M=[k,w,_,R].map(Re),U=[Rt,Rt,wt()];return this.wasm.callWasmExport("schnorr_multisig_combine_signatures",M,U.map(X=>X.SIZE_IN_BYTES)).map((X,ye)=>U[ye].fromBuffer(X))}aesEncryptBufferCbc(k,w,_,R){const M=[k,w,_,R].map(Re),U=[Ht()];return this.wasm.callWasmExport("aes_encrypt_buffer_cbc",M,U.map(X=>X.SIZE_IN_BYTES)).map((X,ye)=>U[ye].fromBuffer(X))[0]}aesDecryptBufferCbc(k,w,_,R){const M=[k,w,_,R].map(Re),U=[Ht()];return this.wasm.callWasmExport("aes_decrypt_buffer_cbc",M,U.map(X=>X.SIZE_IN_BYTES)).map((X,ye)=>U[ye].fromBuffer(X))[0]}srsInitSrs(k,w,_){const R=[k,w,_].map(Re),M=[];this.wasm.callWasmExport("srs_init_srs",R,M.map(V=>V.SIZE_IN_BYTES)).map((V,fe)=>M[fe].fromBuffer(V))}srsInitGrumpkinSrs(k,w){const _=[k,w].map(Re),R=[];this.wasm.callWasmExport("srs_init_grumpkin_srs",_,R.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>R[V].fromBuffer(U))}examplesSimpleCreateAndVerifyProof(){const k=[].map(Re),w=[wt()];return this.wasm.callWasmExport("examples_simple_create_and_verify_proof",k,w.map(M=>M.SIZE_IN_BYTES)).map((M,U)=>w[U].fromBuffer(M))[0]}testThreads(k,w){const _=[k,w].map(Re),R=[oa()];return this.wasm.callWasmExport("test_threads",_,R.map(V=>V.SIZE_IN_BYTES)).map((V,fe)=>R[fe].fromBuffer(V))[0]}commonInitSlabAllocator(k){const w=[k].map(Re),_=[];this.wasm.callWasmExport("common_init_slab_allocator",w,_.map(M=>M.SIZE_IN_BYTES)).map((M,U)=>_[U].fromBuffer(M))}acirGetCircuitSizes(k,w,_){const R=[k,w,_].map(Re),M=[oa(),oa()];return this.wasm.callWasmExport("acir_get_circuit_sizes",R,M.map(fe=>fe.SIZE_IN_BYTES)).map((fe,X)=>M[X].fromBuffer(fe))}acirNewAcirComposer(k){const w=[k].map(Re),_=[kn];return this.wasm.callWasmExport("acir_new_acir_composer",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}acirDeleteAcirComposer(k){const w=[k].map(Re),_=[];this.wasm.callWasmExport("acir_delete_acir_composer",w,_.map(M=>M.SIZE_IN_BYTES)).map((M,U)=>_[U].fromBuffer(M))}acirInitProvingKey(k,w,_){const R=[k,w,_].map(Re),M=[];this.wasm.callWasmExport("acir_init_proving_key",R,M.map(V=>V.SIZE_IN_BYTES)).map((V,fe)=>M[fe].fromBuffer(V))}acirCreateProof(k,w,_,R){const M=[k,w,_,R].map(Re),U=[Ht()];return this.wasm.callWasmExport("acir_create_proof",M,U.map(X=>X.SIZE_IN_BYTES)).map((X,ye)=>U[ye].fromBuffer(X))[0]}acirProveAndVerifyUltraHonk(k,w,_){const R=[k,w,_].map(Re),M=[wt()];return this.wasm.callWasmExport("acir_prove_and_verify_ultra_honk",R,M.map(fe=>fe.SIZE_IN_BYTES)).map((fe,X)=>M[X].fromBuffer(fe))[0]}acirProveAndVerifyMegaHonk(k,w,_){const R=[k,w,_].map(Re),M=[wt()];return this.wasm.callWasmExport("acir_prove_and_verify_mega_honk",R,M.map(fe=>fe.SIZE_IN_BYTES)).map((fe,X)=>M[X].fromBuffer(fe))[0]}acirFoldAndVerifyProgramStack(k,w,_){const R=[k,w,_].map(Re),M=[wt()];return this.wasm.callWasmExport("acir_fold_and_verify_program_stack",R,M.map(fe=>fe.SIZE_IN_BYTES)).map((fe,X)=>M[X].fromBuffer(fe))[0]}acirLoadVerificationKey(k,w){const _=[k,w].map(Re),R=[];this.wasm.callWasmExport("acir_load_verification_key",_,R.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>R[V].fromBuffer(U))}acirInitVerificationKey(k){const w=[k].map(Re),_=[];this.wasm.callWasmExport("acir_init_verification_key",w,_.map(M=>M.SIZE_IN_BYTES)).map((M,U)=>_[U].fromBuffer(M))}acirGetVerificationKey(k){const w=[k].map(Re),_=[Ht()];return this.wasm.callWasmExport("acir_get_verification_key",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}acirGetProvingKey(k,w,_){const R=[k,w,_].map(Re),M=[Ht()];return this.wasm.callWasmExport("acir_get_proving_key",R,M.map(fe=>fe.SIZE_IN_BYTES)).map((fe,X)=>M[X].fromBuffer(fe))[0]}acirVerifyProof(k,w){const _=[k,w].map(Re),R=[wt()];return this.wasm.callWasmExport("acir_verify_proof",_,R.map(V=>V.SIZE_IN_BYTES)).map((V,fe)=>R[fe].fromBuffer(V))[0]}acirGetSolidityVerifier(k){const w=[k].map(Re),_=[Jn()];return this.wasm.callWasmExport("acir_get_solidity_verifier",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}acirSerializeProofIntoFields(k,w,_){const R=[k,w,_].map(Re),M=[en(ve)];return this.wasm.callWasmExport("acir_serialize_proof_into_fields",R,M.map(fe=>fe.SIZE_IN_BYTES)).map((fe,X)=>M[X].fromBuffer(fe))[0]}acirSerializeVerificationKeyIntoFields(k){const w=[k].map(Re),_=[en(ve),ve];return this.wasm.callWasmExport("acir_serialize_verification_key_into_fields",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))}acirProveUltraHonk(k,w,_){const R=[k,w,_].map(Re),M=[Ht()];return this.wasm.callWasmExport("acir_prove_ultra_honk",R,M.map(fe=>fe.SIZE_IN_BYTES)).map((fe,X)=>M[X].fromBuffer(fe))[0]}acirVerifyUltraHonk(k,w){const _=[k,w].map(Re),R=[wt()];return this.wasm.callWasmExport("acir_verify_ultra_honk",_,R.map(V=>V.SIZE_IN_BYTES)).map((V,fe)=>R[fe].fromBuffer(V))[0]}acirWriteVkUltraHonk(k,w){const _=[k,w].map(Re),R=[Ht()];return this.wasm.callWasmExport("acir_write_vk_ultra_honk",_,R.map(V=>V.SIZE_IN_BYTES)).map((V,fe)=>R[fe].fromBuffer(V))[0]}acirProofAsFieldsUltraHonk(k){const w=[k].map(Re),_=[en(ve)];return this.wasm.callWasmExport("acir_proof_as_fields_ultra_honk",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}acirVkAsFieldsUltraHonk(k){const w=[k].map(Re),_=[en(ve)];return this.wasm.callWasmExport("acir_vk_as_fields_ultra_honk",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}acirVkAsFieldsMegaHonk(k){const w=[k].map(Re),_=[en(ve)];return this.wasm.callWasmExport("acir_vk_as_fields_mega_honk",w,_.map(U=>U.SIZE_IN_BYTES)).map((U,V)=>_[V].fromBuffer(U))[0]}}var us=Yt(227),Va=Yt.n(us),cs=Yt(477),mo=Yt.n(cs);function Me(){return mo()(`/*! For license information please see main.worker.worker.js.LICENSE.txt */
var __webpack_modules__ = {
    227: (module, exports, __webpack_require__) => {
        exports.formatArgs = formatArgs;
        exports.save = save;
        exports.load = load;
        exports.useColors = useColors;
        exports.storage = localstorage();
        exports.destroy = (() => {
            let warned = false;
            return () => {
                if (!warned) {
                    warned = true;
                    console.warn("Instance method \`debug.destroy()\` is deprecated and no longer does anything. It will be removed in the next major version of \`debug\`.");
                }
            };
        })();
        exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ];
        function useColors() {
            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
                return true;
            }
            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {
                return false;
            }
            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);
        }
        function formatArgs(args) {
            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
            if (!this.useColors) {
                return;
            }
            const c = "color: " + this.color;
            args.splice(1, 0, c, "color: inherit");
            let index = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match => {
                if (match === "%%") {
                    return;
                }
                index++;
                if (match === "%c") {
                    lastC = index;
                }
            }));
            args.splice(lastC, 0, c);
        }
        exports.log = console.debug || console.log || (() => {});
        function save(namespaces) {
            try {
                if (namespaces) {
                    exports.storage.setItem("debug", namespaces);
                } else {
                    exports.storage.removeItem("debug");
                }
            } catch (error) {}
        }
        function load() {
            let r;
            try {
                r = exports.storage.getItem("debug");
            } catch (error) {}
            if (!r && typeof process !== "undefined" && "env" in process) {
                r = process.env.DEBUG;
            }
            return r;
        }
        function localstorage() {
            try {
                return localStorage;
            } catch (error) {}
        }
        module.exports = __webpack_require__(447)(exports);
        const {formatters} = module.exports;
        formatters.j = function(v) {
            try {
                return JSON.stringify(v);
            } catch (error) {
                return "[UnexpectedJSONParseError]: " + error.message;
            }
        };
    },
    447: (module, __unused_webpack_exports, __webpack_require__) => {
        function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = __webpack_require__(824);
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key => {
                createDebug[key] = env[key];
            }));
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
                let hash = 0;
                for (let i = 0; i < namespace.length; i++) {
                    hash = (hash << 5) - hash + namespace.charCodeAt(i);
                    hash |= 0;
                }
                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
                let prevTime;
                let enableOverride = null;
                let namespacesCache;
                let enabledCache;
                function debug(...args) {
                    if (!debug.enabled) {
                        return;
                    }
                    const self = debug;
                    const curr = Number(new Date);
                    const ms = curr - (prevTime || curr);
                    self.diff = ms;
                    self.prev = prevTime;
                    self.curr = curr;
                    prevTime = curr;
                    args[0] = createDebug.coerce(args[0]);
                    if (typeof args[0] !== "string") {
                        args.unshift("%O");
                    }
                    let index = 0;
                    args[0] = args[0].replace(/%([a-zA-Z%])/g, ((match, format) => {
                        if (match === "%%") {
                            return "%";
                        }
                        index++;
                        const formatter = createDebug.formatters[format];
                        if (typeof formatter === "function") {
                            const val = args[index];
                            match = formatter.call(self, val);
                            args.splice(index, 1);
                            index--;
                        }
                        return match;
                    }));
                    createDebug.formatArgs.call(self, args);
                    const logFn = self.log || createDebug.log;
                    logFn.apply(self, args);
                }
                debug.namespace = namespace;
                debug.useColors = createDebug.useColors();
                debug.color = createDebug.selectColor(namespace);
                debug.extend = extend;
                debug.destroy = createDebug.destroy;
                Object.defineProperty(debug, "enabled", {
                    enumerable: true,
                    configurable: false,
                    get: () => {
                        if (enableOverride !== null) {
                            return enableOverride;
                        }
                        if (namespacesCache !== createDebug.namespaces) {
                            namespacesCache = createDebug.namespaces;
                            enabledCache = createDebug.enabled(namespace);
                        }
                        return enabledCache;
                    },
                    set: v => {
                        enableOverride = v;
                    }
                });
                if (typeof createDebug.init === "function") {
                    createDebug.init(debug);
                }
                return debug;
            }
            function extend(namespace, delimiter) {
                const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
                newDebug.log = this.log;
                return newDebug;
            }
            function enable(namespaces) {
                createDebug.save(namespaces);
                createDebug.namespaces = namespaces;
                createDebug.names = [];
                createDebug.skips = [];
                let i;
                const split = (typeof namespaces === "string" ? namespaces : "").split(/[\\s,]+/);
                const len = split.length;
                for (i = 0; i < len; i++) {
                    if (!split[i]) {
                        continue;
                    }
                    namespaces = split[i].replace(/\\*/g, ".*?");
                    if (namespaces[0] === "-") {
                        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
                    } else {
                        createDebug.names.push(new RegExp("^" + namespaces + "$"));
                    }
                }
            }
            function disable() {
                const namespaces = [ ...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace => "-" + namespace)) ].join(",");
                createDebug.enable("");
                return namespaces;
            }
            function enabled(name) {
                if (name[name.length - 1] === "*") {
                    return true;
                }
                let i;
                let len;
                for (i = 0, len = createDebug.skips.length; i < len; i++) {
                    if (createDebug.skips[i].test(name)) {
                        return false;
                    }
                }
                for (i = 0, len = createDebug.names.length; i < len; i++) {
                    if (createDebug.names[i].test(name)) {
                        return true;
                    }
                }
                return false;
            }
            function toNamespace(regexp) {
                return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, "*");
            }
            function coerce(val) {
                if (val instanceof Error) {
                    return val.stack || val.message;
                }
                return val;
            }
            function destroy() {
                console.warn("Instance method \`debug.destroy()\` is deprecated and no longer does anything. It will be removed in the next major version of \`debug\`.");
            }
            createDebug.enable(createDebug.load());
            return createDebug;
        }
        module.exports = setup;
    },
    824: module => {
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if (type === "string" && val.length > 0) {
                return parse(val);
            } else if (type === "number" && isFinite(val)) {
                return options.long ? fmtLong(val) : fmtShort(val);
            }
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
        function parse(str) {
            str = String(str);
            if (str.length > 100) {
                return;
            }
            var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
            if (!match) {
                return;
            }
            var n = parseFloat(match[1]);
            var type = (match[2] || "ms").toLowerCase();
            switch (type) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return n * y;

              case "weeks":
              case "week":
              case "w":
                return n * w;

              case "days":
              case "day":
              case "d":
                return n * d;

              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return n * h;

              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return n * m;

              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return n * s;

              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return n;

              default:
                return undefined;
            }
        }
        function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
                return Math.round(ms / d) + "d";
            }
            if (msAbs >= h) {
                return Math.round(ms / h) + "h";
            }
            if (msAbs >= m) {
                return Math.round(ms / m) + "m";
            }
            if (msAbs >= s) {
                return Math.round(ms / s) + "s";
            }
            return ms + "ms";
        }
        function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
                return plural(ms, msAbs, d, "day");
            }
            if (msAbs >= h) {
                return plural(ms, msAbs, h, "hour");
            }
            if (msAbs >= m) {
                return plural(ms, msAbs, m, "minute");
            }
            if (msAbs >= s) {
                return plural(ms, msAbs, s, "second");
            }
            return ms + " ms";
        }
        function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= n * 1.5;
            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
    },
    477: module => {
        module.exports = function(content, workerConstructor, workerOptions, url) {
            var globalScope = self || window;
            try {
                try {
                    var blob;
                    try {
                        blob = new globalScope.Blob([ content ]);
                    } catch (e) {
                        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;
                        blob = new BlobBuilder;
                        blob.append(content);
                        blob = blob.getBlob();
                    }
                    var URL = globalScope.URL || globalScope.webkitURL;
                    var objectURL = URL.createObjectURL(blob);
                    var worker = new globalScope[workerConstructor](objectURL, workerOptions);
                    URL.revokeObjectURL(objectURL);
                    return worker;
                } catch (e) {
                    return new globalScope[workerConstructor]("data:application/javascript,".concat(encodeURIComponent(content)), workerOptions);
                }
            } catch (e) {
                if (!url) {
                    throw Error("Inline worker is not supported");
                }
                return new globalScope[workerConstructor](url, workerOptions);
            }
        };
    }
};

var __webpack_module_cache__ = {};

function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
        return cachedModule.exports;
    }
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}

(() => {
    __webpack_require__.n = module => {
        var getter = module && module.__esModule ? () => module["default"] : () => module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();

(() => {
    __webpack_require__.d = (exports, definition) => {
        for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                Object.defineProperty(exports, key, {
                    enumerable: true,
                    get: definition[key]
                });
            }
        }
    };
})();

(() => {
    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();

var __webpack_exports__ = {};

(() => {
    const proxyMarker = Symbol("Comlink.proxy");
    const createEndpoint = Symbol("Comlink.endpoint");
    const releaseProxy = Symbol("Comlink.releaseProxy");
    const finalizer = Symbol("Comlink.finalizer");
    const throwMarker = Symbol("Comlink.thrown");
    const isObject = val => typeof val === "object" && val !== null || typeof val === "function";
    const proxyTransferHandler = {
        canHandle: val => isObject(val) && val[proxyMarker],
        serialize(obj) {
            const {port1, port2} = new MessageChannel;
            expose(obj, port1);
            return [ port2, [ port2 ] ];
        },
        deserialize(port) {
            port.start();
            return wrap(port);
        }
    };
    const throwTransferHandler = {
        canHandle: value => isObject(value) && throwMarker in value,
        serialize({value}) {
            let serialized;
            if (value instanceof Error) {
                serialized = {
                    isError: true,
                    value: {
                        message: value.message,
                        name: value.name,
                        stack: value.stack
                    }
                };
            } else {
                serialized = {
                    isError: false,
                    value
                };
            }
            return [ serialized, [] ];
        },
        deserialize(serialized) {
            if (serialized.isError) {
                throw Object.assign(new Error(serialized.value.message), serialized.value);
            }
            throw serialized.value;
        }
    };
    const transferHandlers = new Map([ [ "proxy", proxyTransferHandler ], [ "throw", throwTransferHandler ] ]);
    function isAllowedOrigin(allowedOrigins, origin) {
        for (const allowedOrigin of allowedOrigins) {
            if (origin === allowedOrigin || allowedOrigin === "*") {
                return true;
            }
            if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
                return true;
            }
        }
        return false;
    }
    function expose(obj, ep = globalThis, allowedOrigins = [ "*" ]) {
        ep.addEventListener("message", (function callback(ev) {
            if (!ev || !ev.data) {
                return;
            }
            if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
                console.warn(\`Invalid origin '\${ev.origin}' for comlink proxy\`);
                return;
            }
            const {id, type, path} = Object.assign({
                path: []
            }, ev.data);
            const argumentList = (ev.data.argumentList || []).map(fromWireValue);
            let returnValue;
            try {
                const parent = path.slice(0, -1).reduce(((obj, prop) => obj[prop]), obj);
                const rawValue = path.reduce(((obj, prop) => obj[prop]), obj);
                switch (type) {
                  case "GET":
                    {
                        returnValue = rawValue;
                    }
                    break;

                  case "SET":
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                        returnValue = true;
                    }
                    break;

                  case "APPLY":
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;

                  case "CONSTRUCT":
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = proxy(value);
                    }
                    break;

                  case "ENDPOINT":
                    {
                        const {port1, port2} = new MessageChannel;
                        expose(obj, port2);
                        returnValue = transfer(port1, [ port1 ]);
                    }
                    break;

                  case "RELEASE":
                    {
                        returnValue = undefined;
                    }
                    break;

                  default:
                    return;
                }
            } catch (value) {
                returnValue = {
                    value,
                    [throwMarker]: 0
                };
            }
            Promise.resolve(returnValue).catch((value => ({
                value,
                [throwMarker]: 0
            }))).then((returnValue => {
                const [wireValue, transferables] = toWireValue(returnValue);
                ep.postMessage(Object.assign(Object.assign({}, wireValue), {
                    id
                }), transferables);
                if (type === "RELEASE") {
                    ep.removeEventListener("message", callback);
                    closeEndPoint(ep);
                    if (finalizer in obj && typeof obj[finalizer] === "function") {
                        obj[finalizer]();
                    }
                }
            })).catch((error => {
                const [wireValue, transferables] = toWireValue({
                    value: new TypeError("Unserializable return value"),
                    [throwMarker]: 0
                });
                ep.postMessage(Object.assign(Object.assign({}, wireValue), {
                    id
                }), transferables);
            }));
        }));
        if (ep.start) {
            ep.start();
        }
    }
    function isMessagePort(endpoint) {
        return endpoint.constructor.name === "MessagePort";
    }
    function closeEndPoint(endpoint) {
        if (isMessagePort(endpoint)) endpoint.close();
    }
    function wrap(ep, target) {
        return createProxy(ep, [], target);
    }
    function throwIfProxyReleased(isReleased) {
        if (isReleased) {
            throw new Error("Proxy has been released and is not useable");
        }
    }
    function releaseEndpoint(ep) {
        return requestResponseMessage(ep, {
            type: "RELEASE"
        }).then((() => {
            closeEndPoint(ep);
        }));
    }
    const proxyCounter = new WeakMap;
    const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep => {
        const newCount = (proxyCounter.get(ep) || 0) - 1;
        proxyCounter.set(ep, newCount);
        if (newCount === 0) {
            releaseEndpoint(ep);
        }
    }));
    function registerProxy(proxy, ep) {
        const newCount = (proxyCounter.get(ep) || 0) + 1;
        proxyCounter.set(ep, newCount);
        if (proxyFinalizers) {
            proxyFinalizers.register(proxy, ep, proxy);
        }
    }
    function unregisterProxy(proxy) {
        if (proxyFinalizers) {
            proxyFinalizers.unregister(proxy);
        }
    }
    function createProxy(ep, path = [], target = function() {}) {
        let isProxyReleased = false;
        const proxy = new Proxy(target, {
            get(_target, prop) {
                throwIfProxyReleased(isProxyReleased);
                if (prop === releaseProxy) {
                    return () => {
                        unregisterProxy(proxy);
                        releaseEndpoint(ep);
                        isProxyReleased = true;
                    };
                }
                if (prop === "then") {
                    if (path.length === 0) {
                        return {
                            then: () => proxy
                        };
                    }
                    const r = requestResponseMessage(ep, {
                        type: "GET",
                        path: path.map((p => p.toString()))
                    }).then(fromWireValue);
                    return r.then.bind(r);
                }
                return createProxy(ep, [ ...path, prop ]);
            },
            set(_target, prop, rawValue) {
                throwIfProxyReleased(isProxyReleased);
                const [value, transferables] = toWireValue(rawValue);
                return requestResponseMessage(ep, {
                    type: "SET",
                    path: [ ...path, prop ].map((p => p.toString())),
                    value
                }, transferables).then(fromWireValue);
            },
            apply(_target, _thisArg, rawArgumentList) {
                throwIfProxyReleased(isProxyReleased);
                const last = path[path.length - 1];
                if (last === createEndpoint) {
                    return requestResponseMessage(ep, {
                        type: "ENDPOINT"
                    }).then(fromWireValue);
                }
                if (last === "bind") {
                    return createProxy(ep, path.slice(0, -1));
                }
                const [argumentList, transferables] = processArguments(rawArgumentList);
                return requestResponseMessage(ep, {
                    type: "APPLY",
                    path: path.map((p => p.toString())),
                    argumentList
                }, transferables).then(fromWireValue);
            },
            construct(_target, rawArgumentList) {
                throwIfProxyReleased(isProxyReleased);
                const [argumentList, transferables] = processArguments(rawArgumentList);
                return requestResponseMessage(ep, {
                    type: "CONSTRUCT",
                    path: path.map((p => p.toString())),
                    argumentList
                }, transferables).then(fromWireValue);
            }
        });
        registerProxy(proxy, ep);
        return proxy;
    }
    function myFlat(arr) {
        return Array.prototype.concat.apply([], arr);
    }
    function processArguments(argumentList) {
        const processed = argumentList.map(toWireValue);
        return [ processed.map((v => v[0])), myFlat(processed.map((v => v[1]))) ];
    }
    const transferCache = new WeakMap;
    function transfer(obj, transfers) {
        transferCache.set(obj, transfers);
        return obj;
    }
    function proxy(obj) {
        return Object.assign(obj, {
            [proxyMarker]: true
        });
    }
    function windowEndpoint(w, context = globalThis, targetOrigin = "*") {
        return {
            postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
            addEventListener: context.addEventListener.bind(context),
            removeEventListener: context.removeEventListener.bind(context)
        };
    }
    function toWireValue(value) {
        for (const [name, handler] of transferHandlers) {
            if (handler.canHandle(value)) {
                const [serializedValue, transferables] = handler.serialize(value);
                return [ {
                    type: "HANDLER",
                    name,
                    value: serializedValue
                }, transferables ];
            }
        }
        return [ {
            type: "RAW",
            value
        }, transferCache.get(value) || [] ];
    }
    function fromWireValue(value) {
        switch (value.type) {
          case "HANDLER":
            return transferHandlers.get(value.name).deserialize(value.value);

          case "RAW":
            return value.value;
        }
    }
    function requestResponseMessage(ep, msg, transfers) {
        return new Promise((resolve => {
            const id = generateUUID();
            ep.addEventListener("message", (function l(ev) {
                if (!ev.data || !ev.data.id || ev.data.id !== id) {
                    return;
                }
                ep.removeEventListener("message", l);
                resolve(ev.data);
            }));
            if (ep.start) {
                ep.start();
            }
            ep.postMessage(Object.assign({
                id
            }, msg), transfers);
        }));
    }
    function generateUUID() {
        return new Array(4).fill(0).map((() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))).join("-");
    }
    var browser = __webpack_require__(227);
    var browser_default = __webpack_require__.n(browser);
    function getSharedMemoryAvailable() {
        const globalScope = typeof window !== "undefined" ? window : globalThis;
        return typeof SharedArrayBuffer !== "undefined" && globalScope.crossOriginIsolated;
    }
    function getRemoteBarretenbergWasm(worker) {
        return wrap(worker);
    }
    function getNumCpu() {
        return navigator.hardwareConcurrency;
    }
    function threadLogger() {
        return undefined;
    }
    function killSelf() {
        self.close();
    }
    var inline = __webpack_require__(477);
    var inline_default = __webpack_require__.n(inline);
    function Worker_fn() {
        return inline_default()('/*! For license information please see thread.worker.worker.worker.js.LICENSE.txt */\\nvar __webpack_modules__ = {\\n    227: (module, exports, __webpack_require__) => {\\n        exports.formatArgs = formatArgs;\\n        exports.save = save;\\n        exports.load = load;\\n        exports.useColors = useColors;\\n        exports.storage = localstorage();\\n        exports.destroy = (() => {\\n            let warned = false;\\n            return () => {\\n                if (!warned) {\\n                    warned = true;\\n                    console.warn("Instance method \`debug.destroy()\` is deprecated and no longer does anything. It will be removed in the next major version of \`debug\`.");\\n                }\\n            };\\n        })();\\n        exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ];\\n        function useColors() {\\n            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {\\n                return true;\\n            }\\n            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\\\/(\\\\d+)/)) {\\n                return false;\\n            }\\n            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\\\/(\\\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\\\/(\\\\d+)/);\\n        }\\n        function formatArgs(args) {\\n            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);\\n            if (!this.useColors) {\\n                return;\\n            }\\n            const c = "color: " + this.color;\\n            args.splice(1, 0, c, "color: inherit");\\n            let index = 0;\\n            let lastC = 0;\\n            args[0].replace(/%[a-zA-Z%]/g, (match => {\\n                if (match === "%%") {\\n                    return;\\n                }\\n                index++;\\n                if (match === "%c") {\\n                    lastC = index;\\n                }\\n            }));\\n            args.splice(lastC, 0, c);\\n        }\\n        exports.log = console.debug || console.log || (() => {});\\n        function save(namespaces) {\\n            try {\\n                if (namespaces) {\\n                    exports.storage.setItem("debug", namespaces);\\n                } else {\\n                    exports.storage.removeItem("debug");\\n                }\\n            } catch (error) {}\\n        }\\n        function load() {\\n            let r;\\n            try {\\n                r = exports.storage.getItem("debug");\\n            } catch (error) {}\\n            if (!r && typeof process !== "undefined" && "env" in process) {\\n                r = process.env.DEBUG;\\n            }\\n            return r;\\n        }\\n        function localstorage() {\\n            try {\\n                return localStorage;\\n            } catch (error) {}\\n        }\\n        module.exports = __webpack_require__(447)(exports);\\n        const {formatters} = module.exports;\\n        formatters.j = function(v) {\\n            try {\\n                return JSON.stringify(v);\\n            } catch (error) {\\n                return "[UnexpectedJSONParseError]: " + error.message;\\n            }\\n        };\\n    },\\n    447: (module, __unused_webpack_exports, __webpack_require__) => {\\n        function setup(env) {\\n            createDebug.debug = createDebug;\\n            createDebug.default = createDebug;\\n            createDebug.coerce = coerce;\\n            createDebug.disable = disable;\\n            createDebug.enable = enable;\\n            createDebug.enabled = enabled;\\n            createDebug.humanize = __webpack_require__(824);\\n            createDebug.destroy = destroy;\\n            Object.keys(env).forEach((key => {\\n                createDebug[key] = env[key];\\n            }));\\n            createDebug.names = [];\\n            createDebug.skips = [];\\n            createDebug.formatters = {};\\n            function selectColor(namespace) {\\n                let hash = 0;\\n                for (let i = 0; i < namespace.length; i++) {\\n                    hash = (hash << 5) - hash + namespace.charCodeAt(i);\\n                    hash |= 0;\\n                }\\n                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\\n            }\\n            createDebug.selectColor = selectColor;\\n            function createDebug(namespace) {\\n                let prevTime;\\n                let enableOverride = null;\\n                let namespacesCache;\\n                let enabledCache;\\n                function debug(...args) {\\n                    if (!debug.enabled) {\\n                        return;\\n                    }\\n                    const self = debug;\\n                    const curr = Number(new Date);\\n                    const ms = curr - (prevTime || curr);\\n                    self.diff = ms;\\n                    self.prev = prevTime;\\n                    self.curr = curr;\\n                    prevTime = curr;\\n                    args[0] = createDebug.coerce(args[0]);\\n                    if (typeof args[0] !== "string") {\\n                        args.unshift("%O");\\n                    }\\n                    let index = 0;\\n                    args[0] = args[0].replace(/%([a-zA-Z%])/g, ((match, format) => {\\n                        if (match === "%%") {\\n                            return "%";\\n                        }\\n                        index++;\\n                        const formatter = createDebug.formatters[format];\\n                        if (typeof formatter === "function") {\\n                            const val = args[index];\\n                            match = formatter.call(self, val);\\n                            args.splice(index, 1);\\n                            index--;\\n                        }\\n                        return match;\\n                    }));\\n                    createDebug.formatArgs.call(self, args);\\n                    const logFn = self.log || createDebug.log;\\n                    logFn.apply(self, args);\\n                }\\n                debug.namespace = namespace;\\n                debug.useColors = createDebug.useColors();\\n                debug.color = createDebug.selectColor(namespace);\\n                debug.extend = extend;\\n                debug.destroy = createDebug.destroy;\\n                Object.defineProperty(debug, "enabled", {\\n                    enumerable: true,\\n                    configurable: false,\\n                    get: () => {\\n                        if (enableOverride !== null) {\\n                            return enableOverride;\\n                        }\\n                        if (namespacesCache !== createDebug.namespaces) {\\n                            namespacesCache = createDebug.namespaces;\\n                            enabledCache = createDebug.enabled(namespace);\\n                        }\\n                        return enabledCache;\\n                    },\\n                    set: v => {\\n                        enableOverride = v;\\n                    }\\n                });\\n                if (typeof createDebug.init === "function") {\\n                    createDebug.init(debug);\\n                }\\n                return debug;\\n            }\\n            function extend(namespace, delimiter) {\\n                const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);\\n                newDebug.log = this.log;\\n                return newDebug;\\n            }\\n            function enable(namespaces) {\\n                createDebug.save(namespaces);\\n                createDebug.namespaces = namespaces;\\n                createDebug.names = [];\\n                createDebug.skips = [];\\n                let i;\\n                const split = (typeof namespaces === "string" ? namespaces : "").split(/[\\\\s,]+/);\\n                const len = split.length;\\n                for (i = 0; i < len; i++) {\\n                    if (!split[i]) {\\n                        continue;\\n                    }\\n                    namespaces = split[i].replace(/\\\\*/g, ".*?");\\n                    if (namespaces[0] === "-") {\\n                        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));\\n                    } else {\\n                        createDebug.names.push(new RegExp("^" + namespaces + "$"));\\n                    }\\n                }\\n            }\\n            function disable() {\\n                const namespaces = [ ...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace => "-" + namespace)) ].join(",");\\n                createDebug.enable("");\\n                return namespaces;\\n            }\\n            function enabled(name) {\\n                if (name[name.length - 1] === "*") {\\n                    return true;\\n                }\\n                let i;\\n                let len;\\n                for (i = 0, len = createDebug.skips.length; i < len; i++) {\\n                    if (createDebug.skips[i].test(name)) {\\n                        return false;\\n                    }\\n                }\\n                for (i = 0, len = createDebug.names.length; i < len; i++) {\\n                    if (createDebug.names[i].test(name)) {\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            function toNamespace(regexp) {\\n                return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\\\.\\\\*\\\\?$/, "*");\\n            }\\n            function coerce(val) {\\n                if (val instanceof Error) {\\n                    return val.stack || val.message;\\n                }\\n                return val;\\n            }\\n            function destroy() {\\n                console.warn("Instance method \`debug.destroy()\` is deprecated and no longer does anything. It will be removed in the next major version of \`debug\`.");\\n            }\\n            createDebug.enable(createDebug.load());\\n            return createDebug;\\n        }\\n        module.exports = setup;\\n    },\\n    824: module => {\\n        var s = 1e3;\\n        var m = s * 60;\\n        var h = m * 60;\\n        var d = h * 24;\\n        var w = d * 7;\\n        var y = d * 365.25;\\n        module.exports = function(val, options) {\\n            options = options || {};\\n            var type = typeof val;\\n            if (type === "string" && val.length > 0) {\\n                return parse(val);\\n            } else if (type === "number" && isFinite(val)) {\\n                return options.long ? fmtLong(val) : fmtShort(val);\\n            }\\n            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));\\n        };\\n        function parse(str) {\\n            str = String(str);\\n            if (str.length > 100) {\\n                return;\\n            }\\n            var match = /^(-?(?:\\\\d+)?\\\\.?\\\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\\n            if (!match) {\\n                return;\\n            }\\n            var n = parseFloat(match[1]);\\n            var type = (match[2] || "ms").toLowerCase();\\n            switch (type) {\\n              case "years":\\n              case "year":\\n              case "yrs":\\n              case "yr":\\n              case "y":\\n                return n * y;\\n\\n              case "weeks":\\n              case "week":\\n              case "w":\\n                return n * w;\\n\\n              case "days":\\n              case "day":\\n              case "d":\\n                return n * d;\\n\\n              case "hours":\\n              case "hour":\\n              case "hrs":\\n              case "hr":\\n              case "h":\\n                return n * h;\\n\\n              case "minutes":\\n              case "minute":\\n              case "mins":\\n              case "min":\\n              case "m":\\n                return n * m;\\n\\n              case "seconds":\\n              case "second":\\n              case "secs":\\n              case "sec":\\n              case "s":\\n                return n * s;\\n\\n              case "milliseconds":\\n              case "millisecond":\\n              case "msecs":\\n              case "msec":\\n              case "ms":\\n                return n;\\n\\n              default:\\n                return undefined;\\n            }\\n        }\\n        function fmtShort(ms) {\\n            var msAbs = Math.abs(ms);\\n            if (msAbs >= d) {\\n                return Math.round(ms / d) + "d";\\n            }\\n            if (msAbs >= h) {\\n                return Math.round(ms / h) + "h";\\n            }\\n            if (msAbs >= m) {\\n                return Math.round(ms / m) + "m";\\n            }\\n            if (msAbs >= s) {\\n                return Math.round(ms / s) + "s";\\n            }\\n            return ms + "ms";\\n        }\\n        function fmtLong(ms) {\\n            var msAbs = Math.abs(ms);\\n            if (msAbs >= d) {\\n                return plural(ms, msAbs, d, "day");\\n            }\\n            if (msAbs >= h) {\\n                return plural(ms, msAbs, h, "hour");\\n            }\\n            if (msAbs >= m) {\\n                return plural(ms, msAbs, m, "minute");\\n            }\\n            if (msAbs >= s) {\\n                return plural(ms, msAbs, s, "second");\\n            }\\n            return ms + " ms";\\n        }\\n        function plural(ms, msAbs, n, name) {\\n            var isPlural = msAbs >= n * 1.5;\\n            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");\\n        }\\n    }\\n};\\n\\nvar __webpack_module_cache__ = {};\\n\\nfunction __webpack_require__(moduleId) {\\n    var cachedModule = __webpack_module_cache__[moduleId];\\n    if (cachedModule !== undefined) {\\n        return cachedModule.exports;\\n    }\\n    var module = __webpack_module_cache__[moduleId] = {\\n        exports: {}\\n    };\\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\\n    return module.exports;\\n}\\n\\n(() => {\\n    __webpack_require__.n = module => {\\n        var getter = module && module.__esModule ? () => module["default"] : () => module;\\n        __webpack_require__.d(getter, {\\n            a: getter\\n        });\\n        return getter;\\n    };\\n})();\\n\\n(() => {\\n    __webpack_require__.d = (exports, definition) => {\\n        for (var key in definition) {\\n            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\\n                Object.defineProperty(exports, key, {\\n                    enumerable: true,\\n                    get: definition[key]\\n                });\\n            }\\n        }\\n    };\\n})();\\n\\n(() => {\\n    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\\n})();\\n\\nvar __webpack_exports__ = {};\\n\\n(() => {\\n    const proxyMarker = Symbol("Comlink.proxy");\\n    const createEndpoint = Symbol("Comlink.endpoint");\\n    const releaseProxy = Symbol("Comlink.releaseProxy");\\n    const finalizer = Symbol("Comlink.finalizer");\\n    const throwMarker = Symbol("Comlink.thrown");\\n    const isObject = val => typeof val === "object" && val !== null || typeof val === "function";\\n    const proxyTransferHandler = {\\n        canHandle: val => isObject(val) && val[proxyMarker],\\n        serialize(obj) {\\n            const {port1, port2} = new MessageChannel;\\n            expose(obj, port1);\\n            return [ port2, [ port2 ] ];\\n        },\\n        deserialize(port) {\\n            port.start();\\n            return comlink_wrap(port);\\n        }\\n    };\\n    const throwTransferHandler = {\\n        canHandle: value => isObject(value) && throwMarker in value,\\n        serialize({value}) {\\n            let serialized;\\n            if (value instanceof Error) {\\n                serialized = {\\n                    isError: true,\\n                    value: {\\n                        message: value.message,\\n                        name: value.name,\\n                        stack: value.stack\\n                    }\\n                };\\n            } else {\\n                serialized = {\\n                    isError: false,\\n                    value\\n                };\\n            }\\n            return [ serialized, [] ];\\n        },\\n        deserialize(serialized) {\\n            if (serialized.isError) {\\n                throw Object.assign(new Error(serialized.value.message), serialized.value);\\n            }\\n            throw serialized.value;\\n        }\\n    };\\n    const transferHandlers = new Map([ [ "proxy", proxyTransferHandler ], [ "throw", throwTransferHandler ] ]);\\n    function isAllowedOrigin(allowedOrigins, origin) {\\n        for (const allowedOrigin of allowedOrigins) {\\n            if (origin === allowedOrigin || allowedOrigin === "*") {\\n                return true;\\n            }\\n            if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    function expose(obj, ep = globalThis, allowedOrigins = [ "*" ]) {\\n        ep.addEventListener("message", (function callback(ev) {\\n            if (!ev || !ev.data) {\\n                return;\\n            }\\n            if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\\n                console.warn(\`Invalid origin \\'\${ev.origin}\\' for comlink proxy\`);\\n                return;\\n            }\\n            const {id, type, path} = Object.assign({\\n                path: []\\n            }, ev.data);\\n            const argumentList = (ev.data.argumentList || []).map(fromWireValue);\\n            let returnValue;\\n            try {\\n                const parent = path.slice(0, -1).reduce(((obj, prop) => obj[prop]), obj);\\n                const rawValue = path.reduce(((obj, prop) => obj[prop]), obj);\\n                switch (type) {\\n                  case "GET":\\n                    {\\n                        returnValue = rawValue;\\n                    }\\n                    break;\\n\\n                  case "SET":\\n                    {\\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\\n                        returnValue = true;\\n                    }\\n                    break;\\n\\n                  case "APPLY":\\n                    {\\n                        returnValue = rawValue.apply(parent, argumentList);\\n                    }\\n                    break;\\n\\n                  case "CONSTRUCT":\\n                    {\\n                        const value = new rawValue(...argumentList);\\n                        returnValue = proxy(value);\\n                    }\\n                    break;\\n\\n                  case "ENDPOINT":\\n                    {\\n                        const {port1, port2} = new MessageChannel;\\n                        expose(obj, port2);\\n                        returnValue = transfer(port1, [ port1 ]);\\n                    }\\n                    break;\\n\\n                  case "RELEASE":\\n                    {\\n                        returnValue = undefined;\\n                    }\\n                    break;\\n\\n                  default:\\n                    return;\\n                }\\n            } catch (value) {\\n                returnValue = {\\n                    value,\\n                    [throwMarker]: 0\\n                };\\n            }\\n            Promise.resolve(returnValue).catch((value => ({\\n                value,\\n                [throwMarker]: 0\\n            }))).then((returnValue => {\\n                const [wireValue, transferables] = toWireValue(returnValue);\\n                ep.postMessage(Object.assign(Object.assign({}, wireValue), {\\n                    id\\n                }), transferables);\\n                if (type === "RELEASE") {\\n                    ep.removeEventListener("message", callback);\\n                    closeEndPoint(ep);\\n                    if (finalizer in obj && typeof obj[finalizer] === "function") {\\n                        obj[finalizer]();\\n                    }\\n                }\\n            })).catch((error => {\\n                const [wireValue, transferables] = toWireValue({\\n                    value: new TypeError("Unserializable return value"),\\n                    [throwMarker]: 0\\n                });\\n                ep.postMessage(Object.assign(Object.assign({}, wireValue), {\\n                    id\\n                }), transferables);\\n            }));\\n        }));\\n        if (ep.start) {\\n            ep.start();\\n        }\\n    }\\n    function isMessagePort(endpoint) {\\n        return endpoint.constructor.name === "MessagePort";\\n    }\\n    function closeEndPoint(endpoint) {\\n        if (isMessagePort(endpoint)) endpoint.close();\\n    }\\n    function comlink_wrap(ep, target) {\\n        return createProxy(ep, [], target);\\n    }\\n    function throwIfProxyReleased(isReleased) {\\n        if (isReleased) {\\n            throw new Error("Proxy has been released and is not useable");\\n        }\\n    }\\n    function releaseEndpoint(ep) {\\n        return requestResponseMessage(ep, {\\n            type: "RELEASE"\\n        }).then((() => {\\n            closeEndPoint(ep);\\n        }));\\n    }\\n    const proxyCounter = new WeakMap;\\n    const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep => {\\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\\n        proxyCounter.set(ep, newCount);\\n        if (newCount === 0) {\\n            releaseEndpoint(ep);\\n        }\\n    }));\\n    function registerProxy(proxy, ep) {\\n        const newCount = (proxyCounter.get(ep) || 0) + 1;\\n        proxyCounter.set(ep, newCount);\\n        if (proxyFinalizers) {\\n            proxyFinalizers.register(proxy, ep, proxy);\\n        }\\n    }\\n    function unregisterProxy(proxy) {\\n        if (proxyFinalizers) {\\n            proxyFinalizers.unregister(proxy);\\n        }\\n    }\\n    function createProxy(ep, path = [], target = function() {}) {\\n        let isProxyReleased = false;\\n        const proxy = new Proxy(target, {\\n            get(_target, prop) {\\n                throwIfProxyReleased(isProxyReleased);\\n                if (prop === releaseProxy) {\\n                    return () => {\\n                        unregisterProxy(proxy);\\n                        releaseEndpoint(ep);\\n                        isProxyReleased = true;\\n                    };\\n                }\\n                if (prop === "then") {\\n                    if (path.length === 0) {\\n                        return {\\n                            then: () => proxy\\n                        };\\n                    }\\n                    const r = requestResponseMessage(ep, {\\n                        type: "GET",\\n                        path: path.map((p => p.toString()))\\n                    }).then(fromWireValue);\\n                    return r.then.bind(r);\\n                }\\n                return createProxy(ep, [ ...path, prop ]);\\n            },\\n            set(_target, prop, rawValue) {\\n                throwIfProxyReleased(isProxyReleased);\\n                const [value, transferables] = toWireValue(rawValue);\\n                return requestResponseMessage(ep, {\\n                    type: "SET",\\n                    path: [ ...path, prop ].map((p => p.toString())),\\n                    value\\n                }, transferables).then(fromWireValue);\\n            },\\n            apply(_target, _thisArg, rawArgumentList) {\\n                throwIfProxyReleased(isProxyReleased);\\n                const last = path[path.length - 1];\\n                if (last === createEndpoint) {\\n                    return requestResponseMessage(ep, {\\n                        type: "ENDPOINT"\\n                    }).then(fromWireValue);\\n                }\\n                if (last === "bind") {\\n                    return createProxy(ep, path.slice(0, -1));\\n                }\\n                const [argumentList, transferables] = processArguments(rawArgumentList);\\n                return requestResponseMessage(ep, {\\n                    type: "APPLY",\\n                    path: path.map((p => p.toString())),\\n                    argumentList\\n                }, transferables).then(fromWireValue);\\n            },\\n            construct(_target, rawArgumentList) {\\n                throwIfProxyReleased(isProxyReleased);\\n                const [argumentList, transferables] = processArguments(rawArgumentList);\\n                return requestResponseMessage(ep, {\\n                    type: "CONSTRUCT",\\n                    path: path.map((p => p.toString())),\\n                    argumentList\\n                }, transferables).then(fromWireValue);\\n            }\\n        });\\n        registerProxy(proxy, ep);\\n        return proxy;\\n    }\\n    function myFlat(arr) {\\n        return Array.prototype.concat.apply([], arr);\\n    }\\n    function processArguments(argumentList) {\\n        const processed = argumentList.map(toWireValue);\\n        return [ processed.map((v => v[0])), myFlat(processed.map((v => v[1]))) ];\\n    }\\n    const transferCache = new WeakMap;\\n    function transfer(obj, transfers) {\\n        transferCache.set(obj, transfers);\\n        return obj;\\n    }\\n    function proxy(obj) {\\n        return Object.assign(obj, {\\n            [proxyMarker]: true\\n        });\\n    }\\n    function windowEndpoint(w, context = globalThis, targetOrigin = "*") {\\n        return {\\n            postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\\n            addEventListener: context.addEventListener.bind(context),\\n            removeEventListener: context.removeEventListener.bind(context)\\n        };\\n    }\\n    function toWireValue(value) {\\n        for (const [name, handler] of transferHandlers) {\\n            if (handler.canHandle(value)) {\\n                const [serializedValue, transferables] = handler.serialize(value);\\n                return [ {\\n                    type: "HANDLER",\\n                    name,\\n                    value: serializedValue\\n                }, transferables ];\\n            }\\n        }\\n        return [ {\\n            type: "RAW",\\n            value\\n        }, transferCache.get(value) || [] ];\\n    }\\n    function fromWireValue(value) {\\n        switch (value.type) {\\n          case "HANDLER":\\n            return transferHandlers.get(value.name).deserialize(value.value);\\n\\n          case "RAW":\\n            return value.value;\\n        }\\n    }\\n    function requestResponseMessage(ep, msg, transfers) {\\n        return new Promise((resolve => {\\n            const id = generateUUID();\\n            ep.addEventListener("message", (function l(ev) {\\n                if (!ev.data || !ev.data.id || ev.data.id !== id) {\\n                    return;\\n                }\\n                ep.removeEventListener("message", l);\\n                resolve(ev.data);\\n            }));\\n            if (ep.start) {\\n                ep.start();\\n            }\\n            ep.postMessage(Object.assign({\\n                id\\n            }, msg), transfers);\\n        }));\\n    }\\n    function generateUUID() {\\n        return new Array(4).fill(0).map((() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))).join("-");\\n    }\\n    function getSharedMemoryAvailable() {\\n        const globalScope = typeof window !== "undefined" ? window : globalThis;\\n        return typeof SharedArrayBuffer !== "undefined" && globalScope.crossOriginIsolated;\\n    }\\n    function getRemoteBarretenbergWasm(worker) {\\n        return wrap(worker);\\n    }\\n    function getNumCpu() {\\n        return navigator.hardwareConcurrency;\\n    }\\n    function threadLogger() {\\n        return undefined;\\n    }\\n    function killSelf() {\\n        self.close();\\n    }\\n    var browser = __webpack_require__(227);\\n    var browser_default = __webpack_require__.n(browser);\\n    const randomBytes = len => {\\n        const getWebCrypto = () => {\\n            if (typeof window !== "undefined" && window.crypto) return window.crypto;\\n            if (typeof globalThis !== "undefined" && globalThis.crypto) return globalThis.crypto;\\n            return undefined;\\n        };\\n        const crypto = getWebCrypto();\\n        if (!crypto) {\\n            throw new Error("randomBytes UnsupportedEnvironment");\\n        }\\n        const buf = new Uint8Array(len);\\n        const MAX_BYTES = 65536;\\n        if (len > MAX_BYTES) {\\n            for (let generated = 0; generated < len; generated += MAX_BYTES) {\\n                crypto.getRandomValues(buf.subarray(generated, generated + MAX_BYTES));\\n            }\\n        } else {\\n            crypto.getRandomValues(buf);\\n        }\\n        return buf;\\n    };\\n    class BarretenbergWasmBase {\\n        constructor() {\\n            this.memStore = {};\\n            this.logger = browser_default()("bb.js:bb_wasm_base");\\n        }\\n        getImportObj(memory) {\\n            const importObj = {\\n                wasi_snapshot_preview1: {\\n                    random_get: (out, length) => {\\n                        out = out >>> 0;\\n                        const randomData = randomBytes(length);\\n                        const mem = this.getMemory();\\n                        mem.set(randomData, out);\\n                    },\\n                    clock_time_get: (a1, a2, out) => {\\n                        out = out >>> 0;\\n                        const ts = BigInt((new Date).getTime()) * 1000000n;\\n                        const view = new DataView(this.getMemory().buffer);\\n                        view.setBigUint64(out, ts, true);\\n                    },\\n                    proc_exit: () => {\\n                        this.logger("PANIC: proc_exit was called.");\\n                        throw new Error;\\n                    }\\n                },\\n                env: {\\n                    logstr: addr => {\\n                        const str = this.stringFromAddress(addr);\\n                        const m = this.getMemory();\\n                        const str2 = \`\${str} (mem: \${(m.length / (1024 * 1024)).toFixed(2)}MiB)\`;\\n                        this.logger(str2);\\n                    },\\n                    get_data: (keyAddr, outBufAddr) => {\\n                        const key = this.stringFromAddress(keyAddr);\\n                        outBufAddr = outBufAddr >>> 0;\\n                        const data = this.memStore[key];\\n                        if (!data) {\\n                            this.logger(\`get_data miss \${key}\`);\\n                            return;\\n                        }\\n                        this.writeMemory(outBufAddr, data);\\n                    },\\n                    set_data: (keyAddr, dataAddr, dataLength) => {\\n                        const key = this.stringFromAddress(keyAddr);\\n                        dataAddr = dataAddr >>> 0;\\n                        this.memStore[key] = this.getMemorySlice(dataAddr, dataAddr + dataLength);\\n                    },\\n                    memory\\n                }\\n            };\\n            return importObj;\\n        }\\n        exports() {\\n            return this.instance.exports;\\n        }\\n        call(name, ...args) {\\n            if (!this.exports()[name]) {\\n                throw new Error(\`WASM function \${name} not found.\`);\\n            }\\n            try {\\n                return this.exports()[name](...args) >>> 0;\\n            } catch (err) {\\n                const message = \`WASM function \${name} aborted, error: \${err}\`;\\n                this.logger(message);\\n                this.logger(err.stack);\\n                throw err;\\n            }\\n        }\\n        memSize() {\\n            return this.getMemory().length;\\n        }\\n        getMemorySlice(start, end) {\\n            return this.getMemory().subarray(start, end).slice();\\n        }\\n        writeMemory(offset, arr) {\\n            const mem = this.getMemory();\\n            mem.set(arr, offset);\\n        }\\n        getMemory() {\\n            return new Uint8Array(this.memory.buffer);\\n        }\\n        stringFromAddress(addr) {\\n            addr = addr >>> 0;\\n            const m = this.getMemory();\\n            let i = addr;\\n            for (;m[i] !== 0; ++i) ;\\n            const textDecoder = new TextDecoder("ascii");\\n            return textDecoder.decode(m.slice(addr, i));\\n        }\\n    }\\n    class BarretenbergWasmThread extends BarretenbergWasmBase {\\n        async initThread(module, memory) {\\n            this.logger = threadLogger() || this.logger;\\n            this.memory = memory;\\n            this.instance = await WebAssembly.instantiate(module, this.getImportObj(this.memory));\\n        }\\n        destroy() {\\n            killSelf();\\n        }\\n        getImportObj(memory) {\\n            const baseImports = super.getImportObj(memory);\\n            return {\\n                ...baseImports,\\n                wasi: {\\n                    "thread-spawn": () => {\\n                        this.logger("PANIC: threads cannot spawn threads!");\\n                        this.logger((new Error).stack);\\n                        killSelf();\\n                    }\\n                },\\n                env: {\\n                    ...baseImports.env,\\n                    env_hardware_concurrency: () => 1\\n                }\\n            };\\n        }\\n    }\\n    self.onmessage = function(e) {\\n        if (e.data.debug) {\\n            browser_default().enable(e.data.debug);\\n        }\\n    };\\n    expose(new BarretenbergWasmThread);\\n    self.postMessage({\\n        ready: true\\n    });\\n    const thread_worker = null;\\n})();', "Worker", undefined, undefined);
    }
    function createThreadWorker() {
        const worker = new Worker_fn;
        const debugStr = browser_default().disable();
        browser_default().enable(debugStr);
        worker.postMessage({
            debug: debugStr
        });
        return worker;
    }
    const randomBytes = len => {
        const getWebCrypto = () => {
            if (typeof window !== "undefined" && window.crypto) return window.crypto;
            if (typeof globalThis !== "undefined" && globalThis.crypto) return globalThis.crypto;
            return undefined;
        };
        const crypto = getWebCrypto();
        if (!crypto) {
            throw new Error("randomBytes UnsupportedEnvironment");
        }
        const buf = new Uint8Array(len);
        const MAX_BYTES = 65536;
        if (len > MAX_BYTES) {
            for (let generated = 0; generated < len; generated += MAX_BYTES) {
                crypto.getRandomValues(buf.subarray(generated, generated + MAX_BYTES));
            }
        } else {
            crypto.getRandomValues(buf);
        }
        return buf;
    };
    class BarretenbergWasmBase {
        constructor() {
            this.memStore = {};
            this.logger = browser_default()("bb.js:bb_wasm_base");
        }
        getImportObj(memory) {
            const importObj = {
                wasi_snapshot_preview1: {
                    random_get: (out, length) => {
                        out = out >>> 0;
                        const randomData = randomBytes(length);
                        const mem = this.getMemory();
                        mem.set(randomData, out);
                    },
                    clock_time_get: (a1, a2, out) => {
                        out = out >>> 0;
                        const ts = BigInt((new Date).getTime()) * 1000000n;
                        const view = new DataView(this.getMemory().buffer);
                        view.setBigUint64(out, ts, true);
                    },
                    proc_exit: () => {
                        this.logger("PANIC: proc_exit was called.");
                        throw new Error;
                    }
                },
                env: {
                    logstr: addr => {
                        const str = this.stringFromAddress(addr);
                        const m = this.getMemory();
                        const str2 = \`\${str} (mem: \${(m.length / (1024 * 1024)).toFixed(2)}MiB)\`;
                        this.logger(str2);
                    },
                    get_data: (keyAddr, outBufAddr) => {
                        const key = this.stringFromAddress(keyAddr);
                        outBufAddr = outBufAddr >>> 0;
                        const data = this.memStore[key];
                        if (!data) {
                            this.logger(\`get_data miss \${key}\`);
                            return;
                        }
                        this.writeMemory(outBufAddr, data);
                    },
                    set_data: (keyAddr, dataAddr, dataLength) => {
                        const key = this.stringFromAddress(keyAddr);
                        dataAddr = dataAddr >>> 0;
                        this.memStore[key] = this.getMemorySlice(dataAddr, dataAddr + dataLength);
                    },
                    memory
                }
            };
            return importObj;
        }
        exports() {
            return this.instance.exports;
        }
        call(name, ...args) {
            if (!this.exports()[name]) {
                throw new Error(\`WASM function \${name} not found.\`);
            }
            try {
                return this.exports()[name](...args) >>> 0;
            } catch (err) {
                const message = \`WASM function \${name} aborted, error: \${err}\`;
                this.logger(message);
                this.logger(err.stack);
                throw err;
            }
        }
        memSize() {
            return this.getMemory().length;
        }
        getMemorySlice(start, end) {
            return this.getMemory().subarray(start, end).slice();
        }
        writeMemory(offset, arr) {
            const mem = this.getMemory();
            mem.set(arr, offset);
        }
        getMemory() {
            return new Uint8Array(this.memory.buffer);
        }
        stringFromAddress(addr) {
            addr = addr >>> 0;
            const m = this.getMemory();
            let i = addr;
            for (;m[i] !== 0; ++i) ;
            const textDecoder = new TextDecoder("ascii");
            return textDecoder.decode(m.slice(addr, i));
        }
    }
    class HeapAllocator {
        constructor(wasm) {
            this.wasm = wasm;
            this.allocs = [];
            this.inScratchRemaining = 1024;
            this.outScratchRemaining = 1024;
        }
        getInputs(buffers) {
            return buffers.map((bufOrNum => {
                if (typeof bufOrNum === "object") {
                    if (bufOrNum.length <= this.inScratchRemaining) {
                        const ptr = this.inScratchRemaining -= bufOrNum.length;
                        this.wasm.writeMemory(ptr, bufOrNum);
                        return ptr;
                    } else {
                        const ptr = this.wasm.call("bbmalloc", bufOrNum.length);
                        this.wasm.writeMemory(ptr, bufOrNum);
                        this.allocs.push(ptr);
                        return ptr;
                    }
                } else {
                    return bufOrNum;
                }
            }));
        }
        getOutputPtrs(outLens) {
            return outLens.map((len => {
                const size = len || 4;
                if (size <= this.outScratchRemaining) {
                    return this.outScratchRemaining -= size;
                } else {
                    const ptr = this.wasm.call("bbmalloc", size);
                    this.allocs.push(ptr);
                    return ptr;
                }
            }));
        }
        addOutputPtr(ptr) {
            if (ptr >= 1024) {
                this.allocs.push(ptr);
            }
        }
        freeAll() {
            for (const ptr of this.allocs) {
                this.wasm.call("bbfree", ptr);
            }
        }
    }
    class BarretenbergWasmMain extends BarretenbergWasmBase {
        constructor() {
            super(...arguments);
            this.workers = [];
            this.remoteWasms = [];
            this.nextWorker = 0;
            this.nextThreadId = 1;
        }
        getNumThreads() {
            return this.workers.length + 1;
        }
        async init(module, threads = Math.min(getNumCpu(), BarretenbergWasmMain.MAX_THREADS), logger = browser_default()("bb.js:bb_wasm"), initial = 32, maximum = 2 ** 16) {
            this.logger = logger;
            const initialMb = initial * 2 ** 16 / (1024 * 1024);
            const maxMb = maximum * 2 ** 16 / (1024 * 1024);
            const shared = getSharedMemoryAvailable();
            this.logger(\`Initializing bb wasm: initial memory \${initial} pages \${initialMb}MiB; \` + \`max memory: \${maximum} pages, \${maxMb}MiB; \` + \`threads: \${threads}; shared memory: \${shared}\`);
            this.memory = new WebAssembly.Memory({
                initial,
                maximum,
                shared
            });
            const instance = await WebAssembly.instantiate(module, this.getImportObj(this.memory));
            this.instance = instance;
            this.call("_initialize");
            if (threads > 1) {
                this.logger(\`Creating \${threads} worker threads\`);
                this.workers = await Promise.all(Array.from({
                    length: threads - 1
                }).map(createThreadWorker));
                this.remoteWasms = await Promise.all(this.workers.map(getRemoteBarretenbergWasm));
                await Promise.all(this.remoteWasms.map((w => w.initThread(module, this.memory))));
            }
        }
        async destroy() {
            await Promise.all(this.workers.map((w => w.terminate())));
        }
        getImportObj(memory) {
            const baseImports = super.getImportObj(memory);
            return {
                ...baseImports,
                wasi: {
                    "thread-spawn": arg => {
                        arg = arg >>> 0;
                        const id = this.nextThreadId++;
                        const worker = this.nextWorker++ % this.remoteWasms.length;
                        this.remoteWasms[worker].call("wasi_thread_start", id, arg).catch(this.logger);
                        return id;
                    }
                },
                env: {
                    ...baseImports.env,
                    env_hardware_concurrency: () => this.remoteWasms.length + 1
                }
            };
        }
        callWasmExport(funcName, inArgs, outLens) {
            const alloc = new HeapAllocator(this);
            const inPtrs = alloc.getInputs(inArgs);
            const outPtrs = alloc.getOutputPtrs(outLens);
            this.call(funcName, ...inPtrs, ...outPtrs);
            const outArgs = this.getOutputArgs(outLens, outPtrs, alloc);
            alloc.freeAll();
            return outArgs;
        }
        getOutputArgs(outLens, outPtrs, alloc) {
            return outLens.map(((len, i) => {
                if (len) {
                    return this.getMemorySlice(outPtrs[i], outPtrs[i] + len);
                }
                const slice = this.getMemorySlice(outPtrs[i], outPtrs[i] + 4);
                const ptr = new DataView(slice.buffer, slice.byteOffset, slice.byteLength).getUint32(0, true);
                alloc.addOutputPtr(ptr);
                const lslice = this.getMemorySlice(ptr, ptr + 4);
                const length = new DataView(lslice.buffer, lslice.byteOffset, lslice.byteLength).getUint32(0, false);
                return this.getMemorySlice(ptr + 4, ptr + 4 + length);
            }));
        }
    }
    BarretenbergWasmMain.MAX_THREADS = 32;
    self.onmessage = function(e) {
        if (e.data.debug) {
            browser_default().enable(e.data.debug);
        }
    };
    expose(new BarretenbergWasmMain);
    self.postMessage({
        ready: true
    });
    const main_worker = null;
})();`,"Worker",void 0,void 0)}function Je(){const y=new Me,k=Va().disable();return Va().enable(k),y.postMessage({debug:k}),y}function mt(){const y=typeof window<"u"?window:globalThis;return typeof SharedArrayBuffer<"u"&&y.crossOriginIsolated}function Ze(y){return te(y)}function cn(){return navigator.hardwareConcurrency}function Gt(){return mo()(`/*! For license information please see thread.worker.worker.js.LICENSE.txt */
var __webpack_modules__ = {
    227: (module, exports, __webpack_require__) => {
        exports.formatArgs = formatArgs;
        exports.save = save;
        exports.load = load;
        exports.useColors = useColors;
        exports.storage = localstorage();
        exports.destroy = (() => {
            let warned = false;
            return () => {
                if (!warned) {
                    warned = true;
                    console.warn("Instance method \`debug.destroy()\` is deprecated and no longer does anything. It will be removed in the next major version of \`debug\`.");
                }
            };
        })();
        exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ];
        function useColors() {
            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
                return true;
            }
            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {
                return false;
            }
            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);
        }
        function formatArgs(args) {
            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
            if (!this.useColors) {
                return;
            }
            const c = "color: " + this.color;
            args.splice(1, 0, c, "color: inherit");
            let index = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match => {
                if (match === "%%") {
                    return;
                }
                index++;
                if (match === "%c") {
                    lastC = index;
                }
            }));
            args.splice(lastC, 0, c);
        }
        exports.log = console.debug || console.log || (() => {});
        function save(namespaces) {
            try {
                if (namespaces) {
                    exports.storage.setItem("debug", namespaces);
                } else {
                    exports.storage.removeItem("debug");
                }
            } catch (error) {}
        }
        function load() {
            let r;
            try {
                r = exports.storage.getItem("debug");
            } catch (error) {}
            if (!r && typeof process !== "undefined" && "env" in process) {
                r = process.env.DEBUG;
            }
            return r;
        }
        function localstorage() {
            try {
                return localStorage;
            } catch (error) {}
        }
        module.exports = __webpack_require__(447)(exports);
        const {formatters} = module.exports;
        formatters.j = function(v) {
            try {
                return JSON.stringify(v);
            } catch (error) {
                return "[UnexpectedJSONParseError]: " + error.message;
            }
        };
    },
    447: (module, __unused_webpack_exports, __webpack_require__) => {
        function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = __webpack_require__(824);
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key => {
                createDebug[key] = env[key];
            }));
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
                let hash = 0;
                for (let i = 0; i < namespace.length; i++) {
                    hash = (hash << 5) - hash + namespace.charCodeAt(i);
                    hash |= 0;
                }
                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
                let prevTime;
                let enableOverride = null;
                let namespacesCache;
                let enabledCache;
                function debug(...args) {
                    if (!debug.enabled) {
                        return;
                    }
                    const self = debug;
                    const curr = Number(new Date);
                    const ms = curr - (prevTime || curr);
                    self.diff = ms;
                    self.prev = prevTime;
                    self.curr = curr;
                    prevTime = curr;
                    args[0] = createDebug.coerce(args[0]);
                    if (typeof args[0] !== "string") {
                        args.unshift("%O");
                    }
                    let index = 0;
                    args[0] = args[0].replace(/%([a-zA-Z%])/g, ((match, format) => {
                        if (match === "%%") {
                            return "%";
                        }
                        index++;
                        const formatter = createDebug.formatters[format];
                        if (typeof formatter === "function") {
                            const val = args[index];
                            match = formatter.call(self, val);
                            args.splice(index, 1);
                            index--;
                        }
                        return match;
                    }));
                    createDebug.formatArgs.call(self, args);
                    const logFn = self.log || createDebug.log;
                    logFn.apply(self, args);
                }
                debug.namespace = namespace;
                debug.useColors = createDebug.useColors();
                debug.color = createDebug.selectColor(namespace);
                debug.extend = extend;
                debug.destroy = createDebug.destroy;
                Object.defineProperty(debug, "enabled", {
                    enumerable: true,
                    configurable: false,
                    get: () => {
                        if (enableOverride !== null) {
                            return enableOverride;
                        }
                        if (namespacesCache !== createDebug.namespaces) {
                            namespacesCache = createDebug.namespaces;
                            enabledCache = createDebug.enabled(namespace);
                        }
                        return enabledCache;
                    },
                    set: v => {
                        enableOverride = v;
                    }
                });
                if (typeof createDebug.init === "function") {
                    createDebug.init(debug);
                }
                return debug;
            }
            function extend(namespace, delimiter) {
                const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
                newDebug.log = this.log;
                return newDebug;
            }
            function enable(namespaces) {
                createDebug.save(namespaces);
                createDebug.namespaces = namespaces;
                createDebug.names = [];
                createDebug.skips = [];
                let i;
                const split = (typeof namespaces === "string" ? namespaces : "").split(/[\\s,]+/);
                const len = split.length;
                for (i = 0; i < len; i++) {
                    if (!split[i]) {
                        continue;
                    }
                    namespaces = split[i].replace(/\\*/g, ".*?");
                    if (namespaces[0] === "-") {
                        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
                    } else {
                        createDebug.names.push(new RegExp("^" + namespaces + "$"));
                    }
                }
            }
            function disable() {
                const namespaces = [ ...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace => "-" + namespace)) ].join(",");
                createDebug.enable("");
                return namespaces;
            }
            function enabled(name) {
                if (name[name.length - 1] === "*") {
                    return true;
                }
                let i;
                let len;
                for (i = 0, len = createDebug.skips.length; i < len; i++) {
                    if (createDebug.skips[i].test(name)) {
                        return false;
                    }
                }
                for (i = 0, len = createDebug.names.length; i < len; i++) {
                    if (createDebug.names[i].test(name)) {
                        return true;
                    }
                }
                return false;
            }
            function toNamespace(regexp) {
                return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, "*");
            }
            function coerce(val) {
                if (val instanceof Error) {
                    return val.stack || val.message;
                }
                return val;
            }
            function destroy() {
                console.warn("Instance method \`debug.destroy()\` is deprecated and no longer does anything. It will be removed in the next major version of \`debug\`.");
            }
            createDebug.enable(createDebug.load());
            return createDebug;
        }
        module.exports = setup;
    },
    824: module => {
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if (type === "string" && val.length > 0) {
                return parse(val);
            } else if (type === "number" && isFinite(val)) {
                return options.long ? fmtLong(val) : fmtShort(val);
            }
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
        function parse(str) {
            str = String(str);
            if (str.length > 100) {
                return;
            }
            var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
            if (!match) {
                return;
            }
            var n = parseFloat(match[1]);
            var type = (match[2] || "ms").toLowerCase();
            switch (type) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return n * y;

              case "weeks":
              case "week":
              case "w":
                return n * w;

              case "days":
              case "day":
              case "d":
                return n * d;

              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return n * h;

              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return n * m;

              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return n * s;

              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return n;

              default:
                return undefined;
            }
        }
        function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
                return Math.round(ms / d) + "d";
            }
            if (msAbs >= h) {
                return Math.round(ms / h) + "h";
            }
            if (msAbs >= m) {
                return Math.round(ms / m) + "m";
            }
            if (msAbs >= s) {
                return Math.round(ms / s) + "s";
            }
            return ms + "ms";
        }
        function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
                return plural(ms, msAbs, d, "day");
            }
            if (msAbs >= h) {
                return plural(ms, msAbs, h, "hour");
            }
            if (msAbs >= m) {
                return plural(ms, msAbs, m, "minute");
            }
            if (msAbs >= s) {
                return plural(ms, msAbs, s, "second");
            }
            return ms + " ms";
        }
        function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= n * 1.5;
            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
    }
};

var __webpack_module_cache__ = {};

function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
        return cachedModule.exports;
    }
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}

(() => {
    __webpack_require__.n = module => {
        var getter = module && module.__esModule ? () => module["default"] : () => module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();

(() => {
    __webpack_require__.d = (exports, definition) => {
        for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                Object.defineProperty(exports, key, {
                    enumerable: true,
                    get: definition[key]
                });
            }
        }
    };
})();

(() => {
    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();

var __webpack_exports__ = {};

(() => {
    const proxyMarker = Symbol("Comlink.proxy");
    const createEndpoint = Symbol("Comlink.endpoint");
    const releaseProxy = Symbol("Comlink.releaseProxy");
    const finalizer = Symbol("Comlink.finalizer");
    const throwMarker = Symbol("Comlink.thrown");
    const isObject = val => typeof val === "object" && val !== null || typeof val === "function";
    const proxyTransferHandler = {
        canHandle: val => isObject(val) && val[proxyMarker],
        serialize(obj) {
            const {port1, port2} = new MessageChannel;
            expose(obj, port1);
            return [ port2, [ port2 ] ];
        },
        deserialize(port) {
            port.start();
            return comlink_wrap(port);
        }
    };
    const throwTransferHandler = {
        canHandle: value => isObject(value) && throwMarker in value,
        serialize({value}) {
            let serialized;
            if (value instanceof Error) {
                serialized = {
                    isError: true,
                    value: {
                        message: value.message,
                        name: value.name,
                        stack: value.stack
                    }
                };
            } else {
                serialized = {
                    isError: false,
                    value
                };
            }
            return [ serialized, [] ];
        },
        deserialize(serialized) {
            if (serialized.isError) {
                throw Object.assign(new Error(serialized.value.message), serialized.value);
            }
            throw serialized.value;
        }
    };
    const transferHandlers = new Map([ [ "proxy", proxyTransferHandler ], [ "throw", throwTransferHandler ] ]);
    function isAllowedOrigin(allowedOrigins, origin) {
        for (const allowedOrigin of allowedOrigins) {
            if (origin === allowedOrigin || allowedOrigin === "*") {
                return true;
            }
            if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
                return true;
            }
        }
        return false;
    }
    function expose(obj, ep = globalThis, allowedOrigins = [ "*" ]) {
        ep.addEventListener("message", (function callback(ev) {
            if (!ev || !ev.data) {
                return;
            }
            if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
                console.warn(\`Invalid origin '\${ev.origin}' for comlink proxy\`);
                return;
            }
            const {id, type, path} = Object.assign({
                path: []
            }, ev.data);
            const argumentList = (ev.data.argumentList || []).map(fromWireValue);
            let returnValue;
            try {
                const parent = path.slice(0, -1).reduce(((obj, prop) => obj[prop]), obj);
                const rawValue = path.reduce(((obj, prop) => obj[prop]), obj);
                switch (type) {
                  case "GET":
                    {
                        returnValue = rawValue;
                    }
                    break;

                  case "SET":
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                        returnValue = true;
                    }
                    break;

                  case "APPLY":
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;

                  case "CONSTRUCT":
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = proxy(value);
                    }
                    break;

                  case "ENDPOINT":
                    {
                        const {port1, port2} = new MessageChannel;
                        expose(obj, port2);
                        returnValue = transfer(port1, [ port1 ]);
                    }
                    break;

                  case "RELEASE":
                    {
                        returnValue = undefined;
                    }
                    break;

                  default:
                    return;
                }
            } catch (value) {
                returnValue = {
                    value,
                    [throwMarker]: 0
                };
            }
            Promise.resolve(returnValue).catch((value => ({
                value,
                [throwMarker]: 0
            }))).then((returnValue => {
                const [wireValue, transferables] = toWireValue(returnValue);
                ep.postMessage(Object.assign(Object.assign({}, wireValue), {
                    id
                }), transferables);
                if (type === "RELEASE") {
                    ep.removeEventListener("message", callback);
                    closeEndPoint(ep);
                    if (finalizer in obj && typeof obj[finalizer] === "function") {
                        obj[finalizer]();
                    }
                }
            })).catch((error => {
                const [wireValue, transferables] = toWireValue({
                    value: new TypeError("Unserializable return value"),
                    [throwMarker]: 0
                });
                ep.postMessage(Object.assign(Object.assign({}, wireValue), {
                    id
                }), transferables);
            }));
        }));
        if (ep.start) {
            ep.start();
        }
    }
    function isMessagePort(endpoint) {
        return endpoint.constructor.name === "MessagePort";
    }
    function closeEndPoint(endpoint) {
        if (isMessagePort(endpoint)) endpoint.close();
    }
    function comlink_wrap(ep, target) {
        return createProxy(ep, [], target);
    }
    function throwIfProxyReleased(isReleased) {
        if (isReleased) {
            throw new Error("Proxy has been released and is not useable");
        }
    }
    function releaseEndpoint(ep) {
        return requestResponseMessage(ep, {
            type: "RELEASE"
        }).then((() => {
            closeEndPoint(ep);
        }));
    }
    const proxyCounter = new WeakMap;
    const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep => {
        const newCount = (proxyCounter.get(ep) || 0) - 1;
        proxyCounter.set(ep, newCount);
        if (newCount === 0) {
            releaseEndpoint(ep);
        }
    }));
    function registerProxy(proxy, ep) {
        const newCount = (proxyCounter.get(ep) || 0) + 1;
        proxyCounter.set(ep, newCount);
        if (proxyFinalizers) {
            proxyFinalizers.register(proxy, ep, proxy);
        }
    }
    function unregisterProxy(proxy) {
        if (proxyFinalizers) {
            proxyFinalizers.unregister(proxy);
        }
    }
    function createProxy(ep, path = [], target = function() {}) {
        let isProxyReleased = false;
        const proxy = new Proxy(target, {
            get(_target, prop) {
                throwIfProxyReleased(isProxyReleased);
                if (prop === releaseProxy) {
                    return () => {
                        unregisterProxy(proxy);
                        releaseEndpoint(ep);
                        isProxyReleased = true;
                    };
                }
                if (prop === "then") {
                    if (path.length === 0) {
                        return {
                            then: () => proxy
                        };
                    }
                    const r = requestResponseMessage(ep, {
                        type: "GET",
                        path: path.map((p => p.toString()))
                    }).then(fromWireValue);
                    return r.then.bind(r);
                }
                return createProxy(ep, [ ...path, prop ]);
            },
            set(_target, prop, rawValue) {
                throwIfProxyReleased(isProxyReleased);
                const [value, transferables] = toWireValue(rawValue);
                return requestResponseMessage(ep, {
                    type: "SET",
                    path: [ ...path, prop ].map((p => p.toString())),
                    value
                }, transferables).then(fromWireValue);
            },
            apply(_target, _thisArg, rawArgumentList) {
                throwIfProxyReleased(isProxyReleased);
                const last = path[path.length - 1];
                if (last === createEndpoint) {
                    return requestResponseMessage(ep, {
                        type: "ENDPOINT"
                    }).then(fromWireValue);
                }
                if (last === "bind") {
                    return createProxy(ep, path.slice(0, -1));
                }
                const [argumentList, transferables] = processArguments(rawArgumentList);
                return requestResponseMessage(ep, {
                    type: "APPLY",
                    path: path.map((p => p.toString())),
                    argumentList
                }, transferables).then(fromWireValue);
            },
            construct(_target, rawArgumentList) {
                throwIfProxyReleased(isProxyReleased);
                const [argumentList, transferables] = processArguments(rawArgumentList);
                return requestResponseMessage(ep, {
                    type: "CONSTRUCT",
                    path: path.map((p => p.toString())),
                    argumentList
                }, transferables).then(fromWireValue);
            }
        });
        registerProxy(proxy, ep);
        return proxy;
    }
    function myFlat(arr) {
        return Array.prototype.concat.apply([], arr);
    }
    function processArguments(argumentList) {
        const processed = argumentList.map(toWireValue);
        return [ processed.map((v => v[0])), myFlat(processed.map((v => v[1]))) ];
    }
    const transferCache = new WeakMap;
    function transfer(obj, transfers) {
        transferCache.set(obj, transfers);
        return obj;
    }
    function proxy(obj) {
        return Object.assign(obj, {
            [proxyMarker]: true
        });
    }
    function windowEndpoint(w, context = globalThis, targetOrigin = "*") {
        return {
            postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
            addEventListener: context.addEventListener.bind(context),
            removeEventListener: context.removeEventListener.bind(context)
        };
    }
    function toWireValue(value) {
        for (const [name, handler] of transferHandlers) {
            if (handler.canHandle(value)) {
                const [serializedValue, transferables] = handler.serialize(value);
                return [ {
                    type: "HANDLER",
                    name,
                    value: serializedValue
                }, transferables ];
            }
        }
        return [ {
            type: "RAW",
            value
        }, transferCache.get(value) || [] ];
    }
    function fromWireValue(value) {
        switch (value.type) {
          case "HANDLER":
            return transferHandlers.get(value.name).deserialize(value.value);

          case "RAW":
            return value.value;
        }
    }
    function requestResponseMessage(ep, msg, transfers) {
        return new Promise((resolve => {
            const id = generateUUID();
            ep.addEventListener("message", (function l(ev) {
                if (!ev.data || !ev.data.id || ev.data.id !== id) {
                    return;
                }
                ep.removeEventListener("message", l);
                resolve(ev.data);
            }));
            if (ep.start) {
                ep.start();
            }
            ep.postMessage(Object.assign({
                id
            }, msg), transfers);
        }));
    }
    function generateUUID() {
        return new Array(4).fill(0).map((() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))).join("-");
    }
    function getSharedMemoryAvailable() {
        const globalScope = typeof window !== "undefined" ? window : globalThis;
        return typeof SharedArrayBuffer !== "undefined" && globalScope.crossOriginIsolated;
    }
    function getRemoteBarretenbergWasm(worker) {
        return wrap(worker);
    }
    function getNumCpu() {
        return navigator.hardwareConcurrency;
    }
    function threadLogger() {
        return undefined;
    }
    function killSelf() {
        self.close();
    }
    var browser = __webpack_require__(227);
    var browser_default = __webpack_require__.n(browser);
    const randomBytes = len => {
        const getWebCrypto = () => {
            if (typeof window !== "undefined" && window.crypto) return window.crypto;
            if (typeof globalThis !== "undefined" && globalThis.crypto) return globalThis.crypto;
            return undefined;
        };
        const crypto = getWebCrypto();
        if (!crypto) {
            throw new Error("randomBytes UnsupportedEnvironment");
        }
        const buf = new Uint8Array(len);
        const MAX_BYTES = 65536;
        if (len > MAX_BYTES) {
            for (let generated = 0; generated < len; generated += MAX_BYTES) {
                crypto.getRandomValues(buf.subarray(generated, generated + MAX_BYTES));
            }
        } else {
            crypto.getRandomValues(buf);
        }
        return buf;
    };
    class BarretenbergWasmBase {
        constructor() {
            this.memStore = {};
            this.logger = browser_default()("bb.js:bb_wasm_base");
        }
        getImportObj(memory) {
            const importObj = {
                wasi_snapshot_preview1: {
                    random_get: (out, length) => {
                        out = out >>> 0;
                        const randomData = randomBytes(length);
                        const mem = this.getMemory();
                        mem.set(randomData, out);
                    },
                    clock_time_get: (a1, a2, out) => {
                        out = out >>> 0;
                        const ts = BigInt((new Date).getTime()) * 1000000n;
                        const view = new DataView(this.getMemory().buffer);
                        view.setBigUint64(out, ts, true);
                    },
                    proc_exit: () => {
                        this.logger("PANIC: proc_exit was called.");
                        throw new Error;
                    }
                },
                env: {
                    logstr: addr => {
                        const str = this.stringFromAddress(addr);
                        const m = this.getMemory();
                        const str2 = \`\${str} (mem: \${(m.length / (1024 * 1024)).toFixed(2)}MiB)\`;
                        this.logger(str2);
                    },
                    get_data: (keyAddr, outBufAddr) => {
                        const key = this.stringFromAddress(keyAddr);
                        outBufAddr = outBufAddr >>> 0;
                        const data = this.memStore[key];
                        if (!data) {
                            this.logger(\`get_data miss \${key}\`);
                            return;
                        }
                        this.writeMemory(outBufAddr, data);
                    },
                    set_data: (keyAddr, dataAddr, dataLength) => {
                        const key = this.stringFromAddress(keyAddr);
                        dataAddr = dataAddr >>> 0;
                        this.memStore[key] = this.getMemorySlice(dataAddr, dataAddr + dataLength);
                    },
                    memory
                }
            };
            return importObj;
        }
        exports() {
            return this.instance.exports;
        }
        call(name, ...args) {
            if (!this.exports()[name]) {
                throw new Error(\`WASM function \${name} not found.\`);
            }
            try {
                return this.exports()[name](...args) >>> 0;
            } catch (err) {
                const message = \`WASM function \${name} aborted, error: \${err}\`;
                this.logger(message);
                this.logger(err.stack);
                throw err;
            }
        }
        memSize() {
            return this.getMemory().length;
        }
        getMemorySlice(start, end) {
            return this.getMemory().subarray(start, end).slice();
        }
        writeMemory(offset, arr) {
            const mem = this.getMemory();
            mem.set(arr, offset);
        }
        getMemory() {
            return new Uint8Array(this.memory.buffer);
        }
        stringFromAddress(addr) {
            addr = addr >>> 0;
            const m = this.getMemory();
            let i = addr;
            for (;m[i] !== 0; ++i) ;
            const textDecoder = new TextDecoder("ascii");
            return textDecoder.decode(m.slice(addr, i));
        }
    }
    class BarretenbergWasmThread extends BarretenbergWasmBase {
        async initThread(module, memory) {
            this.logger = threadLogger() || this.logger;
            this.memory = memory;
            this.instance = await WebAssembly.instantiate(module, this.getImportObj(this.memory));
        }
        destroy() {
            killSelf();
        }
        getImportObj(memory) {
            const baseImports = super.getImportObj(memory);
            return {
                ...baseImports,
                wasi: {
                    "thread-spawn": () => {
                        this.logger("PANIC: threads cannot spawn threads!");
                        this.logger((new Error).stack);
                        killSelf();
                    }
                },
                env: {
                    ...baseImports.env,
                    env_hardware_concurrency: () => 1
                }
            };
        }
    }
    self.onmessage = function(e) {
        if (e.data.debug) {
            browser_default().enable(e.data.debug);
        }
    };
    expose(new BarretenbergWasmThread);
    self.postMessage({
        ready: true
    });
    const thread_worker = null;
})();`,"Worker",void 0,void 0)}function xt(){const y=new Gt,k=Va().disable();return Va().enable(k),y.postMessage({debug:k}),y}class It{constructor(){this.memStore={},this.logger=Va()("bb.js:bb_wasm_base")}getImportObj(k){return{wasi_snapshot_preview1:{random_get:(_,R)=>{_=_>>>0;const M=pa(R);this.getMemory().set(M,_)},clock_time_get:(_,R,M)=>{M=M>>>0;const U=BigInt(new Date().getTime())*1000000n;new DataView(this.getMemory().buffer).setBigUint64(M,U,!0)},proc_exit:()=>{throw this.logger("PANIC: proc_exit was called."),new Error}},env:{logstr:_=>{const R=this.stringFromAddress(_),M=this.getMemory(),U=`${R} (mem: ${(M.length/(1024*1024)).toFixed(2)}MiB)`;this.logger(U)},get_data:(_,R)=>{const M=this.stringFromAddress(_);R=R>>>0;const U=this.memStore[M];if(!U){this.logger(`get_data miss ${M}`);return}this.writeMemory(R,U)},set_data:(_,R,M)=>{const U=this.stringFromAddress(_);R=R>>>0,this.memStore[U]=this.getMemorySlice(R,R+M)},memory:k}}}exports(){return this.instance.exports}call(k,...w){if(!this.exports()[k])throw new Error(`WASM function ${k} not found.`);try{return this.exports()[k](...w)>>>0}catch(_){const R=`WASM function ${k} aborted, error: ${_}`;throw this.logger(R),this.logger(_.stack),_}}memSize(){return this.getMemory().length}getMemorySlice(k,w){return this.getMemory().subarray(k,w).slice()}writeMemory(k,w){this.getMemory().set(w,k)}getMemory(){return new Uint8Array(this.memory.buffer)}stringFromAddress(k){k=k>>>0;const w=this.getMemory();let _=k;for(;w[_]!==0;++_);return new TextDecoder("ascii").decode(w.slice(k,_))}}class Xn{constructor(k){this.wasm=k,this.allocs=[],this.inScratchRemaining=1024,this.outScratchRemaining=1024}getInputs(k){return k.map(w=>{if(typeof w=="object")if(w.length<=this.inScratchRemaining){const _=this.inScratchRemaining-=w.length;return this.wasm.writeMemory(_,w),_}else{const _=this.wasm.call("bbmalloc",w.length);return this.wasm.writeMemory(_,w),this.allocs.push(_),_}else return w})}getOutputPtrs(k){return k.map(w=>{const _=w||4;if(_<=this.outScratchRemaining)return this.outScratchRemaining-=_;{const R=this.wasm.call("bbmalloc",_);return this.allocs.push(R),R}})}addOutputPtr(k){k>=1024&&this.allocs.push(k)}freeAll(){for(const k of this.allocs)this.wasm.call("bbfree",k)}}class Wa extends It{constructor(){super(...arguments),this.workers=[],this.remoteWasms=[],this.nextWorker=0,this.nextThreadId=1}getNumThreads(){return this.workers.length+1}async init(k,w=Math.min(cn(),Wa.MAX_THREADS),_=Va()("bb.js:bb_wasm"),R=32,M=2**16){this.logger=_;const U=R*2**16/(1024*1024),V=M*2**16/(1024*1024),fe=mt();this.logger(`Initializing bb wasm: initial memory ${R} pages ${U}MiB; max memory: ${M} pages, ${V}MiB; threads: ${w}; shared memory: ${fe}`),this.memory=new WebAssembly.Memory({initial:R,maximum:M,shared:fe});const X=await WebAssembly.instantiate(k,this.getImportObj(this.memory));this.instance=X,this.call("_initialize"),w>1&&(this.logger(`Creating ${w} worker threads`),this.workers=await Promise.all(Array.from({length:w-1}).map(xt)),this.remoteWasms=await Promise.all(this.workers.map(Ze)),await Promise.all(this.remoteWasms.map(ye=>ye.initThread(k,this.memory))))}async destroy(){await Promise.all(this.workers.map(k=>k.terminate()))}getImportObj(k){const w=super.getImportObj(k);return{...w,wasi:{"thread-spawn":_=>{_=_>>>0;const R=this.nextThreadId++,M=this.nextWorker++%this.remoteWasms.length;return this.remoteWasms[M].call("wasi_thread_start",R,_).catch(this.logger),R}},env:{...w.env,env_hardware_concurrency:()=>this.remoteWasms.length+1}}}callWasmExport(k,w,_){const R=new Xn(this),M=R.getInputs(w),U=R.getOutputPtrs(_);this.call(k,...M,...U);const V=this.getOutputArgs(_,U,R);return R.freeAll(),V}getOutputArgs(k,w,_){return k.map((R,M)=>{if(R)return this.getMemorySlice(w[M],w[M]+R);const U=this.getMemorySlice(w[M],w[M]+4),V=new DataView(U.buffer,U.byteOffset,U.byteLength).getUint32(0,!0);_.addOutputPtr(V);const fe=this.getMemorySlice(V,V+4),X=new DataView(fe.buffer,fe.byteOffset,fe.byteLength).getUint32(0,!1);return this.getMemorySlice(V+4,V+4+X)})}}Wa.MAX_THREADS=32;const Li=4,go=0,mi=1,bo=2;function On(y){let k=y.length;for(;--k>=0;)y[k]=0}const Sr=0,zi=1,yo=2,ha=3,$h=258,pu=29,Qr=256,pr=Qr+1+pu,wo=30,hu=19,fu=2*pr+1,Ms=15,ds=16,mu=7,Zr=256,gu=16,ps=17,Ui=18,pl=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),xo=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),nb=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),Qc=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),kr=512,Xr=new Array((pr+2)*2);On(Xr);const hl=new Array(wo*2);On(hl);const hs=new Array(kr);On(hs);const Bs=new Array($h-ha+1);On(Bs);const Ls=new Array(pu);On(Ls);const bu=new Array(wo);On(bu);function hr(y,k,w,_,R){this.static_tree=y,this.extra_bits=k,this.extra_base=w,this.elems=_,this.max_length=R,this.has_stree=y&&y.length}let yu,Zc,fl;function ei(y,k){this.dyn_tree=y,this.max_code=0,this.stat_desc=k}const wu=y=>y<256?hs[y]:hs[256+(y>>>7)],zs=(y,k)=>{y.pending_buf[y.pending++]=k&255,y.pending_buf[y.pending++]=k>>>8&255},fa=(y,k,w)=>{y.bi_valid>ds-w?(y.bi_buf|=k<<y.bi_valid&65535,zs(y,y.bi_buf),y.bi_buf=k>>ds-y.bi_valid,y.bi_valid+=w-ds):(y.bi_buf|=k<<y.bi_valid&65535,y.bi_valid+=w)},Mr=(y,k,w)=>{fa(y,w[k*2],w[k*2+1])},xu=(y,k)=>{let w=0;do w|=y&1,y>>>=1,w<<=1;while(--k>0);return w>>>1},Xc=y=>{y.bi_valid===16?(zs(y,y.bi_buf),y.bi_buf=0,y.bi_valid=0):y.bi_valid>=8&&(y.pending_buf[y.pending++]=y.bi_buf&255,y.bi_buf>>=8,y.bi_valid-=8)},ml=(y,k)=>{const w=k.dyn_tree,_=k.max_code,R=k.stat_desc.static_tree,M=k.stat_desc.has_stree,U=k.stat_desc.extra_bits,V=k.stat_desc.extra_base,fe=k.stat_desc.max_length;let X,ye,Qe,He,Pe,ut,Cn=0;for(He=0;He<=Ms;He++)y.bl_count[He]=0;for(w[y.heap[y.heap_max]*2+1]=0,X=y.heap_max+1;X<fu;X++)ye=y.heap[X],He=w[w[ye*2+1]*2+1]+1,He>fe&&(He=fe,Cn++),w[ye*2+1]=He,!(ye>_)&&(y.bl_count[He]++,Pe=0,ye>=V&&(Pe=U[ye-V]),ut=w[ye*2],y.opt_len+=ut*(He+Pe),M&&(y.static_len+=ut*(R[ye*2+1]+Pe)));if(Cn!==0){do{for(He=fe-1;y.bl_count[He]===0;)He--;y.bl_count[He]--,y.bl_count[He+1]+=2,y.bl_count[fe]--,Cn-=2}while(Cn>0);for(He=fe;He!==0;He--)for(ye=y.bl_count[He];ye!==0;)Qe=y.heap[--X],!(Qe>_)&&(w[Qe*2+1]!==He&&(y.opt_len+=(He-w[Qe*2+1])*w[Qe*2],w[Qe*2+1]=He),ye--)}},gl=(y,k,w)=>{const _=new Array(Ms+1);let R=0,M,U;for(M=1;M<=Ms;M++)R=R+w[M-1]<<1,_[M]=R;for(U=0;U<=k;U++){let V=y[U*2+1];V!==0&&(y[U*2]=xu(_[V]++,V))}},vu=()=>{let y,k,w,_,R;const M=new Array(Ms+1);for(w=0,_=0;_<pu-1;_++)for(Ls[_]=w,y=0;y<1<<pl[_];y++)Bs[w++]=_;for(Bs[w-1]=_,R=0,_=0;_<16;_++)for(bu[_]=R,y=0;y<1<<xo[_];y++)hs[R++]=_;for(R>>=7;_<wo;_++)for(bu[_]=R<<7,y=0;y<1<<xo[_]-7;y++)hs[256+R++]=_;for(k=0;k<=Ms;k++)M[k]=0;for(y=0;y<=143;)Xr[y*2+1]=8,y++,M[8]++;for(;y<=255;)Xr[y*2+1]=9,y++,M[9]++;for(;y<=279;)Xr[y*2+1]=7,y++,M[7]++;for(;y<=287;)Xr[y*2+1]=8,y++,M[8]++;for(gl(Xr,pr+1,M),y=0;y<wo;y++)hl[y*2+1]=5,hl[y*2]=xu(y,5);yu=new hr(Xr,pl,Qr+1,pr,Ms),Zc=new hr(hl,xo,0,wo,Ms),fl=new hr(new Array(0),nb,0,hu,mu)},fs=y=>{let k;for(k=0;k<pr;k++)y.dyn_ltree[k*2]=0;for(k=0;k<wo;k++)y.dyn_dtree[k*2]=0;for(k=0;k<hu;k++)y.bl_tree[k*2]=0;y.dyn_ltree[Zr*2]=1,y.opt_len=y.static_len=0,y.sym_next=y.matches=0},bl=y=>{y.bi_valid>8?zs(y,y.bi_buf):y.bi_valid>0&&(y.pending_buf[y.pending++]=y.bi_buf),y.bi_buf=0,y.bi_valid=0},Us=(y,k,w,_)=>{const R=k*2,M=w*2;return y[R]<y[M]||y[R]===y[M]&&_[k]<=_[w]},ti=(y,k,w)=>{const _=y.heap[w];let R=w<<1;for(;R<=y.heap_len&&(R<y.heap_len&&Us(k,y.heap[R+1],y.heap[R],y.depth)&&R++,!Us(k,_,y.heap[R],y.depth));)y.heap[w]=y.heap[R],w=R,R<<=1;y.heap[w]=_},Vs=(y,k,w)=>{let _,R,M=0,U,V;if(y.sym_next!==0)do _=y.pending_buf[y.sym_buf+M++]&255,_+=(y.pending_buf[y.sym_buf+M++]&255)<<8,R=y.pending_buf[y.sym_buf+M++],_===0?Mr(y,R,k):(U=Bs[R],Mr(y,U+Qr+1,k),V=pl[U],V!==0&&(R-=Ls[U],fa(y,R,V)),_--,U=wu(_),Mr(y,U,w),V=xo[U],V!==0&&(_-=bu[U],fa(y,_,V)));while(M<y.sym_next);Mr(y,Zr,k)},re=(y,k)=>{const w=k.dyn_tree,_=k.stat_desc.static_tree,R=k.stat_desc.has_stree,M=k.stat_desc.elems;let U,V,fe=-1,X;for(y.heap_len=0,y.heap_max=fu,U=0;U<M;U++)w[U*2]!==0?(y.heap[++y.heap_len]=fe=U,y.depth[U]=0):w[U*2+1]=0;for(;y.heap_len<2;)X=y.heap[++y.heap_len]=fe<2?++fe:0,w[X*2]=1,y.depth[X]=0,y.opt_len--,R&&(y.static_len-=_[X*2+1]);for(k.max_code=fe,U=y.heap_len>>1;U>=1;U--)ti(y,w,U);X=M;do U=y.heap[1],y.heap[1]=y.heap[y.heap_len--],ti(y,w,1),V=y.heap[1],y.heap[--y.heap_max]=U,y.heap[--y.heap_max]=V,w[X*2]=w[U*2]+w[V*2],y.depth[X]=(y.depth[U]>=y.depth[V]?y.depth[U]:y.depth[V])+1,w[U*2+1]=w[V*2+1]=X,y.heap[1]=X++,ti(y,w,1);while(y.heap_len>=2);y.heap[--y.heap_max]=y.heap[1],ml(y,k),gl(w,fe,y.bl_count)},Ie=(y,k,w)=>{let _,R=-1,M,U=k[0*2+1],V=0,fe=7,X=4;for(U===0&&(fe=138,X=3),k[(w+1)*2+1]=65535,_=0;_<=w;_++)M=U,U=k[(_+1)*2+1],!(++V<fe&&M===U)&&(V<X?y.bl_tree[M*2]+=V:M!==0?(M!==R&&y.bl_tree[M*2]++,y.bl_tree[gu*2]++):V<=10?y.bl_tree[ps*2]++:y.bl_tree[Ui*2]++,V=0,R=M,U===0?(fe=138,X=3):M===U?(fe=6,X=3):(fe=7,X=4))},Ye=(y,k,w)=>{let _,R=-1,M,U=k[0*2+1],V=0,fe=7,X=4;for(U===0&&(fe=138,X=3),_=0;_<=w;_++)if(M=U,U=k[(_+1)*2+1],!(++V<fe&&M===U)){if(V<X)do Mr(y,M,y.bl_tree);while(--V!==0);else M!==0?(M!==R&&(Mr(y,M,y.bl_tree),V--),Mr(y,gu,y.bl_tree),fa(y,V-3,2)):V<=10?(Mr(y,ps,y.bl_tree),fa(y,V-3,3)):(Mr(y,Ui,y.bl_tree),fa(y,V-11,7));V=0,R=M,U===0?(fe=138,X=3):M===U?(fe=6,X=3):(fe=7,X=4)}},bt=y=>{let k;for(Ie(y,y.dyn_ltree,y.l_desc.max_code),Ie(y,y.dyn_dtree,y.d_desc.max_code),re(y,y.bl_desc),k=hu-1;k>=3&&y.bl_tree[Qc[k]*2+1]===0;k--);return y.opt_len+=3*(k+1)+5+5+4,k},At=(y,k,w,_)=>{let R;for(fa(y,k-257,5),fa(y,w-1,5),fa(y,_-4,4),R=0;R<_;R++)fa(y,y.bl_tree[Qc[R]*2+1],3);Ye(y,y.dyn_ltree,k-1),Ye(y,y.dyn_dtree,w-1)},Mt=y=>{let k=4093624447,w;for(w=0;w<=31;w++,k>>>=1)if(k&1&&y.dyn_ltree[w*2]!==0)return go;if(y.dyn_ltree[9*2]!==0||y.dyn_ltree[10*2]!==0||y.dyn_ltree[13*2]!==0)return mi;for(w=32;w<Qr;w++)if(y.dyn_ltree[w*2]!==0)return mi;return go};let et=!1;const st=y=>{et||(vu(),et=!0),y.l_desc=new ei(y.dyn_ltree,yu),y.d_desc=new ei(y.dyn_dtree,Zc),y.bl_desc=new ei(y.bl_tree,fl),y.bi_buf=0,y.bi_valid=0,fs(y)},Rn=(y,k,w,_)=>{fa(y,(Sr<<1)+(_?1:0),3),bl(y),zs(y,w),zs(y,~w),w&&y.pending_buf.set(y.window.subarray(k,k+w),y.pending),y.pending+=w},qa=y=>{fa(y,zi<<1,3),Mr(y,Zr,Xr),Xc(y)},gi=(y,k,w,_)=>{let R,M,U=0;y.level>0?(y.strm.data_type===bo&&(y.strm.data_type=Mt(y)),re(y,y.l_desc),re(y,y.d_desc),U=bt(y),R=y.opt_len+3+7>>>3,M=y.static_len+3+7>>>3,M<=R&&(R=M)):R=M=w+5,w+4<=R&&k!==-1?Rn(y,k,w,_):y.strategy===Li||M===R?(fa(y,(zi<<1)+(_?1:0),3),Vs(y,Xr,hl)):(fa(y,(yo<<1)+(_?1:0),3),At(y,y.l_desc.max_code+1,y.d_desc.max_code+1,U+1),Vs(y,y.dyn_ltree,y.dyn_dtree)),fs(y),_&&bl(y)},yl=(y,k,w)=>(y.pending_buf[y.sym_buf+y.sym_next++]=k,y.pending_buf[y.sym_buf+y.sym_next++]=k>>8,y.pending_buf[y.sym_buf+y.sym_next++]=w,k===0?y.dyn_ltree[w*2]++:(y.matches++,k--,y.dyn_ltree[(Bs[w]+Qr+1)*2]++,y.dyn_dtree[wu(k)*2]++),y.sym_next===y.sym_end);var vo=st,Jh=Rn,Mn=gi,Br=yl,wl=qa,ed={_tr_init:vo,_tr_stored_block:Jh,_tr_flush_block:Mn,_tr_tally:Br,_tr_align:wl},xl=(y,k,w,_)=>{let R=y&65535|0,M=y>>>16&65535|0,U=0;for(;w!==0;){U=w>2e3?2e3:w,w-=U;do R=R+k[_++]|0,M=M+R|0;while(--U);R%=65521,M%=65521}return R|M<<16|0};const ab=()=>{let y,k=[];for(var w=0;w<256;w++){y=w;for(var _=0;_<8;_++)y=y&1?3988292384^y>>>1:y>>>1;k[w]=y}return k},td=new Uint32Array(ab());var Ra=(y,k,w,_)=>{const R=td,M=_+w;y^=-1;for(let U=_;U<M;U++)y=y>>>8^R[(y^k[U])&255];return y^-1},vl={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},nd={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:TS,_tr_stored_block:ad,_tr_flush_block:NS,_tr_tally:So,_tr_align:RS}=ed,{Z_NO_FLUSH:ko,Z_PARTIAL_FLUSH:FS,Z_FULL_FLUSH:fw,Z_FINISH:bi,Z_BLOCK:mw,Z_OK:Qa,Z_STREAM_END:gw,Z_STREAM_ERROR:yi,Z_DATA_ERROR:DS,Z_BUF_ERROR:ib,Z_DEFAULT_COMPRESSION:OS,Z_FILTERED:bw,Z_HUFFMAN_ONLY:Yh,Z_RLE:MS,Z_FIXED:BS,Z_DEFAULT_STRATEGY:LS,Z_UNKNOWN:zS,Z_DEFLATED:jh}=nd,US=9,VS=15,WS=8,sb=256+1+29,ww=30,xw=19,vw=2*sb+1,Sw=15,dn=3,ni=258,ms=ni+dn+1,qS=32,Su=42,Zh=57,Xh=69,Sl=73,kl=91,ob=103,gs=113,ku=666,fr=1,Ao=2,Ws=3,Al=4,kw=3,Eo=(y,k)=>(y.msg=vl[k],k),Aw=y=>y*2-(y>4?9:0),Co=y=>{let k=y.length;for(;--k>=0;)y[k]=0},PS=y=>{let k,w,_,R=y.w_size;k=y.hash_size,_=k;do w=y.head[--_],y.head[_]=w>=R?w-R:0;while(--k);k=R,_=k;do w=y.prev[--_],y.prev[_]=w>=R?w-R:0;while(--k)};let Io=(y,k,w)=>(k<<y.hash_shift^w)&y.hash_mask;const ea=y=>{const k=y.state;let w=k.pending;w>y.avail_out&&(w=y.avail_out),w!==0&&(y.output.set(k.pending_buf.subarray(k.pending_out,k.pending_out+w),y.next_out),y.next_out+=w,k.pending_out+=w,y.total_out+=w,y.avail_out-=w,k.pending-=w,k.pending===0&&(k.pending_out=0))},Za=(y,k)=>{NS(y,y.block_start>=0?y.block_start:-1,y.strstart-y.block_start,k),y.block_start=y.strstart,ea(y.strm)},wn=(y,k)=>{y.pending_buf[y.pending++]=k},Au=(y,k)=>{y.pending_buf[y.pending++]=k>>>8&255,y.pending_buf[y.pending++]=k&255},ef=(y,k,w,_)=>{let R=y.avail_in;return R>_&&(R=_),R===0?0:(y.avail_in-=R,k.set(y.input.subarray(y.next_in,y.next_in+R),w),y.state.wrap===1?y.adler=xl(y.adler,k,R,w):y.state.wrap===2&&(y.adler=Ra(y.adler,k,R,w)),y.next_in+=R,y.total_in+=R,R)},lb=(y,k)=>{let w=y.max_chain_length,_=y.strstart,R,M,U=y.prev_length,V=y.nice_match;const fe=y.strstart>y.w_size-ms?y.strstart-(y.w_size-ms):0,X=y.window,ye=y.w_mask,Qe=y.prev,He=y.strstart+ni;let Pe=X[_+U-1],ut=X[_+U];y.prev_length>=y.good_match&&(w>>=2),V>y.lookahead&&(V=y.lookahead);do if(R=k,!(X[R+U]!==ut||X[R+U-1]!==Pe||X[R]!==X[_]||X[++R]!==X[_+1])){_+=2,R++;do;while(X[++_]===X[++R]&&X[++_]===X[++R]&&X[++_]===X[++R]&&X[++_]===X[++R]&&X[++_]===X[++R]&&X[++_]===X[++R]&&X[++_]===X[++R]&&X[++_]===X[++R]&&_<He);if(M=ni-(He-_),_=He-ni,M>U){if(y.match_start=k,U=M,M>=V)break;Pe=X[_+U-1],ut=X[_+U]}}while((k=Qe[k&ye])>fe&&--w!==0);return U<=y.lookahead?U:y.lookahead},_o=y=>{const k=y.w_size;let w,_,R;do{if(_=y.window_size-y.lookahead-y.strstart,y.strstart>=k+(k-ms)&&(y.window.set(y.window.subarray(k,k+k-_),0),y.match_start-=k,y.strstart-=k,y.block_start-=k,y.insert>y.strstart&&(y.insert=y.strstart),PS(y),_+=k),y.strm.avail_in===0)break;if(w=ef(y.strm,y.window,y.strstart+y.lookahead,_),y.lookahead+=w,y.lookahead+y.insert>=dn)for(R=y.strstart-y.insert,y.ins_h=y.window[R],y.ins_h=Io(y,y.ins_h,y.window[R+1]);y.insert&&(y.ins_h=Io(y,y.ins_h,y.window[R+dn-1]),y.prev[R&y.w_mask]=y.head[y.ins_h],y.head[y.ins_h]=R,R++,y.insert--,!(y.lookahead+y.insert<dn)););}while(y.lookahead<ms&&y.strm.avail_in!==0)},Ew=(y,k)=>{let w=y.pending_buf_size-5>y.w_size?y.w_size:y.pending_buf_size-5,_,R,M,U=0,V=y.strm.avail_in;do{if(_=65535,M=y.bi_valid+42>>3,y.strm.avail_out<M||(M=y.strm.avail_out-M,R=y.strstart-y.block_start,_>R+y.strm.avail_in&&(_=R+y.strm.avail_in),_>M&&(_=M),_<w&&(_===0&&k!==bi||k===ko||_!==R+y.strm.avail_in)))break;U=k===bi&&_===R+y.strm.avail_in?1:0,ad(y,0,0,U),y.pending_buf[y.pending-4]=_,y.pending_buf[y.pending-3]=_>>8,y.pending_buf[y.pending-2]=~_,y.pending_buf[y.pending-1]=~_>>8,ea(y.strm),R&&(R>_&&(R=_),y.strm.output.set(y.window.subarray(y.block_start,y.block_start+R),y.strm.next_out),y.strm.next_out+=R,y.strm.avail_out-=R,y.strm.total_out+=R,y.block_start+=R,_-=R),_&&(ef(y.strm,y.strm.output,y.strm.next_out,_),y.strm.next_out+=_,y.strm.avail_out-=_,y.strm.total_out+=_)}while(U===0);return V-=y.strm.avail_in,V&&(V>=y.w_size?(y.matches=2,y.window.set(y.strm.input.subarray(y.strm.next_in-y.w_size,y.strm.next_in),0),y.strstart=y.w_size,y.insert=y.strstart):(y.window_size-y.strstart<=V&&(y.strstart-=y.w_size,y.window.set(y.window.subarray(y.w_size,y.w_size+y.strstart),0),y.matches<2&&y.matches++,y.insert>y.strstart&&(y.insert=y.strstart)),y.window.set(y.strm.input.subarray(y.strm.next_in-V,y.strm.next_in),y.strstart),y.strstart+=V,y.insert+=V>y.w_size-y.insert?y.w_size-y.insert:V),y.block_start=y.strstart),y.high_water<y.strstart&&(y.high_water=y.strstart),U?Al:k!==ko&&k!==bi&&y.strm.avail_in===0&&y.strstart===y.block_start?Ao:(M=y.window_size-y.strstart,y.strm.avail_in>M&&y.block_start>=y.w_size&&(y.block_start-=y.w_size,y.strstart-=y.w_size,y.window.set(y.window.subarray(y.w_size,y.w_size+y.strstart),0),y.matches<2&&y.matches++,M+=y.w_size,y.insert>y.strstart&&(y.insert=y.strstart)),M>y.strm.avail_in&&(M=y.strm.avail_in),M&&(ef(y.strm,y.window,y.strstart,M),y.strstart+=M,y.insert+=M>y.w_size-y.insert?y.w_size-y.insert:M),y.high_water<y.strstart&&(y.high_water=y.strstart),M=y.bi_valid+42>>3,M=y.pending_buf_size-M>65535?65535:y.pending_buf_size-M,w=M>y.w_size?y.w_size:M,R=y.strstart-y.block_start,(R>=w||(R||k===bi)&&k!==ko&&y.strm.avail_in===0&&R<=M)&&(_=R>M?M:R,U=k===bi&&y.strm.avail_in===0&&_===R?1:0,ad(y,y.block_start,_,U),y.block_start+=_,ea(y.strm)),U?Ws:fr)},To=(y,k)=>{let w,_;for(;;){if(y.lookahead<ms){if(_o(y),y.lookahead<ms&&k===ko)return fr;if(y.lookahead===0)break}if(w=0,y.lookahead>=dn&&(y.ins_h=Io(y,y.ins_h,y.window[y.strstart+dn-1]),w=y.prev[y.strstart&y.w_mask]=y.head[y.ins_h],y.head[y.ins_h]=y.strstart),w!==0&&y.strstart-w<=y.w_size-ms&&(y.match_length=lb(y,w)),y.match_length>=dn)if(_=So(y,y.strstart-y.match_start,y.match_length-dn),y.lookahead-=y.match_length,y.match_length<=y.max_lazy_match&&y.lookahead>=dn){y.match_length--;do y.strstart++,y.ins_h=Io(y,y.ins_h,y.window[y.strstart+dn-1]),w=y.prev[y.strstart&y.w_mask]=y.head[y.ins_h],y.head[y.ins_h]=y.strstart;while(--y.match_length!==0);y.strstart++}else y.strstart+=y.match_length,y.match_length=0,y.ins_h=y.window[y.strstart],y.ins_h=Io(y,y.ins_h,y.window[y.strstart+1]);else _=So(y,0,y.window[y.strstart]),y.lookahead--,y.strstart++;if(_&&(Za(y,!1),y.strm.avail_out===0))return fr}return y.insert=y.strstart<dn-1?y.strstart:dn-1,k===bi?(Za(y,!0),y.strm.avail_out===0?Ws:Al):y.sym_next&&(Za(y,!1),y.strm.avail_out===0)?fr:Ao},No=(y,k)=>{let w,_,R;for(;;){if(y.lookahead<ms){if(_o(y),y.lookahead<ms&&k===ko)return fr;if(y.lookahead===0)break}if(w=0,y.lookahead>=dn&&(y.ins_h=Io(y,y.ins_h,y.window[y.strstart+dn-1]),w=y.prev[y.strstart&y.w_mask]=y.head[y.ins_h],y.head[y.ins_h]=y.strstart),y.prev_length=y.match_length,y.prev_match=y.match_start,y.match_length=dn-1,w!==0&&y.prev_length<y.max_lazy_match&&y.strstart-w<=y.w_size-ms&&(y.match_length=lb(y,w),y.match_length<=5&&(y.strategy===bw||y.match_length===dn&&y.strstart-y.match_start>4096)&&(y.match_length=dn-1)),y.prev_length>=dn&&y.match_length<=y.prev_length){R=y.strstart+y.lookahead-dn,_=So(y,y.strstart-1-y.prev_match,y.prev_length-dn),y.lookahead-=y.prev_length-1,y.prev_length-=2;do++y.strstart<=R&&(y.ins_h=Io(y,y.ins_h,y.window[y.strstart+dn-1]),w=y.prev[y.strstart&y.w_mask]=y.head[y.ins_h],y.head[y.ins_h]=y.strstart);while(--y.prev_length!==0);if(y.match_available=0,y.match_length=dn-1,y.strstart++,_&&(Za(y,!1),y.strm.avail_out===0))return fr}else if(y.match_available){if(_=So(y,0,y.window[y.strstart-1]),_&&Za(y,!1),y.strstart++,y.lookahead--,y.strm.avail_out===0)return fr}else y.match_available=1,y.strstart++,y.lookahead--}return y.match_available&&(_=So(y,0,y.window[y.strstart-1]),y.match_available=0),y.insert=y.strstart<dn-1?y.strstart:dn-1,k===bi?(Za(y,!0),y.strm.avail_out===0?Ws:Al):y.sym_next&&(Za(y,!1),y.strm.avail_out===0)?fr:Ao},rd=(y,k)=>{let w,_,R,M;const U=y.window;for(;;){if(y.lookahead<=ni){if(_o(y),y.lookahead<=ni&&k===ko)return fr;if(y.lookahead===0)break}if(y.match_length=0,y.lookahead>=dn&&y.strstart>0&&(R=y.strstart-1,_=U[R],_===U[++R]&&_===U[++R]&&_===U[++R])){M=y.strstart+ni;do;while(_===U[++R]&&_===U[++R]&&_===U[++R]&&_===U[++R]&&_===U[++R]&&_===U[++R]&&_===U[++R]&&_===U[++R]&&R<M);y.match_length=ni-(M-R),y.match_length>y.lookahead&&(y.match_length=y.lookahead)}if(y.match_length>=dn?(w=So(y,1,y.match_length-dn),y.lookahead-=y.match_length,y.strstart+=y.match_length,y.match_length=0):(w=So(y,0,y.window[y.strstart]),y.lookahead--,y.strstart++),w&&(Za(y,!1),y.strm.avail_out===0))return fr}return y.insert=0,k===bi?(Za(y,!0),y.strm.avail_out===0?Ws:Al):y.sym_next&&(Za(y,!1),y.strm.avail_out===0)?fr:Ao},ub=(y,k)=>{let w;for(;;){if(y.lookahead===0&&(_o(y),y.lookahead===0)){if(k===ko)return fr;break}if(y.match_length=0,w=So(y,0,y.window[y.strstart]),y.lookahead--,y.strstart++,w&&(Za(y,!1),y.strm.avail_out===0))return fr}return y.insert=0,k===bi?(Za(y,!0),y.strm.avail_out===0?Ws:Al):y.sym_next&&(Za(y,!1),y.strm.avail_out===0)?fr:Ao};function Vi(y,k,w,_,R){this.good_length=y,this.max_lazy=k,this.nice_length=w,this.max_chain=_,this.func=R}const Wi=[new Vi(0,0,0,0,Ew),new Vi(4,4,8,4,To),new Vi(4,5,16,8,To),new Vi(4,6,32,32,To),new Vi(4,4,16,16,No),new Vi(8,16,32,32,No),new Vi(8,16,128,128,No),new Vi(8,32,128,256,No),new Vi(32,128,258,1024,No),new Vi(32,258,258,4096,No)],Eu=y=>{y.window_size=2*y.w_size,Co(y.head),y.max_lazy_match=Wi[y.level].max_lazy,y.good_match=Wi[y.level].good_length,y.nice_match=Wi[y.level].nice_length,y.max_chain_length=Wi[y.level].max_chain,y.strstart=0,y.block_start=0,y.lookahead=0,y.insert=0,y.match_length=y.prev_length=dn-1,y.match_available=0,y.ins_h=0};function cb(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=jh,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(vw*2),this.dyn_dtree=new Uint16Array((2*ww+1)*2),this.bl_tree=new Uint16Array((2*xw+1)*2),Co(this.dyn_ltree),Co(this.dyn_dtree),Co(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(Sw+1),this.heap=new Uint16Array(2*sb+1),Co(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*sb+1),Co(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const Cu=y=>{if(!y)return 1;const k=y.state;return!k||k.strm!==y||k.status!==Su&&k.status!==Zh&&k.status!==Xh&&k.status!==Sl&&k.status!==kl&&k.status!==ob&&k.status!==gs&&k.status!==ku?1:0},Ro=y=>{if(Cu(y))return Eo(y,yi);y.total_in=y.total_out=0,y.data_type=zS;const k=y.state;return k.pending=0,k.pending_out=0,k.wrap<0&&(k.wrap=-k.wrap),k.status=k.wrap===2?Zh:k.wrap?Su:gs,y.adler=k.wrap===2?0:1,k.last_flush=-2,TS(k),Qa},db=y=>{const k=Ro(y);return k===Qa&&Eu(y.state),k},Cw=(y,k)=>Cu(y)||y.state.wrap!==2?yi:(y.state.gzhead=k,Qa),pb=(y,k,w,_,R,M)=>{if(!y)return yi;let U=1;if(k===OS&&(k=6),_<0?(U=0,_=-_):_>15&&(U=2,_-=16),R<1||R>US||w!==jh||_<8||_>15||k<0||k>9||M<0||M>BS||_===8&&U!==1)return Eo(y,yi);_===8&&(_=9);const V=new cb;return y.state=V,V.strm=y,V.status=Su,V.wrap=U,V.gzhead=null,V.w_bits=_,V.w_size=1<<V.w_bits,V.w_mask=V.w_size-1,V.hash_bits=R+7,V.hash_size=1<<V.hash_bits,V.hash_mask=V.hash_size-1,V.hash_shift=~~((V.hash_bits+dn-1)/dn),V.window=new Uint8Array(V.w_size*2),V.head=new Uint16Array(V.hash_size),V.prev=new Uint16Array(V.w_size),V.lit_bufsize=1<<R+6,V.pending_buf_size=V.lit_bufsize*4,V.pending_buf=new Uint8Array(V.pending_buf_size),V.sym_buf=V.lit_bufsize,V.sym_end=(V.lit_bufsize-1)*3,V.level=k,V.strategy=M,V.method=w,db(y)},HS=(y,k)=>pb(y,k,jh,VS,WS,LS),GS=(y,k)=>{if(Cu(y)||k>mw||k<0)return y?Eo(y,yi):yi;const w=y.state;if(!y.output||y.avail_in!==0&&!y.input||w.status===ku&&k!==bi)return Eo(y,y.avail_out===0?ib:yi);const _=w.last_flush;if(w.last_flush=k,w.pending!==0){if(ea(y),y.avail_out===0)return w.last_flush=-1,Qa}else if(y.avail_in===0&&Aw(k)<=Aw(_)&&k!==bi)return Eo(y,ib);if(w.status===ku&&y.avail_in!==0)return Eo(y,ib);if(w.status===Su&&w.wrap===0&&(w.status=gs),w.status===Su){let R=jh+(w.w_bits-8<<4)<<8,M=-1;if(w.strategy>=Yh||w.level<2?M=0:w.level<6?M=1:w.level===6?M=2:M=3,R|=M<<6,w.strstart!==0&&(R|=qS),R+=31-R%31,Au(w,R),w.strstart!==0&&(Au(w,y.adler>>>16),Au(w,y.adler&65535)),y.adler=1,w.status=gs,ea(y),w.pending!==0)return w.last_flush=-1,Qa}if(w.status===Zh){if(y.adler=0,wn(w,31),wn(w,139),wn(w,8),w.gzhead)wn(w,(w.gzhead.text?1:0)+(w.gzhead.hcrc?2:0)+(w.gzhead.extra?4:0)+(w.gzhead.name?8:0)+(w.gzhead.comment?16:0)),wn(w,w.gzhead.time&255),wn(w,w.gzhead.time>>8&255),wn(w,w.gzhead.time>>16&255),wn(w,w.gzhead.time>>24&255),wn(w,w.level===9?2:w.strategy>=Yh||w.level<2?4:0),wn(w,w.gzhead.os&255),w.gzhead.extra&&w.gzhead.extra.length&&(wn(w,w.gzhead.extra.length&255),wn(w,w.gzhead.extra.length>>8&255)),w.gzhead.hcrc&&(y.adler=Ra(y.adler,w.pending_buf,w.pending,0)),w.gzindex=0,w.status=Xh;else if(wn(w,0),wn(w,0),wn(w,0),wn(w,0),wn(w,0),wn(w,w.level===9?2:w.strategy>=Yh||w.level<2?4:0),wn(w,kw),w.status=gs,ea(y),w.pending!==0)return w.last_flush=-1,Qa}if(w.status===Xh){if(w.gzhead.extra){let R=w.pending,M=(w.gzhead.extra.length&65535)-w.gzindex;for(;w.pending+M>w.pending_buf_size;){let V=w.pending_buf_size-w.pending;if(w.pending_buf.set(w.gzhead.extra.subarray(w.gzindex,w.gzindex+V),w.pending),w.pending=w.pending_buf_size,w.gzhead.hcrc&&w.pending>R&&(y.adler=Ra(y.adler,w.pending_buf,w.pending-R,R)),w.gzindex+=V,ea(y),w.pending!==0)return w.last_flush=-1,Qa;R=0,M-=V}let U=new Uint8Array(w.gzhead.extra);w.pending_buf.set(U.subarray(w.gzindex,w.gzindex+M),w.pending),w.pending+=M,w.gzhead.hcrc&&w.pending>R&&(y.adler=Ra(y.adler,w.pending_buf,w.pending-R,R)),w.gzindex=0}w.status=Sl}if(w.status===Sl){if(w.gzhead.name){let R=w.pending,M;do{if(w.pending===w.pending_buf_size){if(w.gzhead.hcrc&&w.pending>R&&(y.adler=Ra(y.adler,w.pending_buf,w.pending-R,R)),ea(y),w.pending!==0)return w.last_flush=-1,Qa;R=0}w.gzindex<w.gzhead.name.length?M=w.gzhead.name.charCodeAt(w.gzindex++)&255:M=0,wn(w,M)}while(M!==0);w.gzhead.hcrc&&w.pending>R&&(y.adler=Ra(y.adler,w.pending_buf,w.pending-R,R)),w.gzindex=0}w.status=kl}if(w.status===kl){if(w.gzhead.comment){let R=w.pending,M;do{if(w.pending===w.pending_buf_size){if(w.gzhead.hcrc&&w.pending>R&&(y.adler=Ra(y.adler,w.pending_buf,w.pending-R,R)),ea(y),w.pending!==0)return w.last_flush=-1,Qa;R=0}w.gzindex<w.gzhead.comment.length?M=w.gzhead.comment.charCodeAt(w.gzindex++)&255:M=0,wn(w,M)}while(M!==0);w.gzhead.hcrc&&w.pending>R&&(y.adler=Ra(y.adler,w.pending_buf,w.pending-R,R))}w.status=ob}if(w.status===ob){if(w.gzhead.hcrc){if(w.pending+2>w.pending_buf_size&&(ea(y),w.pending!==0))return w.last_flush=-1,Qa;wn(w,y.adler&255),wn(w,y.adler>>8&255),y.adler=0}if(w.status=gs,ea(y),w.pending!==0)return w.last_flush=-1,Qa}if(y.avail_in!==0||w.lookahead!==0||k!==ko&&w.status!==ku){let R=w.level===0?Ew(w,k):w.strategy===Yh?ub(w,k):w.strategy===MS?rd(w,k):Wi[w.level].func(w,k);if((R===Ws||R===Al)&&(w.status=ku),R===fr||R===Ws)return y.avail_out===0&&(w.last_flush=-1),Qa;if(R===Ao&&(k===FS?RS(w):k!==mw&&(ad(w,0,0,!1),k===fw&&(Co(w.head),w.lookahead===0&&(w.strstart=0,w.block_start=0,w.insert=0))),ea(y),y.avail_out===0))return w.last_flush=-1,Qa}return k!==bi?Qa:w.wrap<=0?gw:(w.wrap===2?(wn(w,y.adler&255),wn(w,y.adler>>8&255),wn(w,y.adler>>16&255),wn(w,y.adler>>24&255),wn(w,y.total_in&255),wn(w,y.total_in>>8&255),wn(w,y.total_in>>16&255),wn(w,y.total_in>>24&255)):(Au(w,y.adler>>>16),Au(w,y.adler&65535)),ea(y),w.wrap>0&&(w.wrap=-w.wrap),w.pending!==0?Qa:gw)},KS=y=>{if(Cu(y))return yi;const k=y.state.status;return y.state=null,k===gs?Eo(y,DS):Qa},Iw=(y,k)=>{let w=k.length;if(Cu(y))return yi;const _=y.state,R=_.wrap;if(R===2||R===1&&_.status!==Su||_.lookahead)return yi;if(R===1&&(y.adler=xl(y.adler,k,w,0)),_.wrap=0,w>=_.w_size){R===0&&(Co(_.head),_.strstart=0,_.block_start=0,_.insert=0);let fe=new Uint8Array(_.w_size);fe.set(k.subarray(w-_.w_size,w),0),k=fe,w=_.w_size}const M=y.avail_in,U=y.next_in,V=y.input;for(y.avail_in=w,y.next_in=0,y.input=k,_o(_);_.lookahead>=dn;){let fe=_.strstart,X=_.lookahead-(dn-1);do _.ins_h=Io(_,_.ins_h,_.window[fe+dn-1]),_.prev[fe&_.w_mask]=_.head[_.ins_h],_.head[_.ins_h]=fe,fe++;while(--X);_.strstart=fe,_.lookahead=dn-1,_o(_)}return _.strstart+=_.lookahead,_.block_start=_.strstart,_.insert=_.lookahead,_.lookahead=0,_.match_length=_.prev_length=dn-1,_.match_available=0,y.next_in=U,y.input=V,y.avail_in=M,_.wrap=R,Qa};var _w=HS,hb=pb,qi=db,Tw=Ro,wi=Cw,xi=GS,Iu=KS,fb=Iw,tf="pako deflate (from Nodeca project)",Fo={deflateInit:_w,deflateInit2:hb,deflateReset:qi,deflateResetKeep:Tw,deflateSetHeader:wi,deflate:xi,deflateEnd:Iu,deflateSetDictionary:fb,deflateInfo:tf};const mb=(y,k)=>Object.prototype.hasOwnProperty.call(y,k);var _u=function(y){const k=Array.prototype.slice.call(arguments,1);for(;k.length;){const w=k.shift();if(w){if(typeof w!="object")throw new TypeError(w+"must be non-object");for(const _ in w)mb(w,_)&&(y[_]=w[_])}}return y},Nw=y=>{let k=0;for(let _=0,R=y.length;_<R;_++)k+=y[_].length;const w=new Uint8Array(k);for(let _=0,R=0,M=y.length;_<M;_++){let U=y[_];w.set(U,R),R+=U.length}return w},El={assign:_u,flattenChunks:Nw};let Cl=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{Cl=!1}const id=new Uint8Array(256);for(let y=0;y<256;y++)id[y]=y>=252?6:y>=248?5:y>=240?4:y>=224?3:y>=192?2:1;id[254]=id[254]=1;var ai=y=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(y);let k,w,_,R,M,U=y.length,V=0;for(R=0;R<U;R++)w=y.charCodeAt(R),(w&64512)===55296&&R+1<U&&(_=y.charCodeAt(R+1),(_&64512)===56320&&(w=65536+(w-55296<<10)+(_-56320),R++)),V+=w<128?1:w<2048?2:w<65536?3:4;for(k=new Uint8Array(V),M=0,R=0;M<V;R++)w=y.charCodeAt(R),(w&64512)===55296&&R+1<U&&(_=y.charCodeAt(R+1),(_&64512)===56320&&(w=65536+(w-55296<<10)+(_-56320),R++)),w<128?k[M++]=w:w<2048?(k[M++]=192|w>>>6,k[M++]=128|w&63):w<65536?(k[M++]=224|w>>>12,k[M++]=128|w>>>6&63,k[M++]=128|w&63):(k[M++]=240|w>>>18,k[M++]=128|w>>>12&63,k[M++]=128|w>>>6&63,k[M++]=128|w&63);return k};const gb=(y,k)=>{if(k<65534&&y.subarray&&Cl)return String.fromCharCode.apply(null,y.length===k?y:y.subarray(0,k));let w="";for(let _=0;_<k;_++)w+=String.fromCharCode(y[_]);return w};var qs=(y,k)=>{const w=k||y.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(y.subarray(0,k));let _,R;const M=new Array(w*2);for(R=0,_=0;_<w;){let U=y[_++];if(U<128){M[R++]=U;continue}let V=id[U];if(V>4){M[R++]=65533,_+=V-1;continue}for(U&=V===2?31:V===3?15:7;V>1&&_<w;)U=U<<6|y[_++]&63,V--;if(V>1){M[R++]=65533;continue}U<65536?M[R++]=U:(U-=65536,M[R++]=55296|U>>10&1023,M[R++]=56320|U&1023)}return gb(M,R)},Rw=(y,k)=>{k=k||y.length,k>y.length&&(k=y.length);let w=k-1;for(;w>=0&&(y[w]&192)===128;)w--;return w<0||w===0?k:w+id[y[w]]>k?w:k},Do={string2buf:ai,buf2string:qs,utf8border:Rw};function Il(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var nf=Il;const af=Object.prototype.toString,{Z_NO_FLUSH:Tu,Z_SYNC_FLUSH:Nu,Z_FULL_FLUSH:rf,Z_FINISH:sf,Z_OK:Ar,Z_STREAM_END:vi,Z_DEFAULT_COMPRESSION:_l,Z_DEFAULT_STRATEGY:Ps,Z_DEFLATED:Hs}=nd;function Pi(y){this.options=El.assign({level:_l,method:Hs,chunkSize:16384,windowBits:15,memLevel:8,strategy:Ps},y||{});let k=this.options;k.raw&&k.windowBits>0?k.windowBits=-k.windowBits:k.gzip&&k.windowBits>0&&k.windowBits<16&&(k.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new nf,this.strm.avail_out=0;let w=Fo.deflateInit2(this.strm,k.level,k.method,k.windowBits,k.memLevel,k.strategy);if(w!==Ar)throw new Error(vl[w]);if(k.header&&Fo.deflateSetHeader(this.strm,k.header),k.dictionary){let _;if(typeof k.dictionary=="string"?_=Do.string2buf(k.dictionary):af.call(k.dictionary)==="[object ArrayBuffer]"?_=new Uint8Array(k.dictionary):_=k.dictionary,w=Fo.deflateSetDictionary(this.strm,_),w!==Ar)throw new Error(vl[w]);this._dict_set=!0}}Pi.prototype.push=function(y,k){const w=this.strm,_=this.options.chunkSize;let R,M;if(this.ended)return!1;for(k===~~k?M=k:M=k===!0?sf:Tu,typeof y=="string"?w.input=Do.string2buf(y):af.call(y)==="[object ArrayBuffer]"?w.input=new Uint8Array(y):w.input=y,w.next_in=0,w.avail_in=w.input.length;;){if(w.avail_out===0&&(w.output=new Uint8Array(_),w.next_out=0,w.avail_out=_),(M===Nu||M===rf)&&w.avail_out<=6){this.onData(w.output.subarray(0,w.next_out)),w.avail_out=0;continue}if(R=Fo.deflate(w,M),R===vi)return w.next_out>0&&this.onData(w.output.subarray(0,w.next_out)),R=Fo.deflateEnd(this.strm),this.onEnd(R),this.ended=!0,R===Ar;if(w.avail_out===0){this.onData(w.output);continue}if(M>0&&w.next_out>0){this.onData(w.output.subarray(0,w.next_out)),w.avail_out=0;continue}if(w.avail_in===0)break}return!0},Pi.prototype.onData=function(y){this.chunks.push(y)},Pi.prototype.onEnd=function(y){y===Ar&&(this.result=El.flattenChunks(this.chunks)),this.chunks=[],this.err=y,this.msg=this.strm.msg};function of(y,k){const w=new Pi(k);if(w.push(y,!0),w.err)throw w.msg||vl[w.err];return w.result}function bb(y,k){return k=k||{},k.raw=!0,of(y,k)}function yb(y,k){return k=k||{},k.gzip=!0,of(y,k)}var Er=Pi,ma=of,En=bb,Tl=yb,bs={Deflate:Er,deflate:ma,deflateRaw:En,gzip:Tl};const Ru=16209,Nl=16191;var Fw=function(k,w){let _,R,M,U,V,fe,X,ye,Qe,He,Pe,ut,Cn,Xt,Ut,Kt,Ft,tt,nn,Vt,Et,_n,Jt,Ct;const vt=k.state;_=k.next_in,Jt=k.input,R=_+(k.avail_in-5),M=k.next_out,Ct=k.output,U=M-(w-k.avail_out),V=M+(k.avail_out-257),fe=vt.dmax,X=vt.wsize,ye=vt.whave,Qe=vt.wnext,He=vt.window,Pe=vt.hold,ut=vt.bits,Cn=vt.lencode,Xt=vt.distcode,Ut=(1<<vt.lenbits)-1,Kt=(1<<vt.distbits)-1;e:do{ut<15&&(Pe+=Jt[_++]<<ut,ut+=8,Pe+=Jt[_++]<<ut,ut+=8),Ft=Cn[Pe&Ut];t:for(;;){if(tt=Ft>>>24,Pe>>>=tt,ut-=tt,tt=Ft>>>16&255,tt===0)Ct[M++]=Ft&65535;else if(tt&16){nn=Ft&65535,tt&=15,tt&&(ut<tt&&(Pe+=Jt[_++]<<ut,ut+=8),nn+=Pe&(1<<tt)-1,Pe>>>=tt,ut-=tt),ut<15&&(Pe+=Jt[_++]<<ut,ut+=8,Pe+=Jt[_++]<<ut,ut+=8),Ft=Xt[Pe&Kt];n:for(;;){if(tt=Ft>>>24,Pe>>>=tt,ut-=tt,tt=Ft>>>16&255,tt&16){if(Vt=Ft&65535,tt&=15,ut<tt&&(Pe+=Jt[_++]<<ut,ut+=8,ut<tt&&(Pe+=Jt[_++]<<ut,ut+=8)),Vt+=Pe&(1<<tt)-1,Vt>fe){k.msg="invalid distance too far back",vt.mode=Ru;break e}if(Pe>>>=tt,ut-=tt,tt=M-U,Vt>tt){if(tt=Vt-tt,tt>ye&&vt.sane){k.msg="invalid distance too far back",vt.mode=Ru;break e}if(Et=0,_n=He,Qe===0){if(Et+=X-tt,tt<nn){nn-=tt;do Ct[M++]=He[Et++];while(--tt);Et=M-Vt,_n=Ct}}else if(Qe<tt){if(Et+=X+Qe-tt,tt-=Qe,tt<nn){nn-=tt;do Ct[M++]=He[Et++];while(--tt);if(Et=0,Qe<nn){tt=Qe,nn-=tt;do Ct[M++]=He[Et++];while(--tt);Et=M-Vt,_n=Ct}}}else if(Et+=Qe-tt,tt<nn){nn-=tt;do Ct[M++]=He[Et++];while(--tt);Et=M-Vt,_n=Ct}for(;nn>2;)Ct[M++]=_n[Et++],Ct[M++]=_n[Et++],Ct[M++]=_n[Et++],nn-=3;nn&&(Ct[M++]=_n[Et++],nn>1&&(Ct[M++]=_n[Et++]))}else{Et=M-Vt;do Ct[M++]=Ct[Et++],Ct[M++]=Ct[Et++],Ct[M++]=Ct[Et++],nn-=3;while(nn>2);nn&&(Ct[M++]=Ct[Et++],nn>1&&(Ct[M++]=Ct[Et++]))}}else if((tt&64)===0){Ft=Xt[(Ft&65535)+(Pe&(1<<tt)-1)];continue n}else{k.msg="invalid distance code",vt.mode=Ru;break e}break}}else if((tt&64)===0){Ft=Cn[(Ft&65535)+(Pe&(1<<tt)-1)];continue t}else if(tt&32){vt.mode=Nl;break e}else{k.msg="invalid literal/length code",vt.mode=Ru;break e}break}}while(_<R&&M<V);nn=ut>>3,_-=nn,ut-=nn<<3,Pe&=(1<<ut)-1,k.next_in=_,k.next_out=M,k.avail_in=_<R?5+(R-_):5-(_-R),k.avail_out=M<V?257+(V-M):257-(M-V),vt.hold=Pe,vt.bits=ut};const Rl=15,Fu=852,Du=592,wb=0,Fl=1,lf=2,Dl=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Gs=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),Oo=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),Ks=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var Ol=(y,k,w,_,R,M,U,V)=>{const fe=V.bits;let X=0,ye=0,Qe=0,He=0,Pe=0,ut=0,Cn=0,Xt=0,Ut=0,Kt=0,Ft,tt,nn,Vt,Et,_n=null,Jt;const Ct=new Uint16Array(Rl+1),vt=new Uint16Array(Rl+1);let Ki=null,Td,vs,mr;for(X=0;X<=Rl;X++)Ct[X]=0;for(ye=0;ye<_;ye++)Ct[k[w+ye]]++;for(Pe=fe,He=Rl;He>=1&&Ct[He]===0;He--);if(Pe>He&&(Pe=He),He===0)return R[M++]=1<<24|64<<16|0,R[M++]=1<<24|64<<16|0,V.bits=1,0;for(Qe=1;Qe<He&&Ct[Qe]===0;Qe++);for(Pe<Qe&&(Pe=Qe),Xt=1,X=1;X<=Rl;X++)if(Xt<<=1,Xt-=Ct[X],Xt<0)return-1;if(Xt>0&&(y===wb||He!==1))return-1;for(vt[1]=0,X=1;X<Rl;X++)vt[X+1]=vt[X]+Ct[X];for(ye=0;ye<_;ye++)k[w+ye]!==0&&(U[vt[k[w+ye]]++]=ye);if(y===wb?(_n=Ki=U,Jt=20):y===Fl?(_n=Dl,Ki=Gs,Jt=257):(_n=Oo,Ki=Ks,Jt=0),Kt=0,ye=0,X=Qe,Et=M,ut=Pe,Cn=0,nn=-1,Ut=1<<Pe,Vt=Ut-1,y===Fl&&Ut>Fu||y===lf&&Ut>Du)return 1;for(;;){Td=X-Cn,U[ye]+1<Jt?(vs=0,mr=U[ye]):U[ye]>=Jt?(vs=Ki[U[ye]-Jt],mr=_n[U[ye]-Jt]):(vs=96,mr=0),Ft=1<<X-Cn,tt=1<<ut,Qe=tt;do tt-=Ft,R[Et+(Kt>>Cn)+tt]=Td<<24|vs<<16|mr|0;while(tt!==0);for(Ft=1<<X-1;Kt&Ft;)Ft>>=1;if(Ft!==0?(Kt&=Ft-1,Kt+=Ft):Kt=0,ye++,--Ct[X]===0){if(X===He)break;X=k[w+U[ye]]}if(X>Pe&&(Kt&Vt)!==nn){for(Cn===0&&(Cn=Pe),Et+=Qe,ut=X-Cn,Xt=1<<ut;ut+Cn<He&&(Xt-=Ct[ut+Cn],!(Xt<=0));)ut++,Xt<<=1;if(Ut+=1<<ut,y===Fl&&Ut>Fu||y===lf&&Ut>Du)return 1;nn=Kt&Vt,R[nn]=Pe<<24|ut<<16|Et-M|0}}return Kt!==0&&(R[Et+Kt]=X-Cn<<24|64<<16|0),V.bits=Pe,0};const sd=0,od=1,Mo=2,{Z_FINISH:Xa,Z_BLOCK:uf,Z_TREES:ld,Z_OK:Ml,Z_STREAM_END:$S,Z_NEED_DICT:JS,Z_STREAM_ERROR:In,Z_DATA_ERROR:cf,Z_MEM_ERROR:Ou,Z_BUF_ERROR:ud,Z_DEFLATED:df}=nd,$s=16180,Bl=16181,Ow=16182,xb=16183,Mw=16184,vb=16185,Bo=16186,pf=16187,cd=16188,Sb=16189,Lo=16190,ys=16191,Mu=16192,hf=16193,ff=16194,dd=16195,kb=16196,Bu=16197,Ab=16198,pd=16199,Hi=16200,mf=16201,gf=16202,Js=16203,Ys=16204,Lu=16205,hd=16206,bf=16207,zu=16208,Bn=16209,Eb=16210,Cb=16211,Uu=852,yf=592,Ib=15,wf=y=>(y>>>24&255)+(y>>>8&65280)+((y&65280)<<8)+((y&255)<<24);function zo(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const zt=y=>{if(!y)return 1;const k=y.state;return!k||k.strm!==y||k.mode<$s||k.mode>Cb?1:0},Fn=y=>{if(zt(y))return In;const k=y.state;return y.total_in=y.total_out=k.total=0,y.msg="",k.wrap&&(y.adler=k.wrap&1),k.mode=$s,k.last=0,k.havedict=0,k.flags=-1,k.dmax=32768,k.head=null,k.hold=0,k.bits=0,k.lencode=k.lendyn=new Int32Array(Uu),k.distcode=k.distdyn=new Int32Array(yf),k.sane=1,k.back=-1,Ml},Sa=y=>{if(zt(y))return In;const k=y.state;return k.wsize=0,k.whave=0,k.wnext=0,Fn(y)},fd=(y,k)=>{let w;if(zt(y))return In;const _=y.state;return k<0?(w=0,k=-k):(w=(k>>4)+5,k<48&&(k&=15)),k&&(k<8||k>15)?In:(_.window!==null&&_.wbits!==k&&(_.window=null),_.wrap=w,_.wbits=k,Sa(y))},Ll=(y,k)=>{if(!y)return In;const w=new zo;y.state=w,w.strm=y,w.window=null,w.mode=$s;const _=fd(y,k);return _!==Ml&&(y.state=null),_},zl=y=>Ll(y,Ib);let md=!0,Ul,Uo;const jS=y=>{if(md){Ul=new Int32Array(512),Uo=new Int32Array(32);let k=0;for(;k<144;)y.lens[k++]=8;for(;k<256;)y.lens[k++]=9;for(;k<280;)y.lens[k++]=7;for(;k<288;)y.lens[k++]=8;for(Ol(od,y.lens,0,288,Ul,0,y.work,{bits:9}),k=0;k<32;)y.lens[k++]=5;Ol(Mo,y.lens,0,32,Uo,0,y.work,{bits:5}),md=!1}y.lencode=Ul,y.lenbits=9,y.distcode=Uo,y.distbits=5},ga=(y,k,w,_)=>{let R;const M=y.state;return M.window===null&&(M.wsize=1<<M.wbits,M.wnext=0,M.whave=0,M.window=new Uint8Array(M.wsize)),_>=M.wsize?(M.window.set(k.subarray(w-M.wsize,w),0),M.wnext=0,M.whave=M.wsize):(R=M.wsize-M.wnext,R>_&&(R=_),M.window.set(k.subarray(w-_,w-_+R),M.wnext),_-=R,_?(M.window.set(k.subarray(w-_,w),0),M.wnext=_,M.whave=M.wsize):(M.wnext+=R,M.wnext===M.wsize&&(M.wnext=0),M.whave<M.wsize&&(M.whave+=R))),0},_b=(y,k)=>{let w,_,R,M,U,V,fe,X,ye,Qe,He,Pe,ut,Cn,Xt=0,Ut,Kt,Ft,tt,nn,Vt,Et,_n;const Jt=new Uint8Array(4);let Ct,vt;const Ki=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(zt(y)||!y.output||!y.input&&y.avail_in!==0)return In;w=y.state,w.mode===ys&&(w.mode=Mu),U=y.next_out,R=y.output,fe=y.avail_out,M=y.next_in,_=y.input,V=y.avail_in,X=w.hold,ye=w.bits,Qe=V,He=fe,_n=Ml;e:for(;;)switch(w.mode){case $s:if(w.wrap===0){w.mode=Mu;break}for(;ye<16;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}if(w.wrap&2&&X===35615){w.wbits===0&&(w.wbits=15),w.check=0,Jt[0]=X&255,Jt[1]=X>>>8&255,w.check=Ra(w.check,Jt,2,0),X=0,ye=0,w.mode=Bl;break}if(w.head&&(w.head.done=!1),!(w.wrap&1)||(((X&255)<<8)+(X>>8))%31){y.msg="incorrect header check",w.mode=Bn;break}if((X&15)!==df){y.msg="unknown compression method",w.mode=Bn;break}if(X>>>=4,ye-=4,Et=(X&15)+8,w.wbits===0&&(w.wbits=Et),Et>15||Et>w.wbits){y.msg="invalid window size",w.mode=Bn;break}w.dmax=1<<w.wbits,w.flags=0,y.adler=w.check=1,w.mode=X&512?Sb:ys,X=0,ye=0;break;case Bl:for(;ye<16;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}if(w.flags=X,(w.flags&255)!==df){y.msg="unknown compression method",w.mode=Bn;break}if(w.flags&57344){y.msg="unknown header flags set",w.mode=Bn;break}w.head&&(w.head.text=X>>8&1),w.flags&512&&w.wrap&4&&(Jt[0]=X&255,Jt[1]=X>>>8&255,w.check=Ra(w.check,Jt,2,0)),X=0,ye=0,w.mode=Ow;case Ow:for(;ye<32;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}w.head&&(w.head.time=X),w.flags&512&&w.wrap&4&&(Jt[0]=X&255,Jt[1]=X>>>8&255,Jt[2]=X>>>16&255,Jt[3]=X>>>24&255,w.check=Ra(w.check,Jt,4,0)),X=0,ye=0,w.mode=xb;case xb:for(;ye<16;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}w.head&&(w.head.xflags=X&255,w.head.os=X>>8),w.flags&512&&w.wrap&4&&(Jt[0]=X&255,Jt[1]=X>>>8&255,w.check=Ra(w.check,Jt,2,0)),X=0,ye=0,w.mode=Mw;case Mw:if(w.flags&1024){for(;ye<16;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}w.length=X,w.head&&(w.head.extra_len=X),w.flags&512&&w.wrap&4&&(Jt[0]=X&255,Jt[1]=X>>>8&255,w.check=Ra(w.check,Jt,2,0)),X=0,ye=0}else w.head&&(w.head.extra=null);w.mode=vb;case vb:if(w.flags&1024&&(Pe=w.length,Pe>V&&(Pe=V),Pe&&(w.head&&(Et=w.head.extra_len-w.length,w.head.extra||(w.head.extra=new Uint8Array(w.head.extra_len)),w.head.extra.set(_.subarray(M,M+Pe),Et)),w.flags&512&&w.wrap&4&&(w.check=Ra(w.check,_,Pe,M)),V-=Pe,M+=Pe,w.length-=Pe),w.length))break e;w.length=0,w.mode=Bo;case Bo:if(w.flags&2048){if(V===0)break e;Pe=0;do Et=_[M+Pe++],w.head&&Et&&w.length<65536&&(w.head.name+=String.fromCharCode(Et));while(Et&&Pe<V);if(w.flags&512&&w.wrap&4&&(w.check=Ra(w.check,_,Pe,M)),V-=Pe,M+=Pe,Et)break e}else w.head&&(w.head.name=null);w.length=0,w.mode=pf;case pf:if(w.flags&4096){if(V===0)break e;Pe=0;do Et=_[M+Pe++],w.head&&Et&&w.length<65536&&(w.head.comment+=String.fromCharCode(Et));while(Et&&Pe<V);if(w.flags&512&&w.wrap&4&&(w.check=Ra(w.check,_,Pe,M)),V-=Pe,M+=Pe,Et)break e}else w.head&&(w.head.comment=null);w.mode=cd;case cd:if(w.flags&512){for(;ye<16;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}if(w.wrap&4&&X!==(w.check&65535)){y.msg="header crc mismatch",w.mode=Bn;break}X=0,ye=0}w.head&&(w.head.hcrc=w.flags>>9&1,w.head.done=!0),y.adler=w.check=0,w.mode=ys;break;case Sb:for(;ye<32;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}y.adler=w.check=wf(X),X=0,ye=0,w.mode=Lo;case Lo:if(w.havedict===0)return y.next_out=U,y.avail_out=fe,y.next_in=M,y.avail_in=V,w.hold=X,w.bits=ye,JS;y.adler=w.check=1,w.mode=ys;case ys:if(k===uf||k===ld)break e;case Mu:if(w.last){X>>>=ye&7,ye-=ye&7,w.mode=hd;break}for(;ye<3;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}switch(w.last=X&1,X>>>=1,ye-=1,X&3){case 0:w.mode=hf;break;case 1:if(jS(w),w.mode=pd,k===ld){X>>>=2,ye-=2;break e}break;case 2:w.mode=kb;break;case 3:y.msg="invalid block type",w.mode=Bn}X>>>=2,ye-=2;break;case hf:for(X>>>=ye&7,ye-=ye&7;ye<32;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}if((X&65535)!==(X>>>16^65535)){y.msg="invalid stored block lengths",w.mode=Bn;break}if(w.length=X&65535,X=0,ye=0,w.mode=ff,k===ld)break e;case ff:w.mode=dd;case dd:if(Pe=w.length,Pe){if(Pe>V&&(Pe=V),Pe>fe&&(Pe=fe),Pe===0)break e;R.set(_.subarray(M,M+Pe),U),V-=Pe,M+=Pe,fe-=Pe,U+=Pe,w.length-=Pe;break}w.mode=ys;break;case kb:for(;ye<14;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}if(w.nlen=(X&31)+257,X>>>=5,ye-=5,w.ndist=(X&31)+1,X>>>=5,ye-=5,w.ncode=(X&15)+4,X>>>=4,ye-=4,w.nlen>286||w.ndist>30){y.msg="too many length or distance symbols",w.mode=Bn;break}w.have=0,w.mode=Bu;case Bu:for(;w.have<w.ncode;){for(;ye<3;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}w.lens[Ki[w.have++]]=X&7,X>>>=3,ye-=3}for(;w.have<19;)w.lens[Ki[w.have++]]=0;if(w.lencode=w.lendyn,w.lenbits=7,Ct={bits:w.lenbits},_n=Ol(sd,w.lens,0,19,w.lencode,0,w.work,Ct),w.lenbits=Ct.bits,_n){y.msg="invalid code lengths set",w.mode=Bn;break}w.have=0,w.mode=Ab;case Ab:for(;w.have<w.nlen+w.ndist;){for(;Xt=w.lencode[X&(1<<w.lenbits)-1],Ut=Xt>>>24,Kt=Xt>>>16&255,Ft=Xt&65535,!(Ut<=ye);){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}if(Ft<16)X>>>=Ut,ye-=Ut,w.lens[w.have++]=Ft;else{if(Ft===16){for(vt=Ut+2;ye<vt;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}if(X>>>=Ut,ye-=Ut,w.have===0){y.msg="invalid bit length repeat",w.mode=Bn;break}Et=w.lens[w.have-1],Pe=3+(X&3),X>>>=2,ye-=2}else if(Ft===17){for(vt=Ut+3;ye<vt;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}X>>>=Ut,ye-=Ut,Et=0,Pe=3+(X&7),X>>>=3,ye-=3}else{for(vt=Ut+7;ye<vt;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}X>>>=Ut,ye-=Ut,Et=0,Pe=11+(X&127),X>>>=7,ye-=7}if(w.have+Pe>w.nlen+w.ndist){y.msg="invalid bit length repeat",w.mode=Bn;break}for(;Pe--;)w.lens[w.have++]=Et}}if(w.mode===Bn)break;if(w.lens[256]===0){y.msg="invalid code -- missing end-of-block",w.mode=Bn;break}if(w.lenbits=9,Ct={bits:w.lenbits},_n=Ol(od,w.lens,0,w.nlen,w.lencode,0,w.work,Ct),w.lenbits=Ct.bits,_n){y.msg="invalid literal/lengths set",w.mode=Bn;break}if(w.distbits=6,w.distcode=w.distdyn,Ct={bits:w.distbits},_n=Ol(Mo,w.lens,w.nlen,w.ndist,w.distcode,0,w.work,Ct),w.distbits=Ct.bits,_n){y.msg="invalid distances set",w.mode=Bn;break}if(w.mode=pd,k===ld)break e;case pd:w.mode=Hi;case Hi:if(V>=6&&fe>=258){y.next_out=U,y.avail_out=fe,y.next_in=M,y.avail_in=V,w.hold=X,w.bits=ye,Fw(y,He),U=y.next_out,R=y.output,fe=y.avail_out,M=y.next_in,_=y.input,V=y.avail_in,X=w.hold,ye=w.bits,w.mode===ys&&(w.back=-1);break}for(w.back=0;Xt=w.lencode[X&(1<<w.lenbits)-1],Ut=Xt>>>24,Kt=Xt>>>16&255,Ft=Xt&65535,!(Ut<=ye);){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}if(Kt&&(Kt&240)===0){for(tt=Ut,nn=Kt,Vt=Ft;Xt=w.lencode[Vt+((X&(1<<tt+nn)-1)>>tt)],Ut=Xt>>>24,Kt=Xt>>>16&255,Ft=Xt&65535,!(tt+Ut<=ye);){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}X>>>=tt,ye-=tt,w.back+=tt}if(X>>>=Ut,ye-=Ut,w.back+=Ut,w.length=Ft,Kt===0){w.mode=Lu;break}if(Kt&32){w.back=-1,w.mode=ys;break}if(Kt&64){y.msg="invalid literal/length code",w.mode=Bn;break}w.extra=Kt&15,w.mode=mf;case mf:if(w.extra){for(vt=w.extra;ye<vt;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}w.length+=X&(1<<w.extra)-1,X>>>=w.extra,ye-=w.extra,w.back+=w.extra}w.was=w.length,w.mode=gf;case gf:for(;Xt=w.distcode[X&(1<<w.distbits)-1],Ut=Xt>>>24,Kt=Xt>>>16&255,Ft=Xt&65535,!(Ut<=ye);){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}if((Kt&240)===0){for(tt=Ut,nn=Kt,Vt=Ft;Xt=w.distcode[Vt+((X&(1<<tt+nn)-1)>>tt)],Ut=Xt>>>24,Kt=Xt>>>16&255,Ft=Xt&65535,!(tt+Ut<=ye);){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}X>>>=tt,ye-=tt,w.back+=tt}if(X>>>=Ut,ye-=Ut,w.back+=Ut,Kt&64){y.msg="invalid distance code",w.mode=Bn;break}w.offset=Ft,w.extra=Kt&15,w.mode=Js;case Js:if(w.extra){for(vt=w.extra;ye<vt;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}w.offset+=X&(1<<w.extra)-1,X>>>=w.extra,ye-=w.extra,w.back+=w.extra}if(w.offset>w.dmax){y.msg="invalid distance too far back",w.mode=Bn;break}w.mode=Ys;case Ys:if(fe===0)break e;if(Pe=He-fe,w.offset>Pe){if(Pe=w.offset-Pe,Pe>w.whave&&w.sane){y.msg="invalid distance too far back",w.mode=Bn;break}Pe>w.wnext?(Pe-=w.wnext,ut=w.wsize-Pe):ut=w.wnext-Pe,Pe>w.length&&(Pe=w.length),Cn=w.window}else Cn=R,ut=U-w.offset,Pe=w.length;Pe>fe&&(Pe=fe),fe-=Pe,w.length-=Pe;do R[U++]=Cn[ut++];while(--Pe);w.length===0&&(w.mode=Hi);break;case Lu:if(fe===0)break e;R[U++]=w.length,fe--,w.mode=Hi;break;case hd:if(w.wrap){for(;ye<32;){if(V===0)break e;V--,X|=_[M++]<<ye,ye+=8}if(He-=fe,y.total_out+=He,w.total+=He,w.wrap&4&&He&&(y.adler=w.check=w.flags?Ra(w.check,R,He,U-He):xl(w.check,R,He,U-He)),He=fe,w.wrap&4&&(w.flags?X:wf(X))!==w.check){y.msg="incorrect data check",w.mode=Bn;break}X=0,ye=0}w.mode=bf;case bf:if(w.wrap&&w.flags){for(;ye<32;){if(V===0)break e;V--,X+=_[M++]<<ye,ye+=8}if(w.wrap&4&&X!==(w.total&4294967295)){y.msg="incorrect length check",w.mode=Bn;break}X=0,ye=0}w.mode=zu;case zu:_n=$S;break e;case Bn:_n=cf;break e;case Eb:return Ou;case Cb:default:return In}return y.next_out=U,y.avail_out=fe,y.next_in=M,y.avail_in=V,w.hold=X,w.bits=ye,(w.wsize||He!==y.avail_out&&w.mode<Bn&&(w.mode<hd||k!==Xa))&&ga(y,y.output,y.next_out,He-y.avail_out),Qe-=y.avail_in,He-=y.avail_out,y.total_in+=Qe,y.total_out+=He,w.total+=He,w.wrap&4&&He&&(y.adler=w.check=w.flags?Ra(w.check,R,He,y.next_out-He):xl(w.check,R,He,y.next_out-He)),y.data_type=w.bits+(w.last?64:0)+(w.mode===ys?128:0)+(w.mode===pd||w.mode===ff?256:0),(Qe===0&&He===0||k===Xa)&&_n===Ml&&(_n=ud),_n},Tb=y=>{if(zt(y))return In;let k=y.state;return k.window&&(k.window=null),y.state=null,Ml},Bw=(y,k)=>{if(zt(y))return In;const w=y.state;return(w.wrap&2)===0?In:(w.head=k,k.done=!1,Ml)},Lw=(y,k)=>{const w=k.length;let _,R,M;return zt(y)||(_=y.state,_.wrap!==0&&_.mode!==Lo)?In:_.mode===Lo&&(R=1,R=xl(R,k,w,0),R!==_.check)?cf:(M=ga(y,k,w,w),M?(_.mode=Eb,Ou):(_.havedict=1,Ml))};var QS=Sa,Nb=fd,Rb=Fn,Fb=zl,Lr=Ll,Ea=_b,Db=Tb,gd=Bw,xf=Lw,Ob="pako inflate (from Nodeca project)",er={inflateReset:QS,inflateReset2:Nb,inflateResetKeep:Rb,inflateInit:Fb,inflateInit2:Lr,inflate:Ea,inflateEnd:Db,inflateGetHeader:gd,inflateSetDictionary:xf,inflateInfo:Ob};function vf(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var Mb=vf;const Sf=Object.prototype.toString,{Z_NO_FLUSH:zw,Z_FINISH:Uw,Z_OK:Vu,Z_STREAM_END:kf,Z_NEED_DICT:Af,Z_STREAM_ERROR:Vw,Z_DATA_ERROR:Ef,Z_MEM_ERROR:Ww}=nd;function bd(y){this.options=El.assign({chunkSize:1024*64,windowBits:15,to:""},y||{});const k=this.options;k.raw&&k.windowBits>=0&&k.windowBits<16&&(k.windowBits=-k.windowBits,k.windowBits===0&&(k.windowBits=-15)),k.windowBits>=0&&k.windowBits<16&&!(y&&y.windowBits)&&(k.windowBits+=32),k.windowBits>15&&k.windowBits<48&&(k.windowBits&15)===0&&(k.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new nf,this.strm.avail_out=0;let w=er.inflateInit2(this.strm,k.windowBits);if(w!==Vu)throw new Error(vl[w]);if(this.header=new Mb,er.inflateGetHeader(this.strm,this.header),k.dictionary&&(typeof k.dictionary=="string"?k.dictionary=Do.string2buf(k.dictionary):Sf.call(k.dictionary)==="[object ArrayBuffer]"&&(k.dictionary=new Uint8Array(k.dictionary)),k.raw&&(w=er.inflateSetDictionary(this.strm,k.dictionary),w!==Vu)))throw new Error(vl[w])}bd.prototype.push=function(y,k){const w=this.strm,_=this.options.chunkSize,R=this.options.dictionary;let M,U,V;if(this.ended)return!1;for(k===~~k?U=k:U=k===!0?Uw:zw,Sf.call(y)==="[object ArrayBuffer]"?w.input=new Uint8Array(y):w.input=y,w.next_in=0,w.avail_in=w.input.length;;){for(w.avail_out===0&&(w.output=new Uint8Array(_),w.next_out=0,w.avail_out=_),M=er.inflate(w,U),M===Af&&R&&(M=er.inflateSetDictionary(w,R),M===Vu?M=er.inflate(w,U):M===Ef&&(M=Af));w.avail_in>0&&M===kf&&w.state.wrap>0&&y[w.next_in]!==0;)er.inflateReset(w),M=er.inflate(w,U);switch(M){case Vw:case Ef:case Af:case Ww:return this.onEnd(M),this.ended=!0,!1}if(V=w.avail_out,w.next_out&&(w.avail_out===0||M===kf))if(this.options.to==="string"){let fe=Do.utf8border(w.output,w.next_out),X=w.next_out-fe,ye=Do.buf2string(w.output,fe);w.next_out=X,w.avail_out=_-X,X&&w.output.set(w.output.subarray(fe,fe+X),0),this.onData(ye)}else this.onData(w.output.length===w.next_out?w.output:w.output.subarray(0,w.next_out));if(!(M===Vu&&V===0)){if(M===kf)return M=er.inflateEnd(this.strm),this.onEnd(M),this.ended=!0,!0;if(w.avail_in===0)break}}return!0},bd.prototype.onData=function(y){this.chunks.push(y)},bd.prototype.onEnd=function(y){y===Vu&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=El.flattenChunks(this.chunks)),this.chunks=[],this.err=y,this.msg=this.strm.msg};function Cf(y,k){const w=new bd(k);if(w.push(y),w.err)throw w.msg||vl[w.err];return w.result}function qw(y,k){return k=k||{},k.raw=!0,Cf(y,k)}var Pw=bd,Bb=Cf,Hw=qw,Gw=Cf,Kw={Inflate:Pw,inflate:Bb,inflateRaw:Hw,ungzip:Gw};const{Deflate:$w,deflate:Jw,deflateRaw:ZS,gzip:Yw}=bs,{Inflate:Wu,inflate:If,inflateRaw:jw,ungzip:_f}=Kw;var yd=$w,Qw=Jw,Zw=ZS,Xw=Yw,ex=Wu,tx=If,nx=jw,Lb=_f,ax=nd,rx={Deflate:yd,deflate:Qw,deflateRaw:Zw,gzip:Xw,Inflate:ex,inflate:tx,inflateRaw:nx,ungzip:Lb,constants:ax};async function zb(y,k){let w;if(k){const V=y?"-threads":"",fe=k.split("/").slice(0,-1).join("/"),X=k.split("/").pop(),[ye,...Qe]=X.split(".");w=`${fe}/${ye}${V}.${Qe.join(".")}`}else w=y?(await o3(async()=>{const{default:V}=await import("./barretenberg-threads-BWbjPrzV.js");return{default:V}},[])).default:(await o3(async()=>{const{default:V}=await import("./barretenberg-Dusd3JVg.js");return{default:V}},[])).default;const R=await(await fetch(w)).arrayBuffer(),M=new Uint8Array(R);return M[0]===31&&M[1]===139&&M[2]===8?rx.ungzip(M).buffer:M}async function Ub(y=32,k,w=Va()("bb.js:fetch_mat")){const _=mt(),R=_?await ix(w):1,M=Math.min(y,R,32);w(`Fetching bb wasm from ${k??"default location"}`);const U=await zb(_,k);w(`Compiling bb wasm of ${U.byteLength} bytes`);const V=await WebAssembly.compile(U);return w("Compilation of bb wasm complete"),{module:V,threads:M}}async function ix(y){if(typeof navigator<"u"&&navigator.hardwareConcurrency)return navigator.hardwareConcurrency;try{return(await Yt.e(522).then(Yt.t.bind(Yt,522,23))).cpus().length}catch(k){return y(`Could not detect environment to query number of threads. Falling back to one thread. Error: ${k.message??k}`),1}}const XS=4,wd=32;function Tf(y,k){const w=y.slice(XS),_=w.slice(0,k*wd);return{proof:w.slice(k*wd),publicInputs:_}}function Nf(y,k){const w=rt((y.length+k.length)/wd);return Uint8Array.from([...w,...y,...k])}function xd(y){const k=Rf(y.publicInputs);return Uint8Array.from([...k,...y.proof])}function vd(y){const w=[];for(let _=0;_<y.length;_+=32){const R=y.slice(_,_+32);w.push(R)}return w.map(t2)}function Rf(y){const k=y.map(sx);return e2(k)}function e2(y){const k=y.reduce((R,M)=>R+M.length,0),w=new Uint8Array(k);let _=0;for(const R of y)w.set(R,_),_+=R.length;return w}function t2(y){const k=[];return y.forEach(function(w){let _=w.toString(16);_.length%2&&(_="0"+_),k.push(_)}),"0x"+k.join("")}function sx(y){const k=BigInt(y).toString(16).padStart(64,"0"),w=k.length/2,_=new Uint8Array(w);let R=0,M=0;for(;R<w;)_[R]=parseInt(k.slice(M,M+2),16),R+=1,M+=2;return _}class Sd{constructor(k={threads:1}){this.options=k}async instantiate(){if(!this.api){const k=await qo.new(this.options);await k.initSRSForCircuitSize(0),this.acirComposer=await k.acirNewAcirComposer(0),this.api=k}}async verifyUltraPlonkProof(k,w){await this.instantiate(),await this.api.acirLoadVerificationKey(this.acirComposer,new $e(w));const _=xd(k);return await this.api.acirVerifyProof(this.acirComposer,_)}async verifyUltraHonkProof(k,w){await this.instantiate();const _=Nf(Rf(k.publicInputs),k.proof);return await this.api.acirVerifyUltraHonk(_,new $e(w))}async destroy(){this.api&&await this.api.destroy()}}var Cr=Uint8Array,Vo=Uint16Array,ox=Int32Array,Vb=new Cr([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),kd=new Cr([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),lx=new Cr([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Wb=function(y,k){for(var w=new Vo(31),_=0;_<31;++_)w[_]=k+=1<<y[_-1];for(var R=new ox(w[30]),_=1;_<30;++_)for(var M=w[_];M<w[_+1];++M)R[M]=M-w[_]<<5|_;return{b:w,r:R}},ux=Wb(Vb,2),Vl=ux.b,Ad=ux.r;Vl[28]=258,Ad[258]=28;for(var Ff=Wb(kd,0),Ed=Ff.b,Cd=new Vo(32768),Yn=0;Yn<32768;++Yn){var js=(Yn&43690)>>1|(Yn&21845)<<1;js=(js&52428)>>2|(js&13107)<<2,js=(js&61680)>>4|(js&3855)<<4,Cd[Yn]=((js&65280)>>8|(js&255)<<8)>>1}for(var ws=function(y,k,w){for(var _=y.length,R=0,M=new Vo(k);R<_;++R)y[R]&&++M[y[R]-1];var U=new Vo(k);for(R=1;R<k;++R)U[R]=U[R-1]+M[R-1]<<1;var V;{V=new Vo(1<<k);var fe=15-k;for(R=0;R<_;++R)if(y[R])for(var X=R<<4|y[R],ye=k-y[R],Qe=U[y[R]-1]++<<ye,He=Qe|(1<<ye)-1;Qe<=He;++Qe)V[Cd[Qe]>>fe]=X}return V},qu=new Cr(288),Yn=0;Yn<144;++Yn)qu[Yn]=8;for(var Yn=144;Yn<256;++Yn)qu[Yn]=9;for(var Yn=256;Yn<280;++Yn)qu[Yn]=7;for(var Yn=280;Yn<288;++Yn)qu[Yn]=8;for(var ri=new Cr(32),Yn=0;Yn<32;++Yn)ri[Yn]=5;var xs=ws(qu,9),Wo=ws(ri,5),Df=function(y){for(var k=y[0],w=1;w<y.length;++w)y[w]>k&&(k=y[w]);return k},Pa=function(y,k,w){var _=k/8|0;return(y[_]|y[_+1]<<8)>>(k&7)&w},Gi=function(y,k){var w=k/8|0;return(y[w]|y[w+1]<<8|y[w+2]<<16)>>(k&7)},Fa=function(y){return(y+7)/8|0},Of=function(y,k,w){return(w==null||w>y.length)&&(w=y.length),new Cr(y.subarray(k,w))},qb=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Ir=function(y,k,w){var _=new Error(k||qb[y]);if(_.code=y,Error.captureStackTrace&&Error.captureStackTrace(_,Ir),!w)throw _;return _},Mf=function(y,k,w,_){var R=y.length,M=0;if(!R||k.f&&!k.l)return w||new Cr(0);var U=!w,V=U||k.i!=2,fe=k.i;U&&(w=new Cr(R*3));var X=function(ta){var _r=w.length;if(ta>_r){var ks=new Cr(Math.max(_r*2,ta));ks.set(w),w=ks}},ye=k.f||0,Qe=k.p||0,He=k.b||0,Pe=k.l,ut=k.d,Cn=k.m,Xt=k.n,Ut=R*8;do{if(!Pe){ye=Pa(y,Qe,1);var Kt=Pa(y,Qe+1,3);if(Qe+=3,Kt)if(Kt==1)Pe=xs,ut=Wo,Cn=9,Xt=5;else if(Kt==2){var Vt=Pa(y,Qe,31)+257,Et=Pa(y,Qe+10,15)+4,_n=Vt+Pa(y,Qe+5,31)+1;Qe+=14;for(var Jt=new Cr(_n),Ct=new Cr(19),vt=0;vt<Et;++vt)Ct[lx[vt]]=Pa(y,Qe+vt*3,7);Qe+=Et*3;for(var Ki=Df(Ct),Td=(1<<Ki)-1,vs=ws(Ct,Ki),vt=0;vt<_n;){var mr=vs[Pa(y,Qe,Td)];Qe+=mr&15;var Ft=mr>>4;if(Ft<16)Jt[vt++]=Ft;else{var Pl=0,Pu=0;for(Ft==16?(Pu=3+Pa(y,Qe,3),Qe+=2,Pl=Jt[vt-1]):Ft==17?(Pu=3+Pa(y,Qe,7),Qe+=3):Ft==18&&(Pu=11+Pa(y,Qe,127),Qe+=7);Pu--;)Jt[vt++]=Pl}}var Kb=Jt.subarray(0,Vt),Ss=Jt.subarray(Vt);Cn=Df(Kb),Xt=Df(Ss),Pe=ws(Kb,Cn),ut=ws(Ss,Xt)}else Ir(1);else{var Ft=Fa(Qe)+4,tt=y[Ft-4]|y[Ft-3]<<8,nn=Ft+tt;if(nn>R){fe&&Ir(0);break}V&&X(He+tt),w.set(y.subarray(Ft,nn),He),k.b=He+=tt,k.p=Qe=nn*8,k.f=ye;continue}if(Qe>Ut){fe&&Ir(0);break}}V&&X(He+131072);for(var $b=(1<<Cn)-1,Uf=(1<<Xt)-1,Vf=Qe;;Vf=Qe){var Pl=Pe[Gi(y,Qe)&$b],zr=Pl>>4;if(Qe+=Pl&15,Qe>Ut){fe&&Ir(0);break}if(Pl||Ir(2),zr<256)w[He++]=zr;else if(zr==256){Vf=Qe,Pe=null;break}else{var ba=zr-254;if(zr>264){var vt=zr-257,Hl=Vb[vt];ba=Pa(y,Qe,(1<<Hl)-1)+Vl[vt],Qe+=Hl}var Wf=ut[Gi(y,Qe)&Uf],Ca=Wf>>4;Wf||Ir(3),Qe+=Wf&15;var Ss=Ed[Ca];if(Ca>3){var Hl=kd[Ca];Ss+=Gi(y,Qe)&(1<<Hl)-1,Qe+=Hl}if(Qe>Ut){fe&&Ir(0);break}V&&X(He+131072);var bx=He+ba;if(He<Ss){var Jb=M-Ss,yx=Math.min(Ss,bx);for(Jb+He<0&&Ir(3);He<yx;++He)w[He]=_[Jb+He]}for(;He<bx;++He)w[He]=w[He-Ss]}}k.l=Pe,k.p=Vf,k.b=He,k.f=ye,Pe&&(ye=1,k.m=Cn,k.d=ut,k.n=Xt)}while(!ye);return He!=w.length&&U?Of(w,0,He):w.subarray(0,He)},cx=new Cr(0),Wl=function(y){(y[0]!=31||y[1]!=139||y[2]!=8)&&Ir(6,"invalid gzip data");var k=y[3],w=10;k&4&&(w+=(y[10]|y[11]<<8)+2);for(var _=(k>>3&1)+(k>>4&1);_>0;_-=!y[w++]);return w+(k&2)},Bf=function(y){var k=y.length;return(y[k-4]|y[k-3]<<8|y[k-2]<<16|y[k-1]<<24)>>>0},dx=function(y,k){return((y[0]&15)!=8||y[0]>>4>7||(y[0]<<8|y[1])%31)&&Ir(6,"invalid zlib data"),(y[1]>>5&1)==1&&Ir(6,"invalid zlib data: "+(y[1]&32?"need":"unexpected")+" dictionary"),(y[1]>>3&4)+2};function px(y,k){return Mf(y,{i:2},k,k)}function hx(y,k){var w=Wl(y);return w+8>y.length&&Ir(6,"invalid gzip data"),Mf(y.subarray(w,-8),{i:2},new Cr(Bf(y)),k)}function Lf(y,k){return Mf(y.subarray(dx(y),-4),{i:2},k,k)}function Id(y,k){return y[0]==31&&y[1]==139&&y[2]==8?hx(y,k):(y[0]&15)!=8||y[0]>>4>7||(y[0]<<8|y[1])%31?px(y,k):Lf(y,k)}typeof TextEncoder<"u"&&new TextEncoder;var Pb=typeof TextDecoder<"u"&&new TextDecoder,fx=0;try{Pb.decode(cx,{stream:!0}),fx=1}catch{}var Hb=Yt(764).lW;class n2 extends Error{constructor(k){super(k)}}class mx{constructor(k,w={threads:1},_={recursive:!1}){this.backendOptions=w,this.circuitOptions=_,this.acirUncompressedBytecode=Gb(k)}async instantiate(){if(!this.api){const k=await qo.new(this.backendOptions),w=!1,[_,R]=await k.acirGetCircuitSizes(this.acirUncompressedBytecode,this.circuitOptions.recursive,w);await k.initSRSForCircuitSize(R),this.acirComposer=await k.acirNewAcirComposer(R),await k.acirInitProvingKey(this.acirComposer,this.acirUncompressedBytecode,this.circuitOptions.recursive),this.api=k}}async generateProof(k){await this.instantiate();const w=await this.api.acirCreateProof(this.acirComposer,this.acirUncompressedBytecode,this.circuitOptions.recursive,Id(k)),R=w.length-2144,M=w.slice(0,R),U=w.slice(R),V=vd(M);return{proof:U,publicInputs:V}}async generateRecursiveProofArtifacts(k,w=0){await this.instantiate();const _=xd(k),R=(await this.api.acirSerializeProofIntoFields(this.acirComposer,_,w)).slice(w);await this.api.acirInitVerificationKey(this.acirComposer);const M=await this.api.acirSerializeVerificationKeyIntoFields(this.acirComposer);return{proofAsFields:R.map(U=>U.toString()),vkAsFields:M[0].map(U=>U.toString()),vkHash:M[1].toString()}}async verifyProof(k){await this.instantiate(),await this.api.acirInitVerificationKey(this.acirComposer);const w=xd(k);return await this.api.acirVerifyProof(this.acirComposer,w)}async getVerificationKey(){return await this.instantiate(),await this.api.acirInitVerificationKey(this.acirComposer),await this.api.acirGetVerificationKey(this.acirComposer)}async getSolidityVerifier(){return await this.instantiate(),await this.api.acirInitVerificationKey(this.acirComposer),await this.api.acirGetSolidityVerifier(this.acirComposer)}async destroy(){this.api&&await this.api.destroy()}}class Ha{constructor(k,w={threads:1},_={recursive:!1}){this.backendOptions=w,this.circuitOptions=_,this.acirUncompressedBytecode=Gb(k)}async instantiate(){if(!this.api){const k=await qo.new(this.backendOptions);await k.acirInitSRS(this.acirUncompressedBytecode,this.circuitOptions.recursive,!0),this.api=k}}async generateProof(k,w){await this.instantiate();const R=await(w!=null&&w.keccak?this.api.acirProveUltraKeccakHonk.bind(this.api):this.api.acirProveUltraHonk.bind(this.api))(this.acirUncompressedBytecode,this.circuitOptions.recursive,Id(k)),U=await(w!=null&&w.keccak?this.api.acirWriteVkUltraKeccakHonk.bind(this.api):this.api.acirWriteVkUltraHonk.bind(this.api))(this.acirUncompressedBytecode,this.circuitOptions.recursive),V=await this.api.acirVkAsFieldsUltraHonk(new $e(U)),fe=Number(V[1].toString()),{proof:X,publicInputs:ye}=Tf(R,fe),Qe=vd(ye);return{proof:X,publicInputs:Qe}}async generateProofForRecursiveAggregation(k,w){await this.instantiate();const R=await(w!=null&&w.keccak?this.api.acirProveUltraKeccakHonk.bind(this.api):this.api.acirProveUltraHonk.bind(this.api))(this.acirUncompressedBytecode,this.circuitOptions.recursive,Id(k)),U=await(w!=null&&w.keccak?this.api.acirWriteVkUltraKeccakHonk.bind(this.api):this.api.acirWriteVkUltraHonk.bind(this.api))(this.acirUncompressedBytecode,this.circuitOptions.recursive),V=await this.api.acirVkAsFieldsUltraHonk(new $e(U)),ye=Number(V[1].toString())-16,{proof:Qe,publicInputs:He}=Tf(R,ye),Pe=vd(He);return{proof:vd(Qe),publicInputs:Pe}}async verifyProof(k,w){await this.instantiate();const _=Nf(Rf(k.publicInputs),k.proof),R=w!=null&&w.keccak?this.api.acirWriteVkUltraKeccakHonk.bind(this.api):this.api.acirWriteVkUltraHonk.bind(this.api),M=w!=null&&w.keccak?this.api.acirVerifyUltraKeccakHonk.bind(this.api):this.api.acirVerifyUltraHonk.bind(this.api),U=await R(this.acirUncompressedBytecode,this.circuitOptions.recursive);return await M(_,new $e(U))}async getVerificationKey(k){return await this.instantiate(),k!=null&&k.keccak?await this.api.acirWriteVkUltraKeccakHonk(this.acirUncompressedBytecode,this.circuitOptions.recursive):await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode,this.circuitOptions.recursive)}async getSolidityVerifier(k){await this.instantiate();const w=k??await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode,this.circuitOptions.recursive);return await this.api.acirHonkSolidityVerifier(this.acirUncompressedBytecode,new $e(w))}async generateRecursiveProofArtifacts(k,w){await this.instantiate();const _=await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode,this.circuitOptions.recursive),R=await this.api.acirVkAsFieldsUltraHonk(_);return{proofAsFields:[],vkAsFields:R.map(M=>M.toString()),vkHash:""}}async destroy(){this.api&&await this.api.destroy()}}class tr{constructor(k,w={threads:1}){this.acirMsgpack=k,this.options=w}async instantiate(){if(!this.api){const k=await qo.new(this.options);await k.initSRSClientIVC(),this.api=k}}async prove(k){await this.instantiate();const w=await this.api.acirProveAztecClient(this.acirMsgpack,k),[_,R]=w;if(!await this.verify(_,R))throw new n2("Failed to verify the private (ClientIVC) transaction proof!");return w}async verify(k,w){return await this.instantiate(),this.api.acirVerifyAztecClient(k,w)}async proveAndVerify(k){return await this.instantiate(),this.api.acirProveAndVerifyAztecClient(this.acirMsgpack,k)}async gates(){return await this.instantiate(),this.api.acirGatesAztecClient(this.acirMsgpack)}async destroy(){this.api&&await this.api.destroy()}}function Gb(y){const k=gx(y);return Id(k)}function gx(y){if(typeof Hb<"u"){const k=Hb.from(y,"base64");return new Uint8Array(k.buffer,k.byteOffset,k.byteLength)}else{if(typeof atob=="function")return Uint8Array.from(atob(y),k=>k.charCodeAt(0));throw new Error("No implementation found for base64 decoding.")}}class qo extends fi{constructor(k,w,_){super(w),this.worker=k,this.options=_}static async new(k={}){var U,V;const w=Je(),_=Ze(w),{module:R,threads:M}=await Ub(k.threads,k.wasmPath,k.logger);return await _.init(R,M,xe(k.logger??Va()("bb.js:bb_wasm_async")),(U=k.memory)==null?void 0:U.initial,(V=k.memory)==null?void 0:V.maximum),new qo(w,_,k)}async getNumThreads(){return await this.wasm.getNumThreads()}async initSRSForCircuitSize(k){const w=await h.new(k+1,this.options.crsPath,this.options.logger);await this.srsInitSrs(new $e(w.getG1Data()),w.numPoints,new $e(w.getG2Data()))}async initSRSClientIVC(){const k=await h.new(1048577,this.options.crsPath,this.options.logger),w=await m.new(2**16+1,this.options.crsPath,this.options.logger);await this.srsInitSrs(new $e(k.getG1Data()),k.numPoints,new $e(k.getG2Data())),await this.srsInitGrumpkinSrs(new $e(w.getG1Data()),w.numPoints)}async acirInitSRS(k,w,_){const[R,M]=await this.acirGetCircuitSizes(k,w,_);return this.initSRSForCircuitSize(M)}async destroy(){await this.wasm.destroy(),await this.worker.terminate()}}let zf,_d;class ql extends ls{constructor(k){super(k)}static async new(k,w=Va()("bb.js:bb_wasm_sync")){const _=new Wa,{module:R,threads:M}=await Ub(1,k,w);return await _.init(R,M,w),new ql(_)}static async initSingleton(k,w=Va()("bb.js:bb_wasm_sync")){return zf||(zf=ql.new(k,w)),_d=await zf,_d}static getSingleton(){if(!_d)throw new Error("First call BarretenbergSync.initSingleton() on @aztec/bb.js module.");return _d}getWasm(){return this.wasm}}})();os.Dv;os.Zh;os.AL;os.tD;os.i2;os.Fr;os.pS;os.ld;var AV=os.yh;os._7;os.H2;os.ly;const $ke="1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",Jke=0xc822ca4aa8f71800,Yke={parameters:[{name:"x",type:{kind:"array",length:128,type:{kind:"struct",path:"quantized::quantized::Quantized",fields:[{name:"x",type:{kind:"field"}}]}},visibility:"private"}],return_type:{abi_type:{kind:"field"},visibility:"public"},error_types:{}},jke="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",Qke="5dzNattAGIXhe9Haizkz3/z5VkoJsi0HgZCMLReKyb1XCVEbaGkWhS707iJ7LHxWeUjs99GcusP9+akfz9Ot2X95NMN0bOd+GperR+PeHrpd2vH16ja317nZex92TTeelp9yfNk1537omn3Sy+63oyH696Om9Oto+cNR70tdbxuc//thBbceVvDlk8POr+9CLsWPh7/uGm1/ot/+xLD9ibb9iXH7E9P2J+btTyzbn1gBv/oJvAH4RgDgCCAcGWAjwDgCIEcA5QjAHAGc4wHO8YS/4wCc4wHO8QbYCHCOBzjHA5zjAc7xAOcEgHMCwDmB8A8rgHOCATYCnBMAzgkA5wSAcwLAOQZwjgGcYwDnGOGTOQbYCHCOAZxjAOcYwDkGcE4EOCcCnBMBzokA50QDbAQ4JwKcEwHOiQDnRIBzEsA5CeCcBHBOAjgnGWAj4btWAOckgHMSwDkJ4JwMcE4GOCcDnJMBzskG2AhwTiZ8qRzgnAxwTgY4pwCcUwDOKQDnFIBzigE2ApxTAM4phHoOwDkF4JwKcE4FOKcCnFMBzqkG2AhwTgU4pwKcUwmZQEQnkBAKdIRSoCOkAh2hFeiMMJJQC3SEXKAj9AIdIRjoCOJhpJEJ4kHEkRF1ZEQeGdFHRgSSEYVkRCKZ0EgWIZIsQiVZhEyyCJ1kEULJIpSSRUgli9BKFiGWLEItWYRcsgi9ZBGCySIUk0VIJovQTBYhmixCNVmEbLII3WQRwskilJNFSCeL0E4WIZ4sQj1ZhHyyCP1kEQLKIhSURUgoi9BQFiGiLEJFWYSMsggdZRFCyiKUlEVIKYvQUhYhpixCTVmEnLIIPWURgsoiFJX1X5PKWennbYP75H3nvL4H5er/bWQmjCxbH7lcHK79MPTPT8N0bOd+Gm/LS5eHv7XXvj0M3fvl+T4ePzw7f7+sz6yvv1ynY3e6X7vXO709t9z+Bw==",Zke={61:{source:`use dep::quantized::quantized::Quantized;

fn main(x: [Quantized; 128]) -> pub Field {
    // Return hash of the registered face
    let mut field_arr = [0;128];
    for i in 0..128 {
      field_arr[i] = x[i].x;
    }
    poseidon::poseidon2::Poseidon2::hash(field_arr, 128)
}`,path:"/Users/elena/Documents/hashcloak/learning/hackathons/2025/noirhack/zkface-demo/circuits/face_hash/src/main.nr"},68:{source:`use std::default::Default;
use std::hash::Hasher;

comptime global RATE: u32 = 3;

pub struct Poseidon2 {
    cache: [Field; 3],
    state: [Field; 4],
    cache_size: u32,
    squeeze_mode: bool, // 0 => absorb, 1 => squeeze
}

impl Poseidon2 {
    #[no_predicates]
    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {
        Poseidon2::hash_internal(input, message_size, message_size != N)
    }

    pub(crate) fn new(iv: Field) -> Poseidon2 {
        let mut result =
            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };
        result.state[RATE] = iv;
        result
    }

    fn perform_duplex(&mut self) {
        // add the cache into sponge state
        for i in 0..RATE {
            // We effectively zero-pad the cache by only adding to the state
            // cache that is less than the specified \`cache_size\`
            if i < self.cache_size {
                self.state[i] += self.cache[i];
            }
        }
        self.state = crate::poseidon2_permutation(self.state, 4);
    }

    fn absorb(&mut self, input: Field) {
        assert(!self.squeeze_mode);
        if self.cache_size == RATE {
            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache
            self.perform_duplex();
            self.cache[0] = input;
            self.cache_size = 1;
        } else {
            // If we're absorbing, and the cache is not full, add the input into the cache
            self.cache[self.cache_size] = input;
            self.cache_size += 1;
        }
    }

    fn squeeze(&mut self) -> Field {
        assert(!self.squeeze_mode);
        // If we're in absorb mode, apply sponge permutation to compress the cache.
        self.perform_duplex();
        self.squeeze_mode = true;

        // Pop one item off the top of the permutation and return it.
        self.state[0]
    }

    fn hash_internal<let N: u32>(
        input: [Field; N],
        in_len: u32,
        is_variable_length: bool,
    ) -> Field {
        let two_pow_64 = 18446744073709551616;
        let iv: Field = (in_len as Field) * two_pow_64;
        let mut sponge = Poseidon2::new(iv);
        for i in 0..input.len() {
            if i < in_len {
                sponge.absorb(input[i]);
            }
        }

        // In the case where the hash preimage is variable-length, we append \`1\` to the end of the input, to distinguish
        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures
        // fixed-length and variable-length hashes do not collide)
        if is_variable_length {
            sponge.absorb(1);
        }
        sponge.squeeze()
    }
}

pub struct Poseidon2Hasher {
    _state: [Field],
}

impl Hasher for Poseidon2Hasher {
    fn finish(self) -> Field {
        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)
        let mut sponge = Poseidon2::new(iv);
        for i in 0..self._state.len() {
            sponge.absorb(self._state[i]);
        }
        sponge.squeeze()
    }

    fn write(&mut self, input: Field) {
        self._state = self._state.push_back(input);
    }
}

impl Default for Poseidon2Hasher {
    fn default() -> Self {
        Poseidon2Hasher { _state: &[] }
    }
}
`,path:"/Users/elena/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr"}},Xke=["main"],eAe=[],u3={noir_version:$ke,hash:Jke,abi:Yke,bytecode:jke,debug_symbols:Qke,file_map:Zke,names:Xke,brillig_names:eAe},tAe="1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",nAe=0xc2818bd1f12b0000,aAe={parameters:[{name:"x",type:{kind:"array",length:128,type:{kind:"struct",path:"quantized::quantized::Quantized",fields:[{name:"x",type:{kind:"field"}}]}},visibility:"private"},{name:"registered",type:{kind:"array",length:128,type:{kind:"struct",path:"quantized::quantized::Quantized",fields:[{name:"x",type:{kind:"field"}}]}},visibility:"private"}],return_type:{abi_type:{kind:"field"},visibility:"public"},error_types:{"6485997221020871071":{error_kind:"string",string:"call to assert_max_bit_size"},"17843811134343075018":{error_kind:"string",string:"Stack too deep"}}},rAe="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",iAe="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",sAe=JSON.parse('{"17":{"source":"use crate::field::field_less_than;\\nuse crate::runtime::is_unconstrained;\\n\\n// The low and high decomposition of the field modulus\\nglobal PLO: Field = 53438638232309528389504892708671455233;\\nglobal PHI: Field = 64323764613183177041862057485226039389;\\n\\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\\nglobal TWO_POW_64: Field = 0x10000000000000000;\\n\\n// Decomposes a single field into two 16 byte fields.\\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\\n    // Here\'s we\'re taking advantage of truncating 64 bit limbs from the input field\\n    // and then subtracting them from the input such the field division is equivalent to integer division.\\n    let low_lower_64 = (x as u64) as Field;\\n    x = (x - low_lower_64) / TWO_POW_64;\\n    let low_upper_64 = (x as u64) as Field;\\n\\n    let high = (x - low_upper_64) / TWO_POW_64;\\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\\n\\n    (low, high)\\n}\\n\\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\\n    compute_decomposition(x)\\n}\\n\\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\\n    if x == y {\\n        true\\n    } else {\\n        field_less_than(x, y)\\n    }\\n}\\n\\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\\n    let (alo, ahi) = a;\\n    let (blo, bhi) = b;\\n    // Safety: borrow is enforced to be boolean due to its type.\\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n    unsafe {\\n        let borrow = lte_hint(alo, blo);\\n\\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\\n        let rhi = ahi - bhi - (borrow as Field);\\n\\n        rlo.assert_max_bit_size::<128>();\\n        rhi.assert_max_bit_size::<128>();\\n    }\\n}\\n\\n/// Decompose a single field into two 16 byte fields.\\npub fn decompose(x: Field) -> (Field, Field) {\\n    if is_unconstrained() {\\n        compute_decomposition(x)\\n    } else {\\n        // Safety: decomposition is properly checked below\\n        unsafe {\\n            // Take hints of the decomposition\\n            let (xlo, xhi) = decompose_hint(x);\\n\\n            // Range check the limbs\\n            xlo.assert_max_bit_size::<128>();\\n            xhi.assert_max_bit_size::<128>();\\n\\n            // Check that the decomposition is correct\\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\\n\\n            // Assert that the decomposition of P is greater than the decomposition of x\\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\\n            (xlo, xhi)\\n        }\\n    }\\n}\\n\\npub fn assert_gt(a: Field, b: Field) {\\n    if is_unconstrained() {\\n        assert(\\n            // Safety: already unconstrained\\n            unsafe { field_less_than(b, a) },\\n        );\\n    } else {\\n        // Decompose a and b\\n        let a_limbs = decompose(a);\\n        let b_limbs = decompose(b);\\n\\n        // Assert that a_limbs is greater than b_limbs\\n        assert_gt_limbs(a_limbs, b_limbs)\\n    }\\n}\\n\\npub fn assert_lt(a: Field, b: Field) {\\n    assert_gt(b, a);\\n}\\n\\npub fn gt(a: Field, b: Field) -> bool {\\n    if is_unconstrained() {\\n        // Safety: unsafe in unconstrained\\n        unsafe {\\n            field_less_than(b, a)\\n        }\\n    } else if a == b {\\n        false\\n    } else {\\n        // Safety: Take a hint of the comparison and verify it\\n        unsafe {\\n            if field_less_than(a, b) {\\n                assert_gt(b, a);\\n                false\\n            } else {\\n                assert_gt(a, b);\\n                true\\n            }\\n        }\\n    }\\n}\\n\\npub fn lt(a: Field, b: Field) -> bool {\\n    gt(b, a)\\n}\\n\\nmod tests {\\n    // TODO: Allow imports from \\"super\\"\\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\\n\\n    #[test]\\n    fn check_decompose() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_decompose_unconstrained() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_lte_hint() {\\n        assert(lte_hint(0, 1));\\n        assert(lte_hint(0, 0x100));\\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\\n        assert(!lte_hint(0 - 1, 0));\\n\\n        assert(lte_hint(0, 0));\\n        assert(lte_hint(0x100, 0x100));\\n        assert(lte_hint(0 - 1, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_assert_gt() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn check_assert_gt_unconstrained() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    fn check_gt() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_gt_unconstrained() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_plo_phi() {\\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\\n        let p_bytes = crate::field::modulus_le_bytes();\\n        let mut p_low: Field = 0;\\n        let mut p_high: Field = 0;\\n\\n        let mut offset = 1;\\n        for i in 0..16 {\\n            p_low += (p_bytes[i] as Field) * offset;\\n            p_high += (p_bytes[i + 16] as Field) * offset;\\n            offset *= 256;\\n        }\\n        assert_eq(p_low, PLO);\\n        assert_eq(p_high, PHI);\\n    }\\n}\\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\\nuse crate::{runtime::is_unconstrained, static_assert};\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    /// Asserts that `self` can be represented in `bit_size` bits.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\\n    // docs:start:assert_max_bit_size\\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\\n        // docs:end:assert_max_bit_size\\n        static_assert(\\n            BIT_SIZE < modulus_num_bits() as u32,\\n            \\"BIT_SIZE must be less than modulus_num_bits\\",\\n        );\\n        self.__assert_max_bit_size(BIT_SIZE);\\n    }\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_le_bits)]\\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_be_bits)]\\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_le_bits\\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_le_bits\\n        let bits = self._to_le_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(p[N - 1 - i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\\n    // docs:start:to_be_bits\\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\\n        // docs:end:to_be_bits\\n        let bits = self._to_be_bits();\\n\\n        if !is_unconstrained() {\\n            // Ensure that the decomposition does not overflow the modulus\\n            let p = modulus_be_bits();\\n            assert(bits.len() <= p.len());\\n            let mut ok = bits.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bits[i] != p[i]) {\\n                        assert(p[i] == 1);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bits\\n    }\\n\\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_le_bytes\\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_le_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_le_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_be_bytes\\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_be_bytes\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        // Compute the byte decomposition\\n        let bytes = self.to_be_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_be_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[i] != p[i]) {\\n                        assert(bytes[i] < p[i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    // docs:start:to_le_radix\\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            static_assert(1 < radix, \\"radix must be greater than 1\\");\\n            static_assert(radix <= 256, \\"radix must be less than or equal to 256\\");\\n            static_assert(radix & (radix - 1) == 0, \\"radix must be a power of 2\\");\\n        }\\n        self.__to_le_radix(radix)\\n    }\\n    // docs:end:to_le_radix\\n\\n    // docs:start:to_be_radix\\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            crate::assert_constant(radix);\\n        }\\n        self.__to_be_radix(radix)\\n    }\\n    // docs:end:to_be_radix\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b: [u1; 32] = exponent.to_le_bits();\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n\\n    /// Convert a little endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        static_assert(\\n            N <= modulus_le_bytes().len(),\\n            \\"N must be less than or equal to modulus_le_bytes().len()\\",\\n        );\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n\\n    /// Convert a big endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[N - 1 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub comptime fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub comptime fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub comptime fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub comptime fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub comptime fn modulus_le_bytes() -> [u8] {}\\n\\n/// An unconstrained only built in to efficiently compare fields.\\n#[builtin(field_less_than)]\\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\\n\\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\\n    __field_less_than(x, y)\\n}\\n\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    if is_unconstrained() {\\n        // Safety: unconstrained context\\n        unsafe {\\n            field_less_than(x, y)\\n        }\\n    } else {\\n        let x_bytes: [u8; 32] = x.to_le_bytes();\\n        let y_bytes: [u8; 32] = y.to_le_bytes();\\n        let mut x_is_lt = false;\\n        let mut done = false;\\n        for i in 0..32 {\\n            if (!done) {\\n                let x_byte = x_bytes[32 - 1 - i] as u8;\\n                let y_byte = y_bytes[32 - 1 - i] as u8;\\n                let bytes_match = x_byte == y_byte;\\n                if !bytes_match {\\n                    x_is_lt = x_byte < y_byte;\\n                    done = true;\\n                }\\n            }\\n        }\\n        x_is_lt\\n    }\\n}\\n\\nmod tests {\\n    use crate::{panic::panic, runtime};\\n    use super::field_less_than;\\n\\n    #[test]\\n    // docs:start:to_be_bits_example\\n    fn test_to_be_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_be_bits();\\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\\n    }\\n    // docs:end:to_be_bits_example\\n\\n    #[test]\\n    // docs:start:to_le_bits_example\\n    fn test_to_le_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_le_bits();\\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\\n    }\\n    // docs:end:to_le_bits_example\\n\\n    #[test]\\n    // docs:start:to_be_bytes_example\\n    fn test_to_be_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_bytes();\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_bytes_example\\n\\n    #[test]\\n    // docs:start:to_le_bytes_example\\n    fn test_to_le_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_bytes();\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_bytes_example\\n\\n    #[test]\\n    // docs:start:to_be_radix_example\\n    fn test_to_be_radix() {\\n        // 259, in base 256, big endian, is [1, 3].\\n        // i.e. 3 * 256^0 + 1 * 256^1\\n        let field = 259;\\n\\n        // The radix (in this example, 256) must be a power of 2.\\n        // The length of the returned byte array can be specified to be\\n        // >= the amount of space needed.\\n        let bytes: [u8; 8] = field.to_be_radix(256);\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_radix_example\\n\\n    #[test]\\n    // docs:start:to_le_radix_example\\n    fn test_to_le_radix() {\\n        // 259, in base 256, little endian, is [3, 1].\\n        // i.e. 3 * 256^0 + 1 * 256^1\\n        let field = 259;\\n\\n        // The radix (in this example, 256) must be a power of 2.\\n        // The length of the returned byte array can be specified to be\\n        // >= the amount of space needed.\\n        let bytes: [u8; 8] = field.to_le_radix(256);\\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_radix_example\\n\\n    #[test(should_fail_with = \\"radix must be greater than 1\\")]\\n    fn test_to_le_radix_1() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(1);\\n        } else {\\n            panic(f\\"radix must be greater than 1\\");\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\\n    //#[test]\\n    //fn test_to_le_radix_brillig_1() {\\n    //    // this test should only fail in constrained mode\\n    //    if runtime::is_unconstrained() {\\n    //        let field = 1;\\n    //        let out: [u8; 8] = field.to_le_radix(1);\\n    //        crate::println(out);\\n    //        let expected = [0; 8];\\n    //        assert(out == expected, \\"unexpected result\\");\\n    //    }\\n    //}\\n\\n    #[test(should_fail_with = \\"radix must be a power of 2\\")]\\n    fn test_to_le_radix_3() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(3);\\n        } else {\\n            panic(f\\"radix must be a power of 2\\");\\n        }\\n    }\\n\\n    #[test]\\n    fn test_to_le_radix_brillig_3() {\\n        // this test should only fail in constrained mode\\n        if runtime::is_unconstrained() {\\n            let field = 1;\\n            let out: [u8; 8] = field.to_le_radix(3);\\n            let mut expected = [0; 8];\\n            expected[0] = 1;\\n            assert(out == expected, \\"unexpected result\\");\\n        }\\n    }\\n\\n    #[test(should_fail_with = \\"radix must be less than or equal to 256\\")]\\n    fn test_to_le_radix_512() {\\n        // this test should only fail in constrained mode\\n        if !runtime::is_unconstrained() {\\n            let field = 2;\\n            let _: [u8; 8] = field.to_le_radix(512);\\n        } else {\\n            panic(f\\"radix must be less than or equal to 256\\")\\n        }\\n    }\\n\\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\\n    //#[test]\\n    //fn test_to_le_radix_brillig_512() {\\n    //    // this test should only fail in constrained mode\\n    //    if runtime::is_unconstrained() {\\n    //        let field = 1;\\n    //        let out: [u8; 8] = field.to_le_radix(512);\\n    //        let mut expected = [0; 8];\\n    //        expected[0] = 1;\\n    //        assert(out == expected, \\"unexpected result\\");\\n    //    }\\n    //}\\n\\n    #[test]\\n    unconstrained fn test_field_less_than() {\\n        assert(field_less_than(0, 1));\\n        assert(field_less_than(0, 0x100));\\n        assert(field_less_than(0x100, 0 - 1));\\n        assert(!field_less_than(0 - 1, 0));\\n    }\\n}\\n","path":"std/field/mod.nr"},"61":{"source":"use dep::quantized::quantized::Quantized;\\n\\n// Prove that you match a registered face\\npub fn main(x: [Quantized; 128], registered: [Quantized; 128]) -> pub Field {\\n    let mut sum: Quantized = Quantized::new(0);\\n\\n    for i in 0..128 {\\n      let diff = x[i] - registered[i];\\n      sum += diff;\\n    }\\n\\n    // Match threshold = 1_500_000_000\\n    assert(sum < Quantized::new(98304000000000));\\n    // Return hash of the registered face\\n    let mut field_arr = [0;128];\\n    for i in 0..128 {\\n      field_arr[i] = registered[i].x;\\n    }\\n    poseidon::poseidon2::Poseidon2::hash(field_arr, 128)\\n\\n}\\n","path":"/Users/elena/Documents/hashcloak/learning/hackathons/2025/noirhack/zkface-demo/circuits/face-eq/src/main.nr"},"68":{"source":"use std::default::Default;\\nuse std::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n","path":"/Users/elena/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr"},"71":{"source":"use std::cmp::Ordering;\\nuse std::field::bn254::decompose;\\nuse std::ops::{Add, Div, Mul, Sub};\\n\\n// IMPORTANT: This library is designed to work with a fixed scale factor of 2^16\\n// See further explanation in the `Quantized` struct comments below.\\nglobal scale: Field = 65536; // 2^16\\n\\n// A signed fixed-point number `x` is represented in a single Field element.\\n//\\n// Representation Overview:\\n// A Field element is a type with 254 bits.\\n// We only use the first 126 or the last 126 bits.\\n// A positive number is within the first 126 bits.\\n// A negative numbers is within the last 126 bits.\\n// The \\"middle\\" 2 bits that are left over, should not be used.\\n// - Positive values have bits set in the lower part: |x_0,x_1,x_2,..,x_125, ... ,_,_,_,_|\\n// - Negative values have bits set in the upper part: |_,_,_,_, .. x_128,x_129,..,x_253|\\n// So following above visual, x_126 and x_127 MUST be 0\\n//\\n// Modular arithmetic ensures correct handling of signed fixed-point numbers by wrapping\\n// values around the field\'s modulus. For example, subtracting 5 from 3 in a field with\\n// modulus `p` results in (3 - 5) mod p = p - 2, representing -2. This behavior allows\\n// negative values to be correctly encoded in the field\'s upper range.\\n//\\n// Scaling:\\n// Since fields do not inherently support decimal values, the fixed-point representation\\n// uses a scale of 2^-16. This means that:\\n// - `Quantized { x: 1 }` represents the value 1/2^16.\\n// - To represent an original value, divide it by the scale, truncate, and store the result.\\n// Example:\\n// - Original value: 0.001\\n// - Scaled value: 0.001 * 2^16 = 65.536\\n// - Truncated result: 65 (stored as `Quantized { x: 65 }`)\\n//\\n// Overflow and overflow prevention:\\n// To make sure the arithmetic performed on a value will not overflow, the library contains\\n// bitsize checks that prevent numbers from growing larger than 126 bits. More concretely:\\n// - multiplication: inputs must have bitsize <= 63\\n// - addition: inputs must have bitsize <=125\\n// - subtraction: inputs must have bitsize <=125\\n//\\n// Conversion Steps to `Quantized`:\\n// 1. Check if the original value `x` is negative. If negative, use (p - |x|), where `p` is\\n//    the field\'s prime modulus. Otherwise, proceed with `x`.\\n// 2. Multiply the value by the scale factor (e.g., 2^16).\\n// 3. Store the scaled value in a `Quantized` struct.\\n//\\n// Prime Modulus:\\n// The field modulus `p` used in this implementation is:\\n//   p = 21888242871839275222246405745257275088548364400416034343698204186575808495617\\n// This prime comes from the Barretenberg backend.\\npub struct Quantized {\\n    pub x: Field,\\n}\\n\\n// returns 1 for a negative element, 0 for a positive element\\n// A Quantized element is negative if the upper bits are set, so this is what we check for.\\n// NOTE: this asserts the field contains has maximum 126 bits. If the element contains more than\\n// 126 bits either way, this function cannot correctly indicate whether it\'s negative or not.\\nfn is_negative(x: Field) -> Field {\\n    let (lower_bytes, higher_bytes) = decompose(x);\\n    if higher_bytes == 0 {\\n        // Make sure the number is not overflowing the 126 bits\\n        x.assert_max_bit_size::<126>();\\n        0\\n    } else {\\n        1\\n    }\\n}\\n\\nimpl Quantized {\\n    // Assert that number of bits <= bitsize\\n    // if quantized is negative, it counts the bits backwards\\n    // NOTE: this works only for bitsize <= 126, because decompose gives us\\n    // 128 and 126 bits\\n    pub fn assert_bitsize<let bitsize: u32>(self: Self) {\\n        // Decomposes into two 128 bits chunks\\n        let (lower_bytes, higher_bytes) = decompose(self.x);\\n        if higher_bytes == 0 {\\n            // positive number\\n            self.x.assert_max_bit_size::<bitsize>();\\n        } else {\\n            // negative number\\n            (-self.x).assert_max_bit_size::<bitsize>();\\n        }\\n    }\\n\\n    pub fn zero() -> Self {\\n        Quantized { x: 0 }\\n    }\\n\\n    pub fn new(x: Field) -> Self {\\n        let res = Self { x: x };\\n        res.assert_bitsize::<126>();\\n        res\\n    }\\n\\n    fn add(self: Self, other: Self) -> Self {\\n        // To prevent overflow, allow max 125 bits for both inputs\\n        self.assert_bitsize::<125>();\\n        other.assert_bitsize::<125>();\\n        Quantized { x: self.x + other.x } // if one is negative, this wraps around automatically\\n    }\\n\\n    fn sub(self: Self, other: Self) -> Self {\\n        // To prevent overflow, allow max 125 bits for both inputs\\n        self.assert_bitsize::<125>();\\n        other.assert_bitsize::<125>();\\n        Quantized { x: self.x - other.x }\\n    }\\n\\n    fn mul(self: Self, other: Self) -> Self {\\n        // To prevent overflow, allow max 63 bits for both inputs\\n        // Perform multiplication of the underlying field elements\\n        // This doubles the scale.\\n        self.assert_bitsize::<63>();\\n        other.assert_bitsize::<63>();\\n        let mut temp: Field = self.x * other.x;\\n\\n        // Scale down by dividing by 2^16\\n        // Since the scale is a multiple of 2^8, this will scale it down correctly.\\n        // Note that we have to take care of the case that the value is negative; in that case we flip the sign\\n        // temporarily, and flip it back at the end. Otherwise the division doesn\'t work\\n\\n        // Check whether we\'re working with a negative value\\n        let negative = is_negative(temp);\\n\\n        temp = negative\\n            * (\\n                21888242871839275222246405745257275088548364400416034343698204186575808495616 - temp\\n                    + 1\\n                    - temp\\n            )\\n            + temp;\\n\\n        // Division by 2^16, code as suggested by Tom French @TomAFrench\\n        // Cast x to a u16 to preserve only the lowest 16 bits.\\n        let lowest_16_bits = temp as u16;\\n\\n        // Subtract off the lowest 16 bits so they are cleared.\\n        let temp_with_cleared_lower_bits = temp - lowest_16_bits as Field;\\n\\n        // The lowest 16 bits are clear, `x_with_cleared_lower_bits` is divisible by `65536`,\\n        // therefore field division is equivalent to integer division.\\n        let mut final_res: Field = temp_with_cleared_lower_bits / 65536;\\n\\n        // If the result was originally negative, flip the sign back\\n        final_res = negative\\n            * (\\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\\n                    - final_res\\n                    + 1\\n                    - final_res\\n            )\\n            + final_res;\\n\\n        // Return the result as a new Quantized instance\\n        Quantized { x: final_res }\\n    }\\n\\n    fn div(self: Self, other: Self) -> Self {\\n        // Ensure `other` is not zero\\n        assert(other.x != 0, \\"Division by zero is not allowed.\\");\\n        self.assert_bitsize::<109>(); // will be multiplied by scale later, so we allow 126-17 bits\\n        other.assert_bitsize::<126>(); // standard bitsize check\\n        // Flip signs of numerator and denominator if negative, work with their absolute values\\n        let mut numerator = self.x;\\n        let mut denominator = other.x;\\n\\n        let mut numerator_is_negative = is_negative(numerator);\\n        let mut denominator_is_negative = is_negative(denominator);\\n\\n        numerator = numerator_is_negative\\n            * (\\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\\n                    - numerator\\n                    + 1\\n                    - numerator\\n            )\\n            + numerator;\\n\\n        denominator = denominator_is_negative\\n            * (\\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\\n                    - denominator\\n                    + 1\\n                    - denominator\\n            )\\n            + denominator;\\n\\n        // Scale numerator before division\\n        let scaled_numerator = numerator * scale;\\n\\n        // Cast to U128 for division\\n        let scaled_numerator_u128 = U128::from_le_bytes(scaled_numerator.to_le_bytes());\\n        let denominator_u128 = U128::from_le_bytes(denominator.to_le_bytes());\\n\\n        // Perform the division in U128\\n        let result_u128 = scaled_numerator_u128 / denominator_u128;\\n\\n        // Cast back to Field\\n        let mut result = Field::from_le_bytes(result_u128.to_le_bytes());\\n\\n        // Determine the sign of the result\\n        let result_is_negative = numerator_is_negative + denominator_is_negative == 1;\\n\\n        // If result is negative, flip sign back\\n        if result_is_negative {\\n            result = 21888242871839275222246405745257275088548364400416034343698204186575808495616\\n                - result\\n                + 1;\\n        }\\n\\n        Quantized { x: result }\\n    }\\n}\\n\\nimpl Add for Quantized {\\n    fn add(self, other: Self) -> Self {\\n        self.add(other)\\n    }\\n}\\n\\nimpl Sub for Quantized {\\n    fn sub(self, other: Self) -> Self {\\n        self.sub(other)\\n    }\\n}\\n\\nimpl Mul for Quantized {\\n    fn mul(self, other: Self) -> Self {\\n        self.mul(other)\\n    }\\n}\\n\\nimpl Div for Quantized {\\n    fn div(self, other: Self) -> Self {\\n        self.div(other)\\n    }\\n}\\n\\nimpl Ord for Quantized {\\n    fn cmp(self: Self, other: Self) -> Ordering {\\n        if self.x == other.x {\\n            Ordering::equal()\\n        } else {\\n            let (_, sub_hi) = decompose(self.x - other.x);\\n            if sub_hi == 0 {\\n                Ordering::greater()\\n            } else {\\n                Ordering::less()\\n            }\\n        }\\n    }\\n}\\n\\n#[test]\\nfn test_order() {\\n    // Test 1: comparison between positive and negative value.\\n    // a = 0.2 and b = -0.2\\n    let a: Field = 13107;\\n    let a_quantized = Quantized { x: a };\\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\\n    let b_quantized = Quantized { x: b };\\n    assert(a_quantized > b_quantized);\\n\\n    // Test 2: comparison between two possitive numbers.\\n    // a = 1 and b = 0.2.\\n    // Then a * 2^16 = 65536\\n    let a: Field = 65536;\\n    let a_quantized = Quantized { x: a };\\n    let b = 13107;\\n    let b_quantized = Quantized { x: b };\\n    assert(a_quantized > b_quantized);\\n\\n    // Test 3: comparison between two possitive numbers where the roles are\\n    // inverted.\\n    // a = 1 and b = 1.2.\\n    // Then a * 2^16 = 65536\\n    let a: Field = 65536;\\n    let a_quantized = Quantized { x: a };\\n    let b = 78643;\\n    let b_quantized = Quantized { x: b };\\n    assert(a_quantized < b_quantized);\\n\\n    // Test 4: comparison between two negative numbers.\\n    // a = -1 and b = -0.2.\\n    // Then a * 2^16 = -65536 therefore taking mod p we obtain that\\n    // a = 21888242871839275222246405745257275088548364400416034343698204186575808430081\\n    // b = 21888242871839275222246405745257275088548364400416034343698204186575808482510\\n    let a: Field = 21888242871839275222246405745257275088548364400416034343698204186575808430081;\\n    let a_quantized = Quantized { x: a };\\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\\n    let b_quantized = Quantized { x: b };\\n    assert(a_quantized < b_quantized);\\n\\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001\\n    // - 32768\\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001\\n    let a = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001 };\\n    // - 327680\\n    let b = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001 };\\n    assert(a > b);\\n}\\n\\n#[test]\\nfn test_is_negative() {\\n    // Test 1: checking if it\'s negative for a positive value.\\n    // a = 0.2   =>   0.2 * 2^16 = 13107\\n    let a: Field = 13107;\\n    assert(is_negative(a) == 0);\\n\\n    // Test 2: checking if it\'s negative for a negative value.\\n    // a = -0.2  =>   -0.2 * 2^16 = -13107\\n    // Hence, -13107 mod p = p - 13107 = 21888242871839275222246405745257275088548364400416034343698204186575808482510\\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\\n    assert(is_negative(a) == 1);\\n\\n    // Test 3: checing if it\'s negative for a negative larger value.\\n    // a = -1301.34  =>  -1301.34 * 2^16 = -85284618\\n    // Hence, -85284618 mod p = p - 85284618 = 21888242871839275222246405745257275088548364400416034343698204186575723210999\\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575723210999;\\n    assert(is_negative(a) == 1);\\n}\\n\\n#[test]\\nfn test_add() {\\n    // Max value 2^60-1, positive and negative\\n    let a = 1152921504606846975;\\n    let b = -1152921504606846975;\\n    let a_quantized = Quantized { x: a };\\n    let b_quantized = Quantized { x: b };\\n    let addition_quantized = a_quantized + b_quantized;\\n    assert(addition_quantized.x == 0);\\n\\n    // Test case 1: Max value 2^60 - 1, positive and zero\\n    let a1 = 1152921504606846975;\\n    let b1 = 0;\\n    let a1_quantized = Quantized { x: a1 };\\n    let b1_quantized = Quantized { x: b1 };\\n    let addition1_quantized = a1_quantized + b1_quantized;\\n    assert(addition1_quantized.x == a1);\\n\\n    // Test case 2: Small positive values\\n    let a2 = 12345;\\n    let b2 = 67890;\\n    let a2_quantized = Quantized { x: a2 };\\n    let b2_quantized = Quantized { x: b2 };\\n    let addition2_quantized = a2_quantized + b2_quantized;\\n    assert(addition2_quantized.x == (a2 + b2));\\n\\n    // Test case 3: Positive and negative values resulting in a non-zero positive result\\n    let a3 = 50000;\\n    let b3 = -30000;\\n    let a3_quantized = Quantized { x: a3 };\\n    let b3_quantized = Quantized { x: b3 };\\n    let addition3_quantized = a3_quantized + b3_quantized;\\n    assert(addition3_quantized.x == 20000);\\n\\n    // Test case 4: Positive and negative values resulting in a non-zero negative result\\n    let a4 = 30000;\\n    let b4 = -50000;\\n    let a4_quantized = Quantized { x: a4 };\\n    let b4_quantized = Quantized { x: b4 };\\n    let addition4_quantized = a4_quantized + b4_quantized;\\n    assert(addition4_quantized.x == -20000);\\n\\n    // Test case 5: Add two negative values resulting in a negative value\\n    let a5 = -40000;\\n    let b5 = -20000;\\n    let a5_quantized = Quantized { x: a5 };\\n    let b5_quantized = Quantized { x: b5 };\\n    let addition5_quantized = a5_quantized + b5_quantized;\\n    assert(addition5_quantized.x == -60000);\\n}\\n\\n#[test]\\nfn test_mul() {\\n    // Test case 1: Small positive values\\n    let a1 = 12345; // original value 12345/2^16 = 0.1883697509765625\\n    let b1 = 67890; // original value 67890/2^16 = 1.035919189453125\\n    let a1_quantized = Quantized { x: a1 };\\n    let b1_quantized = Quantized { x: b1 };\\n    // new value = 0.1883697509765625 * 1.035919189453125 = 0.1951358397491276264190673828125\\n    // x = 0.1951358397491276264190673828125 * 2^16 = 12788.422393798828125 => 12788\\n    let mult1_quantized = a1_quantized * b1_quantized;\\n    assert(mult1_quantized.x == 12788);\\n\\n    // Test case 2: Large positive values\\n    let a2 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\\n    let b2 = 2; // original 2/2^16 = 0.000030517578125\\n    let a2_quantized = Quantized { x: a2 };\\n    let b2_quantized = Quantized { x: b2 };\\n    let mult2_quantized = a2_quantized * b2_quantized;\\n    // 17592186044415.9999847412109375 * 0.000030517578125 = 536870911.9999999995343387126922607421875\\n    // x/2^16 = value;  mult by 2^16 and truncate to whole number => x = 35184372088831\\n    assert(mult2_quantized.x == 35184372088831);\\n\\n    // Test case 3: Large positive and small positive value\\n    let a3 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\\n    let b3 = 1; // original value 1/2^16 = 0.0000152587890625\\n    let a3_quantized = Quantized { x: a3 };\\n    let b3_quantized = Quantized { x: b3 };\\n    // mul = 17592186044415.9999847412109375 * 0.0000152587890625 = 268435455.99999999976716935634613037109375\\n    let mult3_quantized = a3_quantized * b3_quantized;\\n    // mul * 2^16 = 17592186044415.9999847412109375\\n    assert(mult3_quantized.x == 17592186044415);\\n\\n    // Test case 4: Positive and negative value\\n    let a4 = 40000; // Original value 40000/2^16 = 0.6103515625\\n    let b4 = -30000; // Original value -0.457763671875\\n    let a4_quantized = Quantized { x: a4 };\\n    let b4_quantized = Quantized { x: b4 };\\n\\n    // 0.6103515625 * -0.457763671875 = -0.2793967723846435546875\\n    let mult4_quantized = a4_quantized * b4_quantized;\\n    // -0.2793967723846435546875 * 2^16 = -18310.546875\\n    assert(mult4_quantized.x == -18310);\\n\\n    // Test case 5: Both values negative\\n    let a5 = -40000; // Original value -40000 / 2^16 = -0.6103515625\\n    let b5 = -20000; // -0.30517578125\\n    let a5_quantized = Quantized { x: a5 };\\n    let b5_quantized = Quantized { x: b5 };\\n    // -0.6103515625 *  -0.30517578125 = 0.186264514923095703125\\n    let mult5_quantized = a5_quantized * b5_quantized;\\n    // Expected result: 12207.03125\\n    assert(mult5_quantized.x == 12207);\\n}\\n\\n#[test]\\nfn test_sub() {\\n    let a = 1152921504606846975;\\n    let b = 1152921504606846975;\\n    let a_quantized = Quantized { x: a };\\n    let b_quantized = Quantized { x: b };\\n    let addition_quantized = a_quantized - b_quantized;\\n    assert(addition_quantized.x == 0);\\n\\n    let a1 = 1152921504606846975;\\n    let b1 = 0;\\n    let a1_quantized = Quantized { x: a1 };\\n    let b1_quantized = Quantized { x: b1 };\\n    let addition1_quantized = a1_quantized - b1_quantized;\\n    assert(addition1_quantized.x == a1);\\n\\n    let a1 = 1152921504606846975;\\n    let b1 = 0;\\n    let a1_quantized = Quantized { x: a1 };\\n    let b1_quantized = Quantized { x: b1 };\\n    let addition1_quantized = b1_quantized - a1_quantized;\\n    // The result should be -a1, which means it is p - a1 in the field because\\n    // of the wrap around.\\n    let result = 21888242871839275222246405745257275088548364400416034343697051265071201648642;\\n    assert(addition1_quantized.x == result);\\n\\n    let a2 = 12345;\\n    let b2 = 67890;\\n    let a2_quantized = Quantized { x: a2 };\\n    let b2_quantized = Quantized { x: b2 };\\n    let addition2_quantized = a2_quantized + b2_quantized;\\n    assert(addition2_quantized.x == (a2 + b2));\\n}\\n\\n#[test]\\nfn test_division() {\\n    // Field modulus\\n    let p: Field = 0;\\n\\n    // Test case 1: Division with small positive values\\n    let a1 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\\n    let b1 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\\n    let result1 = a1 / b1; // 1.5 / 1.0 = 1.5\\n    assert(result1.x == 98304); // Scaled result for 1.5\\n\\n    // Test case 2: Division resulting in a smaller value\\n    let a2 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\\n    let b2 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\\n    let result2 = a2 / b2; // 1.0 / 1.5 = 0.666...\\n    assert(result2.x == 43690); // Scaled result for ~0.6667\\n\\n    // Test case 3: Negative divided by positive\\n    let a3 = Quantized { x: p - 98304 }; // Represents -1.5 (scaled)\\n    let b3 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\\n    let result3 = a3 / b3; // -1.5 / 1.0 = -1.5\\n    assert(result3.x == p - 98304); // Correctly negative\\n\\n    // Test case 4: Positive divided by negative\\n    let a4 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\\n    let b4 = Quantized { x: p - 65536 }; // Represents -1.0 (scaled)\\n    let result4 = a4 / b4; // 1.5 / -1.0 = -1.5\\n    assert(result4.x == p - 98304); // Correctly negative\\n\\n    // Test case 5: Both negative values\\n    let a5 = Quantized { x: p - 98304 }; // Represents -1.5 (scaled)\\n    let b5 = Quantized { x: p - 65536 }; // Represents -1.0 (scaled)\\n    let result5 = a5 / b5; // -1.5 / -1.0 = 1.5\\n    assert(result5.x == 98304); // Scaled result for 1.5\\n}\\n\\n#[test]\\nfn test_large_values_division() {\\n    // Field modulus\\n    let p: Field = 0;\\n\\n    // Test case 1: Large positive values\\n    let a1 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\\n    let b1 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\\n    let result1 = a1 / b1; // 17592186044416.0 / 8796093022208.0 = 2.0\\n    assert(result1.x == 131072); // Scaled result for 2.0\\n\\n    // Test case 2: Large positive divided by a larger positive\\n    let a2 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\\n    let b2 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\\n    let result2 = a2 / b2; // 8796093022208.0 / 17592186044416.0 = 0.5\\n    assert(result2.x == 32768); // Scaled result for 0.5\\n\\n    // Test case 3: Large negative divided by large positive\\n    let a3 = Quantized { x: p - 1152921504606846976 }; // Represents -17592186044416.0 (scaled)\\n    let b3 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\\n    let result3 = a3 / b3; // -17592186044416.0 / 8796093022208.0 = -2.0\\n    assert(result3.x == p - 131072); // Correctly negative\\n\\n    // Test case 4: Large positive divided by large negative\\n    let a4 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\\n    let b4 = Quantized { x: p - 576460752303423488 }; // Represents -8796093022208.0 (scaled)\\n    let result4 = a4 / b4; // 17592186044416.0 / -8796093022208.0 = -2.0\\n    assert(result4.x == p - 131072); // Correctly negative\\n\\n    // Test case 5: Both large negative values\\n    let a5 = Quantized { x: p - 1152921504606846976 }; // Represents -17592186044416.0 (scaled)\\n    let b5 = Quantized { x: p - 576460752303423488 }; // Represents -8796093022208.0 (scaled)\\n    let result5 = a5 / b5; // -17592186044416.0 / -8796093022208.0 = 2.0\\n    assert(result5.x == 131072); // Scaled result for 2.0\\n}\\n\\n#[test(should_fail)]\\nfn test_division_by_zero() -> Quantized {\\n    Quantized { x: 65536 } / Quantized { x: 0 }\\n}\\n","path":"/Users/elena/nargo/github.com/hashcloak/noir-fixed-point/v0.1.3/src/quantized.nr"}}'),oAe=["main"],lAe=["decompose_hint","lte_hint","directive_invert"],c3={noir_version:tAe,hash:nAe,abi:aAe,bytecode:rAe,debug_symbols:iAe,file_map:sAe,names:oAe,brillig_names:lAe},uAe=2**16,cAe=15e8;function d3(e){return e.map(t=>Math.round(t*uAe))}function dAe(e,t){if(e.length!==t.length)throw new Error("Mismatched lengths");return e.reduce((n,a,r)=>{const i=a-t[r];return n+i*i},0)}async function pAe(e,t){const n=new SV(c3),a=new AV(c3.bytecode),r=e.map(s=>({x:s})),i=t.map(s=>({x:s}));try{const{witness:s}=await n.execute({x:r,registered:i}),o=await a.generateProof(s);return[await a.verifyProof(o),o.publicInputs[0]]}catch(s){return console.error("ZK circuit error:",s),[!1,""]}}async function hAe(e){const t=new SV(u3),n=new AV(u3.bytecode),a=e.map(r=>({x:r}));try{const{witness:r}=await t.execute({x:a});return(await n.generateProof(r)).publicInputs[0]}catch(r){return console.error("ZK circuit error:",r),""}}function fAe(){const e=ii.useRef(null),t=ii.useRef(null),[n,a]=ii.useState("Loading models..."),[r,i]=ii.useState(null),[s,o]=ii.useState(null),[u,d]=ii.useState(null),[c,h]=ii.useState(null),[m,g]=ii.useState(null),[x,v]=ii.useState(null),[S,E]=ii.useState(null),[C,T]=ii.useState(!1),N=ii.useRef(null);ii.useEffect(()=>{const j=async()=>{const z="/models";await Ri.ssdMobilenetv1.loadFromUri(z),await Ri.faceLandmark68Net.loadFromUri(z),await Ri.faceRecognitionNet.loadFromUri(z),a("Models loaded");const ae=await navigator.mediaDevices.getUserMedia({video:!0});e.current.srcObject=ae,await new Promise(ue=>setTimeout(ue,500)),K()},te=new Image;te.src="/sun.png",te.onload=()=>h(te);const Q=new Image;Q.src="/privacy_hat.png",Q.onload=()=>g(Q),j()},[]),ii.useEffect(()=>(N.current||(N.current=setInterval(()=>{K()},500)),()=>{N.current&&(clearInterval(N.current),N.current=null)}),[]);const D=async()=>{const j=e.current,te=t.current;te.width=j.videoWidth,te.height=j.videoHeight;const Q=await hk(j).withFaceLandmarks().withFaceDescriptor();return te.getContext("2d").clearRect(0,0,te.width,te.height),Q?(wA.drawDetections(te,[Q.detection]),Array.from(Q.descriptor)):(a("No face detected"),null)},q=async()=>{T(!0);try{const j=await D();if(!j)return;const te=d3(j),Q=await hAe(te);i(te),v(Q),E(null),o(null),d(null),a("Face registered")}finally{T(!1)}},H=async()=>{if(!r){a("Register a face");return}const j=await D();if(!j)return;const te=d3(j),Q=dAe(te,r);d(Q),o("pending");const[z,ae]=await pAe(te,r),ue=Q<cAe&&z;if(o(ue),a(ue?"Match: ":"Match: "),z&&E(ae),ue){clearInterval(N.current),N.current=null;const he=e.current,Z=t.current,se=Z.getContext("2d");he.pause(),se.drawImage(he,0,0,Z.width,Z.height);const de=await hk(Z).withFaceLandmarks();if(de&&c&&m){const Ce=de.landmarks.getLeftEye(),Y=de.landmarks.getRightEye(),ie=(Ce[0].x+Y[3].x)/2,xe=(Ce[0].y+Y[3].y)/2+15,me=Math.abs(Y[3].x-Ce[0].x)*1.9,_e=me,Le=me/2;se.drawImage(c,ie-_e/2,xe-Le/2,_e,Le);const qe=de.detection.box,$e=qe.width*3,Ke=$e*(m.height/m.width),rt=15,ht=31,kt=qe.x+qe.width/2-$e/2+rt,_t=qe.y-Ke*.6+ht;se.drawImage(m,kt,_t,$e,Ke)}setTimeout(()=>{he.play(),o(null),E(null),d(null),a("Models loaded"),N.current||(N.current=setInterval(()=>{K()},300))},3e3)}},K=async()=>{const j=e.current,te=t.current;if(!j||!te||j.readyState!==4)return;te.width=j.videoWidth,te.height=j.videoHeight,te.getContext("2d").clearRect(0,0,te.width,te.height);try{const z=await hk(j).withFaceLandmarks().withFaceDescriptor();z?wA.drawDetections(te,[z.detection]):console.log("No detection in frame.")}catch(z){console.error("Face detection error:",z)}};return aa.jsxs("div",{style:{padding:"2rem",fontFamily:"sans-serif"},children:[aa.jsx("h2",{children:" zkFace: Webcam Detection"}),aa.jsx("p",{children:n}),x&&aa.jsxs("div",{style:{marginTop:"1rem"},children:[aa.jsx("strong",{children:"Registered Face Hash:"}),aa.jsx("pre",{style:{wordBreak:"break-word",whiteSpace:"pre-wrap"},children:x})]}),S&&aa.jsxs("div",{style:{marginTop:"1rem"},children:[aa.jsx("strong",{children:"Recognized Face Hash:"}),aa.jsx("pre",{style:{wordBreak:"break-word",whiteSpace:"pre-wrap"},children:S}),aa.jsxs("p",{children:[aa.jsx("strong",{children:"Hashes match:"})," ",S===x?" Yes":" No"]})]}),aa.jsxs("div",{style:{position:"relative",maxWidth:"600px"},children:[s==="pending"&&aa.jsx("div",{style:{position:"absolute",zIndex:10,backgroundColor:"rgba(255,255,255,0.8)",width:"100%",height:"100%",display:"flex",justifyContent:"center",alignItems:"center",borderRadius:"10px"},children:aa.jsx("p",{style:{fontSize:"1.2rem"},children:" Generating ZK proof, please wait..."})}),C&&aa.jsx("div",{style:{position:"absolute",zIndex:10,backgroundColor:"rgba(255,255,255,0.8)",width:"100%",height:"100%",display:"flex",justifyContent:"center",alignItems:"center",borderRadius:"10px"},children:aa.jsx("p",{style:{fontSize:"1.2rem"},children:" Registering face, please wait..."})}),aa.jsx("video",{ref:e,autoPlay:!0,muted:!0,style:{width:"100%",borderRadius:"10px"}}),aa.jsx("canvas",{ref:t,style:{position:"absolute",top:0,left:0}})]}),aa.jsxs("div",{style:{marginTop:"1rem",display:"flex",gap:"1rem"},children:[aa.jsx("button",{onClick:q,children:" Register face"}),aa.jsx("button",{onClick:H,children:" Verify face"})]}),u!==null&&aa.jsxs("p",{children:[aa.jsx("strong",{children:"Distance:"})," ",u," ",aa.jsx("br",{}),aa.jsx("strong",{children:"Result:"})," ",s==="pending"?" Generating proof...":s===!0?" Match":s===!1?" Match":""]})]})}F6.createRoot(document.getElementById("root")).render(aa.jsx(ii.StrictMode,{children:aa.jsx(fAe,{})}));
